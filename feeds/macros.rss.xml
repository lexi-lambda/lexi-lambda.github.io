<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Alexis King's Blog: Posts tagged 'macros'</title>
  <description>Alexis King's Blog: Posts tagged 'macros'</description>
  <link>http://lexi-lambda.github.io/tags/macros.html</link>
  <lastBuildDate>Sun, 21 Apr 2019 05:30:00 UT</lastBuildDate>
  <pubDate>Sun, 21 Apr 2019 05:30:00 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Defeating Racket’s separate compilation guarantee</title>
   <link>http://lexi-lambda.github.io/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/?utm_source=macros&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2019-04-21-defeating-racket-s-separate-compilation-guarantee</guid>
   <pubDate>Sun, 21 Apr 2019 05:30:00 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Being a self-described &lt;a href="https://felleisen.org/matthias/manifesto/sec_pl-pl.html"&gt;programming-language programming language&lt;/a&gt; is an ambitious goal. To preserve predictability while permitting linguistic extension, Racket comes equipped with a module system carefully designed to accommodate &lt;a href="https://www.cs.utah.edu/plt/publications/macromod.pdf"&gt;composable and compilable macros&lt;/a&gt;. One of the module system’s foundational properties is its &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._separate-compilation%29"&gt;&lt;em&gt;separate compilation guarantee&lt;/em&gt;&lt;/a&gt;, which imposes strong, unbreakable limits on the extent of compile-time side-effects. It is &lt;em&gt;essential&lt;/em&gt; for preserving static guarantees in a world where compiling a module can execute arbitrary code, and despite numerous unsafe trapdoors that have crept into Racket since its birth as PLT Scheme, none have ever given the programmer the ability to cheat it.&lt;/p&gt;

&lt;p&gt;Yet today, in this blog post, we’re going to do exactly that.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="what-is-the-separate-compilation-guarantee"&gt;What is the separate compilation guarantee?&lt;/h1&gt;

&lt;p&gt;Before we get to the fun part (i.e. breaking things), let’s go over some fundamentals so we understand what we’re breaking. The authoritative source for the separate compilation guarantee is &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._separate-compilation%29"&gt;the Racket reference&lt;/a&gt;, but it is dense, as authoritative sources tend to be. Although I enjoy reading technical manuals for sport, it is my understanding that not all the people who read this blog are as strange as I am, so let’s start with a quick primer, instead. (If you’re already an expert, feel free to &lt;a href="#section:main-start"&gt;skip to the next section&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Racket is a macro-enabled programming language. In Racket, a macro is a user-defined, code-to-code transformation that occurs at compile-time. These transformations cannot make arbitrary changes to the program—in Racket, they are usually required to be &lt;em&gt;local&lt;/em&gt;, affecting a single expression or definition at a time—but they may be implemented using arbitrary code. This means that a macro can, if it so desires, read the SSH keys off your filesystem and issue an HTTP request to send them someplace.&lt;/p&gt;

&lt;p&gt;That kind of attack is bad, admittedly, but it’s also &lt;em&gt;uninteresting&lt;/em&gt;: Racket allows you do all that and then some, making no attempt to prevent it.&lt;sup&gt;&lt;a href="#2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-1-definition" name="2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; Racket calls these “external effects,” things that affect state outside of the programming language. They sound scary, but in practice, &lt;em&gt;internal effects&lt;/em&gt;—effects that mutate state inside the programming language—are a much bigger obstacle to practical programming. Let’s take a look at why.&lt;/p&gt;

&lt;p&gt;Let’s say we have a module with some global, mutable state. Perhaps it is used to keep track of a set of delicious foods:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; foods.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;add-delicious-food!&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mutable-set&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set-member?&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set-add!&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Using this interface, let’s write a program that checks if a particular food, given as a command-line argument, is delicious:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; check-food.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"foods.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="s2"&gt;"pineapple"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="s2"&gt;"sushi"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="s2"&gt;"cheesecake"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;command-line&lt;/span&gt;
  &lt;span class="kd"&gt;#:args&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;food-to-check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;food-to-check&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"~a is a delicious food.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;food-to-check&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"~a is not delicious.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;food-to-check&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ racket check-food.rkt cheesecake
cheesecake is a delicious food.
$ racket check-food.rkt licorice
licorice is not delicious.
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Exhilarating. (Sorry, licorice fans.) But what if a &lt;em&gt;macro&lt;/em&gt; were to call &lt;code&gt;add-delicious-food!&lt;/code&gt;? What would happen? For example, what if we wrote a macro to add a lot of foods at once?&lt;sup&gt;&lt;a href="#2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-2-definition" name="2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-food-combinations!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fst:string&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snd:string&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;for*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;fst-str&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;datum&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fst&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]))]&lt;/span&gt;
               &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snd-str&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;datum&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snd&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]))])&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;string-append&lt;/span&gt; &lt;span class="n"&gt;fst-str&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="n"&gt;snd-str&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;void&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; should add “fried chicken,” “roasted chicken”, “fried potato,” and “roasted potato”&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-food-combinations!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"fried"&lt;/span&gt; &lt;span class="s2"&gt;"roasted"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"chicken"&lt;/span&gt; &lt;span class="s2"&gt;"potato"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, what do you think executing &lt;code&gt;racket check-food.rkt 'fried chicken'&lt;/code&gt; will do?&lt;/p&gt;

&lt;p&gt;Clearly, the program should print &lt;code&gt;fried chicken is a delicious food&lt;/code&gt;, and indeed, many traditional Lisp systems would happily produce such a result. After all, running &lt;code&gt;racket check-food.rkt 'fried chicken'&lt;/code&gt; must load the source code inside &lt;code&gt;check-food.rkt&lt;/code&gt;, expand and compile it, then run the result. While the program is being expanded, the compile-time calls to &lt;code&gt;add-delicious-food!&lt;/code&gt; should add new elements to the &lt;code&gt;delicious-food&lt;/code&gt; set, so when the program is executed, the string &lt;code&gt;"fried chicken"&lt;/code&gt; ought to be in it.&lt;/p&gt;

&lt;p&gt;But if you actually try this yourself, you will find that &lt;em&gt;isn’t&lt;/em&gt; what happens. Instead, Racket rejects the program:&lt;/p&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
check-food.rkt:12:11: add-delicious-food!: reference to an unbound identifier
  at phase: &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; the transformer environment
  in: add-delicious-food!
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Why does Racket reject this program? Well, consider that Racket allows programs to be pre-compiled using &lt;code&gt;raco make&lt;/code&gt;, doing all the work of macroexpansion and compilation to bytecode ahead of time. Subsequent runs of the program will use the pre-compiled version, without having to run all the macros again. This is a problem, since expanding the &lt;code&gt;add-food-combinations!&lt;/code&gt; macro had side-effects that our program depended on!&lt;/p&gt;

&lt;p&gt;If Racket allowed the above program, it might do different things depending on whether it was pre-compiled. Running directly from source code might treat &lt;code&gt;'fried chicken'&lt;/code&gt; as a delicious food, while running from pre-compiled bytecode might not. Racket considers this unacceptable, so it disallows the program entirely.&lt;/p&gt;

&lt;h2 id="preserving-separate-compilation-via-phases"&gt;Preserving separate compilation via phases&lt;/h2&gt;

&lt;p&gt;Hopefully, you are now mostly convinced that the above program is a bad one, but you might have some lingering doubts. You might, for example, wonder if Racket disallows mutable compile-time state entirely. That is not the case—Racket really does allow everything that happens at runtime to happen at compile-time—but it does prevent compile-time and run-time state from ever &lt;em&gt;interacting&lt;/em&gt;. Racket stratifies every program into a compile-time part and a run-time part, and it restricts communication between them to limited, well-defined channels (mainly via expanding to code that does something at run-time).&lt;/p&gt;

&lt;p&gt;Racket calls this system of stratification &lt;em&gt;phases&lt;/em&gt;. Code that executes at run-time belongs to the &lt;em&gt;run-time phase&lt;/em&gt;, while code that executes at compile-time (i.e. macros) belongs to the &lt;em&gt;compile-time phase&lt;/em&gt;. When a variable is defined, it is always defined in a particular phase, so bindings declared with &lt;code&gt;define&lt;/code&gt; can only be used at run-time, while bindings declared with &lt;code&gt;define-for-syntax&lt;/code&gt; can only be used at compile-time. Since &lt;code&gt;add-delicious-food!&lt;/code&gt; was declared using &lt;code&gt;define&lt;/code&gt;, it was not allowed (and in fact was not even visible) in the body of the &lt;code&gt;add-food-combinations!&lt;/code&gt; macro.&lt;/p&gt;

&lt;p&gt;While the whole macro system could work precisely as just described, such a strict stratification would be incredibly rigid. Since every definition would belong to either run-time or compile-time, but never both, reusing run-time code to implement macros would be impossible. While the example in the previous section might make it seem like that’s a good thing, it very often isn’t: imagine if general-purpose functions like &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; all needed to be written twice!&lt;/p&gt;

&lt;p&gt;To avoid this problem, Racket allows modules to be imported at both run-time and compile-time, so long as it’s done explicitly. Writing &lt;code&gt;(require "some-library.rkt")&lt;/code&gt; requires &lt;code&gt;some-library.rkt&lt;/code&gt; for run-time code, but writing &lt;code&gt;(require (for-syntax "some-library.rkt"))&lt;/code&gt; requires it for compile-time code. Requiring a module &lt;code&gt;for-syntax&lt;/code&gt; is sort of like implicitly adjusting all of its uses of &lt;code&gt;define&lt;/code&gt; to be &lt;code&gt;define-for-syntax&lt;/code&gt;, instead, effectively shifting all the code from run-time to compile-time. This kind of operation is therefore known as &lt;em&gt;phase shifting&lt;/em&gt; in Racket terminology.&lt;/p&gt;

&lt;p&gt;We can use phase shifting to make the program we wrote compile. If we adjust the &lt;code&gt;require&lt;/code&gt; at the beginning of our program, then we can ensure &lt;code&gt;add-delicious-food!&lt;/code&gt; is visible to both the run-time and compile-time parts of &lt;code&gt;check-food.rkt&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"foods.rkt"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="s2"&gt;"foods.rkt"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now our program compiles. However, if you’ve been following everything carefully, you should be wondering why! According to the last section, sharing state between run-time and compile-time fundamentally can’t work without introducing inconsistencies between uncompiled and pre-compiled code. And that’s true—such a thing would cause all sorts of problems, and Racket doesn’t allow it. If you run the program, whether pre-compiled or not, you’ll find it always does the same thing:&lt;/p&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
fried chicken is not delicious.
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This seems rather confusing. What happened to the calls to &lt;code&gt;add-delicious-food!&lt;/code&gt; inside our &lt;code&gt;add-food-combinations!&lt;/code&gt; macro? If we stick a &lt;code&gt;printf&lt;/code&gt; inside &lt;code&gt;add-delicious-food!&lt;/code&gt;, we’ll find that it really does get called:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"Registering ~a as a delicious food.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set-add!&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
Registering fried chicken as a delicious food.
Registering fried potato as a delicious food.
Registering roasted chicken as a delicious food.
Registering roasted potato as a delicious food.
Registering pineapple as a delicious food.
Registering sushi as a delicious food.
Registering cheesecake as a delicious food.
fried chicken is not delicious.
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And in fact, if we pre-compile &lt;code&gt;check-food.rkt&lt;/code&gt;, we’ll see that the first four registrations appear at compile-time, exactly as we expect:&lt;/p&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ raco make check-food.rkt
Registering fried chicken as a delicious food.
Registering fried potato as a delicious food.
Registering roasted chicken as a delicious food.
Registering roasted potato as a delicious food.
$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
Registering pineapple as a delicious food.
Registering sushi as a delicious food.
Registering cheesecake as a delicious food.
fried chicken is not delicious.
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The compile-time registrations really are happening, but Racket is automatically restricting the compile-time side-effects so they only apply at compile-time. After compilation has finished, Racket ensures that compile-time side effects are thrown away, and the run-time code starts over with fresh, untouched state. This guarantees consistent behavior, since it becomes impossible to distinguish at run-time whether a module was just compiled on the fly, or if it was pre-compiled long ago (possibly even on someone else’s computer).&lt;/p&gt;

&lt;p&gt;This is the essence of the separate compilation guarantee. To summarize:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Run-time and compile-time are distinct &lt;em&gt;phases&lt;/em&gt; of execution, which cannot interact.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Modules can be required at multiple phases via &lt;em&gt;phase shifting&lt;/em&gt;, but their state is kept separate. Each phase gets its own copy of the state.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Ensuring that the state is kept separate ensures predictable program behavior, no matter when the program is compiled.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This summary is a simplification of phases in Racket. The full Racket module system does not have only two phases, since macros can also be &lt;em&gt;used&lt;/em&gt; at compile-time to implement other macros, effectively creating a separate “compile-time” for the compile-time code. Each compile-time pass is isolated to its own phase, creating a finite but arbitrarily large number of distinct program phases (all but one of which occur at compile-time).&lt;/p&gt;

&lt;p&gt;Furthermore, the separate compilation guarantee does not just isolate the state of each phase from the state of other phases but also isolates all compile-time state from the compile-time state of other modules. This ensures that compilation is still deterministic even if modules are compiled in a different &lt;em&gt;order&lt;/em&gt;, or if several modules are sometimes compiled individually while other times compiled together all at once.&lt;/p&gt;

&lt;p&gt;If you want to learn more, the full details of the module system are described at length in the &lt;a href="https://docs.racket-lang.org/guide/phases.html"&gt;General Phase Levels&lt;/a&gt; section of the Racket Guide, but the abridged summary I’ve described is enough for the purposes of this blog post. If the bulleted list above mostly made sense to you, you’re ready to move on.&lt;/p&gt;

&lt;h1 id="section:main-start"&gt;How we’re going to break it&lt;/h1&gt;

&lt;p&gt;The separate compilation guarantee is a sturdy opponent, but it is not without weaknesses. Although no API in Racket, safe or unsafe, allows arbitrarily disabling phase separation, a couple features of Racket are already known to allow limited forms of cross-phase communication.&lt;/p&gt;

&lt;p&gt;The most significant of these, and the one we’ll be using as our vector of attack, is the logger. Unlike many logging systems, which are exclusively string-oriented, Racket’s logging interface allows structured logging by associating an arbitrary Racket value with each and every log message. Since it is possible to set up listeners within Racket that receive log messages sent to a particular “topic,” the logger can be used as a communication channel to send values between different parts of a program.&lt;/p&gt;

&lt;p&gt;The following program illustrates how this works. One thread creates a listener for all log messages on the topic &lt;code&gt;'send-me-a-value&lt;/code&gt; using &lt;code&gt;make-log-receiver&lt;/code&gt;, then uses &lt;code&gt;sync&lt;/code&gt; to block until a value is received. Meanwhile, a second thread sends values through the logger using &lt;code&gt;log-message&lt;/code&gt;. Together, this creates a makeshift buffered, asynchronous channel:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; log-comm.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-log-receiver&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;send-me-a-value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;log-message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;send-me-a-value&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sleep&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; wait forever&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;$ racket log-comm.rkt
'#(debug "" 1 send-me-a-value)
'#(debug "" 2 send-me-a-value)
'#(debug "" 3 send-me-a-value)
'#(debug "" 4 send-me-a-value)
^Cuser break&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this program, the value being sent through the logger is just a number, which isn’t very interesting. But the value really can be &lt;em&gt;any&lt;/em&gt; value, even arbitrary closures or mutable data structures. It’s even possible to send a &lt;a href="https://docs.racket-lang.org/guide/concurrency.html#%28part._.Channels%29"&gt;channel&lt;/a&gt; through a logger, which can subsequently be used to communicate directly, without having to abuse the logger.&lt;/p&gt;

&lt;p&gt;Generally, this feature of loggers isn’t very useful, since Racket has plenty of features for cross-thread communication. What’s special about the logger, however, is that it is global, and it is cross-phase.&lt;/p&gt;

&lt;p&gt;The cross-phase nature of the logger makes some sense. If a Racket program creates a namespace (that is, a fresh environment for dynamic evaluation), then uses it to expand and compile a Racket module, the process of compilation might produce some log messages, and the calling thread might wish to receive them. It wouldn’t be a very useful logging system if log messages during compile-time were always lost. However, this convenience is a loophole in the phase separation system, since it allows values to flow—bidirectionally—between phases.&lt;/p&gt;

&lt;p&gt;This concept forms the foundation of our exploit, but it alone is not a new technique, and I did not discover it. However, all existing uses I know of that use the logger for cross-phase communication require control of the parent namespace in which modules are being compiled, which means some code must exist “outside” the actual program. That technique does not work for ordinary programs run directly with &lt;code&gt;racket&lt;/code&gt; or compiled directly with &lt;code&gt;raco make&lt;/code&gt;, so to get there, we’ll need something more clever.&lt;/p&gt;

&lt;h2 id="the-challenge"&gt;The challenge&lt;/h2&gt;

&lt;p&gt;Our goal, therefore, is to share state between phases &lt;em&gt;without&lt;/em&gt; controlling the compilation namespace. More precisely, we want to be able to create an arbitrary module-level definition that is &lt;em&gt;cross-phase persistent&lt;/em&gt;, which means it will be evaluated once and only once no matter how many times its enclosing module is re-instantiated (i.e. given a fresh, untouched state) at various phases. A phase-shifted &lt;code&gt;require&lt;/code&gt; of the module that contains the definition should share state with an unshifted version of the module, breaking the separate compilation guarantee wide open.&lt;/p&gt;

&lt;p&gt;To use the example from the previous section, we should be able to adjust &lt;code&gt;foods.rkt&lt;/code&gt; very slightly…&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; foods.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"define-cross-phase.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;add-delicious-food!&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;; share across phases&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mutable-set&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="cm"&gt;#| ... |#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…and the &lt;code&gt;delicious-foods&lt;/code&gt; mutable state should magically become cross-phase persistent. When running &lt;code&gt;check-food.rkt&lt;/code&gt; from source, we should see the side-effects persisted from the module’s compilation, while running from pre-compiled bytecode should give us the result with compile-time effects discarded.&lt;/p&gt;

&lt;p&gt;We already know the logger is going to be part of our exploit, but implementing &lt;code&gt;define/cross-phase&lt;/code&gt; on top of it is more subtle than it might seem. In our previous example that used &lt;code&gt;make-log-receiver&lt;/code&gt;, we had well-defined sender and receiver threads, but who is the “sender” in our multi-phased world? And what exactly is the sender sending?&lt;/p&gt;

&lt;p&gt;To answer those questions, allow me to outline the general idea of our approach:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;The first time our &lt;code&gt;foods.rkt&lt;/code&gt; module is instantiated, at any phase, it evaluates the &lt;code&gt;(mutable-set)&lt;/code&gt; expression to produce a new mutable set. It spawns a sender thread that sends this value via the logger to anyone who will listen, and that thread lingers in the background for the remaining duration of the program.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All subsequent instantiations of &lt;code&gt;foods.rkt&lt;/code&gt; do &lt;em&gt;not&lt;/em&gt; evaluate the &lt;code&gt;(mutable-set)&lt;/code&gt; expression. Instead, they obtain the existing set by creating a log receiver and obtaining the value the sender thread is broadcasting. This ensures that a single value is shared across all instantiations of the module.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;This sounds deceptively simple, but the crux of the problem is how to determine whether &lt;code&gt;foods.rkt&lt;/code&gt; has previously been instantiated or not. Since we can only communicate across phases via the logger, we cannot use any shared state to directly record the first time the module is instantiated. We can listen to a log receiver and wait to see if we get a response, but this introduces a race condition: how long do we wait until giving up and deciding we’re the first instantiation? Worse, what if two threads instantiate the module at the same time, and both threads end up spawning a new sender thread, duplicating the state?&lt;/p&gt;

&lt;p&gt;The true challenge, therefore, is to develop a protocol by which we can be &lt;em&gt;certain&lt;/em&gt; we are the first instantiation of a module, without relying on any unspecified behavior, and without introducing any race conditions. This is possible, but it isn’t obvious, and it requires combining loggers with some extra tools available to the Racket programmer.&lt;/p&gt;

&lt;h2 id="the-key-idea"&gt;The key idea&lt;/h2&gt;

&lt;p&gt;It’s finally time to tackle the key idea at the heart of our exploit: garbage collection. In Racket, garbage collection is an observable effect, since Racket allows attaching finalizers to values via &lt;a href="https://docs.racket-lang.org/reference/willexecutor.html"&gt;wills and executors&lt;/a&gt;. Since a single heap is necessarily shared by the entire VM, behavior happening on other threads (even in other phases) can be indirectly observed by creating a unique value—a “canary”—then sending it to another thread, and waiting to see if it will be garbage collected or not (that is, whether or not the canary “dies”).&lt;/p&gt;

&lt;p&gt;Remember that logs and log receivers are effectively buffered, multicast, asynchronous FIFO channels. Since they are buffered, if any thread is already listening to a logger topic when a value is sent, it cannot possibly be garbage collected until that thread either reads it and discards it or the receiver itself is garbage collected. It’s possible to use this mechanism to observe whether or not another thread is already listening on a topic, as the following program demonstrates:&lt;sup&gt;&lt;a href="#2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-3-definition" name="2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; check-receivers.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-will-executor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;; limit scope of `canary` so we don’t retain a reference&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;canary&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;will-register&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;log-message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync/timeout&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"no receivers for ~v&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"receiver exists for ~v&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;; add a receiver on topic &amp;#39;foo&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-log-receiver&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;$ racket check-receivers.rkt
no receivers for 'bar
receiver exists for 'foo&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, this program has some problems. For one, it needs to call &lt;code&gt;collect-garbage&lt;/code&gt; several times to be certain that the canary will be collected if there are no listeners, which can take a second or two, and it also assumes that three calls to &lt;code&gt;collect-garbage&lt;/code&gt; will be enough to collect the canary, though there is no guarantee that will be true.&lt;/p&gt;

&lt;p&gt;A bulletproof solution should be both reasonably performant and guaranteed to work. To get there, we have to combine this idea with something more. Here’s the trick: instead of sending the canary alone, send a &lt;a href="https://docs.racket-lang.org/guide/concurrency.html#%28part._.Channels%29"&gt;channel&lt;/a&gt; alongside it. Synchronize on both the canary’s executor &lt;em&gt;and&lt;/em&gt; the channel so that the thread will unblock if either the canary is collected &lt;em&gt;or&lt;/em&gt; the channel is received and sent a value using &lt;code&gt;channel-put&lt;/code&gt;. Have the receiver listen for the channel on a separate thread, and when it receives it, send a value back to unblock the waiting thread as quickly as possible, without needing to rely on a timeout or a particular number of calls to &lt;code&gt;collect-garbage&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Using that idea, we can revise the program:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; check-receivers.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-will-executor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;; limit scope of `canary` so we don’t retain a reference&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;canary&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;will-register&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;log-message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
                 &lt;span class="c1"&gt;; send the channel + the canary&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector-immutable&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; yield to try to let the receiver thread work&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync/timeout&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;wrap-evt&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;received&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;wrap-evt&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;collected&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;collected&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;received&lt;/span&gt;  &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="c1"&gt;; collect garbage and try again&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;minor&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;major&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"no receivers for ~v&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"receiver exists for ~v&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;; add a receiver on topic &amp;#39;foo&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-log-receiver&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;channel-put&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)])))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now the program completes almost instantly. For this simple program, the explicit &lt;code&gt;(sleep)&lt;/code&gt; call is effective enough at yielding that, on my machine, &lt;code&gt;(check-receivers 'foo)&lt;/code&gt; returns without ever calling &lt;code&gt;collect-garbage&lt;/code&gt;, and &lt;code&gt;(check-receivers 'bar)&lt;/code&gt; returns after performing a single minor collection.&lt;/p&gt;

&lt;p&gt;This is extremely close to a bulletproof solution, but there are two remaining subtle issues:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;There is technically a race condition between the &lt;code&gt;(sync recv)&lt;/code&gt; in the receiver thread and the subsequent &lt;code&gt;channel-put&lt;/code&gt;, since it’s possible for the canary to be received, discarded, and garbage collected before reaching the call to &lt;code&gt;channel-put&lt;/code&gt;, which the sending thread would incorrectly interpret as indicating the topic has no receivers.&lt;/p&gt;
  &lt;p&gt; To fix that, the receiver thread can send the canary itself back through the channel, which fundamentally has to work, since the value cannot be collected until it has been received by the sending thread, at which point the &lt;code&gt;sync&lt;/code&gt; has already chosen the channel.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;It is possible for the receiver thread to receive the log message and call &lt;code&gt;channel-put&lt;/code&gt;, but for the sending thread to somehow die in the meantime (which cannot be protected against in general in Racket, since &lt;code&gt;thread-kill&lt;/code&gt; immediately and forcibly terminates a thread). If this were to happen, the sending thread would never obtain the value from the channel, blocking the receiving thread indefinitely.&lt;/p&gt;
  &lt;p&gt; A solution is to spawn a new thread for each &lt;code&gt;channel-put&lt;/code&gt; instead of calling it directly from the receiving thread. Conveniently, this both ensures the receiving thread never gets stuck and avoids resource leaks, since the Racket runtime is smart enough to GC a thread blocked on a channel that has no other references and therefore can never be unblocked.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;With those fixes in place, the program is, to the best of my knowledge, bulletproof. It will always correctly determine whether or not a logger has a listener, with no race conditions or reliance upon unspecified behavior of the Racket runtime. It does, however, make a couple of assumptions.&lt;/p&gt;

&lt;p&gt;First, it assumes that the value of &lt;code&gt;(current-logger)&lt;/code&gt; is shared between the threads. It is true that &lt;code&gt;(current-logger)&lt;/code&gt; can be changed, and sometimes is, but it’s usually done via &lt;code&gt;parameterize&lt;/code&gt;, not mutation of the parameter directly. Therefore, this can largely be mitigated by storing the value of &lt;code&gt;(current-logger)&lt;/code&gt; at module instantiation time.&lt;/p&gt;

&lt;p&gt;Second, it assumes that no other receivers are listening on the same topic. Technically, even using a unique, uninterned key for the topic is insufficient to ensure that no receivers are listening to it, since a receiver can choose to listen to all topics. However, in practice, it is highly unlikely that any receiver would willfully choose to listen to all topics at the &lt;code&gt;'debug&lt;/code&gt; level, since the receiver would be inundated with enormous amounts of useless information. Even if such a receiver were to be created, it is highly likely that it would dequeue the messages as quickly as possible and discard the accompanying payload, since doing otherwise would cause all messages to be retained in memory, leading to a significant memory leak.&lt;/p&gt;

&lt;p&gt;Both these problems can be mitigated by using a logger other than the root logger, which is easy in this example. However, for the purpose of subverting the separate compilation guarantee, we would have no way to share the logger object itself across phases, defeating the whole purpose, so we are forced to use the root logger and hope the above two assumptions remain true (but they usually do).&lt;/p&gt;

&lt;h2 id="preparing-the-exploit"&gt;Preparing the exploit&lt;/h2&gt;

&lt;p&gt;If you’ve made it here, congratulations! The most difficult part of this blog post is over. All that’s left is the fun part: performing the exploit.&lt;/p&gt;

&lt;p&gt;The bulk of our implementation is a slightly adapted version of &lt;code&gt;check-receivers&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; define-cross-phase.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;root-logger&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-cross-phase&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="k"&gt;thunk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-log-receiver&lt;/span&gt; &lt;span class="n"&gt;root-logger&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-will-executor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;canary&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;will-register&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;collected&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;log-message&lt;/span&gt; &lt;span class="n"&gt;root-logger&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector-immutable&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;==&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="nb"&gt;eq?&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)])))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;execute-evt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;wrap-evt&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="nb"&gt;will-execute&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync/timeout&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="n"&gt;execute-evt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;minor&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;major&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;collected&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;thunk&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;channel-put&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector-immutable&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)]))))&lt;/span&gt;
     &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;There are a few minor differences, which I’ll list:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;The most obvious difference is that &lt;code&gt;make-cross-phase&lt;/code&gt; does the work of both checking if a receiver exists—which I’ll call the &lt;em&gt;manager thread&lt;/em&gt;—and spawning it if it doesn’t. If it does end up spawning a manager thread, it evaluates the given thunk to produce a value, which becomes the cross-phase value that will be sent through the channel alongside the canary.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Once the manager thread is created, subsequent calls to &lt;code&gt;make-cross-phase&lt;/code&gt; will receive the value through the channel and return it instead of re-invoking &lt;code&gt;thunk&lt;/code&gt;. This is what ensures the right-hand side of each use of &lt;code&gt;define/cross-phase&lt;/code&gt; is only ever evaluated once.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Since &lt;code&gt;make-cross-phase&lt;/code&gt; needs to create a log receiver if no manager thread exists, it does so immediately, before sending the canary through the logger. This avoids a race condition between multiple threads that are simultaneously competing to become the manager thread, where both threads could send a canary through the logger before either was listening, both canaries would get GC’d, and both threads would spawn a new manager.&lt;sup&gt;&lt;a href="#2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-4-definition" name="2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-4-return"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
  &lt;p&gt; Creating the receiver before sending the canary avoids this problem, but the thread now needs to receive its own canary and discard it before synchronizing on the channel and executor, since otherwise it will retain a reference to the canary. It’s possible that in between creating the receiver and sending the canary, another thread also sent a canary, so it needs to drop any log messages it finds that don’t include its own canary.&lt;/p&gt;
  &lt;p&gt; This ends up working out perfectly, since every thread drops all the messages received before the one containing its own canary, but retains all subsequent values. This means that only one thread can ever “win” and become the manager, since the first thread to send a canary is guaranteed to retain all subsequent canaries, yet also guaranteed its canary will be GC’d. Other threads racing to become the manager will remain blocked until the manager thread is created, since its canaries will be retained by the manager-to-be until it dequeues them.&lt;/p&gt;
  &lt;p&gt; (This is the most subtle part of the process to get right, but conveniently, it mostly just works out without very much code. If you didn’t understand any of the above three paragraphs, it isn’t a big deal.)&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The final piece to this puzzle is to define the &lt;code&gt;define/cross-phase&lt;/code&gt; macro that wraps &lt;code&gt;make-cross-phase&lt;/code&gt;. The macro is actually slightly more involved than just generating a call to &lt;code&gt;make-cross-phase&lt;/code&gt; directly, since we’d like to use an uninterned symbol for the topic instead of an interned one, just to ensure it is unique. Ordinarily, this might seem impossible, since an uninterned symbol is fundamentally a unique value that needs to be communicated across phases, and the whole problem we are solving is creating a communication channel that spans phases. However, Racket actually provides some built-in support for sharing uninterned symbols across phases (plus some other kinds of values, but they must always be immutable). To do this, we need to generate a &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._cross-phase._persistent-modules%29"&gt;cross-phase persistent submodule&lt;/a&gt; that exports an uninterned symbol, then pass that symbol as the topic to &lt;code&gt;make-cross-phase&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;racket/syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;define/cross-phase&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;topic-mod-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generate-temporary&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;cross-phase-topic-key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;topic-mod-name&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;#%kernel&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%declare&lt;/span&gt; &lt;span class="kd"&gt;#:cross-phase-persistent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%provide&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt; &lt;span class="s2"&gt;"cross-phase"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;topic-mod-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-cross-phase&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And that’s really it. We’re done.&lt;/p&gt;

&lt;h2 id="executing-the-exploit"&gt;Executing the exploit&lt;/h2&gt;

&lt;p&gt;With our implementation of &lt;code&gt;define/cross-phase&lt;/code&gt; in hand, all that’s left to do is run our original &lt;code&gt;check-foods.rkt&lt;/code&gt; program and see what happens:&lt;/p&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
set-add!: contract violation:
expected: set?
given: &lt;span class="o"&gt;(&lt;/span&gt;mutable-set &lt;span class="s2"&gt;"fried chicken"&lt;/span&gt; &lt;span class="s2"&gt;"roasted chicken"&lt;/span&gt; &lt;span class="s2"&gt;"roasted potato"&lt;/span&gt; &lt;span class="s2"&gt;"fried potato"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
argument position: 1st
other arguments...:
  x: &lt;span class="s2"&gt;"pineapple"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Well, I don’t know what you expected. Play stupid games, win stupid prizes.&lt;/p&gt;

&lt;p&gt;This error actually makes sense, but it belies one reason (of many) why this whole endeavor is probably a bad idea. Although we’ve managed to make our mutable set cross-phase persistent, our references to set operations like &lt;code&gt;set-add!&lt;/code&gt; and &lt;code&gt;set-member?&lt;/code&gt; are not, and every time &lt;code&gt;racket/set&lt;/code&gt; is instantiated in a fresh phase, it creates an entirely new instance of the &lt;code&gt;set&lt;/code&gt; structure type. This means that even though we have a bona fide mutable set, it isn’t actually the type of set that this phase’s &lt;code&gt;set-add!&lt;/code&gt; understands!&lt;/p&gt;

&lt;p&gt;Of course, this isn’t a problem that some liberal application of &lt;code&gt;define/cross-phase&lt;/code&gt; can’t solve:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; foods.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"define-cross-phase.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;add-delicious-food!&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;cross:set-member?&lt;/span&gt; &lt;span class="nb"&gt;set-member?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;cross:set-add!&lt;/span&gt; &lt;span class="nb"&gt;set-add!&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mutable-set&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cross:set-member?&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cross:set-add!&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
fried chicken is a delicious food.
$ raco make check-food.rkt
$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
fried chicken is not delicious.
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And thus we find that another so-called “guarantee” isn’t.&lt;/p&gt;

&lt;h1 id="reflection"&gt;Reflection&lt;/h1&gt;

&lt;p&gt;Now comes the time in the blog post when I have to step back and think about what I’ve done. Have mercy.&lt;/p&gt;

&lt;p&gt;Everything in this blog post is a terrible idea. No, you should not use loggers for anything that isn’t logging, you shouldn’t use wills and executors for critical control flow, and obviously you should absolutely not intentionally break one of the most helpful guarantees the Racket module system affords you.&lt;/p&gt;

&lt;p&gt;But I thought it was fun to do all that, anyway.&lt;/p&gt;

&lt;p&gt;The meaningful takeaways from this blog post aren’t that the separate compilation guarantee can be broken, nor that any of the particular techniques I used hold, but that&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;ensuring non-trivial guarantees is really hard,&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;despite that, the separate compilation guarantee is really, really hard to break,&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;the separate compilation guarantee is good, and you should appreciate the luxury it affords you while writing Racket macros,&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;avoiding races in a concurrent environment can be extremely subtle,&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;and Racket is totally &lt;em&gt;awesome&lt;/em&gt; for giving me this much rope to hang myself with.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;If you want to hang yourself with Racket, too, &lt;a href="https://gist.github.com/lexi-lambda/f173a84fc9727977bcea657b3bb0cd4f"&gt;runnable code from this blog post is available here&lt;/a&gt;.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;This isn’t &lt;em&gt;strictly&lt;/em&gt; true, since Racket provides sandboxing mechanisms that can compile and execute untrusted code without file system or network access, but this is not the default compilation mode. Usually, it doesn’t matter nearly as much as it might sound: most of the time, if you’re compiling untrusted code, you’re also going to run it, and running untrusted code can do all those things, anyway.&amp;nbsp;&lt;a href="#2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;This is actually a &lt;em&gt;terrible&lt;/em&gt; use case for a macro, since an ordinary function would do just fine, but I’m simplifying a little to keep the example small.&amp;nbsp;&lt;a href="#2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;Racket actually provides this functionality directly via the &lt;code&gt;log-level?&lt;/code&gt; procedure. However, since &lt;code&gt;log-level?&lt;/code&gt; provides no way to determine how &lt;em&gt;many&lt;/em&gt; receivers are listening to a topic, using it to guard against creating a receiver is vulnerable to a race condition that the garbage collection-based approach can avoid, as is discussed later. Furthermore, the GC technique is more likely to be resilient to nosy log receivers listening on all topics at the &lt;code&gt;'debug&lt;/code&gt; level, since they will almost certainly dequeue and discard the value quickly (as otherwise they would leak large quantities of memory).&amp;nbsp;&lt;a href="#2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-4-definition" class="footnote-definition"&gt;
   &lt;p&gt;This race is the one that makes using &lt;code&gt;log-level?&lt;/code&gt; untenable, since the receiver needs to be created before the topic is checked for listeners to avoid the race, which can’t be done with &lt;code&gt;log-level?&lt;/code&gt; (since it would always return &lt;code&gt;#t&lt;/code&gt;).&amp;nbsp;&lt;a href="#2019-04-21-defeating-racket-s-separate-compilation-guarantee-footnote-4-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item>
  <item>
   <title>Macroexpand anywhere with `local-apply-transformer`!</title>
   <link>http://lexi-lambda.github.io/blog/2018/10/06/macroexpand-anywhere-with-local-apply-transformer/?utm_source=macros&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2018-10-06-macroexpand-anywhere-with-local-apply-transformer</guid>
   <pubDate>Sat, 06 Oct 2018 22:34:46 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Racket programmers are accustomed to the language’s incredible capacity for extension and customization. Writing useful macros that do complicated things is easy, and it’s simple to add new syntactic forms to meet domain-specific needs. However, it doesn’t take long before many budding macrologists bump into the realization that only &lt;em&gt;certain positions&lt;/em&gt; in Racket code are subject to macroexpansion.&lt;/p&gt;

&lt;p&gt;To illustrate, consider a macro that provides a Clojure-style &lt;code&gt;let&lt;/code&gt; form:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-let&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;body:expr&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This can be used anywhere an expression is expected, and it does as one would expect:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-let&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, a novice macro programmer might realize that &lt;code&gt;clj-let&lt;/code&gt; really only modifies the syntax of &lt;em&gt;binding pairs&lt;/em&gt; for a &lt;code&gt;let&lt;/code&gt; form. Therefore, could one define a macro that only adjusts the binding pairs of some existing &lt;code&gt;let&lt;/code&gt; form instead of expanding to an entire &lt;code&gt;let&lt;/code&gt;? That is, could one write the above example like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
         &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The answer is &lt;em&gt;no&lt;/em&gt;: the binding pairs of a &lt;code&gt;let&lt;/code&gt; form are not subject to macroexpansion, so the above attempt fails with a syntax error. In this blog post, we will examine the reasons behind this limitation, then explain how to overcome it using a solution that allows macroexpansion &lt;em&gt;anywhere&lt;/em&gt; in a Racket program.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="why-only-some-positions-are-subject-to-macroexpansion"&gt;Why only some positions are subject to macroexpansion&lt;/h1&gt;

&lt;p&gt;To understand &lt;em&gt;why&lt;/em&gt; the macroexpander refuses to touch certain positions in a program, we must first understand how the macro system operates. In Racket, a macro is defined as a compile-time function associated with a particular binding, and macros are given complete control over the syntax trees they are surrounded with. If we define a macro &lt;em&gt;&lt;code&gt;mac&lt;/code&gt;&lt;/em&gt;, then we write the expression &lt;code&gt;(
  &lt;i&gt;mac&lt;/i&gt;
  &lt;i&gt;form&lt;/i&gt;)&lt;/code&gt;, &lt;em&gt;&lt;code&gt;form&lt;/code&gt;&lt;/em&gt; is provided as-is to &lt;em&gt;&lt;code&gt;mac&lt;/code&gt;&lt;/em&gt; as a syntax object. Its structure can be anything at all, since &lt;em&gt;&lt;code&gt;mac&lt;/code&gt;&lt;/em&gt; can be an arbitrary Racket function, and that function can use &lt;em&gt;&lt;code&gt;form&lt;/code&gt;&lt;/em&gt; however it pleases.&lt;/p&gt;

&lt;p&gt;To give a concrete illustration, consider a macro that binds some identifiers to symbols in a local scope:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;let-symbols&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;let-symbols&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;goodbye&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;goodbye&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;hello&lt;/span&gt; &lt;span class="ss"&gt;goodbye&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It isn’t the most exciting macro in the world, but it illustrates a key point: the first subform to &lt;code&gt;let-symbols&lt;/code&gt; is a list of identifiers that are eventually put in &lt;em&gt;binding&lt;/em&gt; position. This means that &lt;code&gt;hello&lt;/code&gt; and &lt;code&gt;goodbye&lt;/code&gt; are bindings, not uses, and such bindings shadow any existing bindings that might have been in scope:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;let-symbols&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This might not seem very interesting, but it’s critical to understand, since it means that the expander &lt;em&gt;can’t know&lt;/em&gt; which sub-pieces of a use of &lt;code&gt;let-symbols&lt;/code&gt; will eventually be expressions themselves until it expands the macro and discovers it produces a &lt;code&gt;let&lt;/code&gt; form, so it can’t know where it’s safe to perform macroexpansion. To make this more explicit, imagine we define a macro under some name, then try and use that name with our &lt;code&gt;let-symbols&lt;/code&gt; macro:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;let-symbols&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;goodbye&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;What should the above program do? If we treat the first use of &lt;code&gt;hello&lt;/code&gt; in the &lt;code&gt;let-symbols&lt;/code&gt; form as a macro application, then &lt;code&gt;(hello goodbye)&lt;/code&gt; should be transformed into &lt;code&gt;(goodbye)&lt;/code&gt;, and the use of &lt;code&gt;hello&lt;/code&gt; in the body should be a syntax error. But if the first use of &lt;code&gt;hello&lt;/code&gt; was instead intended to be a binder, then it should shadow the &lt;code&gt;hello&lt;/code&gt; definition above, and the output of the program should be &lt;code&gt;'hello&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To avoid the chaos that would ensue if defining a macro could completely break local reasoning about other macros, Racket chooses the second option, and the program produces &lt;code&gt;'hello&lt;/code&gt;. The macroexpander has no way of knowing &lt;em&gt;how&lt;/em&gt; each macro will inspect its constituent pieces, so it avoids touching anything until the macro expands. After it discovers the &lt;code&gt;let&lt;/code&gt; form in the expansion of &lt;code&gt;let-symbols&lt;/code&gt;, it can safely determine that the body expressions are, indeed, expressions, and it can recursively expand any macros they contain. To put things another way, a macro’s sub-forms are never expanded before the macro itself is expanded, only after.&lt;/p&gt;

&lt;h1 id="forcing-sub-form-expansion"&gt;Forcing sub-form expansion&lt;/h1&gt;

&lt;p&gt;The above section explains why the expander must operate as it does, but it’s a little bit unsatisfying. What if we write a macro where we &lt;em&gt;want&lt;/em&gt; certain sub-forms to be expanded before they are passed to us? Fortunately, the Racket macro system provides an API to handle this use case, too.&lt;/p&gt;

&lt;p&gt;It is true that the Racket macro system never &lt;em&gt;automatically&lt;/em&gt; expands sub-forms before outer forms are expanded, but macro transformers can explicitly op-in to recursive expansion via the &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._local-expand%29%29"&gt;&lt;code&gt;local-expand&lt;/code&gt;&lt;/a&gt; function. This function effectively yields control back to the expander to expand some arbitrary piece of syntax as an expression, and when it returns, the macro transformer can inspect the expanded expression however it wishes. In theory, this can be used to implement extensible macros that allow macroexpansion in locations other than expression position.&lt;/p&gt;

&lt;p&gt;To give an example of such a macro, consider the Racket &lt;code&gt;match&lt;/code&gt; form, which implements an expressive pattern-matcher as a macro. One of the most interesting qualities of Racket’s &lt;code&gt;match&lt;/code&gt; macro is that its pattern language is user-extensible, essentially allowing pattern-level macros. For example, a user might find they frequently match against natural numbers, and they wish to be able to write &lt;code&gt;(nat n)&lt;/code&gt; as a shorthand for &lt;code&gt;(? exact-nonnegative-integer? n)&lt;/code&gt;. Fortunately, this is easy using &lt;code&gt;define-match-expander&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-match-expander&lt;/span&gt; &lt;span class="n"&gt;nat&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;pat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;?&lt;/span&gt; &lt;span class="nb"&gt;exact-nonnegative-integer?&lt;/span&gt; &lt;span class="n"&gt;pat&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;-5&lt;/span&gt; &lt;span class="mi"&gt;-2&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;-7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nat&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Clearly, &lt;code&gt;match&lt;/code&gt; is somehow expanding the &lt;code&gt;nat&lt;/code&gt; match expander as a part of its expansion. Is it using &lt;code&gt;local-expand&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Well, no. While &lt;a href="/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/"&gt;a previous blog post of mine&lt;/a&gt; has illustrated that it is possible to do such a thing with &lt;code&gt;local-expand&lt;/code&gt; via some clever trickery, &lt;code&gt;local-expand&lt;/code&gt; is really designed to expand &lt;em&gt;expressions&lt;/em&gt;. This is a problem, since &lt;code&gt;(nat n)&lt;/code&gt; is not an expression, it’s a pattern: it will expand into &lt;code&gt;(? exact-nonnegative-integer? n)&lt;/code&gt;, which will lead to a syntax error, since &lt;code&gt;?&lt;/code&gt; is not bound in the world of expressions. Instead, for a long while, &lt;code&gt;match&lt;/code&gt; and forms like it have emulated how the expander performs macroexpansion in ad-hoc ways. Fortunately, as of Racket v7.0, the new &lt;a href="http://docs.racket-lang.org/syntax/transformer-helpers.html#%28def._%28%28lib._syntax%2Fapply-transformer..rkt%29._local-apply-transformer%29%29"&gt;&lt;code&gt;local-apply-transformer&lt;/code&gt;&lt;/a&gt; API provides a way to invoke recursive macroexpansion in a consistent way, and it doesn’t assume that what’s being expanded is an expression.&lt;/p&gt;

&lt;h2 id="a-closer-look-at-local-apply-transformer"&gt;A closer look at &lt;code&gt;local-apply-transformer&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;If &lt;code&gt;local-apply-transformer&lt;/code&gt; is the answer, what does it actually do? Well, &lt;code&gt;local-apply-transformer&lt;/code&gt; allows explicitly invoking a transformer function on some piece of syntax and retrieving the result. In other words, &lt;code&gt;local-apply-transformer&lt;/code&gt; allows expanding an arbitrary macro, but since it doesn’t make any assumptions about what the output will be, it only expands it &lt;em&gt;once&lt;/em&gt;: just a single step of macro transformation.&lt;/p&gt;

&lt;p&gt;To illustrate, we can write a macro that uses &lt;code&gt;local-apply-transformer&lt;/code&gt; to invoke a transformer function and preserve the result using &lt;code&gt;quote-syntax&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/apply-transformer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-for-syntax&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-apply-transformer&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote-syntax&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;When we use &lt;code&gt;mac&lt;/code&gt;, our &lt;code&gt;flip&lt;/code&gt; function will be applied, as a macro, to the syntax object we provide:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;#&amp;lt;syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Alright, so this works, but it raises some questions. Why is &lt;code&gt;flip&lt;/code&gt; defined as a function at phase 1 (using &lt;code&gt;define-for-syntax&lt;/code&gt;) instead of as a macro (using &lt;code&gt;define-syntax&lt;/code&gt;)? What’s the deal with the &lt;code&gt;'expression&lt;/code&gt; argument to &lt;code&gt;local-apply-transformer&lt;/code&gt; given that &lt;code&gt;local-apply-transformer&lt;/code&gt; is supposedly decoupled from expression expansion? And finally, how is this any different from just calling our &lt;code&gt;flip&lt;/code&gt; function on the syntax object directly by writing &lt;code&gt;(flip #'(([x 1]) let x))&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Let’s start with the first of those questions: why is &lt;code&gt;flip&lt;/code&gt; defined as a function rather than as a macro? Well, &lt;code&gt;local-apply-transformer&lt;/code&gt; is a fairly low-level operation: remember, it doesn’t assume &lt;em&gt;anything&lt;/em&gt; about the argument it’s given! Therefore, it doesn’t take an expression containing a macro and expand it based on its structure, it needs to be explicitly provided the macro transformer function to apply. In practice, this might not seem very useful, since presumably we want to write our macros as macros, not as phase 1 functions. Fortunately, it’s possible to look up the function associated with a macro binding using the &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-value%29%29"&gt;&lt;code&gt;syntax-local-value&lt;/code&gt;&lt;/a&gt; function, so if we use that, we can define &lt;code&gt;flip&lt;/code&gt; using &lt;code&gt;define-syntax&lt;/code&gt; as usual:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-apply-transformer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                         &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote-syntax&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now for the next question: what is the meaning of the &lt;code&gt;'expression&lt;/code&gt; argument? This one is more of a historical artifact than anything else: when the expander applies a macro transformer, it does it in a “context”, which is accessible using the &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-context%29%29"&gt;&lt;code&gt;syntax-local-context&lt;/code&gt;&lt;/a&gt; function. This context can be one of a predefined enumeration of cases, including &lt;code&gt;'expression&lt;/code&gt;, &lt;code&gt;'top-level&lt;/code&gt;, &lt;code&gt;'module&lt;/code&gt;, &lt;code&gt;'module-begin&lt;/code&gt;, or a list representing a definition context. Whether or not any of those actually apply to our use case, we still have to pick one, but aside from how they affect the value returned by &lt;code&gt;syntax-local-context&lt;/code&gt; (which some macros inspect), the value we choose is largely irrelevant. Using &lt;code&gt;'expression&lt;/code&gt; will do, even if it’s a bit of a lie.&lt;/p&gt;

&lt;p&gt;Finally, how does any of this differ from just applying the function we get directly? Well, the critical answer is all about &lt;em&gt;hygiene&lt;/em&gt;. Racket’s macro system is hygienic, which, among other things, ensures bindings defined with the same name in different places do not unintentionally conflict. Racket’s hygiene mechanism is implemented in the macroexpander, when macro transformers are applied. If we just applied the &lt;code&gt;flip&lt;/code&gt; transformer procedure to a syntax object directly, we would circumvent this hygiene mechanism, potentially causing all sorts of problems. By using &lt;code&gt;local-apply-transformer&lt;/code&gt;, we ensure hygiene is preserved.&lt;/p&gt;

&lt;p&gt;There is one small problem left with our program, however. Can you spot it? The key is to consider what would happen if we used &lt;code&gt;flip&lt;/code&gt; as an ordinary macro, without using &lt;code&gt;local-apply-transformer&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;let:&lt;/span&gt; &lt;span class="n"&gt;bad&lt;/span&gt; &lt;span class="k"&gt;syntax&lt;/span&gt;
  &lt;span class="n"&gt;in:&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;What happened? Well, remember that when a macro in Racket is used, it receives the whole use site as a syntax object: in this case, &lt;code&gt;#'(flip (([x 1]) let x))&lt;/code&gt;. This means that &lt;code&gt;flip&lt;/code&gt; ought to be written to parse its argument slightly differently:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Indeed, now that we’ve properly restructured the macro, we can easily switch to using the convenient &lt;code&gt;define-simple-macro&lt;/code&gt; shorthand:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This means we also need to update our definition of &lt;code&gt;mac&lt;/code&gt; to provide the full syntax object the expander would:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-apply-transformer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                                         &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote-syntax&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This might seem redundant, but remember, &lt;code&gt;local-apply-transformer&lt;/code&gt; is very low-level! While the convention that &lt;code&gt;(
  &lt;i&gt;mac&lt;/i&gt; . _)&lt;/code&gt; is the syntax for a macro transformation might seem obvious, &lt;code&gt;local-apply-transformer&lt;/code&gt; makes no assumptions. It just does what we tell it to do.&lt;/p&gt;

&lt;h2 id="applying-local-apply-transformer"&gt;Applying &lt;code&gt;local-apply-transformer&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;So what does &lt;code&gt;local-apply-transformer&lt;/code&gt; have to do with the problem at the beginning of this blog post? Well, as it happens, we can use &lt;code&gt;local-apply-transformer&lt;/code&gt; to implement a macro that allows expansion &lt;em&gt;anywhere&lt;/em&gt; using some simple tricks. While it’s true that we cannot magically divine which locations ought to be expanded, what we &lt;em&gt;can&lt;/em&gt; do is explicitly annotate which places to expand.&lt;/p&gt;

&lt;p&gt;To do this, we will implement a macro, &lt;code&gt;expand-inside&lt;/code&gt;, that looks for subforms annotated with a special &lt;code&gt;$expand&lt;/code&gt; identifier and performs macro transformation on those locations before proceeding with ordinary macroexpansion. Using the &lt;code&gt;clj-binding-pairs&lt;/code&gt; example from the beginning of this blog post, our solution to that problem will look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-inside&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
           &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Put another way, &lt;code&gt;expand-inside&lt;/code&gt; will force eager expansion on any subform surrounded with an &lt;code&gt;$expand&lt;/code&gt; annotation.&lt;/p&gt;

&lt;p&gt;We’ll start by defining the &lt;code&gt;$expand&lt;/code&gt; binding itself. This binding won’t mean anything at all outside of &lt;code&gt;expand-inside&lt;/code&gt;, but we’d like it to be a unique binding so that users can rename it (using, &lt;code&gt;rename-in&lt;/code&gt;, for example) if they wish. To do this, we’ll use the usual trick of defining it as a macro that always produces an error if it’s ever used:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="s2"&gt;"illegal outside an ‘expand-inside’ form"&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Next, we’ll implement a syntax class that will form the bulk of our implementation of &lt;code&gt;expand-inside&lt;/code&gt;. Since we need to find uses of &lt;code&gt;$expand&lt;/code&gt; that might be deeply-nested inside the syntax object provided to &lt;code&gt;expand-inside&lt;/code&gt;, we need to recursively look through the syntax object, find any instances of &lt;code&gt;$expand&lt;/code&gt;, and put it all back together once we’re done. This can be done relatively cleanly using a recursive syntax class:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;do-expand-inside&lt;/span&gt;
    &lt;span class="kd"&gt;#:literals&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="n"&gt;$expand&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;:do-expand-inside&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;do-$expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a:do-expand-inside&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;b:do-expand-inside&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;reassembled&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax?&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="n"&gt;reassembled&lt;/span&gt;
                                  &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="n"&gt;reassembled&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;There are some tricky details to get right in the reassembly of pairs, since syntax lists are actually composed of ordinary pairs rather than syntax pairs, but ultimately, the code for walking a syntax object is small. The key case of this syntax class is the call to &lt;code&gt;do-$expand&lt;/code&gt; in the first clause, which we have not yet defined. This function will actually handle performing the expansion by invoking &lt;code&gt;local-apply-transformer&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;do-$expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
      &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="n"&gt;trans&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trans&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)}})&lt;/span&gt;
       &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;trans&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;disjoin&lt;/span&gt; &lt;span class="nb"&gt;procedure?&lt;/span&gt; &lt;span class="nb"&gt;set!-transformer?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                               &lt;span class="s2"&gt;"syntax transformer"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-apply-transformer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;trans.value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;
                                &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This uses the handy &lt;code&gt;static&lt;/code&gt; syntax class that comes with &lt;code&gt;syntax/parse&lt;/code&gt;, which implicitly handles the call to &lt;code&gt;syntax-local-value&lt;/code&gt; and produces a nice error message if the value returned does not match a predicate. All we have to do is apply the transformer value bound to the &lt;code&gt;trans.value&lt;/code&gt; attribute using &lt;code&gt;local-apply-transformer&lt;/code&gt;, and now the &lt;code&gt;expand-macro&lt;/code&gt; can be written in just a couple lines of code:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;expand-inside&lt;/span&gt;
  &lt;span class="kd"&gt;#:track-literals&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;form:do-expand-inside&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;form.expansion&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;(Using the &lt;code&gt;#:track-literals&lt;/code&gt; option, also new in Racket v7.0, ensures that Check Syntax will be able to recognize the uses of &lt;code&gt;$expand&lt;/code&gt; that disappear from after &lt;code&gt;expand-inside&lt;/code&gt; is expanded.)&lt;/p&gt;

&lt;p&gt;Putting everything together, our example from above really works:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-inside&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
           &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;That’s it. All told, the entire implementation is only about 30 lines of code. For a full, compilable, working example, see &lt;a href="https://gist.github.com/lexi-lambda/65d69043023b519694f50dfca2dc7d33"&gt;this gist&lt;/a&gt;.&lt;/p&gt;</description></item>
  <item>
   <title>Custom core forms in Racket, part II: generalizing to arbitrary expressions and internal definitions</title>
   <link>http://lexi-lambda.github.io/blog/2018/09/13/custom-core-forms-in-racket-part-ii-generalizing-to-arbitrary-expressions-and-internal-definitions/?utm_source=macros&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2018-09-13-custom-core-forms-in-racket-part-ii-generalizing-to-arbitrary-expressions-and-internal-definitions</guid>
   <pubDate>Thu, 13 Sep 2018 00:00:00 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;In my &lt;a href="/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/"&gt;previous blog post&lt;/a&gt;, I covered the process involved in creating a small language with a custom set of core forms. Specifically, it discussed what was necessary to create Hackett’s type language, which involved expanding to custom expressions. While somewhat involved, Hackett’s type language was actually a relatively simple example to use, since it only made use of a subset of the linguistic features Racket supports. In this blog post, I’ll demonstrate how that same technique can be generalized to support runtime bindings and internal definitions, two key concepts useful if intending to develop a more featureful language than Hackett’s intentionally-restrictive type system.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="what-are-internal-definitions"&gt;What are internal definitions?&lt;/h1&gt;

&lt;p&gt;This blog post is going to be largely focused on how to properly implement a form that handles the expansion of &lt;em&gt;internal definitions&lt;/em&gt; in Racket. This is a tricky topic to get right, but before we can discuss internal definitions, we have to establish what definitions themselves are and how they relate to other binding forms.&lt;/p&gt;

&lt;p&gt;In a traditional Lisp, there are two kinds of bindings: top-level bindings and local bindings. In Scheme and its descendants, this distinction is characterized by two different binding forms, &lt;code&gt;define&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;. To a first approximation, &lt;code&gt;define&lt;/code&gt; is used for defining top-level, global bindings, and it resembles variable definitions in many mainstream languages in the sense that definitions using &lt;code&gt;define&lt;/code&gt; are not really expressions. They don’t produce a value, they define a new binding. Definitions written with &lt;code&gt;define&lt;/code&gt; look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="s2"&gt;"hello"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Each definition is made up of two parts: the &lt;em&gt;binding identifier&lt;/em&gt;, in this case &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and the &lt;em&gt;right hand side&lt;/em&gt;, or RHS for short. Each RHS is a single expression that will be evaluated and used as the value for the introduced binding.&lt;/p&gt;

&lt;p&gt;In Scheme and Racket, &lt;code&gt;define&lt;/code&gt; also supports a shorthand form for defining functions in a natural syntax without the explicit need to write &lt;code&gt;lambda&lt;/code&gt;, which looks like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, this is just syntactic sugar. The above form is really just a macro for the following equivalent, expanded version:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Since we only care about fully-expanded programs, we’ll focus exclusively on the expanded version of &lt;code&gt;define&lt;/code&gt; in this blog post, since if we handle that, we’ll also handle the function shorthand’s expansion.&lt;/p&gt;

&lt;p&gt;In contrast to &lt;code&gt;define&lt;/code&gt;, there is also &lt;code&gt;let&lt;/code&gt;, which has a rather different shape. A &lt;code&gt;let&lt;/code&gt; form &lt;em&gt;is&lt;/em&gt; an expression, and it creates local bindings in a delimited scope:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The binding clauses of a &lt;code&gt;let&lt;/code&gt; expression are known as the &lt;em&gt;binding pairs&lt;/em&gt;, and the sequence of expressions afterwards are known as the &lt;em&gt;body&lt;/em&gt; of the &lt;code&gt;let&lt;/code&gt;. Each binding pair consists of a binding identifier and a RHS, just like a top-level definition created with &lt;code&gt;define&lt;/code&gt;, but while &lt;code&gt;define&lt;/code&gt; is a standalone form, the binding pairs cannot meaningfully exist outside of a &lt;code&gt;let&lt;/code&gt;—they are recognized as part of the grammar of the &lt;code&gt;let&lt;/code&gt; form itself.&lt;/p&gt;

&lt;p&gt;Like other Lisps, Racket distinguishes between top-level—or, more precisely, &lt;em&gt;module-level&lt;/em&gt;—bindings and local bindings. A module-level binding can be exported using &lt;code&gt;provide&lt;/code&gt;, which will allow other modules to access the binding by importing the module with &lt;code&gt;require&lt;/code&gt;. Such definitions are treated specially by the macroexpander, compiler, and runtime system alike. There is a pervasive, meaningful difference between module-level definitions and local definitions besides simply scope.&lt;/p&gt;

&lt;p&gt;I am making an effort to make this as clear as possible before discussing internal definitions because without it, the following point can be rather confusing: internal definitions are written using &lt;code&gt;define&lt;/code&gt;, but they are local bindings, &lt;em&gt;not&lt;/em&gt; module-level ones! In Racket, &lt;code&gt;define&lt;/code&gt; is allowed to appear in the body of virtually all block forms like &lt;code&gt;let&lt;/code&gt;, so the following is a legal program:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This program is equivalent to the one expressed using &lt;code&gt;let&lt;/code&gt;. In fact, when the Racket macroexpander expands these local uses of &lt;code&gt;define&lt;/code&gt;, it actually translates them into uses of &lt;code&gt;letrec&lt;/code&gt;. After expanding the above expression, it would look closer to the following:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
           &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this sense, &lt;code&gt;define&lt;/code&gt; is a form with a double life in Racket. When used at the module level, it creates module-level definitions, which remain in a fully-expanded program and can be imported by other modules. When used inside local blocks, it creates internal definitions, which do not remain in fully expanded programs, since they are translated into recursive local binding forms.&lt;/p&gt;

&lt;p&gt;In this blog post, we will ignore module-level definitions. Like in the previous blog post, we will focus exclusively on expanding expressions, not whole modules. However, we will extend our language to allow internal definitions inside local binding forms, and we will translate them into &lt;code&gt;letrec&lt;/code&gt; forms in the same way as the Racket macroexpander.&lt;/p&gt;

&lt;h1 id="revisiting-and-generalizing-the-expression-expander"&gt;Revisiting and generalizing the expression expander&lt;/h1&gt;

&lt;p&gt;In the previous blog post, our expander expanded types, which were essentially expressions from the perspective of the Racket macroexpander. We wrote a syntax class that handled the parsing of a restricted type grammar that disallowed most Racket-level expression forms, like &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;#%plain-lambda&lt;/code&gt;, and &lt;code&gt;quote&lt;/code&gt;. After all, Hackett is not dependently-typed, and it disallows explicit type abstraction to preserve type inference, so it would be a very bad thing if we allowed &lt;code&gt;if&lt;/code&gt; or explicit lambda abstraction to appear in our types. For this blog post, however, we will restructure the type expander to handle the full grammar of expressions permitted by Racket.&lt;/p&gt;

&lt;p&gt;While the syntax class approach used in the previous blog post was cute, this blog post will use ordinary functions defined at phase 1 instead of syntax classes. In practice, this provides superior error reporting, since it reports syntax errors in terms of the form that went wrong, not the form prior to expansion. Since we can still use &lt;code&gt;syntax-parse&lt;/code&gt; to parse the arguments to these functions, we don’t lose any expressive power in the expression of our pattern language.&lt;/p&gt;

&lt;p&gt;To start, we’ll extract the call to &lt;code&gt;local-expand&lt;/code&gt; into its own function. This corresponds to the &lt;code&gt;type&lt;/code&gt; syntax class from the previous blog post, but we’ll use phase 1 parameters to avoid threading so many explicit function arguments around:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-parameter&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;current-stop-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-parameter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-parameter&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-stop-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Due to the way &lt;code&gt;local-expand&lt;/code&gt; implicitly extends the stop list, as discussed in the previous blog post, we can initialize the stop list to a list containing just &lt;code&gt;define-values&lt;/code&gt; and &lt;code&gt;define-syntaxes&lt;/code&gt;, and the other forms we care about will be included automatically.&lt;/p&gt;

&lt;p&gt;Next, we’ll use this function to implement a &lt;code&gt;expand-expression&lt;/code&gt; function, which will emulate the way the expander expands a single expression, as the name implies. We’ll ignore any custom core forms for now, so we’ll just focus exclusively on the Racket core forms.&lt;/p&gt;

&lt;p&gt;A few of Racket’s core forms are not actually subject to any expansion at all, and they expand to themselves. These forms are &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;quote-syntax&lt;/code&gt;, and &lt;code&gt;#%variable-reference&lt;/code&gt;. Additionally, &lt;code&gt;#%top&lt;/code&gt; is not something useful to handle ourselves, since it involves no recursive expansion, so we’ll treat it as if it expands to itself as well and allow the expander to raise any unbound identifier errors it produces. Here’s what the &lt;code&gt;expand-expression&lt;/code&gt; function looks like when exclusively handling these things:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="ss"&gt;quote-syntax&lt;/span&gt; &lt;span class="k"&gt;#%top&lt;/span&gt; &lt;span class="k"&gt;#%variable-reference&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Another set of Racket core forms are simple expressions which contain subforms, all of which are themselves expressions. These forms include things like &lt;code&gt;#%expression&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, and &lt;code&gt;if&lt;/code&gt;, and they can be expanded recursively. We’ll add another clause to handle these, which can be written with a straightforward recursive call to &lt;code&gt;expand-expression&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="k"&gt;#%expression&lt;/span&gt; &lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="k"&gt;begin0&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;with-continuation-mark&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Another easy form to handle is &lt;code&gt;set!&lt;/code&gt;, since it also requires simple recursive expansion, but it can’t be handled in the same way as the above forms since one of its subforms (the variable to mutate) should not be expanded. It needs another small clause:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:set!&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The other expressions are harder, since they’re all the binding forms. Fully-expanded Racket code has four local binding forms: &lt;code&gt;#%plain-lambda&lt;/code&gt;, &lt;code&gt;case-lambda&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, and &lt;code&gt;letrec-values&lt;/code&gt;. Additionally, as discussed in the previous blog post, &lt;code&gt;local-expand&lt;/code&gt; can also produce &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; forms produced by local syntax bindings. In the type expander, we completely disallowed runtime bindings from appearing in the resulting program, so we completely removed &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; in our expansion, but in the case of handling arbitrary Racket programs, we actually want to leave a &lt;code&gt;letrec-values&lt;/code&gt; form behind to hold any runtime bindings (i.e. the &lt;code&gt;values&lt;/code&gt; part of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We’ll start with &lt;code&gt;#%plain-lambda&lt;/code&gt;, which is the simplest of all the five aforementioned binding forms. It binds a sequence of identifiers at runtime, and they are in scope within the body of the lambda expression. Just as we created and used an internal-definition context to hold the bindings of a &lt;code&gt;letrec-syntax+values&lt;/code&gt; form in the previous blog post, we’ll do the same for Racket’s other binding forms as well:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:#%plain-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, the above handling of &lt;code&gt;#%plain-lambda&lt;/code&gt; isn’t &lt;em&gt;quite&lt;/em&gt; right, since the argument list can also include a “rest argument” binding in addition to a sequence of positional arguments. To accommodate this, we can introduce a simple syntax class that handles the different permutations:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;plain-formals&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"formals"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id*:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;id**:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;id*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;id**&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we can use this to adjust &lt;code&gt;#%plain-lambda&lt;/code&gt; to handle rest arguments:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:#%plain-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;formals:plain-formals&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;formals.id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;formals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Next, we’ll handle &lt;code&gt;case-lambda&lt;/code&gt;. As it turns out, expanding &lt;code&gt;case-lambda&lt;/code&gt; is almost exactly the same as expanding &lt;code&gt;#%plain-lambda&lt;/code&gt;, except that it has multiple clauses. Since each clause is expanded identically to the body of a &lt;code&gt;#%plain-lambda&lt;/code&gt;, and it even has the same shape, the clauses can be extracted into a separate syntax class to share code between the two forms:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;lambda-clause&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;formals:plain-formals&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;formals.id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;formals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, both &lt;code&gt;#%plain-lambda&lt;/code&gt; and &lt;code&gt;case-lambda&lt;/code&gt; can be handled in a few lines of code each:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:#%plain-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;clause:lambda-clause&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;clause.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;

&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:case-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;clause:lambda-clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;clause.expansion&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Finally, we need to tackle the three &lt;code&gt;let&lt;/code&gt; forms. None of these involve any fundamentally new ideas, but they are a little bit more involved than the variants of lambda due to the need to handle the RHSs. Each variant is slightly different, but not dramatically so: the bindings aren’t in scope when expanding the RHSs of &lt;code&gt;let-values&lt;/code&gt;, but they are for &lt;code&gt;letrec-values&lt;/code&gt; and &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, and &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; creates transformer bindings and must evaluate some RHSs in phase 1 while &lt;code&gt;let-values&lt;/code&gt; and &lt;code&gt;letrec-values&lt;/code&gt; exclusively bind runtime bindings. It would be possible to implement these three forms in separate clauses, but since we’d ideally like to duplicate as little code as possible, we can write a rather elaborate &lt;code&gt;syntax/parse&lt;/code&gt; pattern to handle all three binding forms all at once.&lt;/p&gt;

&lt;p&gt;We’ll start by handling &lt;code&gt;let-values&lt;/code&gt; alone to keep things simple:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This isn’t dramatically different from the implementation of &lt;code&gt;#%plain-lambda&lt;/code&gt;. The only difference is that we have to recursively invoke &lt;code&gt;expand-expression&lt;/code&gt; on the RHSs in addition to expanding the body expressions. To handle &lt;code&gt;letrec-values&lt;/code&gt; in the same clause, however, we’ll have to get a little more creative.&lt;/p&gt;

&lt;p&gt;So far, we haven’t actually tapped very far into &lt;code&gt;syntax/parse&lt;/code&gt;’s pattern language over the course of these two blog posts. The full language available to patterns is rather extensive, and we can take advantage of that to write a modification of the above clause that handles both &lt;code&gt;let-values&lt;/code&gt; and &lt;code&gt;letrec-values&lt;/code&gt; at once:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:letrec-values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]}}}&lt;/span&gt;
  &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rec?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;~bind&lt;/code&gt; pattern allows us to explicitly control how attributes are bound as part of the pattern-matching process, which allows us to track when we want to enable the recursive binding behavior of &lt;code&gt;letrec-values&lt;/code&gt; in our handler code. Since the vast majority of the logic is otherwise identical, this is a significant improvement over duplicating the clause.&lt;/p&gt;

&lt;p&gt;Adding support for &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; is done in the same general way, but the pattern is even more involved. In addition to tracking whether or not the bindings are recursive, we have to track if any syntax bindings were present at all, and if they were, bind them with &lt;code&gt;syntax-local-bind-syntaxes&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:letrec-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
             &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x/s:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)}}&lt;/span&gt;
  &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x/s&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
               &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rec?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;syntax/loc&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This behemoth clause handles all three varieties of &lt;code&gt;let&lt;/code&gt; forms that can appear in the result of &lt;code&gt;local-expand&lt;/code&gt;. Notably, in the &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; case, we expand into &lt;code&gt;letrec-values&lt;/code&gt;, since the transformer bindings are effectively erased, and we use &lt;code&gt;syntax-track-origin&lt;/code&gt; to record that the result originally came from a use of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With these five clauses, we’ve handled all the special forms that can appear in expression position in Racket’s kernel language. To tie things off, we just need to handle the cases of a variable reference, which is represented by a bare identifier not bound to syntax, or literal data, like numbers or strings. We can add one more clause at the end to handle those:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
 &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Putting them all together, our &lt;code&gt;expand-expression&lt;/code&gt; function looks as follows:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="ss"&gt;quote-syntax&lt;/span&gt; &lt;span class="k"&gt;#%top&lt;/span&gt; &lt;span class="k"&gt;#%variable-reference&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

      &lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="k"&gt;#%expression&lt;/span&gt; &lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="k"&gt;begin0&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;with-continuation-mark&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;

      &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:#%plain-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;clause:lambda-clause&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;clause.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;

      &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:case-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;clause:lambda-clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;clause.expansion&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;

      &lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}&lt;/span&gt;
                  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:letrec-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}}&lt;/span&gt;
             &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
                   &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x/s:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)}}&lt;/span&gt;
        &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x/s&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
       &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
       &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rec?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;syntax/loc&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;

      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
       &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If we try it out, we’ll see that it really does work! Even complicated local binding forms are handled properly by our expander:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-rename-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                       &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-rename-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="n"&gt;#&amp;lt;syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-values&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We are now able to expand arbitrary Racket expressions in the same way that the expander does. While this might not seem immediately useful—after all, we haven’t actually gained anything here over just calling &lt;code&gt;local-expand&lt;/code&gt; with an empty stop list—we can use this as the basis of an expander that can extensibly handle custom core forms, which I may cover in a future blog post.&lt;/p&gt;

&lt;h1 id="adding-support-for-internal-definitions"&gt;Adding support for internal definitions&lt;/h1&gt;

&lt;p&gt;In the previous section, we defined an expander that could expand arbitrary Racket expressions, but our expander is still imperfect: we still do not support internal definitions. For all forms that have bodies, including &lt;code&gt;#%plain-lambda&lt;/code&gt;, &lt;code&gt;case-lambda&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, &lt;code&gt;letrec-values&lt;/code&gt;, and &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, Racket permits the use of internal definitions.&lt;/p&gt;

&lt;p&gt;In practice, internal-definition contexts allow for an increased degree of modularity compared to traditional local binding forms, since they provide an &lt;em&gt;extensible&lt;/em&gt; binding language. Users may mix many different binding forms within a single definition context, such as &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;define-syntax&lt;/code&gt;, &lt;code&gt;match-define&lt;/code&gt;, and even &lt;code&gt;struct&lt;/code&gt;. However, this means the rewriting process described earlier in this blog post is not as simple as detecting the definitions and lifting them into a local binding form, since it’s not immediately apparent which forms are binding forms and which are expressions!&lt;/p&gt;

&lt;p&gt;For this reason, expanding internal-definition contexts happens to be a nontrivial problem in itself. It involves a little more care than expanding expressions does, since it requires using partial expansion to discover which forms are definitions and which forms are expressions. We must take care to never expand too much, but also to expand enough that we reveal all uses of &lt;code&gt;define-values&lt;/code&gt; and &lt;code&gt;define-syntaxes&lt;/code&gt; (which all definition forms eventually expand into). We also must handle the splicing behavior of &lt;code&gt;begin&lt;/code&gt;, which is necessary to allow single forms to expand into multiple definitions.&lt;/p&gt;

&lt;p&gt;We’ll start by writing an &lt;code&gt;expand-body&lt;/code&gt; function, which operates similarly to our previous &lt;code&gt;expand-expression&lt;/code&gt; function. Unlike &lt;code&gt;expand-expression&lt;/code&gt;, &lt;code&gt;expand-body&lt;/code&gt; will accept a &lt;em&gt;list&lt;/em&gt; of syntax objects, which represents the sequence of forms that make up the body. Logically, each body will create a first-class definition context with &lt;code&gt;syntax-local-make-definition-context&lt;/code&gt; to represent the sequence of definitions:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The bulk of our &lt;code&gt;expand-body&lt;/code&gt; function will be a loop that partially expands body forms, adds definitions to the definition context as it discovers them, and returns the expressions and runtime definitions to be rewritten into binding pairs for a &lt;code&gt;letrec-values&lt;/code&gt; form. Additionally, the loop will also track so-called &lt;em&gt;disappeared uses&lt;/em&gt; and &lt;em&gt;disappeared bindings&lt;/em&gt;, which are attached to the expansion using syntax properties to allow tools like DrRacket to learn about the binding structure of phase 1 definitions that are erased as part of macroexpansion.&lt;/p&gt;

&lt;p&gt;The skeleton of this loop is relatively straightforward to write. We will iterate over the syntax objects that make up the body, expand them, and process the expansion using &lt;code&gt;syntax-parse&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stxs&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;disappeared-bindings&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()])&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;empty?&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="p"&gt;)))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The hard part, of course, is actually handling the potential results of that expansion. We need to handle three forms specially: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;define-values&lt;/code&gt;, and &lt;code&gt;define-syntaxes&lt;/code&gt;. All other results of partial expansion will be treated as expressions. We’ll start by handling &lt;code&gt;begin&lt;/code&gt;, since it’s the simplest case; we only need to prepend the subforms to the list of body forms to be processed, then continue looping:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:begin&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, as is often the case, this isn’t quite perfect, since the information that these forms came from a surrounding &lt;code&gt;begin&lt;/code&gt; is lost, which tools like DrRacket want to know. To solve this problem, the expander adjusts the &lt;code&gt;origin&lt;/code&gt; property for all spliced forms, which we can mimic using &lt;code&gt;syntax-track-origin&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:begin&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is sufficient for &lt;code&gt;begin&lt;/code&gt;, so we can move onto the actual definitions themselves. This actually isn’t too hard, since we just need to add the bindings we discover to the first-class definition context and preserve &lt;code&gt;define-values&lt;/code&gt; bindings as binding pairs:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This solution is missing one thing, however, which is the use of &lt;code&gt;syntax-local-identifier-as-binding&lt;/code&gt; to any use-site scopes that were added to the binding identifier while expanding the binding form in the definition context. Explaining precisely why this is necessary is outside the scope of this blog post, and is best understood by reading &lt;a href="http://www.cs.utah.edu/plt/scope-sets/pattern-macros.html#%28part._use-site%29"&gt;the section on use-site scopes&lt;/a&gt; in the paper that describes the theory behind Racket’s current macro system, Bindings as Sets of Scopes. In any case, the impact on our implementation is small:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Finally, as with &lt;code&gt;begin&lt;/code&gt;, we want to track that the binding pairs we generate actually came from a use of &lt;code&gt;define-values&lt;/code&gt; (which in turn likely came from a use of some other definition form). Therefore, we’ll add another use of &lt;code&gt;syntax-track-origin&lt;/code&gt; to copy and extend the necessary properties:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;That’s it for &lt;code&gt;define-values&lt;/code&gt;. All that’s left is to handle &lt;code&gt;define-syntaxes&lt;/code&gt;, which is quite similar, but instead of storing the definition in a binding pair, its RHS is immediately evaluated and added to the definition context using &lt;code&gt;syntax-local-bind-syntaxes&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-syntaxes&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;As the above snippet indicates, this is also where the disappeared uses and disappeared bindings come in. In previous cases, we’ve used &lt;code&gt;syntax-track-origin&lt;/code&gt; to indicate that a piece of syntax was the result of expanding a different piece of syntax, but in this case, &lt;code&gt;define-syntaxes&lt;/code&gt; doesn’t expand into anything at all; it’s simply removed from the expansion entirely. Therefore, we need to resort to tracking the information in syntax properties on the resulting &lt;code&gt;letrec-values&lt;/code&gt; form, so we’ll save them for later.&lt;/p&gt;

&lt;p&gt;Finally, to finish things up, we can add a catchall clause that handles all other forms, which are now guaranteed to be expressions:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This completes our loop that processes definition forms, so all that’s left to do is handle the results. The only significant remaining work is to actually expand the RHSs of the binding pairs we collected and the body expressions, which can be done by calling our own &lt;code&gt;expand-expression&lt;/code&gt; function directly:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expanded-binding-clauses&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;binding-clause&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;binding-clause&lt;/span&gt;
      &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)])])))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expanded-exprs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Finally, we can assemble all the pieces together into a single local binding form with the appropriate syntax properties:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;expanded-binding-clauses&lt;/span&gt; &lt;span class="o"&gt;#,@&lt;/span&gt;&lt;span class="n"&gt;expanded-exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;disappeared-bindings&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;That’s it. We’ve now written an &lt;code&gt;expand-body&lt;/code&gt; function that can process internal definition contexts in the same way that the macroexpander does. Overall, the whole function is just under 45 lines of code:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stxs&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;disappeared-bindings&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()])&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;empty?&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:begin&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                               &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-syntaxes&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]))))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expanded-binding-clauses&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;binding-clause&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;binding-clause&lt;/span&gt;
            &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
               &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)])])))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expanded-exprs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;expanded-binding-clauses&lt;/span&gt; &lt;span class="o"&gt;#,@&lt;/span&gt;&lt;span class="n"&gt;expanded-exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;disappeared-bindings&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The next step is to actually use this function. We need to replace certain recursive calls to &lt;code&gt;expand-expression&lt;/code&gt; with calls to &lt;code&gt;expand-body&lt;/code&gt;, but if we do this naïvely, we’ll have some problems. Currently, when we expand body forms, they’re always immediately inside another definition context (i.e. the bindings introduced by lambda formals or by &lt;code&gt;let&lt;/code&gt; binding pairs), but they haven’t actually been expanded in that context yet. When we call &lt;code&gt;expand-body&lt;/code&gt;, we create a nested context, which will inherit the bindings, but won’t automatically add the parent context’s scope. Therefore, we need to manually call &lt;code&gt;internal-definition-context-introduce&lt;/code&gt; on the body syntax objects before calling &lt;code&gt;expand-body&lt;/code&gt;. We can write a small helper function to make this easier:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body/in-ctx&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-ctx-scope&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-ctx-scope&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;add-ctx-scope&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we just need to replace the relevant calls to &lt;code&gt;expand-expression&lt;/code&gt; with calls to &lt;code&gt;expand-body/in-ctx&lt;/code&gt;, starting with a minor adjustment to our &lt;code&gt;lambda-clause&lt;/code&gt; syntax class from earlier:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;lambda-clause&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;formals:plain-formals&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;formals.id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;formals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body/in-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The only other change must occur in the handling of the various &lt;code&gt;let&lt;/code&gt; forms, which similarly replaces &lt;code&gt;expand-expression&lt;/code&gt; with &lt;code&gt;expand-body/in-ctx&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:letrec-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
             &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x/s:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)}}&lt;/span&gt;
  &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x/s&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
               &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rec?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body/in-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;syntax/loc&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With these changes, we’ve now extended our expression expander with the ability to expand internal definitions. We can see this in action on a simple example:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-rename-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-rename-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="n"&gt;#&amp;lt;syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-values&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Just as we’d like, the transformer bindings were expanded and subsequently eliminated, and the runtime binding was collected into a &lt;code&gt;letrec-values&lt;/code&gt; form. The outer &lt;code&gt;let-values&lt;/code&gt; is left over from the outer &lt;code&gt;let&lt;/code&gt;, which is needed only to create an internal-definition context to hold our internal definitions.&lt;/p&gt;

&lt;h1 id="putting-the-expression-expander-to-work"&gt;Putting the expression expander to work&lt;/h1&gt;

&lt;p&gt;So far, we’ve done a lot of work to emulate the behavior of Racket’s macroexpander, and as the above example demonstrates, we’ve been fairly successful in that goal. However, you might be wondering &lt;em&gt;why&lt;/em&gt; we did any of this, as replicating the behavior of &lt;code&gt;local-expand&lt;/code&gt; is not very useful on its own. As mentioned above, this can be used as the foundation of an expander for custom core forms that extends, rather than replaces, the built-in Racket core forms, It can also be used to “cheat” and expand through the behavior of the &lt;code&gt;local-expand&lt;/code&gt; stop list, which implicitly adds the Racket core forms to any non-empty stop list. Hopefully, I’ll have a chance to cover some of these things more deeply in the future, but for now, I’ll just give a small taste of the latter.&lt;/p&gt;

&lt;p&gt;By using the power of our &lt;code&gt;expand-expression&lt;/code&gt; function, it’s actually possible to use this kind of expression expander to do genuinely nefarious things, such as hijack the behavior of arbitrary macros! For example, we could do something evil like make &lt;code&gt;for&lt;/code&gt; loops run in reverse order by adding &lt;code&gt;for&lt;/code&gt; to &lt;code&gt;current-stop-list&lt;/code&gt;, then adding an additional special case to &lt;code&gt;expand-expression&lt;/code&gt; for &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;current-stop-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-parameter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="kd"&gt;#:literals&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="c1"&gt;; ...&lt;/span&gt;
      &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;seq:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sequence-&amp;gt;list&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
      &lt;span class="c1"&gt;; ...&lt;/span&gt;
    &lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Amazingly, due to the fact that we’ve taken complete control of the expansion process, this will rewrite uses of &lt;code&gt;for&lt;/code&gt; &lt;em&gt;even if they are introduced by macroexpansion&lt;/em&gt;. For example, we could write a small macro that expands into a use of &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-up-to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-range&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-up-to&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If we write a wrapper macro that applies our evil version of &lt;code&gt;expand-expression&lt;/code&gt; to its body, then wrap a use of our &lt;code&gt;print-up-to&lt;/code&gt; macro with it, it will execute the loop in reverse order:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;hijack-for-loops&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;form:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hijack-for-loops&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-up-to&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;On its own, this is not that impressive, since we could have just used &lt;code&gt;local-expand&lt;/code&gt; on the body directly to achieve this. However, what’s remarkable about &lt;code&gt;hijack-for-loops&lt;/code&gt; is that it will work even if the &lt;code&gt;for&lt;/code&gt; loop is buried deep inside some arbitrary expression:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hijack-for-loops&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-up-to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Of course, this example is rather contrived—mucking with &lt;code&gt;for&lt;/code&gt; loops like this isn’t useful at all, and nobody would really write &lt;code&gt;print-up-to&lt;/code&gt; as a macro, anyway—but there is potential for using this technique to do more interesting things.&lt;/p&gt;

&lt;h1 id="closing-thoughts"&gt;Closing thoughts&lt;/h1&gt;

&lt;p&gt;The system outlined in this blog post is not something I would recommend using in any real macro. It is enormously complicated, requires knowledge well above that of your average working macrologist, and it involves doing rather horrible things to the macro system, things it was undoubtably never designed to do. Still, I believe this blog post is useful, for a few different reasons:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;The technology outlined in this post, while perhaps not directly applicable to existing real-world problems, provides a framework for implementing various new kinds of syntax transformations in Racket &lt;em&gt;without&lt;/em&gt; extending the macro system. It demonstrates the expressive power of the macro system, and it hopefully lays the foundation for a better, more high-level interface for users who wish to define their own languages with custom core forms.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;This system provides insight into the way the Racket macroexpander operates, &lt;em&gt;in terms of the userspace syntax API&lt;/em&gt;. The canonical existing model of hygienic macroexpansion, in the aforementioned &lt;a href="http://www.cs.utah.edu/plt/scope-sets/"&gt;Bindings as Sets of Scopes&lt;/a&gt; paper, does not explain the workings of internal definition contexts in detail, and it certainly doesn’t explain them in terms that a Racket programmer would already be familiar with. By reencoding those ideas within the macro system itself, an advanced macro writer may be able to more easily connect concepts in the macro system’s implementation to concepts they have already been exposed to.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The capability of the proof-of-concept outlined here demonstrates that the limitation imposed by the existing implementation of the stop list (namely, the way it is implicitly extended with additional identifiers) is essentially artificial, and it can be hacked around with sufficient (albeit significant) effort. This isn’t enormously important, but it is somewhat relevant to a recent debate in &lt;a href="https://github.com/racket/racket/issues/2154"&gt;a GitHub issue&lt;/a&gt; about the handling of the &lt;code&gt;local-expand&lt;/code&gt; stop list.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, for myself as much as anyone else, this implementation records in a concise way (perhaps overly concise at times) the collection of very subtle details I’ve learned over the past six months about how information is preserved and propagated during the expansion process.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;This blog post is not for everybody. If you made it to the end, give yourself a pat on the back. If you made it to the end &lt;em&gt;and&lt;/em&gt; understood everything you read: congratulations, you are a certified expert in Racket macro programming. If not, do not fear, and do not lose hope—I plan for something significantly more mellow next time.&lt;/p&gt;

&lt;p&gt;As always, I’d like to give thanks to the people who contributed significantly, if indirectly, to the contents of this blog post, namely &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, &lt;a href="http://mballantyne.net"&gt;Michael Ballantyne&lt;/a&gt;, and &lt;a href="http://www.ccs.neu.edu/home/ryanc/"&gt;Ryan Culpepper&lt;/a&gt;. And finally, for those interested, all of the code in this blog post can be found in a runnable form &lt;a href="https://gist.github.com/lexi-lambda/c4f4b91ac9c0a555447d72d02e18be7b"&gt;in this GitHub gist&lt;/a&gt;.&lt;/p&gt;</description></item>
  <item>
   <title>Reimplementing Hackett’s type language: expanding to custom core forms in Racket</title>
   <link>http://lexi-lambda.github.io/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/?utm_source=macros&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2018-04-15-reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket</guid>
   <pubDate>Sun, 15 Apr 2018 00:00:00 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;In the past couple of weeks, I &lt;a href="https://github.com/lexi-lambda/hackett/commit/ba64193da38f63dab2523f42c1b7614cdfa8c935"&gt;completely rewrote the implementation of Hackett’s type language&lt;/a&gt; to improve the integration between the type representation and Racket’s macro system. The new type language effectively implements a way to reuse as much of the Racket macroexpanding infrastructure as possible while expanding a completely custom language, which uses a custom set of core forms. The fundamental technique used to do so is not novel, and it seems to be periodically rediscovered every so often, but it has never been published or documented anywhere, and getting it right involves understanding a great number of subtleties about the Racket macro system. While I cannot entirely eliminate the need to understand those subtleties, in this blog post, I hope to make the secret sauce considerably less secret.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;This blog post is both a case study on how I implemented the expander for Hackett’s new type language and a discussion of how such a technique can apply more generally. Like &lt;a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/"&gt;my previous blog post on Hackett&lt;/a&gt;, which covered the implementation of its namespace system, the implementation section of this blog post is highly technical and probably requires significant experience with Racket’s macro system to completely comprehend. However, the surrounding material is written to be more accessible, so even if you are not a Racket programmer, you should hopefully be able to understand the big ideas behind this change.&lt;/p&gt;

&lt;h1 id="what-are-core-forms"&gt;What are core forms?&lt;/h1&gt;

&lt;p&gt;Before we can get started writing &lt;em&gt;custom core forms&lt;/em&gt;, we need to understand the meaning of Racket’s plain old &lt;em&gt;core forms&lt;/em&gt;. What is a core form? In order to answer that question, we need to think about how Racket’s expansion and compilation model works.&lt;/p&gt;

&lt;p&gt;To start, let’s consider a simple Racket program. Racket programs are organized into modules, which are usually written with a &lt;code&gt;#lang&lt;/code&gt; line at the top. In this case, we’ll use &lt;code&gt;#lang racket&lt;/code&gt; to keep things simple:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;How does Racket see this program? Well, before it can do anything with it, it must parse the program text, which is known in Racket as &lt;em&gt;reading&lt;/em&gt; the program. The &lt;code&gt;#lang&lt;/code&gt; line controls how the program is read—some &lt;code&gt;#lang&lt;/code&gt;s provide parsers that allow syntax that is very different from the parser used for &lt;code&gt;#lang racket&lt;/code&gt;—but no matter which reader is used, the result is an s-expression (actually a syntax object, but essentially an s-expression) representing a module. In the case of the above program, the result looks like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;racket&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%module-begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note the introduction of &lt;code&gt;#%module-begin&lt;/code&gt;. Despite the fancy name, this is really just an ordinary macro provided by the &lt;code&gt;racket&lt;/code&gt; language. By convention, the reader and expander cooperate to ensure the body of every module is wrapped with &lt;code&gt;#%module-begin&lt;/code&gt;; as we’ll see shortly, this allows languages to add functionality that affects the entire contents of the module.&lt;/p&gt;

&lt;p&gt;One the program has been read, it is subsequently &lt;em&gt;expanded&lt;/em&gt; by the macroexpander. As the name implies, this is the phase that expands all the macros in a module. What does the above module look like after expansion? Well, it doesn’t look unrecognizable, but it certainly does look different:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;racket&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-module-begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="nb"&gt;call-with-values&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="n"&gt;print-values&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Let’s note the things that changed:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;#%module-begin&lt;/code&gt; was replaced with &lt;code&gt;#%plain-module-begin&lt;/code&gt;. &lt;code&gt;#%plain-module-begin&lt;/code&gt; is a binding that wraps the body of every expanded module, and all definitions of &lt;code&gt;#%module-begin&lt;/code&gt; in any language must eventually expand to &lt;code&gt;#%plain-module-begin&lt;/code&gt;. However, &lt;code&gt;#lang racket&lt;/code&gt;’s &lt;code&gt;#%module-begin&lt;/code&gt; doesn’t &lt;em&gt;just&lt;/em&gt; expand to &lt;code&gt;#%plain-module-begin&lt;/code&gt;, it also wraps bare expressions at the top level of a module so that their results are printed. This is why running the above program prints &lt;code&gt;5&lt;/code&gt; even though there is no code related to printing in the original program!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The lambda shorthand used with &lt;code&gt;define&lt;/code&gt; was converted to an explicit use of &lt;code&gt;lambda&lt;/code&gt;, and it was expanded to &lt;code&gt;define-values&lt;/code&gt;. In Racket, &lt;code&gt;define&lt;/code&gt; and &lt;code&gt;define-syntax&lt;/code&gt; are really just macros for &lt;code&gt;define-values&lt;/code&gt; and &lt;code&gt;define-syntaxes&lt;/code&gt; that only bind a single identifier.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All function applications were tagged explicitly with &lt;code&gt;#%plain-app&lt;/code&gt;. This syntactically distinguishes function applications from uses of forms like &lt;code&gt;define-values&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;. It also allows languages to customize function application by providing their own macros named &lt;code&gt;#%app&lt;/code&gt; (just like languages can provide their own macros named &lt;code&gt;#%module-begin&lt;/code&gt; that expand to &lt;code&gt;#%plain-module-begin&lt;/code&gt;), but that is outside the scope of this blog post.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All literals have been wrapped with &lt;code&gt;quote&lt;/code&gt;, so &lt;code&gt;2&lt;/code&gt; became &lt;code&gt;'2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; became &lt;code&gt;'3&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Importantly, the resulting program contains &lt;strong&gt;no macros&lt;/strong&gt;. Such programs are called &lt;em&gt;fully expanded&lt;/em&gt;, since all macros have been eliminated and no further expansion can take place.&lt;/p&gt;

&lt;p&gt;So what’s left behind? Well, some of the things in the program are literal data, like the numbers &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt;. There are also some variable references, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;add2&lt;/code&gt;. Most of the program, however, is built out of primitives like &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;#%plain-module-begin&lt;/code&gt;, &lt;code&gt;#%plain-app&lt;/code&gt;, &lt;code&gt;define-values&lt;/code&gt;, and &lt;code&gt;lambda&lt;/code&gt;. These primitives are &lt;em&gt;core forms&lt;/em&gt;—they are not variables, since they do not represent bindings that contain values at runtime, but they are also not macros, since they cannot be expanded any further.&lt;/p&gt;

&lt;p&gt;In this sense, a fully-expanded program is just like a program in most languages that do not have macros. Core forms in Racket correspond to the syntax of other languages. We can imagine a JavaScript program similar to the above fully-expanded Racket program:&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Just as this JavaScript program is internally transformed into an AST containing a definition node, a function abstraction node, and some function application nodes, a fully-expanded Racket program represents an AST ready to be sent off to be &lt;em&gt;compiled&lt;/em&gt;. The Racket compiler has built-in rules for how to compile core forms like &lt;code&gt;define-values&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;, and &lt;code&gt;#%plain-app&lt;/code&gt;, and the result is optimized Racket bytecode.&lt;/p&gt;

&lt;p&gt;In the remainder of this blog post, as most discussions of macros do, we’ll ignore the &lt;em&gt;read&lt;/em&gt; and &lt;em&gt;compile&lt;/em&gt; steps of the Racket program pipeline and focus exclusively on the &lt;em&gt;expand&lt;/em&gt; step. It’s useful, however, to keep the other steps in mind, since we’re going to be discussing what it means to implement custom core forms, and core forms really only make sense in the context of the subsequent compilation step that consumes them.&lt;/p&gt;

&lt;h2 id="rackets-default-core-forms"&gt;Racket’s default core forms&lt;/h2&gt;

&lt;p&gt;So, now that we know what core forms are in an abstract sense, what are they in practice? We’ve already encountered &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;#%plain-module-begin&lt;/code&gt;, &lt;code&gt;#%plain-app&lt;/code&gt;, &lt;code&gt;define-values&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;, and &lt;code&gt;quote&lt;/code&gt;, but there are many more. The full list is available in the section of the Racket reference named &lt;a href="http://docs.racket-lang.org/reference/syntax-model.html#%28part._fully-expanded%29"&gt;Fully Expanded Programs&lt;/a&gt;, and I will not list all of them here. In general, they are more or less what you’d expect. The list of Racket’s core forms also includes things like &lt;code&gt;define-syntaxes&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, &lt;code&gt;letrec-values&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;quote-syntax&lt;/code&gt;, and &lt;code&gt;set!&lt;/code&gt;. Fundamentally, these correspond to the basic operations the Racket compiler understands, and it allows the remainder of Racket’s compilation pipeline to ignore the complexities of macroexpansion.&lt;/p&gt;

&lt;p&gt;These forms are fairly versatile, and it’s easy to build high-level abstractions on top of them. For example, &lt;code&gt;#lang racket&lt;/code&gt; implements &lt;code&gt;cond&lt;/code&gt; as a macro that eventually expands into &lt;code&gt;if&lt;/code&gt;, and it implements &lt;code&gt;syntax&lt;/code&gt; as a macro that eventually expands into function calls and &lt;code&gt;quote-syntax&lt;/code&gt;. The real power comes in the way new macros can be built out of other macros, not just core forms, so Racket’s &lt;code&gt;match&lt;/code&gt; can expand into uses of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt;, and it doesn’t need to concern itself with using &lt;code&gt;let-values&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt;. For this reason, Racket’s core forms are quite capable of representing any language imaginable, since fully-expanded programs are essentially instructions for the Racket virtual machine, and macros are mini-compilers that can be mixed and matched.&lt;/p&gt;

&lt;h2 id="the-need-for-custom-core-forms"&gt;The need for custom core forms&lt;/h2&gt;

&lt;p&gt;With that in mind, why might we wish to define &lt;em&gt;custom&lt;/em&gt; core forms? In fact, what would such a thing even mean? By their very nature, &lt;em&gt;all&lt;/em&gt; Racket programs eventually expand into Racket’s core forms; new core forms cannot be added because Racket’s underlying compiler infrastructure is not (currently) extensible. New forms can be added that are defined in terms of other forms, but adding new primitives doesn’t make any sense, since the compiler would not know what to do with them.&lt;/p&gt;

&lt;p&gt;Despite this, there &lt;em&gt;are&lt;/em&gt; at least two use-cases in which a programmer might wish to customize the set of core forms produced by the macroexpander. Each situation is slightly different, but they both revolve around the same idea.&lt;/p&gt;

&lt;h3 id="supporting-multiple-backends"&gt;Supporting multiple backends&lt;/h3&gt;

&lt;p&gt;The most commonly discussed use case for customizing the set of core forms is for languages that wish to use the Racket macroexpander, but target backends that are not the Racket compiler. For example, a user might implement a Racket &lt;code&gt;#lang&lt;/code&gt; that describes electronic circuits, and they might even implement a way to execute such a program in Racket, but they might &lt;em&gt;also&lt;/em&gt; wish to compile the result to a more traditional hardware description language. Like other languages in the Racket ecosystem, such a language would be made up of a tower of macros built on top of core forms; unlike other languages, the core forms might need to be more abstract than the ones provided by Racket to efficiently compile to other targets.&lt;/p&gt;

&lt;p&gt;In the case of a hardware description language, the custom core forms might include things like &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; for declaring circuit inputs and outputs, and expressions might be built out of hardware operations rather than high-level things like function calls. The Racket macroexpander would expand the input program into the custom set of core forms, at which point an external compiler program could compile the resutling AST in a more traditional way. If the language author wished, they could &lt;em&gt;additionally&lt;/em&gt; define implementations of these core forms as Racket macros that eventually expand into Racket, which would allow them to emulate their circuits in Racket at little cost, but this would be a wholly optional step.&lt;/p&gt;

&lt;p&gt;Essentially, this use case stems from a desire to reuse Racket’s advanced language-development technology, such as the macroexpander, the module system, and editor tooling, without also committing to using Racket as a runtime, which is not always appropriate for all languages. This use case is not nearly as easy as it ought to be, but it is a common request, and it is possible that future improvements to the Racket toolchain will be designed specifically to address this problem.&lt;/p&gt;

&lt;h3 id="compiling-an-extensible-embedded-language"&gt;Compiling an extensible embedded language&lt;/h3&gt;

&lt;p&gt;A second use case for custom core forms is less frequently discussed, but I think it might actually be significantly more common in practice were it available in a form accessible to working macro programmers. In this scenario, users might wish to remain within Racket, but still want to define a custom language that other macros can consume.&lt;/p&gt;

&lt;p&gt;This concept is a little more vague and fuzzily-defined than the case of developing a separate backend, so allow me to propose an example. Imagine a Racket programmer decides to build an embedded DSL for asynchronously producing and consuming events, similar to first-order functional reactive programming. In this case, the DSL is designed to be used in larger Racket programs, so it &lt;em&gt;will&lt;/em&gt; eventually expand to Racket’s core forms. However, it’s possible that such a language might wish to enforce static invariants about the network graph, and in doing so, it might be able to produce significantly more optimal Racket code via a compile-time analysis.&lt;/p&gt;

&lt;p&gt;Performing such a compile-time analysis is essentially writing a custom optimizer as part of a macro, which has been done numerous times already within the Racket ecosystem. One of the most prominent examples of such a thing is the &lt;code&gt;match&lt;/code&gt; macro, which parses users’ patterns into compile-time data structures, performs a fairly traditional optimization pass designed to efficiently compile pattern matching, and it emits optimized Racket code as a result. This approach works well for fairly contained problems like pattern-matching, but it works less well for entirely new embedded languages that include everything from their own notion of evaluation to their own binding forms.&lt;/p&gt;

&lt;p&gt;Existing DSLs of this type are rare, but they do exist. &lt;code&gt;syntax/parse&lt;/code&gt; provides an expressive, specialized pattern-matching language designed specifically for matching syntax objects, and it uses a different model from &lt;code&gt;racket/match&lt;/code&gt; to be more suitable for that task. It allows backtracking with cuts, an extensible pattern language, an abstraction language for defining reusable parsers that can accept inputs and produce outputs, and fine-grained control over both parsing and binding. While &lt;code&gt;match&lt;/code&gt; is essentially just a traditional pattern-matcher, albeit an extensible one, &lt;code&gt;syntax-parse&lt;/code&gt; is its own programming language, closer in some ways to Prolog than to Racket.&lt;/p&gt;

&lt;p&gt;For this reason, &lt;code&gt;syntax/parse&lt;/code&gt; has an extensive language to do everything from creating new bindings to controlling when and how parsing fails. This language is represented in two ways: an inline pattern language, and an alternate syntax known as &lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#%28part._.Pattern_.Directives%29"&gt;&lt;em&gt;pattern directives&lt;/em&gt;&lt;/a&gt;. Here is an example of pattern directives in action, from my own &lt;code&gt;threading&lt;/code&gt; library:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;ex:expr&lt;/span&gt; &lt;span class="n"&gt;cl:clause&lt;/span&gt; &lt;span class="n"&gt;remaining:clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl.call&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;split-at&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;cl.insertion-point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Each directive is represented by a keyword, in this case &lt;code&gt;#:do&lt;/code&gt; and &lt;code&gt;#:with&lt;/code&gt;. Each directive has a corresponding keyword in the pattern language, in this case &lt;code&gt;~do&lt;/code&gt; and &lt;code&gt;~parse&lt;/code&gt;. Therefore, the above pattern could equivalently be written this way:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;ex:expr&lt;/span&gt; &lt;span class="n"&gt;cl:clause&lt;/span&gt; &lt;span class="n"&gt;remaining:clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~do&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl.call&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;split-at&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;cl.insertion-point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))))}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~parse&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~parse&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~parse&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)}}&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The transformation can go in the other direction, too—each syntax class annotation on each pattern variable can be extracted into the directive language using &lt;code&gt;#:declare&lt;/code&gt;, so this is also equivalent:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;
 &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt; &lt;span class="n"&gt;clause&lt;/span&gt;
 &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="n"&gt;clause&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl.call&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;split-at&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;cl.insertion-point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is very much a programming language, but it has very different semantics from programming in Racket! Failure to match against a &lt;code&gt;#:with&lt;/code&gt; or &lt;code&gt;~parse&lt;/code&gt; pattern causes pattern-matching to backtrack, and though it’s possible to escape to Racket using &lt;code&gt;#:do&lt;/code&gt; or &lt;code&gt;~do&lt;/code&gt;, practical uses of &lt;code&gt;syntax/parse&lt;/code&gt; really do involve quite a lot of programming in its pattern DSL.&lt;/p&gt;

&lt;p&gt;But the Racket programmer might not find this DSL wholly satisfying. Why? Well, it isn’t extensible! The pattern directives—&lt;code&gt;#:declare&lt;/code&gt;, &lt;code&gt;#:do&lt;/code&gt;, and &lt;code&gt;#:with&lt;/code&gt;, among others—are essentially the core forms of &lt;code&gt;syntax/parse&lt;/code&gt;’s pattern-matching language, but new ones cannot be defined. The desire to make this language easy to analyze statically in order to emit optimal pattern-matching code meant its author opted to define the language in terms of a specific grammar rather than a tower of macros.&lt;/p&gt;

&lt;p&gt;But what if &lt;code&gt;syntax/parse&lt;/code&gt; could define its own core forms? What if, instead of &lt;code&gt;#:do&lt;/code&gt;, &lt;code&gt;#:declare&lt;/code&gt;, and &lt;code&gt;#:with&lt;/code&gt; being implemented as keyword options specially recognized by the &lt;code&gt;syntax-parse&lt;/code&gt; grammar, it defined &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;declare&lt;/code&gt;, and &lt;code&gt;with&lt;/code&gt; as core forms for a new, macro-enabled language? A user of the language could then define a completely ordinary Racket macro and use it with this new language as long as it eventually expanded into the &lt;code&gt;syntax/parse&lt;/code&gt; core forms. The implementation of &lt;code&gt;syntax/parse&lt;/code&gt; could then invoke the macroexpander to request each clause be expanded into its core forms, perform its static analysis on the result, and finally emit optimized Racket code.&lt;/p&gt;

&lt;p&gt;Now, to be fair, &lt;code&gt;syntax/parse&lt;/code&gt; is not actually entirely inextensible. While new directives cannot be defined, new patterns can be added through a pattern-expander API that was added to the library after its initial design. However, pattern expanders are still not ideal because they are not ordinary Racket macros—users must explicitly define each pattern expander differently from how they would a macro—and they cannot use existing Racket forms, even ones that would theoretically be compatible with an arbitrary set of core forms.&lt;/p&gt;

&lt;p&gt;The technique described in this blog post avoids all those problems. In the following sections, I’ll show that it’s possible to define an embedded language with a custom set of core forms that works well with the rest of the Racket ecosystem and still permits arbitrary static analysis.&lt;/p&gt;

&lt;h1 id="the-need-for-a-custom-type-language-in-hackett"&gt;The need for a custom type language in Hackett&lt;/h1&gt;

&lt;p&gt;In the previous section, I described two use cases for custom core forms. Hackett, in fact, has uses for &lt;em&gt;both&lt;/em&gt; of them:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Hackett can definitely make use of custom core forms to compile to multiple backends. Eventually, it would be nice to compile Hackett to an intermediate language that can target both the Racket runtime and Haskell or GHC Core. This would allow Hackett to take advantage of GHC’s advanced optimizing compiler that already has decades of tuning for a pure, lazy, functional programming language, at the cost of not having access to the rest of Racket’s ecosystem of libraries at runtime.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Hackett can &lt;em&gt;also&lt;/em&gt; make use of custom core forms for an embedded DSL. In this case, that embedded DSL is actually Hackett’s type language.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The second of those two use cases is simpler, and it’s what I ended up implementing first, so it’s what I will focus on in this blog post. Hackett’s type language is fundamentally quite simple, so its set of custom core forms is small as well. Everything in the type language eventually compiles into only seven core forms:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;(#%type:con
    &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; — Type constructors, like &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;. These are one of the fundamental building blocks of Hackett types.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;(#%type:app
    &lt;i&gt;type&lt;/i&gt;
    &lt;i&gt;type&lt;/i&gt;)&lt;/code&gt; — Type application, such as &lt;code&gt;(Maybe Integer)&lt;/code&gt;. Types are curried, so type constructors that accept multiple arguments are represented by nested uses of &lt;code&gt;#%type:app&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;(#%type:forall
    &lt;i&gt;id&lt;/i&gt;
    &lt;i&gt;type&lt;/i&gt;)&lt;/code&gt; — Universal quantification. This is essentially a binding form, which binds any uses of &lt;code&gt;(#%type:bound-var
    &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; in &lt;code&gt;
    &lt;i&gt;type&lt;/i&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;(#%type:qual
    &lt;i&gt;type&lt;/i&gt;
    &lt;i&gt;type&lt;/i&gt;)&lt;/code&gt; — Qualified types, aka types with typeclass constraints. Constraints in Hackett, like in GHC, are represented by types, so typeclass names like &lt;code&gt;Eq&lt;/code&gt; are bound as type constructors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, Hackett types support three different varieties of type variables:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;code&gt;(#%type:bound-var
      &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; — Bound type variables. These are only legal under a corresponding &lt;code&gt;#%type:forall&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;code&gt;(#%type:wobbly-var
      &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; — Solver variables, which may unify with any other type as part of the typechecking process.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;code&gt;(#%type:rigid-var
      &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; — Rigid variables, aka skolem variables, which only unify with themselves. They represent a unique, anonymous type used to ensure types are suitably polymorphic.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;To implement our custom core forms in Racket, we need to somehow define them, but how? Intentionally, these should never be expanded, since we want the expander to stop expanding whenever it encounters one of these identifiers. While we can’t encode this directly, we &lt;em&gt;can&lt;/em&gt; bind them to macros that do nothing but raise an exception if something attempts to expand them:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
                  &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="s2"&gt;"cannot be used as an expression"&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;
            &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This will ensure our core forms are never accidentally expanded, and we’ll instruct the macroexpander to stop whenever it sees one of them via a separate mechanism.&lt;/p&gt;

&lt;h2 id="expanding-types-in-our-type-language"&gt;Expanding types in our type language&lt;/h2&gt;

&lt;p&gt;We’ve now defined our core forms, but we’ve intentionally left them meaningless. How do we actually inform the expander about how our types ought to be expanded? While it’s true that we don’t want the core forms themselves to be eliminated, we &lt;em&gt;do&lt;/em&gt; want to expand some of their subforms. For example, in the type &lt;code&gt;(#%type:app a b)&lt;/code&gt;, we want to recursively expand &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In order to do this, we’ll use the API made available by the expander for manually invoking macroexpansion from within another macro. This API is called &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._local-expand%29%29"&gt;&lt;code&gt;local-expand&lt;/code&gt;&lt;/a&gt;, and it has an option relevant to our needs: the stop list.&lt;/p&gt;

&lt;p&gt;Often, &lt;code&gt;local-expand&lt;/code&gt; is used to force the expander to completely, recursively expand a form. For example, by using &lt;code&gt;local-expand&lt;/code&gt;, we can produce a fragment of a fully-expanded program from a piece of syntax that still includes macros:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; (let-values ([(x) &amp;#39;1]) (#%plain-app + x &amp;#39;2))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The third argument to &lt;code&gt;local-expand&lt;/code&gt; is the &lt;em&gt;stop list&lt;/em&gt;, which controls how deep the expander ought to expand a given form. By providing an empty list, we ask for a complete, recursive expansion. In this case, however, we don’t want a complete expansion! We can inform the expander to stop whenever it sees any of our custom core forms by passing a list of our core form identifiers instead of an empty list:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt;
          &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;; =&amp;gt; (#%type:forall x t)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Of course, this isn’t very interesting, since it just gives us back exactly what we gave it. It spotted the &lt;code&gt;#%type:forall&lt;/code&gt; identifier, which is in our stop list, and immediately halted expansion. It didn’t attempt to continue expanding &lt;code&gt;t&lt;/code&gt; since the expander has no way of knowing which pieces of &lt;code&gt;(#%type:forall x t)&lt;/code&gt; it should expand! In this case, we want it to recur to expand &lt;code&gt;t&lt;/code&gt;, since it should be a type, but not &lt;code&gt;x&lt;/code&gt;, since &lt;code&gt;#%type:forall&lt;/code&gt; essentially puts &lt;code&gt;x&lt;/code&gt; in binding position.&lt;/p&gt;

&lt;p&gt;Therefore, we have to get more clever. We need to call &lt;code&gt;local-expand&lt;/code&gt; to produce a type, then we have to pattern-match on it and subsequently call &lt;code&gt;local-expand&lt;/code&gt; &lt;em&gt;again&lt;/em&gt; on any of the pieces of syntax we want to keep expanding. Eventually, we’ll run out of things to expand, and our type will be fully-expanded.&lt;/p&gt;

&lt;p&gt;One good way to do this is to use &lt;code&gt;syntax/parse&lt;/code&gt; syntax classes, since they provide a convenient way for other macros to invoke the type expander. To implement our type expander, we’ll use two mutually recursive syntax classes: one to perform the actual expansion using &lt;code&gt;local-expand&lt;/code&gt; and a second to pattern-match on the resulting expanded type. For example, here’s what these two classes would look like if they only handled &lt;code&gt;#%type:con&lt;/code&gt; and &lt;code&gt;#%type:app&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-literal-set&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
     &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"type"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;:expanded-type&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;expanded-type&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;a:type&lt;/span&gt; &lt;span class="n"&gt;b:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This blog post is definitely &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;syntax/parse&lt;/code&gt; tutorial, so I will not explain in detail everything that’s going on here, but the gist of it is that the above code defines two syntax classes, both of which produce a single output attribute named &lt;code&gt;expansion&lt;/code&gt;. This attribute contains the fully expanded version of the type currently being parsed. In the &lt;code&gt;#%type:con&lt;/code&gt; case, &lt;code&gt;expansion&lt;/code&gt; is just &lt;code&gt;this-syntax&lt;/code&gt;, which holds the current piece of syntax being parsed. This makes sense, since uses of &lt;code&gt;#%type:con&lt;/code&gt; just expand to themselves—expanding &lt;code&gt;(#%type:con Maybe)&lt;/code&gt; should not perform any additional expansion on &lt;code&gt;Maybe&lt;/code&gt;. This is one of Hackett’s atomic types.&lt;/p&gt;

&lt;p&gt;In contrast, &lt;code&gt;#%type:app&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; recursively expand its arguments. By annotating its two subforms with &lt;code&gt;:type&lt;/code&gt;, the &lt;code&gt;type&lt;/code&gt; syntax class will invoke &lt;code&gt;local-expand&lt;/code&gt; on each subform, which will in turn use &lt;code&gt;expanded-type&lt;/code&gt; to parse the resulting type. This is what implements the expansion loop that will eventually expand each type completely. Once &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have been expanded, &lt;code&gt;#%type:app&lt;/code&gt; reassembles them into a new syntax object using &lt;code&gt;#'(#%type:app a.expansion b.expansion)&lt;/code&gt;, which replaces their unexpanded versions with their new, expanded versions.&lt;/p&gt;

&lt;p&gt;We can see this behavior by writing a small &lt;code&gt;expand-type&lt;/code&gt; function that will expand its argument:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;t:type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we can use it to observe what happens when we try expanding a type using &lt;code&gt;#%type:app&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; #%type:app: expected type&lt;/span&gt;
&lt;span class="c1"&gt;;      at: Maybe&lt;/span&gt;
&lt;span class="c1"&gt;;      in: (#%type:app Maybe Integer)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Okay, it failed with an error, which is not ideal, but it makes sense. We haven’t actually defined &lt;code&gt;Maybe&lt;/code&gt; or &lt;code&gt;Integer&lt;/code&gt; anywhere. Let’s do so! We can define them as simple macros that expand into uses of &lt;code&gt;#%type:con&lt;/code&gt;, which can be done easily using &lt;a href="http://docs.racket-lang.org/syntax/transformer-helpers.html#%28def._%28%28lib._syntax%2Ftransformer..rkt%29._make-variable-like-transformer%29%29"&gt;&lt;code&gt;make-variable-like-transformer&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;syntax/transformer&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, if we try expanding that same type again:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; (#%type:app (#%type:con Maybe) (#%type:con Integer))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…it works! Neat. Now we just need to add the cases for the remaining forms in our type language:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;expanded-type&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;a:type&lt;/span&gt; &lt;span class="n"&gt;b:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;t:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;a:type&lt;/span&gt; &lt;span class="n"&gt;b:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is pretty good already, and to a first approximation, it’s done! However, it doesn’t actually work as well as we’d really like it to. One of the whole points of doing things this way is to allow other macros like &lt;code&gt;let-syntax&lt;/code&gt; to work in types. For example, we ought to be able to create a local type binding with &lt;code&gt;let-syntax&lt;/code&gt; and have it just work. Unfortunately, it doesn’t:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; let-syntax: expected one of these identifiers: `#%type:con&amp;#39;, `#%type:app&amp;#39;, `#%type:forall&amp;#39;, `#%type:qual&amp;#39;, `#%type:bound-var&amp;#39;, `#%type:wobbly-var&amp;#39;, or `#%type:rigid-var&amp;#39;&lt;/span&gt;
&lt;span class="c1"&gt;;     at: letrec-syntaxes+values&lt;/span&gt;
&lt;span class="c1"&gt;;     in: (let-syntax ((Bool (make-variable-like-transformer (syntax Bool)))) (#%type:app Maybe Bool))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;What went wrong? And why is it complaining about &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;? Well, if you read the documentation for &lt;code&gt;local-expand&lt;/code&gt;, you’ll find that its behavior is a little more complicated than you might at first believe:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;If &lt;em&gt;&lt;code&gt;stop-ids&lt;/code&gt;&lt;/em&gt; is [a nonempty list containing more than just &lt;code&gt;module*&lt;/code&gt;], then &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;set!&lt;/code&gt;, &lt;code&gt;#%plain-lambda&lt;/code&gt;, &lt;code&gt;case-lambda&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, &lt;code&gt;letrec-values&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;begin0&lt;/code&gt;, &lt;code&gt;with-continuation-mark&lt;/code&gt;, &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, &lt;code&gt;#%plain-app&lt;/code&gt;, &lt;code&gt;#%expression&lt;/code&gt;, &lt;code&gt;#%top&lt;/code&gt;, and &lt;code&gt;#%variable-reference&lt;/code&gt; are implicitly added to &lt;em&gt;&lt;code&gt;stop-ids&lt;/code&gt;&lt;/em&gt;. Expansion stops when the expander encounters any of the forms in &lt;em&gt;&lt;code&gt;stop-ids&lt;/code&gt;&lt;/em&gt;, and the result is the partially-expanded form.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That’s a little strange, isn’t it? I am not completely sure why the behavior works quite this way, though I’m sure backwards compatibility plays a significant part, but while some of the behavior seems unnecessary, the issue with &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; (which &lt;code&gt;let-syntax&lt;/code&gt; expands to) is a reasonable one. If the expander naïvely expanded &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; in the presence of a nonempty stop list, it could cause some significant problems!&lt;/p&gt;

&lt;p&gt;Allow me to illustrate with an example. Let’s imagine we are the expander, and we are instructed to expand the following program:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We see &lt;code&gt;let-syntax&lt;/code&gt;, so we start by evaluating the expression on the right hand side of the &lt;code&gt;Bool&lt;/code&gt; binding. This produces a transformer expression, so we bind &lt;code&gt;Bool&lt;/code&gt; to the transformer in the local environment, then move onto expanding the body. At this point, the expander is looking at this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;; local bindings:&lt;/span&gt;
&lt;span class="c1"&gt;;   Bool -&amp;gt; #&amp;lt;variable-like-transformer&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, the identifier in application position is &lt;code&gt;#%type:app&lt;/code&gt;, and &lt;code&gt;#%type:app&lt;/code&gt; is in the stop list. Therefore, expansion must stop, and it does not attempt to expand any further. But what should the result of expansion be? Well, the &lt;code&gt;let-syntax&lt;/code&gt; needs to go away when we expand it—local syntax bindings are erased as part of macroexpansion—so the logical thing to expand into is &lt;code&gt;(#%type:app Maybe Bool)&lt;/code&gt;. But this is a problem, because when we then go to expand &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt; isn’t in the local binding table anymore! The &lt;code&gt;let-syntax&lt;/code&gt; was already erased, and &lt;code&gt;Bool&lt;/code&gt; is unbound!&lt;/p&gt;

&lt;p&gt;When expanding recursively, this isn’t a problem, since the entire expression is guaranteed to be expanded while the local binding is still in the expander’s environment. As soon as we introduce partial expansion, however, we run the risk of a binding getting erased too early. So we’re stuck: we can’t recursively expand, or we’ll expand too much, but we can’t partially expand, since we might expand too little.&lt;/p&gt;

&lt;p&gt;Confronted with this problem, there is some good news and some bad news. The good news is that, while the macroexpander can’t help us, we can help the macroexpander by doing some of the necessary bookkeeping for it. We can do this using first-class definition contexts, which allow us to manually extend the local environment when we call &lt;code&gt;local-expand&lt;/code&gt;. The bad news is that first-class definition contexts are &lt;em&gt;complicated&lt;/em&gt;, and using them properly is a surprisingly subtle problem.&lt;/p&gt;

&lt;p&gt;Fortunately, I’ve already spent a lot of time figuring out what needs to be done to properly manipulate the necessary definition contexts in this particular situation. The first step is to parameterize our &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;expanded-type&lt;/code&gt; syntax classes so that we may thread a definition context around as we recursively expand:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"type"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;||&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, we can add an additional case to &lt;code&gt;expanded-type&lt;/code&gt; to handle &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, which will explicitly create a new definition context, add bindings to it, and use it when parsing the body:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
         &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But even this isn’t quite right. The problem with this implementation is that it throws away the existing &lt;code&gt;intdef-ctx&lt;/code&gt; argument to &lt;code&gt;expanded-type&lt;/code&gt;, which means those bindings will be lost as soon as we introduce a new set. To fix this, we have to make the new definition context a &lt;em&gt;child&lt;/em&gt; of the previous definition context by passing the old context as an argument to &lt;code&gt;syntax-local-make-definition-context&lt;/code&gt;. This will ensure the parent bindings are brought into scope when expanding using the child context:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
         &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With this in place, our example using &lt;code&gt;let-syntax&lt;/code&gt; actually works!&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; (#%type:app (#%type:con Maybe) (#%type:con Bool))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Pretty cool, isn’t it?&lt;/p&gt;

&lt;h2 id="preserving-syntax-properties-and-source-locations"&gt;Preserving syntax properties and source locations&lt;/h2&gt;

&lt;p&gt;We’ve now managed to essentially implement an expander for our custom language by periodically yielding to the Racket macroexpander, and for the most part, it works. However, our implementation isn’t perfect. The real Racket macroexpander takes great care to preserve source locations and syntax properties on syntax objects wherever possible, which our implementation does not do. Normally we don’t have to worry so much about such things, since the macroexpander automatically copies properties when expanding macros, but since we’re circumventing the expander, we don’t get that luxury. In order to properly preserve this information, we’ll have to be a little more careful.&lt;/p&gt;

&lt;p&gt;To start, we really ought to copy the identifier in application position into the output wherever we can. In addition to preserving source location information and syntax properties, it also preserves the even more visible renamings. For example, if a user imports &lt;code&gt;#%type:app&lt;/code&gt; under a different name, like &lt;code&gt;#%type:apply&lt;/code&gt;, we should expand to a piece of syntax that still has &lt;code&gt;#%type:apply&lt;/code&gt; in application position instead of replacing it with &lt;code&gt;#%type:app&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To do this, we just need to bind each of the identifiers in application position, then use that binding when we produce output. For example, we would adjust the &lt;code&gt;#%type:app&lt;/code&gt; clause to the following:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But even after doing this, some source locations and syntax properties are lost, since we’re still reconstructing the pair from scratch. To ensure we copy &lt;em&gt;everything&lt;/em&gt;, we can define two helper macros, &lt;code&gt;syntax/loc/props&lt;/code&gt; and &lt;code&gt;quasisyntax/loc/props&lt;/code&gt;, which are like &lt;code&gt;syntax/loc&lt;/code&gt; and &lt;code&gt;quasisyntax/loc&lt;/code&gt; but copy properties in addition to source location information:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;syntax-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
          &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr:expr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~describe&lt;/span&gt; &lt;span class="s2"&gt;"template"&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
           &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax?&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-argument-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;#,&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt; &lt;span class="s2"&gt;"syntax?"&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;syntax-id&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-disarm&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-rearm&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-e&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)))]))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;quasisyntax&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Using &lt;code&gt;syntax/loc/props&lt;/code&gt;, we can be truly thorough about ensuring all properties are preserved:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Applying this to the other relevant clauses, we get an updated version of the &lt;code&gt;expanded-type&lt;/code&gt; syntax class:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                         &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we’re getting closer, but if you can believe it, even &lt;em&gt;this&lt;/em&gt; isn’t good enough. The real expander’s implementation of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; does two things our implementation does not: it copies properties and updates the &lt;code&gt;'origin&lt;/code&gt; property to indicate the syntax came from a use of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, and it adds a &lt;code&gt;'disappeared-use&lt;/code&gt; property to record the erased bindings for use by tools like DrRacket. We can apply &lt;code&gt;syntax-track-origin&lt;/code&gt; and &lt;code&gt;internal-definition-context-track&lt;/code&gt; to the resulting syntax to add the same properties the expander would:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
         &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;internal-definition-context-track&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we’ve &lt;em&gt;finally&lt;/em&gt; dotted all our i’s and crossed our t’s. While it does take a lot to properly emulate what the macroexpander is doing, the important thing is that it’s actually possible! The end result of all this definition context juggling and property copying is that we’ve effectively managed to move some of the macroexpander’s logic into userspace code, which allows us to manipulate it as we see fit.&lt;/p&gt;

&lt;h2 id="connecting-our-custom-language-to-hackett"&gt;Connecting our custom language to Hackett&lt;/h2&gt;

&lt;p&gt;It took a lot of work, but we finally managed to write a custom type language, and while the code is not exactly simple, it’s not actually very long. The entire implementation of our custom type language is less than 80 lines of code:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket/base&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-meta&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/intdef&lt;/span&gt;
                     &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;syntax-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
          &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr:expr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~describe&lt;/span&gt; &lt;span class="s2"&gt;"template"&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
           &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax?&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-argument-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;#,&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt; &lt;span class="s2"&gt;"syntax?"&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;syntax-id&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-disarm&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-rearm&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-e&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)))]))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;quasisyntax&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
                  &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="s2"&gt;"cannot be used as an expression"&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;
            &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt;
          &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-literal-set&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
     &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"type"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;||&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                         &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;internal-definition-context-track&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;t:type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But what now? Just as Racket fully-expanded programs are useless without a compiler to turn them into something useful, our custom type language doesn’t do anything at all in isolation. As it happens, in the case of the type language, we don’t have a compiler at all—we have a &lt;em&gt;typechecker&lt;/em&gt;. The Hackett typechecker consumes fully-expanded types as input and uses them to perform its typechecking process. The actual implementation of Hackett’s typechecker is outside the scope of this blog post, since it’s really an entirely separate problem, but you can probably imagine what such a thing might look like, in an extremely vague, handwavy sense.&lt;/p&gt;

&lt;p&gt;But we don’t &lt;em&gt;just&lt;/em&gt; need a typechecker. Just as the authors of Racket don’t expect users to write programs using the core forms directly, we also don’t expect users to write their types using the fully-expanded syntax. If we did, all this fancy expansion machinery would be pretty pointless! Hackett provides a custom &lt;code&gt;#%app&lt;/code&gt; binding that converts n-ary type applications to nested uses of &lt;code&gt;#%type:app&lt;/code&gt;, as well as a nicer &lt;code&gt;forall&lt;/code&gt; macro that supports specifying multiple type variables and multiple typeclass constraints all at once. The best part, though, is that these macros can be defined in a completely straightforward way, just as any ordinary Racket macro would be written, and the machinery will work precisely as intended. It’s also perfectly okay to have two different versions of &lt;code&gt;#%app&lt;/code&gt;—one for types and one for values—since &lt;a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/"&gt;Hackett supports multiple namespaces&lt;/a&gt;, and each can have its own &lt;code&gt;#%app&lt;/code&gt; binding.&lt;/p&gt;

&lt;p&gt;The real implementation of Hackett’s type language is a little bit longer than the one in this blog post because it includes some extra definitions to provide custom &lt;code&gt;syntax/parse&lt;/code&gt; pattern expanders for matching types and some template metafunctions for producing them, which are used by the typechecker, but if you’d like to see the whole thing, &lt;a href="https://github.com/lexi-lambda/hackett/blob/ba64193da38f63dab2523f42c1b7614cdfa8c935/hackett-lib/hackett/private/type-language.rkt"&gt;it’s available on GitHub here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id="evaluation-limitations-and-acknowledgements"&gt;Evaluation, limitations, and acknowledgements&lt;/h1&gt;

&lt;p&gt;Reimplementing Hackett’s type language took about a week and a half, about half of which was supplemented by the extra time I had before I started &lt;a href="https://twitter.com/lexi_lambda/status/976533916596097024"&gt;my new job&lt;/a&gt; this past week. A portion of that time was spent deciding what I actually wanted to do, and a lot of it was spent hunting down fiddly bugs. All told, the rewrite resulted in a net addition of 250 lines of code to the Hackett codebase. However, 350 of the added lines reside in a new, self-contained module dedicated to Hackett’s type language, so the change actually resulted in a net &lt;em&gt;removal&lt;/em&gt; of 100 lines from the rest of the codebase, which I consider an organizational win.&lt;/p&gt;

&lt;p&gt;As for whether or not the change will accomplish the goals I had in mind, I think signs currently point to a strong likelihood of the answer being yes. The very same night I finalized and merged the changes to the type language, I dusted off an old prototype of typeclass deriving I had not been able to get working due to insufficiencies of the old type representation. Not only was I &lt;a href="https://twitter.com/lexi_lambda/status/985051504867446786"&gt;able to get it working&lt;/a&gt; quickly and easily, I was able to do it in &lt;a href="https://twitter.com/lexi_lambda/status/985052476473856000"&gt;no more than 20 lines of code&lt;/a&gt;. While the implementation is not as robust as it should ideally be, nor is it safe or simple enough yet to be easy for Hackett users to write themselves, making the impossible possible is usually a sign of motion in the right direction.&lt;/p&gt;

&lt;p&gt;Unfortunately, the technique outlined in this blog post is not completely flawless. Due to its reliance on the &lt;code&gt;local-expand&lt;/code&gt; stop list, this technique is incompatible with macros that force recursive expansion using an empty stop list. In the upcoming reimplementation of the Racket macroexpander to be released in Racket 7, this includes &lt;code&gt;syntax-parameterize&lt;/code&gt;, which unfortunately means syntax parameters don’t work in the type language. This is a problem, and while it’s not a dealbreaker, it is something that will almost certainly have to be fixed at some point. Fortunately, it isn’t intractable, and I’ve been discussing some potential approaches to fixing the problem, whether via changes to the macroexpander or by making macros like &lt;code&gt;syntax-parameterize&lt;/code&gt; cooperate better with things like Hackett’s type language.&lt;/p&gt;

&lt;p&gt;Finally, as seems to be the case more and more with my blog posts, I cannot express enough thanks to &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, without whose help I would probably not have been able to get everything working (not to mention that the Racket macro system would not exist without Matthew inventing and implementing it nearly singlehandedly). Matthew does an almost unfathomable number of things for Racket already without me pestering him with questions, bug reports, and feature requests, but he’s always patient and helpful all the same. Also, once again, I’d like to thank &lt;a href="http://www.ccs.neu.edu/home/ryanc/"&gt;Ryan Culpepper&lt;/a&gt; for &lt;a href="https://www2.ccs.neu.edu/racket/pubs/dissertation-culpepper.pdf"&gt;his incredible work on constructing tools for the working macro developer&lt;/a&gt;, including writing the fantastic &lt;code&gt;syntax/parse&lt;/code&gt; library that powers essentially everything I do. Thank you both.&lt;/p&gt;</description></item>
  <item>
   <title>User-programmable infix operators in Racket</title>
   <link>http://lexi-lambda.github.io/blog/2017/08/12/user-programmable-infix-operators-in-racket/?utm_source=macros&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2017-08-12-user-programmable-infix-operators-in-racket</guid>
   <pubDate>Sat, 12 Aug 2017 16:26:05 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Lisps are not known for infix operators, quite the opposite; infix operators generally involve more syntax and parsing than Lispers are keen to support. However, in &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Hackett&lt;/a&gt;, all functions are curried, and variable-arity functions do not exist. Infix operators are almost necessary for that to be palatable, and though there are other reasons to want them, it may not be obvious how to support them without making the reader considerably more complex.&lt;/p&gt;

&lt;p&gt;Fortunately, if we require users to syntactically specify where they wish to use infix expressions, support for infix operators is not only possible, but can support be done &lt;em&gt;without&lt;/em&gt; modifying the stock &lt;code&gt;#lang racket&lt;/code&gt; reader. Futhermore, the resulting technique makes it possible for fixity information to be specified locally in a way that cooperates nicely with the Racket macro system, allowing the parsing of infix expressions to be manipulated at compile-time by users’ macros.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="our-mission"&gt;Our mission&lt;/h1&gt;

&lt;p&gt;Before we embark, let’s clarify our goal. We want to support infix operators in Racket, of course, but that could mean a lot of different things! Let’s start with what we &lt;em&gt;do&lt;/em&gt; want:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Infix operators should be user-extensible, not limited to a special set of built-in operators.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Furthermore, operators’ names should not be restricted to a separate “operator” character set. Any valid Lisp identifier should be usable as an infix operator.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;We want to be able to support fixity/associativity annotations. Some operators should associate to the left, like subtraction, but others should associate to the right, like &lt;code&gt;cons&lt;/code&gt;. This allows &lt;code&gt;5 - 1 - 2&lt;/code&gt; to be parsed as &lt;code&gt;(- (- 5 1) 2)&lt;/code&gt;, but &lt;code&gt;5 :: 1 :: nil&lt;/code&gt; to be parsed as &lt;code&gt;(:: 5 (:: 1 nil))&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;These are nice goals, but we also won’t be too ambitious. In order to keep things simple and achievable, we’ll keep the following restrictions:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;We will &lt;strong&gt;not&lt;/strong&gt; permit infix expressions in arbitrary locations, since that would be impossible to parse given how we want to allow users to pick any names for operators they wish. Instead, infix expressions must be wrapped in curly braces, e.g. replacing &lt;code&gt;(+ 1 2)&lt;/code&gt; with &lt;code&gt;{1 + 2}&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Our implementation will &lt;strong&gt;not&lt;/strong&gt; support any notion of operator precedence; all operators will have equal precedence, and it will be illegal to mix operators of different associativity in the same expression. Precedence is entirely possible to implement in theory, but it would be considerably more work, so this blog post does not include it.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All operators will be binary, and we will &lt;strong&gt;not&lt;/strong&gt; support unary or mixfix operators. My intuition is that this technique should be able to be generalized to both of those things, but it would be considerably more complicated.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;With those points in mind, what would the interface for our infix operator library look like for our users? Ideally, something like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-in&lt;/span&gt; &lt;span class="n"&gt;racket/base/&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="s2"&gt;"infix.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;racket/base/-&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; &amp;#39;(1 7)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Let’s get started.&lt;/p&gt;

&lt;h1 id="implementing-infix-operators"&gt;Implementing infix operators&lt;/h1&gt;

&lt;p&gt;Now that we know what we want, how do we get there? Well, there are a few pieces to this puzzle. We’ll need to solve a two main problems:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;How do we “hook into” expressions wrapped with curly braces so that we can perform a desugaring pass?&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;How can we associate fixity information with certain operators?&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;We’ll start by tackling the first problem, since its solution will inform the answer to the second. Since we won’t have any fixity information to start with, we’ll just assume that all operators associate left by default.&lt;/p&gt;

&lt;p&gt;So, how &lt;em&gt;do&lt;/em&gt; we detect if a Racket expression is surrounded by curly braces? Normally, in &lt;code&gt;#lang racket&lt;/code&gt;, parentheses, square brackets, and curly braces are all interchangeable. Indeed, if you use curly braces in the REPL, you will find that they are treated &lt;em&gt;exactly&lt;/em&gt; the same as parentheses:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If they are treated identically, giving them special behavior might seem hopeless, but don’t despair! Racket is no ordinary programming language, and it provides some tools to help us out here.&lt;/p&gt;

&lt;p&gt;Someone who has worked with Lisps before is likely already aware that Lisp source code is a very direct representation of its AST, composed mostly of lists, pairs, symbols, numbers, and strings. In Racket, this is also true, but Racket also wraps these datums in boxes known as &lt;a href="http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29"&gt;&lt;em&gt;syntax objects&lt;/em&gt;&lt;/a&gt;. Syntax objects contain extra metadata about the code, most notably its lexical context, necessary for Racket’s hygiene system. However, syntax objects can also contain arbitrary metadata, known as &lt;a href="http://docs.racket-lang.org/reference/stxprops.html#%28tech._syntax._property%29"&gt;&lt;em&gt;syntax properties&lt;/em&gt;&lt;/a&gt;. Macros can attach arbitrary values to the syntax objects they produce using syntax properties, and other macros can inspect them. Racket’s &lt;a href="http://docs.racket-lang.org/guide/Pairs__Lists__and_Racket_Syntax.html#%28tech._reader%29"&gt;&lt;em&gt;reader&lt;/em&gt;&lt;/a&gt; (the syntax parser that turns program text into Racket syntax objects) also attaches certain syntax properties as part of its parsing process. One of those is named &lt;a href="http://docs.racket-lang.org/reference/reader.html#%28idx._%28gentag._30._%28lib._scribblings%2Freference%2Freference..scrbl%29%29%29"&gt;&lt;code&gt;'paren-shape&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This syntax property, as the name implies, keeps track of the shape of parentheses in syntax objects. You can see that for yourself by inspecting the property’s value for different syntax objects in the REPL:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="no"&gt;#f&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="sc"&gt;#\[&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="sc"&gt;#\{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This syntax property gives us the capability to distinguish between syntax objects that use curly braces and those that don’t, which is a step in the right direction, but it still doesn’t give us any hook with which we can change the behavior of certain expressions. Fortunately, there’s something else that can.&lt;/p&gt;

&lt;h2 id="customizing-application"&gt;Customizing application&lt;/h2&gt;

&lt;p&gt;Racket is a language &lt;em&gt;designed&lt;/em&gt; to be extended, and it provides a variety of hooks in the language for the purposes of tweaking pieces in minor ways. One such hook is named &lt;a href="http://docs.racket-lang.org/reference/application.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~23~25app%29%29"&gt;&lt;code&gt;#%app&lt;/code&gt;&lt;/a&gt;, which is automatically introduced by the macroexpander whenever it encounters a function application. That means it effectively turns this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…into this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;What’s special about &lt;code&gt;#%app&lt;/code&gt; is that the macroexpander will use whichever &lt;code&gt;#%app&lt;/code&gt; is in scope in the expression’s lexical context, so if we write our own version of &lt;code&gt;#%app&lt;/code&gt;, it will be used instead of the one from &lt;code&gt;#lang racket&lt;/code&gt;. This is what we will use to hook into ordinary Racket expressions.&lt;/p&gt;

&lt;p&gt;To write our custom version of &lt;code&gt;#%app&lt;/code&gt;, we will use the usual tool: Racket’s industrial-strength macro-authoring DSL, &lt;a href="http://docs.racket-lang.org/syntax/stxparse.html"&gt;&lt;code&gt;syntax/parse&lt;/code&gt;&lt;/a&gt;. We’ll also use a helper library that provides some tools for pattern-matching on syntax objects with the &lt;code&gt;'paren-shape&lt;/code&gt; syntax property, &lt;a href="http://docs.racket-lang.org/syntax-classes/index.html#%28mod-path._syntax%2Fparse%2Fclass%2Fparen-shape%29"&gt;&lt;code&gt;syntax/parse/class/paren-shape&lt;/code&gt;&lt;/a&gt;. Using these, we can transform expressions that are surrounded in curly braces differently from how we would transform expressions surrounded by parentheses:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/class/paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-in&lt;/span&gt; &lt;span class="n"&gt;racket/base/&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="k"&gt;#%app&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~braces&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This code will transform any applications surrounded in curly braces into one that starts with &lt;code&gt;#%infix&lt;/code&gt; instead of &lt;code&gt;#%app&lt;/code&gt;, so &lt;code&gt;{1 + 2}&lt;/code&gt; will become &lt;code&gt;(#%infix 1 + 2)&lt;/code&gt;, for example. The identifier &lt;code&gt;#%infix&lt;/code&gt; isn’t actually special in any way, it just has a funny name, but we haven’t actually defined &lt;code&gt;#%infix&lt;/code&gt; yet, so we need to do that next!&lt;/p&gt;

&lt;p&gt;To start, we’ll just handle the simplest case: infix expressions with precisely three subexpressions, like &lt;code&gt;{1 + 2}&lt;/code&gt;, should be converted into the equivalent prefix expressions, in this case &lt;code&gt;(+ 1 2)&lt;/code&gt;. We can do this with a simple macro:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Due to the way Racket propagates syntax properties, we explicitly indicate that the resulting expansion should use the &lt;code&gt;#%app&lt;/code&gt; from &lt;code&gt;racket/base&lt;/code&gt;, which will avoid any accidental infinite recursion between our &lt;code&gt;#%app&lt;/code&gt; and &lt;code&gt;#%infix&lt;/code&gt;. With this in place, we can now try our code out in the REPL, and believe it or not, we now support infix expressions with just those few lines of code:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;That’s pretty cool!&lt;/p&gt;

&lt;p&gt;Of course, we probably want to support infix applications with more than just a single binary operator, such as &lt;code&gt;{1 + 2 + 3}&lt;/code&gt;. We can implement that just by adding another case to &lt;code&gt;#%infix&lt;/code&gt; that handles more subforms:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…and now, just by adding those two lines, we support arbitrarily-large sequences of infix operators:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;I don’t know about you, but I think being able to do this in less than 20 lines of code is pretty awesome. We can even mix different operators in the same expression:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Of course, all of our infix expressions currently assume that all operators associate left, as was our plan. In general, though, there are lots of useful operators that associate right, such as &lt;code&gt;cons&lt;/code&gt;, nested &lt;code&gt;-&amp;gt;&lt;/code&gt; types or contracts for curried functions, and &lt;code&gt;expt&lt;/code&gt;, the exponentiation operator.&lt;/p&gt;

&lt;h2 id="tracking-operator-fixity"&gt;Tracking operator fixity&lt;/h2&gt;

&lt;p&gt;Clearly, we need some way to associate operator fixity with certain identifiers, and we need to be able to do it at compile-time. Fortunately, Racket has a very robust mechanism for creating compile-time values. Unfortunately, simply associating metadata with an identifier is a little less convenient than it could be, but there is a general technique that can be done with little boilerplate.&lt;/p&gt;

&lt;p&gt;Essentially, Racket (like Scheme) uses a &lt;code&gt;define-syntax&lt;/code&gt; form to define macros, which is what &lt;code&gt;define-syntax-parser&lt;/code&gt; eventually expands into. However, unlike Scheme, Racket’s &lt;code&gt;define-syntax&lt;/code&gt; is not &lt;em&gt;just&lt;/em&gt; for defining macros—it’s for defining arbitrary bindings with compile-time (aka “phase 1”) values. Using this, we can define bindings that have entirely arbitrary values at compile-time, including plain data like numbers or strings:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Once a binding has been defined using &lt;code&gt;define-syntax&lt;/code&gt;, a macro can look up the value associated with it by using the &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-value%29%29"&gt;&lt;code&gt;syntax-local-value&lt;/code&gt;&lt;/a&gt; function, which returns the compile-time value associated with an identifier:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The cool thing is that &lt;code&gt;syntax-local-value&lt;/code&gt; gets the value associated with a specific &lt;em&gt;binding&lt;/em&gt;, not a specific name. This means a macro can look up the compile-time value associated with an identifier provided to it as a subform. This is close to what we want, since we could use &lt;code&gt;syntax-local-value&lt;/code&gt; to look up something associated with our infix operator bindings, but the trouble is that they would then cease to be usable as ordinary functions. For example, if you try and use the &lt;code&gt;foo&lt;/code&gt; binding from the above example as an expression, Racket will complain about an “illegal use of syntax”, which makes sense, because &lt;code&gt;foo&lt;/code&gt; is not bound to anything at runtime.&lt;/p&gt;

&lt;p&gt;To solve this problem, we can use something of a trick: any compile-time binding that happens to have a procedure as its value will be treated like a macro—that is, using it as an expression will cause the macroexpander to invoke the procedure with a syntax object representing the macro invocation, and the procedure is expected to produce a new syntax object as output. Additionally, Racket programmers can make custom datatypes valid procedures by using the &lt;a href="http://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29"&gt;&lt;code&gt;prop:procedure&lt;/code&gt;&lt;/a&gt; structure type property.&lt;/p&gt;

&lt;p&gt;If you are not familiar with the Racket macro system, this probably sounds rather complicated, but in practice, it’s not as confusing as it might seem. The trick here is to create a custom structure type at compile-time that we can use to track operator fixity alongside its runtime binding:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/transformer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runtime-binding&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:property&lt;/span&gt; &lt;span class="nb"&gt;prop:procedure&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;set!-transformer-procedure&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-runtime-binding&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is quite the magical incantation, and all the details of what is going on here are outside the scope of this blog post. Essentially, though, we can use values of this structure as a compile-time binding that will act just like the identifier provided for &lt;code&gt;runtime-binding&lt;/code&gt;, but we can also include a value of our choosing for &lt;code&gt;fixity&lt;/code&gt;. Here’s an example:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;right&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This new &lt;code&gt;::&lt;/code&gt; binding will act, in every way, just like &lt;code&gt;cons&lt;/code&gt;. If we use it in the REPL, you can see that it acts exactly the same:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, we can also use &lt;code&gt;syntax-local-value&lt;/code&gt; to extract this binding’s fixity at compile-time, and that’s what makes it interesting:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;::&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; &amp;#39;right&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Using this extra compile-time information, we can adjust our &lt;code&gt;#%infix&lt;/code&gt; macro to inspect bindings and determine their fixity, then use that to make decisions about parsing. Just like we used &lt;code&gt;syntax/parse/class/paren-shape&lt;/code&gt; to make decisions based on the &lt;code&gt;'paren-shape&lt;/code&gt; syntax property, we can use &lt;a href="http://docs.racket-lang.org/syntax-classes/index.html#%28mod-path._syntax%2Fparse%2Fclass%2Flocal-value%29"&gt;&lt;code&gt;syntax/parse/class/local-value&lt;/code&gt;&lt;/a&gt; to pattern-match on bindings with a particular compile-time value. We’ll wrap this in a syntax class of our own to make the code easier to read:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;infix-op&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"infix operator"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-value&lt;/span&gt; &lt;span class="n"&gt;infix-operator?&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.local-value&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, we can update &lt;code&gt;#%infix&lt;/code&gt; to use our new &lt;code&gt;infix-op&lt;/code&gt; syntax class:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Notably, we now require all operators to be bound to compile-time infix operator values, and we include two conditions via &lt;code&gt;#:when&lt;/code&gt; clauses. These clauses check to ensure that the operator in question has the expected fixity before committing to that clause; if the condition fails, then parsing backtracks. Using this new definition of &lt;code&gt;#%infix&lt;/code&gt;, we can successfully use &lt;code&gt;::&lt;/code&gt; in an infix expression, and it will be parsed with the associativity that we expect:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Exciting!&lt;/p&gt;

&lt;h2 id="a-nicer-interface-for-defining-infix-operators"&gt;A nicer interface for defining infix operators&lt;/h2&gt;

&lt;p&gt;We currently have to define infix operators by explicitly using &lt;code&gt;define-syntax&lt;/code&gt;, but this is not a very good interface. Users of infix syntax probably don’t want to have to understand the internal workings of the infix operator implementation, so we just need to define one final macro to consider this done: the &lt;code&gt;define-infix-operator&lt;/code&gt; form from the example at the very beginning of this blog post.&lt;/p&gt;

&lt;p&gt;Fortunately, this macro is absolutely trivial to write. In fact, we can do it in a mere three lines of code, since it’s very minor sugar over the &lt;code&gt;define-syntax&lt;/code&gt; definitions we were already writing:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;op:id&lt;/span&gt; &lt;span class="n"&gt;value:id&lt;/span&gt;
                       &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;}}})&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With this in hand, we can define some infix operators with a much nicer syntax:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;racket/base/+&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;racket/base/-&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;racket/base/*&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="n"&gt;racket/base//&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="nb"&gt;expt&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With these simple definitions, we can write some very nice mathematical expressions that use infix syntax, in ordinary &lt;code&gt;#lang racket&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;-1&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;256&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And you know what’s most amazing about this? The entire thing is &lt;strong&gt;only 50 lines of code&lt;/strong&gt;. Here is the entire implementation of infix operators from this blog post in a single code block, with absolutely nothing hidden or omitted:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/class/local-value&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/parse/class/paren-shape&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/transformer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-in&lt;/span&gt; &lt;span class="n"&gt;racket/base/&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runtime-binding&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:property&lt;/span&gt; &lt;span class="nb"&gt;prop:procedure&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;set!-transformer-procedure&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-runtime-binding&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;infix-op&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"infix operator"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-value&lt;/span&gt; &lt;span class="n"&gt;infix-operator?&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.local-value&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="k"&gt;#%app&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~braces&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;op:id&lt;/span&gt; &lt;span class="n"&gt;value:id&lt;/span&gt;
                       &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;}}})&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;racket/base/+&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;racket/base/-&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;racket/base/*&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="n"&gt;racket/base//&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="nb"&gt;expt&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Racket is a hell of a programming language.&lt;/p&gt;

&lt;h1 id="applications-limitations-and-implications"&gt;Applications, limitations, and implications&lt;/h1&gt;

&lt;p&gt;This blog post has outlined a complete, useful model for infix operators, and it is now hopefully clear how they work, but many of the most interesting properties of this implementation are probably not obvious. As far as I can make out, this embedding of infix operators into a macro system is novel, and I am &lt;em&gt;almost certain&lt;/em&gt; that the way this implementation tracks fixity information is unique. One of the most interesting capabilities gained from this choice of implementation is the ability for macros to define infix operators and control their fixity, even &lt;em&gt;locally&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What does this mean? Well, remember that infix operators are just special syntax bindings. Racket includes a variety of forms for binding or adjusting macros locally, such as &lt;code&gt;let-syntax&lt;/code&gt; and &lt;code&gt;syntax-parameterize&lt;/code&gt;. Using these tools, it would be entirely possible to implement a &lt;code&gt;with-fixity&lt;/code&gt; macro, that could adjust the fixity of an operator within a syntactic block. This could be used, for example, to make &lt;code&gt;/&lt;/code&gt; right associative within a block of code:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;1/6&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;with-fixity&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="m"&gt;1/2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In fact, this macro is hardly theoretical, since it could be implemented in a trivial 7 lines, simply expanding to uses of &lt;code&gt;splicing-let&lt;/code&gt; and &lt;code&gt;splicing-let-syntax&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;with-fixity&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;op:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;}}}]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;op-tmp&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;generate-temporaries&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;splicing-let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;op-tmp&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;splicing-let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;op-tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is not especially useful given the current set of infix operator features, but it’s easy to imagine how useful it could be in a system that also supported a notion of precedence. It is not entirely uncommon to encounter certain expressions that could be more cleanly expressed with a local set of operator precedence rules, perhaps described as a set of relations &lt;em&gt;between&lt;/em&gt; operators rather than a global table of magic precedence numbers. With traditional approaches to infix operators, parsing such code would be difficult without a very rigid syntactic structure, but this technique makes it easy.&lt;/p&gt;

&lt;p&gt;As mentioned at the beginning of this blog post, this technique is also not merely a novelty—as of now, I am actively using this in &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Hackett&lt;/a&gt; to support infix operators with all of the features outlined here. The Hackett implementation is a little bit fancier than the one in this blog post, since it works harder to produce better error messages. It explicitly disallows mixing left associative and right associative operators in the same expression, so it does some additional validation as part of expansion, and it arranges for source location information to be copied onto the result. It also make a different design decision to allow &lt;em&gt;any&lt;/em&gt; expression to serve as an infix operator, assuming left associativity if no fixity annotation is available.&lt;/p&gt;

&lt;p&gt;If you’re interested in the code behind the additional steps Hackett takes to make infix operators more usable and complete, take a look at &lt;a href="https://github.com/lexi-lambda/hackett/blob/0d177d00a9ee96f30dd76761f1cb86f15830779f/hackett-lib/hackett/private/infix.rkt"&gt;this file for the definition of infix bindings&lt;/a&gt;, as well as &lt;a href="https://github.com/lexi-lambda/hackett/blob/0d177d00a9ee96f30dd76761f1cb86f15830779f/hackett-lib/hackett/private/kernel.rkt#L80-L101"&gt;this file for the defintion of infix application&lt;/a&gt;. My hope is to eventually add support for some sort of precedence information, though who knows—maybe infix operators will be easier to reason about if the rules are kept extremely simple. I am also considering adding support for so-called “operator sections” at some point, which would allow things like &lt;code&gt;{_ - 1}&lt;/code&gt; to serve as a shorthand for &lt;code&gt;(lambda [x] {x - 1})&lt;/code&gt;, but I haven’t yet decided if I like the tradeoffs involved.&lt;/p&gt;

&lt;p&gt;It’s possible that this implementation of infix operators might also be useful in languages in the Racket ecosystem besides Hackett. However, I’m not sure it makes a ton of sense in &lt;code&gt;#lang racket&lt;/code&gt; without modifications, as variadic functions subsume many of the cases where infix operators are needed in Haskell. If there is a clamoring for this capability, I would be happy to consider extracting the functionality into a library, but as of right now, I don’t have any plans to do so.&lt;/p&gt;

&lt;p&gt;Finally, the main point of this blog post is to showcase how easy it is to do things in Racket that would be impossible in most languages and difficult even in most Lisps. It also helps to show off how Hackett is already benefitting from those capabilities: while this particular feature is built-in to &lt;code&gt;#lang hackett&lt;/code&gt;, there’s no reason something similar but more powerful couldn’t be built as a separate library by a &lt;em&gt;user&lt;/em&gt; of Hackett. Even as Hackett’s author, I think that’s exciting, since makes it possible for users to experiment with improvements to the language on their own. Some of those improvements may eventually be rolled into the core language or standard library, but many of them can likely live effectively in separate libraries, accessible on-demand to those who need them. After all, that’s one of Racket’s most important promises—languages as libraries—and it’s why Hackett is a part of the Racket ecosystem.&lt;/p&gt;</description></item>
  <item>
   <title>Simple, safe multimethods in Racket</title>
   <link>http://lexi-lambda.github.io/blog/2016/02/18/simple-safe-multimethods-in-racket/?utm_source=macros&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2016-02-18-simple-safe-multimethods-in-racket</guid>
   <pubDate>Thu, 18 Feb 2016 18:48:32 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Racket ships with &lt;code&gt;racket/generic&lt;/code&gt;, a system for defining &lt;em&gt;generic methods&lt;/em&gt;, functions that work differently depending on what sort of value they are supplied. I have made heavy use of this feature in my collections library, and it has worked well for my needs, but that system does have a bit of a limitation: it only supports &lt;em&gt;single dispatch&lt;/em&gt;. Method implementations may only be chosen based on a single argument, so multiple dispatch is impossible.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="motivating-multiple-dispatch"&gt;Motivating multiple dispatch&lt;/h1&gt;

&lt;p&gt;What is multiple dispatch and why is it necessary? Well, in most cases, it &lt;em&gt;isn’t&lt;/em&gt; necessary at all. &lt;a href="http://dl.acm.org/citation.cfm?doid=1449764.1449808"&gt;It has been shown that multiple dispatch is much rarer than single dispatch in practice.&lt;/a&gt; However, when actually needed, having multiple dispatch in the toolbox is a valuable asset.&lt;/p&gt;

&lt;p&gt;A classic example of multiple dispatch is multiplication over both scalars and vectors. Ideally, all of the following operations should work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2 × 3 = 6
2 × ⟨3, 4⟩ = ⟨6, 8⟩
⟨3, 4⟩ × 2 = ⟨6, 8⟩&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In practice, most languages do not support such flexible dispatch rules without fairly complicated branching constructs to handle each permutation of input types. Furthermore, since most languages only support single dispatch (such as most object-oriented languages), it is nearly impossible to add support for a new combination of types to an existing method.&lt;/p&gt;

&lt;p&gt;To illustrate the above, even if a language supported operator overloading &lt;em&gt;and&lt;/em&gt; it included a &lt;code&gt;Vector&lt;/code&gt; class that overloaded multiplication to properly work with numbers and vectors, it might not implement matrix multiplication. If a user defines a &lt;code&gt;Matrix&lt;/code&gt; class, they may overload &lt;em&gt;its&lt;/em&gt; multiplication to support numbers, vectors, and matrices, but it is impossible to extend the multiplication implementation for the &lt;code&gt;Vector&lt;/code&gt; class. That method is now completely set in stone, unless it is edited directly (and the programmer may not have access to &lt;code&gt;Vector&lt;/code&gt;’s implementation).&lt;/p&gt;

&lt;p&gt;Multiple dispatch solves all of these problems. Rather than specify implementations of functions for singular types, it is possible to specify implementations for sets of types. In the above example, a programmer would be able to define a new function that operates on &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Matrix&lt;/code&gt; arguments. Since each definition does not “belong” to any given type, extending this set of operations is trivial.&lt;/p&gt;

&lt;h1 id="multiple-dispatch-in-racket"&gt;Multiple dispatch in Racket&lt;/h1&gt;

&lt;p&gt;This blog post is somewhat long and technical, so before proceeding any further, I want to show some real code that actually works so you can get a feel for what I’m talking about. As a proof-of-concept, I have created &lt;a href="https://github.com/lexi-lambda/racket-multimethod"&gt;a very simple implementation of multiple dispatch in Racket&lt;/a&gt;. The above example would look like this in Racket using my module:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;multimethod&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct-out&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct-out&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-generic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;curry&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Pardon the somewhat clunky syntax, but the functionality is there. Using the above code works as expected:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; (mul (num 2) (num 3))
(num 6)
&amp;gt; (mul (num 2) (vec '(3 4)))
(vec '(6 8))
&amp;gt; (mul (vec '(3 4)) (num 2))
(vec '(6 8))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Making the above snippet work is not particularly hard. In fact, it’s likely that most competent Racketeers could do it without much thought. However, there’s a tiny bit more going on behind the scenes than it may seem.&lt;/p&gt;

&lt;h1 id="the-problem-with-multiple-dispatch"&gt;The problem with multiple dispatch&lt;/h1&gt;

&lt;p&gt;The single-dispatch design limitation of &lt;code&gt;racket/generic&lt;/code&gt; comes directly from a desire to avoid what has been described as “spooky action at a distance”, a problem that is prevalent in many systems that support methods with multiple dispatch (aka &lt;em&gt;multimethods&lt;/em&gt;). Specifically, the issue arises when new method implementations are defined for existing datatypes, which can have far-reaching effects throughout a program because the method table is global state. Both CLOS and Clojure suffer from this shortcoming.&lt;/p&gt;

&lt;p&gt;Interestingly, Haskell with multi-parameter typeclasses (a nonstandard but highly useful extension) makes it quite trivial to create constructs similar to multiple dispatch (though the overload resolution is done at compile-time). The similarities are significant: Haskell &lt;em&gt;also&lt;/em&gt; suffers from the possibility of a certain sort of “spooky action”. However, Haskell’s static typing and resolution allows the compiler to catch these potential issues, known as “orphan instances”, at compile time. Even though Racket does not support the same sort of static typing, the same idea can be used to keep multiple dispatch safe using the macro system.&lt;/p&gt;

&lt;h1 id="safe-dynamically-typed-multiple-dispatch"&gt;Safe, dynamically-typed multiple dispatch&lt;/h1&gt;

&lt;p&gt;In order to make multiple dispatch safe, we first need to determine exactly what is unsafe. Haskell has rules for determining what constitutes an “orphan instance”, and these rules are equally applicable for determining dangerous multimethod implementations. Specifically, a definition can be considered unsafe if &lt;em&gt;both&lt;/em&gt; of the following conditions are true:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The multimethod that is being implemented was declared in a different module from the implementation.&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;All&lt;/em&gt; of the types used for dispatch in the multimethod instance were declared in a different module from the implementation.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Conversely, a multimethod implementation is safe if &lt;em&gt;either&lt;/em&gt; of the following conditions are true:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The multimethod that is being implemented is declared in the same module as the implementation.&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;Any&lt;/em&gt; of the types used for dispatch in the multimethod instance are declared in the same module as the implementation.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Why do these two rules provide a strong enough guarantee to eliminate the dangers created by global state? Well, to understand that, we need to understand what can go wrong if these rules are ignored.&lt;/p&gt;

&lt;h2 id="multimethods-and-dangerous-instances"&gt;Multimethods and dangerous instances&lt;/h2&gt;

&lt;p&gt;What exactly is this dangerous-sounding “spooky action”, and what causes it? Well, the trouble stems from the side-effectful nature of multimethod instance definitions. Consider the Racket module from earlier, which defines multiplication instances for scalars and vectors:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct-out&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct-out&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-generic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;curry&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that there is not actually a &lt;code&gt;(mul vec vec)&lt;/code&gt; implementation. This is intentional: there are &lt;em&gt;two&lt;/em&gt; ways to take the product of two vectors, so no default implementation is provided. However, it is possible that another module might desire an instance for &lt;code&gt;mul&lt;/code&gt; that takes the dot product, and the programmer might write the following definition:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;foldl&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, there is something fishy about the above definition: it doesn’t need to be exported with &lt;code&gt;provide&lt;/code&gt; to work! Since instances don’t create new bindings, they only add dispatch options, they don’t ever need to &lt;code&gt;provide&lt;/code&gt; anything. This is problematic, though: it means that a program could continue to happily compile &lt;em&gt;even if&lt;/em&gt; the module containing the dot product instance was never loaded with &lt;code&gt;require&lt;/code&gt;, but an attempt to multiply two vectors would fail at runtime, claiming that there was no &lt;code&gt;(mul vec vec)&lt;/code&gt; implementation. This drastic change of behavior violates Racket programmers’ assumptions about the guarantees made by modules (&lt;code&gt;require&lt;/code&gt; should not cause any side-effects if the module’s bindings are not used).&lt;/p&gt;

&lt;p&gt;Of course, while this seems potentially unexpected, it is workable: just be careful to &lt;code&gt;require&lt;/code&gt; modules containing instances. Unfortunately, it gets much worse—what if a different library defines &lt;em&gt;its own&lt;/em&gt; &lt;code&gt;(mul vec vec)&lt;/code&gt; instance? What if that instance takes the cross product instead? That library may function entirely properly on its own, but when loaded alongside the program that defines a dot product instance, it is impossible to determine which instance should be used where. Because &lt;code&gt;define-instance&lt;/code&gt; operates by modifying the aforementioned global state, the implementations clash, and the two systems &lt;em&gt;cannot&lt;/em&gt; continue to operate together as written.&lt;/p&gt;

&lt;p&gt;This is pretty bad. Defining extra instances is a reasonable use-case for multiple dispatch, but if these instances can break &lt;em&gt;third-party code&lt;/em&gt;, how can they be trusted? This sort of problem can make multiple dispatch difficult to reason about and even more difficult to trust.&lt;/p&gt;

&lt;h2 id="what-determines-safety"&gt;What determines safety?&lt;/h2&gt;

&lt;p&gt;With those problems in mind, we can turn back to the two rules for &lt;em&gt;safe&lt;/em&gt; multiple dispatch. How do they prevent the above issues? Well, let’s take them one at a time.&lt;/p&gt;

&lt;p&gt;Remember that an instance can be unequivocally determined to be safe if either of the two conditions are true, so we can consider them entirely independently. The first one is simple—an instance is safe if the following condition holds:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;The multimethod that is being implemented is declared in the same module as the implementation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This one is pretty obvious. It is impossible to create a “bad” instance of a method declared in the same module because it is impossible to import the method without also bringing in the instance. Furthermore, a conflicting instance cannot be defined at the place where the types themselves are defined because that would require a circular module dependency, which Racket does not permit.&lt;/p&gt;

&lt;p&gt;With the above explanation in mind, the second condition should make sense, too:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Any&lt;/em&gt; of the types used for dispatch in the multimethod instance are declared in the same module as the implementation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The same argument for the first point holds for the second, but with the parties swapped. Again, it is impossible to use the instance without somehow requiring the module that defines the datatype itself, so the instance would always be required, anyway. The most interesting aspect of this condition is that it demonstrates that instances can be defined for existing datatypes (that are defined in other modules) just so long as &lt;em&gt;at least one&lt;/em&gt; of the datatypes is defined in the same module. This continues to permit the important use-case of extending the interfaces of existing types.&lt;/p&gt;

&lt;h2 id="encoding-the-safety-rules-into-rackets-macro-system"&gt;Encoding the safety rules into Racket’s macro system&lt;/h2&gt;

&lt;p&gt;In order to keep track of which methods and instances are defined where, I leveraged a technique based on the one &lt;a href="http://www.ccs.neu.edu/racket/pubs/scheme2007-ctf.pdf"&gt;used by Typed Racket to keep track of whether or not a typed identifier is used in a typed or untyped context&lt;/a&gt;. However, instead of using a simple mutable boolean flag, I used a mutable &lt;a href="http://docs.racket-lang.org/syntax/syntax-helpers.html#%28tech._identifier._set%29"&gt;free identifier set&lt;/a&gt;, which keeps track of the identifiers within a given module that should be considered “privileged”.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket/base&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;syntax/id-set&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;mark-id-as-privileged!&lt;/span&gt;
         &lt;span class="n"&gt;id-privileged?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;privileged-ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutable-free-id-set&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mark-id-as-privileged!&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;free-id-set-add!&lt;/span&gt; &lt;span class="n"&gt;privileged-ids&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;free-id-set-member?&lt;/span&gt; &lt;span class="n"&gt;privileged-ids&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Making this work with &lt;code&gt;define-generic&lt;/code&gt; is obvious: just invoke &lt;code&gt;mark-id-as-privileged!&lt;/code&gt; on the method name to note that the method is “privileged” in the scope of the current module. Keeping track of privileged structs is similarly straightforward, though it is a little more devious: the &lt;code&gt;multimethod&lt;/code&gt; module provides a custom &lt;code&gt;struct&lt;/code&gt; macro that just expands to &lt;code&gt;struct&lt;/code&gt; from &lt;code&gt;racket/base&lt;/code&gt;, but adds privilege information.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;define-instance&lt;/code&gt; macro does all the heavy lifting to ensure that only privileged identifiers can be used in instance definitions. A simple check for the identifier annotations is performed before proceeding with macro expansion:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ormap&lt;/span&gt; &lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;When the privilege checks fail, an error is raised:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;define-instance&lt;/span&gt;
                        &lt;span class="s2"&gt;"expected name of struct defined in current module"&lt;/span&gt;
                        &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With the above safeguards in place, the dangerous dot product implementation from above &lt;strong&gt;would not be allowed&lt;/strong&gt;. The checks manage to encode both of the safety rules into the macro system such that invalid instances will fail &lt;em&gt;at compile time&lt;/em&gt;, preventing dangerous uses of multimethods from ever slipping by unnoticed.&lt;/p&gt;

&lt;h2 id="actually-implementing-multiple-dispatch"&gt;Actually implementing multiple dispatch&lt;/h2&gt;

&lt;p&gt;The rest of the multimethod implementation is relatively straightforward and is not even particularly robust. If anything, it is the bare minimum of what would be needed to allow the safety mechanisms above to work. Lots of features that would likely be needed in a real implementation are not included, and graceful error handling is largely ignored.&lt;/p&gt;

&lt;p&gt;Multimethods themselves are implemented as Racket &lt;a href="http://docs.racket-lang.org/guide/proc-macros.html#%28tech._transformer._binding%29"&gt;transformer bindings&lt;/a&gt; containing custom data, including a reference to the multimethod’s arity and dispatch table. The custom datatype includes a &lt;code&gt;prop:procedure&lt;/code&gt; structure type property, which allows such bindings to also function as macros. The macro procedure expands to an operation that looks up the proper instance to use in the multimethod’s dispatch table and invokes it with the supplied arguments.&lt;/p&gt;

&lt;p&gt;The relevant code for defining multimethods is reproduced below:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;multimethod&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arity&lt;/span&gt; &lt;span class="n"&gt;dispatch-table&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:property&lt;/span&gt; &lt;span class="nb"&gt;prop:procedure&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
        &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apply-multimethod&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;
         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apply-multimethod&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;))]))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-generic&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method:id&lt;/span&gt; &lt;span class="n"&gt;arg:id&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;with-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;arity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;length&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generate-temporary&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mark-id-as-privileged!&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-hash&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;multimethod&lt;/span&gt; &lt;span class="n"&gt;arity&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;dispatch-table&lt;/span&gt;&lt;span class="p"&gt;))))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The dispatch tables are implemented entirely in terms of Racket’s structure types, so while they can be defined on arbitrary structure types (including ones defined in the Racket standard library), they &lt;em&gt;cannot&lt;/em&gt; be defined on primitives such as pairs or vectors. Implementations are registered in the dispatch table using the compile-time information associated with structs’ transformer bindings, and the same information is retrieved from struct instances at runtime to look up the proper implementation to call. Notably, this only works if the struct is &lt;code&gt;#:transparent&lt;/code&gt;, or more generally and accurately, if the calling code has access to the struct’s inspector. All structs defined by the &lt;code&gt;struct&lt;/code&gt; form from the &lt;code&gt;multimethod&lt;/code&gt; module are automatically marked as &lt;code&gt;#:transparent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The following code implements defining multimethod instances:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;define-instance&lt;/span&gt;
                          &lt;span class="s2"&gt;"expected name of struct defined in current module"&lt;/span&gt;
                          &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-instance&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="c1"&gt;; standard (define (proc ...) ...) shorthand&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;type:id&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body:expr&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="c1"&gt;; full (define proc lambda-expr) notation&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;type:id&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;proc:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;multimethod&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ormap&lt;/span&gt; &lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;with-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;multimethod-dispatch-table&lt;/span&gt; &lt;span class="n"&gt;multimethod&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                     &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;struct-type-id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;compose1&lt;/span&gt; &lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="n"&gt;extract-struct-info&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;struct-types&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="n"&gt;struct-type-id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-set!&lt;/span&gt; &lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="n"&gt;struct-types&lt;/span&gt; &lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="p"&gt;))))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The resulting implementation is a useful, if certainly incomplete implementation of multimethods in Racket that does not sacrifice the safety provided by &lt;code&gt;racket/generic&lt;/code&gt;’s single-dispatch approach.&lt;/p&gt;

&lt;h1 id="related-work-advantages-and-disadvantages-and-areas-for-future-improvement"&gt;Related work, advantages and disadvantages, and areas for future improvement&lt;/h1&gt;

&lt;p&gt;As previously mentioned, this implementation of multiple dispatch was inspired by the types of APIs offered by CLOS and Clojure while also maintaining the safety of &lt;code&gt;racket/generic&lt;/code&gt;. The inspiration for the safety rules came from GHC’s detection of orphan instances. Although most of the ideas presented above exist in other places, I am unsure if the concept of safety checking has been used before in any dynamically-typed programming languages.&lt;/p&gt;

&lt;p&gt;The primary advantage offered over Racket’s existing generics system is obvious: multiple dispatch. Furthermore, this system can supersede many uses of &lt;code&gt;racket/generic&lt;/code&gt; simply by dispatching on a single type. However, the current implementation does &lt;em&gt;not&lt;/em&gt; support all of the features of &lt;code&gt;racket/generic&lt;/code&gt;, such as supporting non-structure types and allowing fallback implementations. While those are well within the realm of possibility, other things like attaching structure type properties are probably not possible with this approach, so it is unlikely that the existing system could be subsumed by one like this one.&lt;/p&gt;

&lt;p&gt;Additionally, this implementation would almost certainly need numerous improvements before being useful to most programmers:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Good error reporting for failure cases.&lt;/strong&gt; Right now, even something obvious like calling a method on values that do not implement it simply fails with an error produced by &lt;code&gt;hash-ref&lt;/code&gt;. In a more interesting sense, using the arity to generate compile-time error messages for &lt;code&gt;define-instance&lt;/code&gt; would be a nice improvement.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Support for Racket primitive data types.&lt;/strong&gt; This might require some cooperation from Racket itself to permit an elegant implementation, but they could also just be special-cased. So long as lookup for primitives was done &lt;em&gt;after&lt;/em&gt; consulting the main dispatch table, there wouldn’t be any performance hit for non-primitive types.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Option to supply fallback implementations.&lt;/strong&gt; This wouldn’t be too hard at all, though it’s questionable whether or not it would be useful without method groupings like &lt;code&gt;define/generic&lt;/code&gt; provides. There would likely also need to be some sort of way to check if a set of values implements a particular method.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Better cooperation with structure inspectors to alleviate the need for all structures to be transparent.&lt;/strong&gt; It’s currently unclear to me how exactly this works and how it &lt;em&gt;should&lt;/em&gt; work. There might be a better way to do this without mucking with inspectors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Much more flexible argument lists, including the ability to specify arguments that are not used for dispatch.&lt;/strong&gt; This is really a pretty fundamental requirement, but the parsing required was significant enough for me to put it off for this initial prototype.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Scribble forms to document generic methods and their instances.&lt;/strong&gt; This is something &lt;code&gt;racket/generic&lt;/code&gt; &lt;em&gt;doesn’t&lt;/em&gt; have, and it has suffered for it. It would be very nice to have easy documentation forms for multimethods.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Proper consideration of struct subtyping.&lt;/strong&gt; Racket structs support subtyping, which I have not given much thought for this prototype. It is possible that subtyping violates constraints I had assumed would hold, so reviewing the existing code with that context would be useful.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;I’m not sure how much effort is involved in most of the above ideas, and in fact I’m not even completely sure how useful this system is to begin with. I have not found myself reaching much for multiple dispatch in my time as a Racket programmer, but that could simply be because it was previously unavailable. It will be interesting to see if that changes now that I have built this system, even if it is a bit rough around the edges.&lt;/p&gt;

&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Despite the lack of need for multiple dispatch to solve most problems, as indicated by its general lack of support in mainstream programming languages, it’s a nice tool to have in the toolbox, and it &lt;em&gt;is&lt;/em&gt; asked for in the Racket community from time to time (perhaps due to its familiarity in other parts of the Lisp world). Time will tell if pointing people to something like this will create or stifle interest in multiple dispatch for Racket.&lt;/p&gt;

&lt;p&gt;The source for the &lt;a href="https://github.com/lexi-lambda/racket-multimethod"&gt;&lt;code&gt;multimethod&lt;/code&gt; package can be found here&lt;/a&gt; if you are at all interested in playing with it yourself.&lt;/p&gt;</description></item>
  <item>
   <title>ADTs in Typed Racket with macros</title>
   <link>http://lexi-lambda.github.io/blog/2015/12/21/adts-in-typed-racket-with-macros/?utm_source=macros&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2015-12-21-adts-in-typed-racket-with-macros</guid>
   <pubDate>Mon, 21 Dec 2015 17:57:07 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Macros are one of Racket&amp;rsquo;s flagship features, and its macro system really is state of the art. Of course, it can sometimes be difficult to demonstrate &lt;em&gt;why&lt;/em&gt; macros are so highly esteemed, in part because it can be hard to find self-contained examples of using macros in practice. Of course, one thing that macros are perfect for is filling a &amp;ldquo;hole&amp;rdquo; in the language by introducing a feature a language lacks, and one of those features in Typed Racket is &lt;strong&gt;ADTs&lt;/strong&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="warning-this-is-not-a-macro-tutorial"&gt;Warning: this is not a macro tutorial&lt;/h1&gt;

&lt;p&gt;First, a disclaimer: this post assumes at least some knowledge of Scheme/Racket macros. Ideally, you would be familiar with Racket itself. But if you aren&amp;rsquo;t, fear not: if you get lost, don&amp;rsquo;t worry. Hold on to the bigger picture, and you&amp;rsquo;ll likely learn more than someone who knows enough to follow all the way through. If you &lt;em&gt;are&lt;/em&gt; interested in learning about macros, I must recommend Greg Hendershott&amp;rsquo;s &lt;a href="http://www.greghendershott.com/fear-of-macros/"&gt;Fear of Macros&lt;/a&gt;. It is good. This is not that.&lt;/p&gt;

&lt;p&gt;Now, with that out of the way, let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h1 id="what-were-building"&gt;What we&amp;rsquo;re building&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Algebraic_data_type"&gt;Algebraic data types&lt;/a&gt;, or &lt;em&gt;ADTs&lt;/em&gt;, are a staple of the ML family of functional programming languages. I won&amp;rsquo;t go into detail here—I want to focus on the implementation—but they&amp;rsquo;re a very descriptive way of modeling data that encourages designing functions in terms of pattern-matching, something that Racket is already good at.&lt;/p&gt;

&lt;p&gt;Racket also already has a facility for creating custom data structures in the form of &lt;em&gt;structs&lt;/em&gt;, which are extremely flexible, but also a little verbose. Racket structs are more powerful than we need, but that means we can implement our ADTs in terms of Racket&amp;rsquo;s struct system.&lt;/p&gt;

&lt;p&gt;With that in mind, what should our syntax look like? Well, let&amp;rsquo;s consider a quintessential example of ADTs: modeling a simple tree. For now, let&amp;rsquo;s just consider a tree of integers. For reference, the Haskell syntax for such a data structure would look like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Empty&lt;/span&gt;
          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Node&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This already demonstrates a few of the core things we&amp;rsquo;ll need to build:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Each ADT has a &lt;em&gt;data type&lt;/em&gt;, in this case &lt;code&gt;Tree&lt;/code&gt;. This name only exists in the world of types, it isn&amp;rsquo;t a value.&lt;/li&gt;
 &lt;li&gt;Each ADT has various &lt;em&gt;data constructors&lt;/em&gt;, in this case &lt;code&gt;Leaf&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Each data constructor may accept any number of arguments, each of which have a specific type.&lt;/li&gt;
 &lt;li&gt;The types that data constructors may accept include the ADT&amp;rsquo;s datatype itself—that is, definitions can be recursive.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Of course, there&amp;rsquo;s one more important feature we&amp;rsquo;re missing: polymorphism. Our definition of a tree is overly-specific, and really, it should be able to hold any kind of data, not just integers. In Haskell, we can do that by adding a type parameter:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Empty&lt;/span&gt;
            &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
            &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With this in mind, we can add a fifth and final point to our list:&lt;/p&gt;

&lt;p&gt; 
 &lt;ol start="5"&gt;
  &lt;li&gt;ADTs must be able to be parametrically polymorphic.&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;

&lt;p&gt;That covers all of our requirements for basic ADTs. Now we&amp;rsquo;re ready to port this idea to Racket.&lt;/p&gt;

&lt;h2 id="describing-adts-in-racket"&gt;Describing ADTs in Racket&lt;/h2&gt;

&lt;p&gt;How should we take the Haskell syntax for an ADT definition and adapt it to Racket&amp;rsquo;s parenthetical s-expressions? By taking some cues from the Haskell implementation, Typed Racket&amp;rsquo;s type syntax, and Racket&amp;rsquo;s naming conventions, a fairly logical syntax emerges:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;Empty&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This looks pretty good. Just like with the Haskell implementation, &lt;code&gt;Tree&lt;/code&gt; should only exist at the type level, and &lt;code&gt;Empty&lt;/code&gt;, &lt;code&gt;Leaf&lt;/code&gt;, and &lt;code&gt;Node&lt;/code&gt; should be constructor functions. Our syntax mirrors Racket function application, too—the proper way to create a leaf would be &lt;code&gt;(Leaf 7)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that we can create ADT values, how should we extract the values from them? Well, just like in ML-likes, we can use pattern-matching. We don&amp;rsquo;t need to reinvent the wheel for this one; we should be able to just use Racket&amp;rsquo;s &lt;code&gt;&lt;a href="http://docs.racket-lang.org/reference/match.html#(form._((lib._racket/match..rkt)._match))" style="color: inherit"&gt;match&lt;/a&gt;&lt;/code&gt; with our datatypes. For example, a function that sums all the values in a tree might look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;               &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="n"&gt;n&lt;/span&gt;               &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Given that Racket&amp;rsquo;s &lt;code&gt;struct&lt;/code&gt; form automatically produces identifiers that cooperate with &lt;code&gt;match&lt;/code&gt;, this shouldn&amp;rsquo;t be hard at all. And with our syntax settled, we&amp;rsquo;re ready to begin implementation.&lt;/p&gt;

&lt;h1 id="implementing-adts-as-syntax"&gt;Implementing ADTs as syntax&lt;/h1&gt;

&lt;p&gt;Now for the fun part. To implement our ADT syntax, we&amp;rsquo;ll employ Racket&amp;rsquo;s industrial-strength macro DSL, &lt;a href="http://docs.racket-lang.org/syntax/stxparse.html"&gt;&lt;code&gt;syntax/parse&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;syntax/parse&lt;/code&gt; library works like the traditional Scheme &lt;code&gt;syntax-case&lt;/code&gt; on steroids, and one of the most useful features is the ability to define &amp;ldquo;syntax classes&amp;rdquo; that encapsulate reusable parsing rules into declarative components.&lt;/p&gt;

&lt;p&gt;Since this is not a macro tutorial, the following implementation assumes you already know how to use &lt;code&gt;syntax/parse&lt;/code&gt;. However, all of the concepts here are well within the reaches of any intermediate macrologist, so don&amp;rsquo;t be intimidated by some of the more complex topics at play.&lt;/p&gt;

&lt;h2 id="parsing-types-with-a-syntax-class"&gt;Parsing types with a syntax class&lt;/h2&gt;

&lt;p&gt;To implement ADTs, we&amp;rsquo;re going to want to define exactly one syntax class, a class that describes the grammar for a type. As we&amp;rsquo;ve seen, types can be bare identifiers, like &lt;code&gt;Tree&lt;/code&gt;, or they can be identifiers with parameters, like &lt;code&gt;(Tree a)&lt;/code&gt;. We&amp;rsquo;ll want to cover both cases.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This syntax class has two rules, one that&amp;rsquo;s a bare identifier, and one that&amp;rsquo;s a list. The ellipsis followed by a plus (&lt;code&gt;...+&lt;/code&gt;) in the second example means &amp;ldquo;one or more&amp;rdquo;, so parsing those parameters will automatically be handled for us. In the bare identifier example, we use &lt;code&gt;#:attr&lt;/code&gt; to give the &lt;code&gt;param&lt;/code&gt; attribute the default value of an empty list, so this syntax class will actually &lt;em&gt;normalize&lt;/em&gt; the input we get in addition to actually parsing it.&lt;/p&gt;

&lt;h2 id="a-first-attempt-at-define-datatype"&gt;A first attempt at &lt;code&gt;define-datatype&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Now we can move on to actually implementing &lt;code&gt;define-datatype&lt;/code&gt;. The rules are simple: we need to generate a structure type for each one of the data constructors, and we need to generate a type definition for the parent type itself. This is pretty simple to implement using &lt;code&gt;syntax-parser&lt;/code&gt;, which actually does the parsing for our macro.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-datatype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;type-name:type&lt;/span&gt; &lt;span class="n"&gt;data-constructor:type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This definition will do all the parsing we need. It parses the entire macro &amp;ldquo;invocation&amp;rdquo;, ignoring the first datum with &lt;code&gt;_&lt;/code&gt; (which will just be the identifier &lt;code&gt;define-datatype&lt;/code&gt;), then expecting a &lt;code&gt;type-name&lt;/code&gt;, which uses the &lt;code&gt;type&lt;/code&gt; syntax class we defined above. Next, we expect zero or more &lt;code&gt;data-constructor&lt;/code&gt;s, which also use the &lt;code&gt;type&lt;/code&gt; syntax class. That&amp;rsquo;s all we have to do for parsing. We now have all the information we need to actually output the expansion for the macro.&lt;/p&gt;

&lt;p&gt;Of course, it won&amp;rsquo;t be that easy: this is the difficult part. The first step is to generate a Racket struct for each data constructor. We can do this pretty easily with some simple use of Racket&amp;rsquo;s syntax templating facility. A naïve attempt would look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-datatype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;type-name:type&lt;/span&gt; &lt;span class="n"&gt;data-constructor:type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is actually really close to being correct. This will generate a struct definition for each &lt;code&gt;data-constructor&lt;/code&gt;, where each struct has the name of the data constructor and the same number of fields as arguments provided. The trouble is that in Racket structs, all of the fields have &lt;em&gt;names&lt;/em&gt;, but in our ADTs, all the fields are anonymous and by-position. Currently, we&amp;rsquo;re just using the same name for &lt;em&gt;all&lt;/em&gt; the fields, &lt;code&gt;f&lt;/code&gt;, so if any data constructor has two or more fields, we&amp;rsquo;ll get an error.&lt;/p&gt;

&lt;p&gt;Since we don&amp;rsquo;t care about the field names, what we want to do is just generate random names for every field. To do this, we can use a Racket function called &lt;code&gt;generate-temporary&lt;/code&gt;, which generates random identifiers. Our next attempt might look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt;
      &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generate-temporary&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;#,&lt;/code&gt; lets us &amp;ldquo;escape&amp;rdquo; from the template to execute &lt;code&gt;(generate-temporary)&lt;/code&gt; and interpolate its result into the syntax. Unfortunately, this doesn&amp;rsquo;t work. We &lt;em&gt;do&lt;/em&gt; generate a random field name, but the ellipsis will re-use the same generated value when it repeats the fields, rendering our whole effort pointless. We need to generate the field names once per type.&lt;/p&gt;

&lt;h2 id="more-leveraging-syntax-classes"&gt;More leveraging syntax classes&lt;/h2&gt;

&lt;p&gt;As it turns out, this is &lt;em&gt;also&lt;/em&gt; easy to do with syntax classes. We can add an extra attribute to our &lt;code&gt;type&lt;/code&gt; syntax class to generate a random identifier with each one. Again, we can use &lt;code&gt;#:attr&lt;/code&gt; to do that automatically. Our new definition for &lt;code&gt;type&lt;/code&gt; will look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="n"&gt;name:id&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;generate-temporaries&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Here we&amp;rsquo;re using &lt;code&gt;generate-temporaries&lt;/code&gt; instead of &lt;code&gt;generate-temporary&lt;/code&gt;, which will conveniently generate a new identifier for each of the elements in the list we provide it. This way, we&amp;rsquo;ll get a fresh identifier for each &lt;code&gt;param&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can now fix our macro to use this &lt;code&gt;field-id&lt;/code&gt; attribute instead of the static field name:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt;
      &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;data-constructor.field-id&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;h2 id="creating-the-supertype"&gt;Creating the supertype&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re almost done—now we just need to implement our overall type, the one defined by &lt;code&gt;type-name&lt;/code&gt;. This is implemented as a trivial type alias, but we need to ensure that polymorphic types are properly handled. For example, a non-polymorphic type would need to be handled like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-type&lt;/span&gt; &lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, a polymorphic type alias would need to include the type parameters in each subtype, like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;How can we do this? Well, so far, we&amp;rsquo;ve been very declarative by using syntax patterns, templates, and classes. However, this is a more pernicious problem to solve with our declarative tools. Fortunately, it&amp;rsquo;s very easy to fall back to using &lt;strong&gt;procedural macros&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;To build each properly-instantiated type, we&amp;rsquo;ll use a combination of &lt;code&gt;define/with-syntax&lt;/code&gt; and Racket&amp;rsquo;s list comprehensions, &lt;code&gt;for/list&lt;/code&gt;. The &lt;code&gt;define/with-syntax&lt;/code&gt; form binds values to pattern identifiers, which can be used within syntax patterns just like the ones bound by &lt;code&gt;syntax-parser&lt;/code&gt;. This will allow us to break up our result into multiple steps. Technically, &lt;code&gt;define/with-syntax&lt;/code&gt; is not strictly necessary—we could just use &lt;code&gt;#`&lt;/code&gt; and &lt;code&gt;#,&lt;/code&gt;—but it&amp;rsquo;s cleaner to work with.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start by defining a set of instantiated data constructor types, one per &lt;code&gt;data-constructor&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/with-syntax&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we can fill in the body with any code we&amp;rsquo;d like, so long as each body returns a syntax object. We can use some trivial branching logic to determine which form we need:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/with-syntax&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx-null?&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now with our definition for &lt;code&gt;data-type&lt;/code&gt;, we can implement our type alias for the supertype extremely easily:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-type&lt;/span&gt; &lt;span class="n"&gt;type-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;h2 id="putting-it-all-together"&gt;Putting it all together&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s just one more thing to do before we can call this macro finished: we need to ensure that all the type parameters defined by &lt;code&gt;type-name&lt;/code&gt; are in scope for each data constructor&amp;rsquo;s structure definition. We can do this by making use of &lt;code&gt;type-name.param&lt;/code&gt; within each produced struct definition, resulting in this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;data-constructor.field-id&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And we&amp;rsquo;re done! The final macro, now completed, looks like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="n"&gt;name:id&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;generate-temporaries&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-datatype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;type-name:type&lt;/span&gt; &lt;span class="n"&gt;data-constructor:type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/with-syntax&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx-null?&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
             &lt;span class="n"&gt;name&lt;/span&gt;
             &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt;
           &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;data-constructor.field-id&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-type&lt;/span&gt; &lt;span class="n"&gt;type-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;rsquo;s a little bit dense, certainly, but it is not as complicated or scary as it might seem. It&amp;rsquo;s a simple, mostly declarative, powerful way to transform a DSL into ordinary Typed Racket syntax, and now all we have to do is put it to use.&lt;/p&gt;

&lt;h1 id="using-our-adts"&gt;Using our ADTs&lt;/h1&gt;

&lt;p&gt;With the macro built, we can now actually use our ADTs using the syntax we described! The following is now &lt;em&gt;valid code&lt;/em&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;Empty&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;Positive-Byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We can use this to define common data types, such as Haskell&amp;rsquo;s &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;maybe-default&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;All&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maybe-default&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;maybe-then&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;All&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maybe-then&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And of course, we can also use it to define ADTs that use concrete types rather that type parameters, if we so desire. This implements a small mathematical language, along with a trivial interpreter:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Subtract&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Multiply&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Divide&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="n"&gt;x&lt;/span&gt;                            &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Subtract&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Multiply&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Divide&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Multiply&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Divide&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="m"&gt;1/2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;There&amp;rsquo;s all the power of ADTs, right in Racket, all implemented in 22 lines of code. If you&amp;rsquo;d like to see all the code together in a runnable form, &lt;a href="https://gist.github.com/lexi-lambda/18cf7a9156f743a1317e"&gt;I&amp;rsquo;ve put together a gist here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id="conclusions-and-credit"&gt;Conclusions and credit&lt;/h1&gt;

&lt;p&gt;This isn&amp;rsquo;t the simplest macro to create, nor is it the most complex. The code examples might not even make much sense until you try it out yourself. Macros, like any difficult concept, are not always easy to pick up, but they certainly &lt;em&gt;are&lt;/em&gt; powerful. The ability to extend the language in such a way, in the matter of minutes, is unparalleled in languages other than Lisp.&lt;/p&gt;

&lt;p&gt;This is, of course, a blessing and a curse. Lisps reject some of the syntactic landmarks that often aid in readability for the power to abstract programs into their bare components. In the end, is this uniform conciseness more or less readable? That&amp;rsquo;s an incredibly subjective question, one that has prompted powerfully impassioned discussions, and I will not attempt to argue one way or the other here.&lt;/p&gt;

&lt;p&gt;That said, I think it&amp;rsquo;s pretty cool.&lt;/p&gt;

&lt;p&gt;Finally, I must give credit where credit is due. Thanks to &lt;a href="http://andmkent.com"&gt;Andrew M. Kent&lt;/a&gt; for the creation of the &lt;a href="https://github.com/andmkent/datatype"&gt;datatype&lt;/a&gt; package, which served as the inspiration for this blog post. Many thanks to &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt; for his work creating Typed Racket, as well as helping me dramatically simplify the implementation used in this blog post. Also thanks to &lt;a href="http://www.ccs.neu.edu/home/ryanc/"&gt;Ryan Culpepper&lt;/a&gt; and &lt;a href="http://www.ccs.neu.edu/home/matthias/"&gt;Matthias Felleisen&lt;/a&gt; for their work on creating &lt;code&gt;syntax/parse&lt;/code&gt;, which is truly a marvelous tool for exploring the world of macros, and, of course, a big thanks to &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt; for his implementation of hygiene in Racket, as well as much of the rest of Racket itself. Not to mention the entire legacy of those who formulated the foundations of the Scheme macro system and created the framework for all of this to be possible so many decades later.&lt;/p&gt;

&lt;p&gt;Truly, working in Racket feels like standing on the shoulders of giants. If you&amp;rsquo;re intrigued, give it a shot. It&amp;rsquo;s a fun feeling.&lt;/p&gt;</description></item></channel></rss>