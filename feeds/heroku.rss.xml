<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Alexis King's Blog: Posts tagged 'heroku'</title>
  <description>Alexis King's Blog: Posts tagged 'heroku'</description>
  <link>http://lexi-lambda.github.io/tags/heroku.html</link>
  <lastBuildDate>Sat, 22 Aug 2015 14:47:49 UT</lastBuildDate>
  <pubDate>Sat, 22 Aug 2015 14:47:49 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Deploying Racket applications on Heroku</title>
   <link>http://lexi-lambda.github.io/blog/2015/08/22/deploying-racket-applications-on-heroku/?utm_source=heroku&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2015-08-22-deploying-racket-applications-on-heroku</guid>
   <pubDate>Sat, 22 Aug 2015 14:47:49 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;&lt;a href="https://www.heroku.com"&gt;Heroku&lt;/a&gt; is a &amp;ldquo;platform as a service&amp;rdquo; that provides an incredibly simple way to deploy simple internet applications, and I take liberal advantage of its free tier for testing out simple applications. It has support for a variety of languages built-in, but Racket is not currently among them. Fortunately, Heroku provides an interface for adding custom build processes for arbitrary types of applications, called “buildpacks”. I&amp;rsquo;ve built one for Racket apps, and with just a little bit of configuration, it’s possible to get a Racket webserver running on Heroku.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="building-the-server"&gt;Building the server&lt;/h1&gt;

&lt;p&gt;Racket&amp;rsquo;s &lt;a href="http://docs.racket-lang.org/web-server/index.html"&gt;web-server&lt;/a&gt; package makes building and running a simple server incredibly easy. Here&amp;rsquo;s all the code we&amp;rsquo;ll need to get going:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;web-server/servlet&lt;/span&gt;
         &lt;span class="n"&gt;web-server/servlet-env&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response/xexpr&lt;/span&gt;
   &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;html&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;title&lt;/span&gt; &lt;span class="s2"&gt;"Racket Heroku App"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;body&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;h1&lt;/span&gt; &lt;span class="s2"&gt;"It works!"&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serve/servlet&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="kd"&gt;#:servlet-path&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Running the above file will start up the server on the default port, 8080. When running on Heroku, however, we&amp;rsquo;re required to bind to the port that Heroku provides via the &lt;code&gt;PORT&lt;/code&gt; environment variable. We can access this using the Racket &lt;code&gt;&lt;a href="http://docs.racket-lang.org/reference/envvars.html#(def._((lib._racket/private/misc..rkt)._getenv))" style="color: inherit"&gt;getenv&lt;/a&gt;&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Additionally, the Racket web server specifically binds to localhost, but Heroku doesn&amp;rsquo;t allow that restriction, so we need to pass &lt;code&gt;#f&lt;/code&gt; for the &lt;code&gt;#:listen-ip&lt;/code&gt; argument.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;getenv&lt;/span&gt; &lt;span class="s2"&gt;"PORT"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;string-&amp;gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;getenv&lt;/span&gt; &lt;span class="s2"&gt;"PORT"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serve/servlet&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
               &lt;span class="kd"&gt;#:servlet-path&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;
               &lt;span class="kd"&gt;#:listen-ip&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
               &lt;span class="kd"&gt;#:port&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Also, by default, &lt;code&gt;serve/servlet&lt;/code&gt; will open a web browser automatically when the program is run, which is very useful for rapid prototyping within something like DrRacket, but we&amp;rsquo;ll want to turn that off.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serve/servlet&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
               &lt;span class="kd"&gt;#:servlet-path&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;
               &lt;span class="kd"&gt;#:listen-ip&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
               &lt;span class="kd"&gt;#:port&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;
               &lt;span class="kd"&gt;#:command-line?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;That&amp;rsquo;s it! Now we have a Racket web server that can run on Heroku. Obviously it&amp;rsquo;s not a very interesting application right now, but that&amp;rsquo;s fine for our purposes.&lt;/p&gt;

&lt;h1 id="setting-up-our-app-for-heroku"&gt;Setting up our app for Heroku&lt;/h1&gt;

&lt;p&gt;The next step is to actually create an app on Heroku. Don&amp;rsquo;t worry—it&amp;rsquo;s free! That said, explaining precisely how Heroku works is outside the scope of this article. Just make an account, then create an app. I called mine &amp;ldquo;racket-heroku-sample&amp;rdquo;. Once you&amp;rsquo;ve created an app and set up Heroku&amp;rsquo;s command-line tool, you can specify the proper buildpack:&lt;/p&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git init
$ heroku git:remote -a racket-heroku-sample
$ heroku buildpacks:set https://github.com/lexi-lambda/heroku-buildpack-racket
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We&amp;rsquo;ll also need to pick a particular Racket version before we deploy our app. At the time of this writing, Racket 6.2.1 is the latest version, so I just set the &lt;code&gt;RACKET_VERSION&lt;/code&gt; environment variable as follows:&lt;/p&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ heroku config:set &lt;span class="nv"&gt;RACKET_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt;.2.1
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now there&amp;rsquo;s just one thing left to do before we can push to Heroku: we need to tell Heroku what command to use to run our application. To do this, we use something called a &amp;ldquo;Procfile&amp;rdquo; that contains information about the process types for our app. Heroku supports multiple processes of different types, but we&amp;rsquo;re just going to have a single web process.&lt;/p&gt;

&lt;p&gt;Specifically, we just want to run our &lt;code&gt;serve.rkt&lt;/code&gt; module. The Racket buildpack installs the repository as a package, so we can run &lt;code&gt;racket&lt;/code&gt; with the &lt;code&gt;-l&lt;/code&gt; flag to specify a module path, which will be more robust than specifying a filesystem path directly. Therefore, our Procfile will look like this:&lt;/p&gt;

&lt;div class="brush: procfile"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;web: racket -l sample-heroku-app/server
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now all that&amp;rsquo;s left to do is push our repository to Heroku&amp;rsquo;s git remote. Once the build completes, we can &lt;a href="https://racket-heroku-sample.herokuapp.com"&gt;navigate to our app&amp;rsquo;s URL and actually see it running live&lt;/a&gt;!&lt;/p&gt;

&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;That&amp;rsquo;s all that&amp;rsquo;s needed to get a Racket app up and running on Heroku, but it probably isn&amp;rsquo;t the best way to manage a real application. Usually it&amp;rsquo;s best to use a continuous integration service to automatically deploy certain GitHub branches to Heroku, after running the tests, of course. Also, a real application would obviously be a little more complicated.&lt;/p&gt;

&lt;p&gt;That said, this provides the foundation and shell. If you&amp;rsquo;d like to see the sample app used in this post, you can &lt;a href="https://github.com/lexi-lambda/racket-sample-heroku-app"&gt;find it on GitHub here&lt;/a&gt;. For more details on the buildpack itself, &lt;a href="https://github.com/lexi-lambda/heroku-buildpack-racket"&gt;it&amp;rsquo;s also available on GitHub here&lt;/a&gt;.&lt;/p&gt;</description></item></channel></rss>