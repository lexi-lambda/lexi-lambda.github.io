<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">Alexis King's Blog: Posts tagged 'functional programming'</title>
 <link rel="self" href="http://lexi-lambda.github.io/feeds/functional-programming.atom.xml" />
 <link href="http://lexi-lambda.github.io/tags/functional-programming.html" />
 <id>urn:http-lexi-lambda-github-io:-tags-functional-programming-html</id>
 <updated>2021-03-25T00:00:00Z</updated>
 <entry>
  <title type="text">An introduction to typeclass metaprogramming</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/?utm_source=functional-programming&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2021-03-25-an-introduction-to-typeclass-metaprogramming</id>
  <published>2021-03-25T00:00:00Z</published>
  <updated>2021-03-25T00:00:00Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;&lt;em&gt;Typeclass metaprogramming&lt;/em&gt; is a powerful technique available to Haskell programmers to automatically generate term-level code from static type information. It has been used to great effect in several popular Haskell libraries (such as the &lt;a href="https://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; ecosystem), and it is the core mechanism used to implement generic programming via &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Generics.html"&gt;GHC generics&lt;/a&gt;. Despite this, remarkably little material exists that explains the technique, relegating it to folk knowledge known only to advanced Haskell programmers.&lt;/p&gt;

&lt;p&gt;This blog post attempts to remedy that by providing an overview of the foundational concepts behind typeclass metaprogramming. It does &lt;em&gt;not&lt;/em&gt; attempt to be a complete guide to type-level programming in Haskell—such a task could easily fill a book—but it does provide explanations and illustrations of the most essential components. This is also &lt;em&gt;not&lt;/em&gt; a blog post for Haskell beginners—familiarity with the essentials of the Haskell type system and several common GHC extensions is assumed—but it does not assume any prior knowledge of type-level programming.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="part-1-basic-building-blocks"&gt;Part 1: Basic building blocks&lt;/h1&gt;

&lt;p&gt;Typeclass metaprogramming is a big subject, which makes covering it in a blog post tricky. To break it into more manageable chunks, this post is divided into several parts, each of which introduces new type system features or type-level programming techniques, then presents an example of how they can be applied.&lt;/p&gt;

&lt;p&gt;To start, we’ll cover the absolute foundations of typeclass metaprogramming.&lt;/p&gt;

&lt;h2 id="typeclasses-as-functions-from-types-to-terms"&gt;Typeclasses as functions from types to terms&lt;/h2&gt;

&lt;p&gt;As its name implies, typeclass metaprogramming (henceforth TMP&lt;sup&gt;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-1-definition" name="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;) centers around Haskell’s typeclass construct. Traditionally, typeclasses are viewed as a mechanism for principled operator overloading; for example, they underpin Haskell’s polymorphic &lt;code&gt;==&lt;/code&gt; operator via the &lt;code&gt;Eq&lt;/code&gt; class. Though that is often the most useful way to think about typeclasses, TMP encourages a different perspective: &lt;strong&gt;typeclasses are functions from types to (runtime) terms&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;What does that mean? Let’s illustrate with an example. Suppose we define a typeclass called &lt;code&gt;TypeOf&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The idea is that this typeclass will accept some value and return the name of its type as a string. To illustrate, here are a couple potential instances:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Bool"&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Char"&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"("&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;", "&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;")"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Given these instances, we can observe that they do what we expect in GHCi:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;"(Bool, Char)"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that both the &lt;code&gt;TypeOf Bool&lt;/code&gt; and &lt;code&gt;TypeOf Char&lt;/code&gt; instances ignore the argument to &lt;code&gt;typeOf&lt;/code&gt; altogether. This makes sense, as the whole point of the &lt;code&gt;TypeOf&lt;/code&gt; class is to get access to &lt;em&gt;type&lt;/em&gt; information, which is the same regardless of which value is provided. To make this more explicit, we can take advantage of some GHC extensions to eliminate the value-level argument altogether:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;{-# LANGUAGE AllowAmbiguousTypes, ScopedTypeVariables, TypeApplications #-}&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This typeclass definition is a little unusual, as the type parameter &lt;code&gt;a&lt;/code&gt; doesn’t appear anywhere in the body. To understand what it means, recall that the type of each method of a typeclass is implicitly extended with the typeclass’s constraint. For example, in the definition&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;the full type of the &lt;code&gt;show&lt;/code&gt; method is implicitly extended with a &lt;code&gt;Show a&lt;/code&gt; constraint to yield:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;show&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Furthermore, if we write &lt;code&gt;forall&lt;/code&gt;s explicitly, each typeclass method is also implicitly quantified over the class’s type parameters, which makes the following the &lt;em&gt;full&lt;/em&gt; type of &lt;code&gt;show&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;show&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In the same vein, we can write out the full type of &lt;code&gt;typeOf&lt;/code&gt;, as given by our new definition of &lt;code&gt;TypeOf&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This type is still unusual, as the &lt;code&gt;a&lt;/code&gt; type parameter doesn’t appear anywhere to the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow. This makes the type parameter trivially &lt;em&gt;ambiguous&lt;/em&gt;, which is to say it’s impossible for GHC to infer what &lt;code&gt;a&lt;/code&gt; should be at any call site. Fortunately, &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/type_applications.html"&gt;we can use &lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; to pass a type for &lt;code&gt;a&lt;/code&gt; directly, as we can see in the updated definition of &lt;code&gt;TypeOf (a, b)&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Bool"&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Char"&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"("&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;", "&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;")"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Once again, we can test out our new definitions in GHCi:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="s"&gt;"Bool"&lt;/span&gt;
&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;"(Bool, Char)"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This illustrates very succinctly how typeclasses can be seen as functions from types to terms. Our &lt;code&gt;typeOf&lt;/code&gt; function is, quite literally, a function that accepts a single type as an argument and returns a term-level &lt;code&gt;String&lt;/code&gt;. Of course, the &lt;code&gt;TypeOf&lt;/code&gt; typeclass is not a particularly &lt;em&gt;useful&lt;/em&gt; example of such a function, but it demonstrates how easy it is to construct.&lt;/p&gt;

&lt;h2 id="type-level-interpreters"&gt;Type-level interpreters&lt;/h2&gt;

&lt;p&gt;One important consequence of eliminating the value-level argument of &lt;code&gt;typeOf&lt;/code&gt; is that there is no need for its argument type to actually be &lt;em&gt;inhabited&lt;/em&gt;. For example, consider the &lt;code&gt;TypeOf&lt;/code&gt; instance on &lt;code&gt;Void&lt;/code&gt; from &lt;code&gt;Data.Void&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Void"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This above instance is no different from the ones on &lt;code&gt;Bool&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt; even though &lt;code&gt;Void&lt;/code&gt; is a completely uninhabited type. This is an important point: as we delve into type-level programming, it’s important to keep in mind that the language of types is mostly blind to the term-level meaning of those types. Although we usually write typeclasses that operate on values, this is not at all essential. This turns out to be quite important in practice, even in something as simple as the definition of &lt;code&gt;TypeOf&lt;/code&gt; on lists:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"["&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;"]"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If &lt;code&gt;typeOf&lt;/code&gt; required a value-level argument, not just a type, our instance above would be in a pickle when given the empty list, since it would have no value of type &lt;code&gt;a&lt;/code&gt; to recursively apply &lt;code&gt;typeOf&lt;/code&gt; to. But since &lt;code&gt;typeOf&lt;/code&gt; only accepts a type-level argument, the term-level meaning of the list type poses no obstacle.&lt;/p&gt;

&lt;p&gt;A perhaps unintuitive consequence of this property is that we can use typeclasses to write interesting functions on types even if none of the types are inhabited at all. For example, consider the following pair of type definitions:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It is impossible to construct any values of these types, but we can nevertheless use them to construct natural numbers at the type level:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;Z&lt;/code&gt; is a type that represents 0.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;S Z&lt;/code&gt; is a type that represents 1.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;S (S Z)&lt;/code&gt; is a type that represents 2.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;And so on. These types might not seem very useful, since they aren’t inhabited by any values, but remarkably, we can still use a typeclass to distinguish them and convert them to term-level values:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Numeric.Natural&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;As its name implies, &lt;code&gt;reifyNat&lt;/code&gt; reifies a type-level natural number encoded using our datatypes above into a term-level &lt;code&gt;Natural&lt;/code&gt; value:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="kt"&gt;Z&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;One way to think about &lt;code&gt;reifyNat&lt;/code&gt; is as an &lt;em&gt;interpreter&lt;/em&gt; of a type-level language. In this case, the type-level language is very simple, only capturing natural numbers, but in general, it could be arbitrarily complex—and typeclasses can be used to give it a useful meaning, even if it has no term-level representation.&lt;/p&gt;

&lt;h2 id="overlapping-instances"&gt;Overlapping instances&lt;/h2&gt;

&lt;p&gt;Generally, typeclass instances aren’t supposed to overlap. That is, if you write an instance for &lt;code&gt;Show (Maybe a)&lt;/code&gt;, you aren’t supposed to &lt;em&gt;also&lt;/em&gt; write an instance for &lt;code&gt;Show (Maybe Bool)&lt;/code&gt;, since it isn’t clear whether &lt;code&gt;show (Just True)&lt;/code&gt; should use the first instance or the second. For that reason, by default, GHC rejects any form of instance overlap as soon as it detects it.&lt;/p&gt;

&lt;p&gt;Usually, this is the right behavior. Due to the way Haskell’s typeclass system is designed to preserve coherency—that is, the same combination of type arguments always selects the same instance—overlapping instances can be unintuitive or even cause nonsensical behavior if orphan instances are defined. However, when doing TMP, it’s useful to make exceptions to that rule of thumb, so GHC provides the option to explicitly opt-in to overlapping instances.&lt;/p&gt;

&lt;p&gt;As a simple example, suppose we wanted to write a typeclass that checks whether a given type is &lt;code&gt;()&lt;/code&gt; or not:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If we were to write an ordinary, value-level function, we could write something like this pseudo-Haskell:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;-- not actually valid Haskell, just an example&lt;/span&gt;
&lt;span class="nf"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="nf"&gt;isUnit&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;
&lt;span class="nf"&gt;isUnit&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But if we try to translate this to typeclass instances, we’ll get a problem:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The problem is that a function definition has a closed set of clauses matched from top to bottom, but typeclass instances are open and unordered.&lt;sup&gt;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-2-definition" name="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; This means GHC will complain about instance overlap if we try to evaluate &lt;code&gt;isUnit @()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ghci&amp;gt; isUnit @()

error:
    • Overlapping instances for IsUnit ()
        arising from a use of ‘isUnit’
      Matching instances:
        instance IsUnit a
        instance IsUnit ()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, we have to explicitly mark &lt;code&gt;IsUnit ()&lt;/code&gt; as overlapping:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now GHC accepts the expression without complaint:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="kt"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;What does the &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; pragma do, exactly? The gory details are &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/instances.html#overlapping-instances"&gt;spelled out in the GHC User’s Guide&lt;/a&gt;, but the simple explanation is that &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; relaxes the overlap checker as long as the instance is &lt;em&gt;strictly more specific&lt;/em&gt; than the instance(s) it overlaps with. In this case, that is true: &lt;code&gt;IsUnit ()&lt;/code&gt; is trivially more specific than &lt;code&gt;IsUnit a&lt;/code&gt;, since the former only matches &lt;code&gt;()&lt;/code&gt; while the latter matches anything at all. That means our overlap is well-formed, and instance resolution should behave the way we’d like.&lt;/p&gt;

&lt;p&gt;Overlapping instances are a useful tool when performing TMP, as they make it possible to write piecewise functions on types in the same way it’s possible to write piecewise functions on terms. However, they must still be used with care, as without understanding how they work, they can produce unintuitive results. For an example of how things can go wrong, consider the following definition:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;guardUnit&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;guardUnit&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="s"&gt;"unit is not allowed"&lt;/span&gt;
  &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The intent of &lt;code&gt;guardUnit&lt;/code&gt; is to use &lt;code&gt;isUnit&lt;/code&gt; to detect if its argument is of type &lt;code&gt;()&lt;/code&gt;, and if it is, to return an error. However, even though we marked &lt;code&gt;IsUnit ()&lt;/code&gt; overlapping, we still get an overlapping instance error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error:
    • Overlapping instances for IsUnit a arising from a use of ‘isUnit’
      Matching instances:
        instance IsUnit a
        instance [overlapping] IsUnit ()
    • In the expression: isUnit @a&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What gives? The problem is that GHC simply doesn’t know what type &lt;code&gt;a&lt;/code&gt; is when compiling &lt;code&gt;guardUnit&lt;/code&gt;. It &lt;em&gt;could&lt;/em&gt; be instantiated to &lt;code&gt;()&lt;/code&gt; where it’s called, but it might not be. Therefore, GHC doesn’t know which instance to pick, and an overlapping instance error is still reported.&lt;/p&gt;

&lt;p&gt;This behavior is actually a very, very good thing. If GHC were to blindly pick the &lt;code&gt;IsUnit a&lt;/code&gt; instance in this case, then &lt;code&gt;guardUnit&lt;/code&gt; would always take the &lt;code&gt;False&lt;/code&gt; branch, even when passed a value of type &lt;code&gt;()&lt;/code&gt;! That would certainly not be what was intended, so it’s better to reject this program than to silently do the wrong thing. However, in more complicated situations, it can be quite surprising that GHC is complaining about instance overlap even when &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; annotations are used, so it’s important to keep their limitations in mind.&lt;/p&gt;

&lt;p&gt;As it happens, in this particular case, the error is easily remedied. We simply have to add an &lt;code&gt;IsUnit&lt;/code&gt; constraint to the type signature of &lt;code&gt;guardUnit&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;guardUnit&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;guardUnit&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="s"&gt;"unit is not allowed"&lt;/span&gt;
  &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now picking the right &lt;code&gt;IsUnit&lt;/code&gt; instance is deferred to the place where &lt;code&gt;guardUnit&lt;/code&gt; is used, and the definition is accepted.&lt;sup&gt;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-3-definition" name="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id="type-families-are-functions-from-types-to-types"&gt;Type families are functions from types to types&lt;/h2&gt;

&lt;p&gt;In the previous section, we discussed how typeclasses are functions from types to terms, but what about functions from types to types? For example, suppose we wanted to sum two type-level natural numbers and get a new type-level natural number as a result? For that, we can use a type family:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;{-# LANGUAGE TypeFamilies #-}&lt;/span&gt;

&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;     &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The above is a &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/type_families.html#closed-type-families"&gt;closed type family&lt;/a&gt;, which works quite a lot like an ordinary Haskell function definition, just at the type level instead of at the value level. For comparison, the equivalent value-level definition of &lt;code&gt;Sum&lt;/code&gt; would look like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt;

&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt;
&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;     &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;As you can see, the two are quite similar. Both are defined via a pair of pattern-matching clauses, and though it doesn’t matter here, both closed type families and ordinary functions evaluate their clauses top to bottom.&lt;/p&gt;

&lt;p&gt;To test our definition of &lt;code&gt;Sum&lt;/code&gt; in GHCi, we can use &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/ghci.html#ghci-cmd-:kind"&gt;the &lt;code&gt;:kind!&lt;/code&gt; command&lt;/a&gt;, which prints out a type and its kind after reducing it as much as possible:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kind&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We can also combine &lt;code&gt;Sum&lt;/code&gt; with our &lt;code&gt;ReifyNat&lt;/code&gt; class from earlier:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Type families are a useful complement to typeclasses when performing type-level programming. They allow computation to occur entirely at the type-level, which is necessarily computation that occurs entirely at compile-time, and the result can then be passed to a typeclass method to produce a term-level value from the result.&lt;/p&gt;

&lt;h2 id="example-1-generalized-concat"&gt;Example 1: Generalized &lt;code&gt;concat&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Finally, using what we’ve discussed so far, we can do our first bit of practical TMP. Specifically, we’re going to define a &lt;code&gt;flatten&lt;/code&gt; function similar to like-named functions provided by many dynamically-typed languages. In those languages, &lt;code&gt;flatten&lt;/code&gt; is like &lt;code&gt;concat&lt;/code&gt;, but it works on a list of arbitrary depth. For example, we might use it like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="p"&gt;[[[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]]]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In Haskell, lists of different depths have different types, so multiple levels of &lt;code&gt;concat&lt;/code&gt; have to be applied explicitly. But using TMP, we can write a generic &lt;code&gt;flatten&lt;/code&gt; function that operates on lists of any depth!&lt;/p&gt;

&lt;p&gt;Since this is &lt;em&gt;typeclass&lt;/em&gt; metaprogramming, we’ll unsurprisingly begin with a typeclass:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;???&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Our first challenge is writing the return type of &lt;code&gt;flatten&lt;/code&gt;. Since the argument could be a list of any depth, there’s no direct way to obtain its element type. Fortunately, we can define a type family that does precisely that:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we can write our &lt;code&gt;Flatten&lt;/code&gt; instances. The base case is when the type is a list of depth 1, in which case we don’t have any flattening to do:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The inductive case is when the type is a nested list, in which case we want to apply &lt;code&gt;concat&lt;/code&gt; and recur:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concat&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Sadly, if we try to compile these definitions, GHC will reject our &lt;code&gt;Flatten [a]&lt;/code&gt; instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error:
    • Couldn't match type ‘a’ with ‘ElementOf [a]’
      ‘a’ is a rigid type variable bound by
        the instance declaration
      Expected type: [ElementOf [a]]
        Actual type: [a]
    • In the expression: x
      In an equation for ‘flatten’: flatten x = x
      In the instance declaration for ‘Flatten [a]’
   |
   |   flatten x = x
   |               ^&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At first blush, this error looks very confusing. Why doesn’t GHC think &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;ElementOf [a]&lt;/code&gt; are the same type? Well, consider what would happen if we picked a type like &lt;code&gt;[Int]&lt;/code&gt; for &lt;code&gt;a&lt;/code&gt;. Then &lt;code&gt;[a]&lt;/code&gt; would be &lt;code&gt;[[Int]]&lt;/code&gt;, a nested list, so the first case of &lt;code&gt;ElementOf&lt;/code&gt; would apply. Therefore, GHC refuses to pick the second equation of &lt;code&gt;ElementOf&lt;/code&gt; so hastily.&lt;/p&gt;

&lt;p&gt;In this particular case, we might think that’s rather silly. After all, if &lt;code&gt;a&lt;/code&gt; were &lt;code&gt;[Int]&lt;/code&gt;, then GHC wouldn’t have picked the &lt;code&gt;Flatten [a]&lt;/code&gt; instance to begin with, it would pick the more specific &lt;code&gt;Flatten [[a]]&lt;/code&gt; instance defined below. Therefore, the hypothetical situation above could never happen. Unfortunately, GHC does not realize this, so we find ourselves at an impasse.&lt;/p&gt;

&lt;p&gt;Fortunately, we can soothe GHC’s anxiety by adding an extra constraint to our &lt;code&gt;Flatten [a]&lt;/code&gt; instance:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is a &lt;em&gt;type equality constraint&lt;/em&gt;. Type equality constraints are written with the syntax &lt;code&gt;a ~ b&lt;/code&gt;, and they state that &lt;code&gt;a&lt;/code&gt; must be the same type as &lt;code&gt;b&lt;/code&gt;. Type equality constraints are mostly useful when type families are involved, since they can be used (as in this case) to require a type family reduce to a certain type. In this case, we’re asserting that &lt;code&gt;ElementOf [a]&lt;/code&gt; must always be &lt;code&gt;a&lt;/code&gt;, which allows the instance to typecheck.&lt;/p&gt;

&lt;p&gt;Note that this doesn’t let us completely wriggle out of our obligation, as the type equality constraint must &lt;em&gt;eventually&lt;/em&gt; be checked when the instance is actually used, so initially this might seem like we’ve only deferred the problem to later. But in this case, that’s exactly what we need: by the time the &lt;code&gt;Flatten [a]&lt;/code&gt; instance is selected, GHC will know that &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a list type, and it will be able to reduce &lt;code&gt;ElementOf [a]&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; without difficulty. Indeed, we can see this for ourselves by using &lt;code&gt;flatten&lt;/code&gt; in GHCi:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="p"&gt;[[[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]]]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It works! But why do we need the type annotation on &lt;code&gt;1&lt;/code&gt;? If we leave it out, we get a rather hairy type error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error:
    • Couldn't match type ‘ElementOf [a0]’ with ‘ElementOf [a]’
      Expected type: [ElementOf [a]]
        Actual type: [ElementOf [a0]]
      NB: ‘ElementOf’ is a non-injective type family
      The type variable ‘a0’ is ambiguous&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The issue here stems from the polymorphic nature of Haskell number literals. Theoretically, someone could define a &lt;code&gt;Num [a]&lt;/code&gt; instance, in which case &lt;code&gt;1&lt;/code&gt; could actually have a list type, and either case of &lt;code&gt;ElementOf&lt;/code&gt; could match depending on the choice of &lt;code&gt;Num&lt;/code&gt; instance. Of course, no such &lt;code&gt;Num&lt;/code&gt; instance exists, nor should it, but the possibility of it being defined means GHC can’t be certain of the depth of the argument list.&lt;/p&gt;

&lt;p&gt;This issue happens to come up a lot in simple examples of TMP, since polymorphic number literals introduce a level of ambiguity. In real programs, this is much less of an issue, since there’s no reason to call &lt;code&gt;flatten&lt;/code&gt; on a completely hardcoded list! However, it’s still important to understand what these type errors mean and why they occur.&lt;/p&gt;

&lt;p&gt;That wrinkle aside, &lt;code&gt;flatten&lt;/code&gt; is a functioning example of what useful TMP can look like. We’ve written a single, generic definition that flattens lists of any depth, taking advantage of static type information to choose what to do at runtime.&lt;/p&gt;

&lt;h3 id="typeclasses-as-compile-time-code-generation"&gt;Typeclasses as compile-time code generation&lt;/h3&gt;

&lt;p&gt;Presented with the above definition of &lt;code&gt;Flatten&lt;/code&gt;, it might not be immediately obvious how to think about &lt;code&gt;Flatten&lt;/code&gt; as a function from types to terms. After all, it looks a lot more like an “ordinary” typeclass (like, say, &lt;code&gt;Eq&lt;/code&gt; or &lt;code&gt;Show&lt;/code&gt;) than the &lt;code&gt;TypeOf&lt;/code&gt; and &lt;code&gt;ReifyNat&lt;/code&gt; classes we defined above.&lt;/p&gt;

&lt;p&gt;One useful way to shift our perspective is to consider equivalent &lt;code&gt;Flatten&lt;/code&gt; instances written using point-free style:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;concat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;These definitions of &lt;code&gt;flatten&lt;/code&gt; no longer (syntactically) depend on term-level arguments, just like our definitions of &lt;code&gt;typeOf&lt;/code&gt; and &lt;code&gt;reifyNat&lt;/code&gt; didn’t accept any term-level arguments above. This allows us to consider what &lt;code&gt;flatten&lt;/code&gt; might “expand to” given a type argument alone:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;flatten @[Int]&lt;/code&gt; is just &lt;code&gt;id&lt;/code&gt;, since the &lt;code&gt;Flatten [a]&lt;/code&gt; instance is selected.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;flatten @[[Int]]&lt;/code&gt; is &lt;code&gt;flatten @[Int] . concat&lt;/code&gt;, since the &lt;code&gt;Flatten [[a]]&lt;/code&gt; instance is selected. That then becomes &lt;code&gt;id . concat&lt;/code&gt;, which can be further simplified to just &lt;code&gt;concat&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;flatten @[[[Int]]]&lt;/code&gt; is &lt;code&gt;flatten @[[Int]] . concat&lt;/code&gt;, which simplifies to &lt;code&gt;concat . concat&lt;/code&gt; by the same reasoning above.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;flatten @[[[[Int]]]]&lt;/code&gt; is then &lt;code&gt;concat . concat . concat&lt;/code&gt;, and so on.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This meshes quite naturally with our intuition of typeclasses as functions from types to terms. Each application of &lt;code&gt;flatten&lt;/code&gt; takes a type as an argument and produces some number of composed &lt;code&gt;concat&lt;/code&gt;s as a result. From this perspective, &lt;code&gt;Flatten&lt;/code&gt; is performing a kind of compile-time code generation, synthesizing an expression to do the concatenation on the fly by inspecting the type information.&lt;/p&gt;

&lt;p&gt;This framing is one of the key ideas that makes TMP so powerful, and indeed, it explains how it’s worthy of the name &lt;em&gt;metaprogramming&lt;/em&gt;. As we continue to more sophisticated examples of TMP, try to keep this perspective in mind.&lt;/p&gt;

&lt;h1 id="part-2-generic-programming"&gt;Part 2: Generic programming&lt;/h1&gt;

&lt;p&gt;Part 1 of this blog post established the foundational techniques used in TMP, all of which are useful on their own. If you’ve read up to this point, you now know enough to start applying TMP yourself, and the remainder of this blog post will simply continue to build upon what you already know.&lt;/p&gt;

&lt;p&gt;In the previous section, we discussed how to use TMP to write a generic &lt;code&gt;flatten&lt;/code&gt; operation. In this section, we’ll aim a bit higher: totally generic functions that operate on &lt;em&gt;arbitrary&lt;/em&gt; datatypes.&lt;/p&gt;

&lt;h2 id="open-type-families-and-associated-types"&gt;Open type families and associated types&lt;/h2&gt;

&lt;p&gt;Before we can dive into examples, we need to revisit type families. In the previous sections, we discussed closed type families, but we did not cover their counterpart, &lt;em&gt;open type families&lt;/em&gt;. Like closed type families, open type families are effectively functions from types to types, but unlike closed type families, they are not defined with a predefined set of equations. Instead, new equations are added separately using &lt;code&gt;type instance&lt;/code&gt; declarations. For example, we could define our &lt;code&gt;Sum&lt;/code&gt; family from above like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In the case of &lt;code&gt;Sum&lt;/code&gt;, this would not be very useful, and indeed, &lt;code&gt;Sum&lt;/code&gt; is much better expressed as a closed type family than an open one. But the advantage of open type families is similar to the advantage of typeclasses: new equations can be added at any time, even in modules other than the one that declares the open type family.&lt;/p&gt;

&lt;p&gt;This extensibility means open type families are used less for type-level computation and more for type-level maps that associate types with other types. For example, one might define a &lt;code&gt;Key&lt;/code&gt; open type family that relates types to the types used to index them:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ByteString&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This can be combined with a typeclass to provide a generic way to see if a data structure contains a given key:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this case, anyone could define their own data structure, define instances of &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;HasKey&lt;/code&gt; for their data structure, and use &lt;code&gt;hasKey&lt;/code&gt; to see if it contains a given key, regardless of the structure of those keys. In fact, it’s so common for open type families and typeclasses to cooperate in this way that GHC provides the option to make the connection explicit by defining them together:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ByteString&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;An open family declared inside a typeclass like this is called an &lt;em&gt;associated type&lt;/em&gt;. It works exactly the same way as the separate definitions of &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;HasKey&lt;/code&gt;, it just uses a different syntax. Note that although the &lt;code&gt;family&lt;/code&gt; and &lt;code&gt;instance&lt;/code&gt; keywords have disappeared from the declarations, that is only an abbreviation; the keywords are simply implicitly added (and explicitly writing them is still allowed, though most people do not).&lt;/p&gt;

&lt;p&gt;Open type families and associated types are extremely useful for abstracting over similar types with slightly different structure, and libraries like &lt;a href="https://hackage.haskell.org/package/mono-traversable"&gt;&lt;code&gt;mono-traversable&lt;/code&gt;&lt;/a&gt; are examples of how they can be used to that end for their full effect. However, those use cases can’t really be classified as TMP, just using typeclasses for their traditional purpose of operation overloading.&lt;/p&gt;

&lt;p&gt;However, that doesn’t mean open type families aren’t useful for TMP. In fact, one use case of TMP makes &lt;em&gt;heavy&lt;/em&gt; use of open type families: datatype-generic programming.&lt;/p&gt;

&lt;h2 id="example-2-datatype-generic-programming"&gt;Example 2: Datatype-generic programming&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Datatype-generic programming&lt;/em&gt; refers to a class of techniques for writing generic functions that operate on arbitrary data structures. Some useful applications of datatype-generic programming include&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;equality, comparison, and hashing,&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;recursive traversal of self-similar data structures, and&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;serialization and deserialization,&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;among other things. The idea is that by exploiting the structure of datatype definitions themselves, it’s possible for a datatype-generic function to provide implementations of functionality like the above on &lt;em&gt;any&lt;/em&gt; datatype.&lt;/p&gt;

&lt;p&gt;In Haskell, the most popular approach to datatype-generic programming leverages GHC generics, which is quite sophisticated. The &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Generics.html"&gt;module documentation for &lt;code&gt;GHC.Generics&lt;/code&gt;&lt;/a&gt; already includes a fairly lengthy explanation of how it works, so I will not regurgitate it here (that could fill a blog post of its own!), but I will show how to construct a simplified version of the system that highlights the key role of TMP.&lt;/p&gt;

&lt;h3 id="generic-datatype-representations"&gt;Generic datatype representations&lt;/h3&gt;

&lt;p&gt;At the heart of the &lt;code&gt;Generic&lt;/code&gt; class is a simple concept: all non-GADT Haskell datatypes can be represented as sums of products. For example, if we have&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt;
  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;AuthBasic&lt;/span&gt; &lt;span class="kt"&gt;Username&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;AuthSSH&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;then we have a type that is essentially equivalent to this one:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If we know how to define a function on a nested tree built out of &lt;code&gt;Either&lt;/code&gt;s and pairs, then we know how to define it on &lt;em&gt;any&lt;/em&gt; such datatype! This is where TMP comes in: recall the way we viewed &lt;code&gt;Flatten&lt;/code&gt; as a mechanism for compile-time code generation based on type information. Could we use the same technique to generate implementations of equality, comparison, hashing, etc. from statically-known information about the structure of a datatype?&lt;/p&gt;

&lt;p&gt;The answer to that question is &lt;em&gt;yes&lt;/em&gt;. To start, let’s consider a particularly simple example: suppose we want to write a generic function that counts the number of fields stored in an arbitrary constructor. For example, &lt;code&gt;numFields (AuthBasic "alyssa" "pass1234")&lt;/code&gt; would return &lt;code&gt;2&lt;/code&gt;, while &lt;code&gt;numFields (AuthSSH "&amp;lt;key&amp;gt;")&lt;/code&gt; would return &lt;code&gt;1&lt;/code&gt;. Not a very useful function, admittedly, but it’s a simple example of what generic programming can do.&lt;/p&gt;

&lt;p&gt;We’ll start by using TMP to implement a “generic” version of &lt;code&gt;numFields&lt;/code&gt; that operates on trees of &lt;code&gt;Either&lt;/code&gt;s and pairs as described above:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;

&lt;span class="c1"&gt;-- base case: leaf value&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Just like our &lt;code&gt;Flatten&lt;/code&gt; class from earlier, &lt;code&gt;GNumFields&lt;/code&gt; uses the type-level structure of its argument to choose what to do:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;If we find a pair, that corresponds to a product, so we recur into both sides and sum the results.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If we find &lt;code&gt;Left&lt;/code&gt; or &lt;code&gt;Right&lt;/code&gt;, that corresponds to the “spine” differentiating different constructors, so we simply recur into the contained value.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In the case of any other value, we’re at a “leaf” in the tree of &lt;code&gt;Either&lt;/code&gt;s and pairs, which corresponds to a single field, so we just return &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Now if we call &lt;code&gt;gnumFields (Left ("alyssa", "pass1234"))&lt;/code&gt;, we’ll get &lt;code&gt;2&lt;/code&gt;, and if we call &lt;code&gt;gnumFields (Right "&amp;lt;key&amp;gt;")&lt;/code&gt;, we’ll get &lt;code&gt;1&lt;/code&gt;. All that’s left to do is write a bit of code that converts our &lt;code&gt;Authentication&lt;/code&gt; type to a tree of &lt;code&gt;Either&lt;/code&gt;s and pairs:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;genericizeAuthentication&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;
&lt;span class="nf"&gt;genericizeAuthentication&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthBasic&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;genericizeAuthentication&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthSSH&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;

&lt;span class="nf"&gt;numFieldsAuthentication&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;
&lt;span class="nf"&gt;numFieldsAuthentication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;genericizeAuthentication&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we get the results we want on our &lt;code&gt;Authentication&lt;/code&gt; type using &lt;code&gt;numFieldsAuthentication&lt;/code&gt;, but we’re not done yet, since it only works on &lt;code&gt;Authentication&lt;/code&gt; values. Is there a way to define a generic &lt;code&gt;numFields&lt;/code&gt; function that works on arbitrary datatypes that implement this conversion to sums-of-products? Yes, with another typeclass:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthBasic&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthSSH&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;

&lt;span class="nf"&gt;numFields&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;
&lt;span class="nf"&gt;numFields&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;genericize&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now &lt;code&gt;numFields (AuthBasic "alyssa" "pass1234")&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;, as desired, and it will &lt;em&gt;also&lt;/em&gt; work with any datatype that provides a &lt;code&gt;Generic&lt;/code&gt; instance. If the above code makes your head spin, don’t worry: this is by far the most complicated piece of code in this blog post up to this point. Let’s break down how it works piece by piece:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;First, we define the &lt;code&gt;Generic&lt;/code&gt; class, comprised of two parts:&lt;/p&gt;
  &lt;ol&gt;
   &lt;li&gt;
    &lt;p&gt;The &lt;code&gt;Rep a&lt;/code&gt; associated type maps a type &lt;code&gt;a&lt;/code&gt; onto its generic, sums-of-products representation, i.e. one built out of combinations of &lt;code&gt;Either&lt;/code&gt; and pairs.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;The &lt;code&gt;genericize&lt;/code&gt; method converts an actual &lt;em&gt;value&lt;/em&gt; of type &lt;code&gt;a&lt;/code&gt; to the equivalent value using the sums-of-products representation.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Next, we define a &lt;code&gt;Generic&lt;/code&gt; instance for &lt;code&gt;Authentication&lt;/code&gt;. &lt;code&gt;Rep Authentication&lt;/code&gt; is the sums-of-products representation we described above, and &lt;code&gt;genericize&lt;/code&gt; is likewise &lt;code&gt;genericizeAuthentication&lt;/code&gt; from above.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, we define &lt;code&gt;numFields&lt;/code&gt; as a function with a &lt;code&gt;GNumFields (Rep a)&lt;/code&gt; constraint. This is where all the magic happens:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;When we apply &lt;code&gt;numFields&lt;/code&gt; to a datatype, &lt;code&gt;Rep&lt;/code&gt; retrieves its generic, sums-of-products representation type.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;The &lt;code&gt;GNumFields&lt;/code&gt; class then uses various TMP techniques we’ve already described so far in this blog post to generate a &lt;code&gt;numFields&lt;/code&gt; implementation on the fly from the structure of &lt;code&gt;Rep a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;Finally, that generated &lt;code&gt;numFields&lt;/code&gt; implementation is applied to the genericized term-level value, and the result is produced.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;After all that, I suspect you might think this seems like a very convoluted way to define the (rather unhelpful) &lt;code&gt;numFields&lt;/code&gt; operation. Surely just defining &lt;code&gt;numFields&lt;/code&gt; on each type directly would be far easier? Indeed, if we were just considering &lt;code&gt;numFields&lt;/code&gt;, you’d be right, but in fact we get much more than that. Using the same machinery, we can continue to define other generic operations—equality, comparison, etc.—the same way we defined &lt;code&gt;numFields&lt;/code&gt;, and all of them would automatically work on &lt;code&gt;Authentication&lt;/code&gt; because they all leverage the same &lt;code&gt;Generic&lt;/code&gt; instance!&lt;/p&gt;

&lt;p&gt;This is the basic value proposition of generic programming: we can do a little work up front to normalize our datatype to a generic representation &lt;em&gt;once&lt;/em&gt;, then get a whole buffet of generic operations on it for free. In Haskell, the code generation capabilities of TMP is a key piece of that puzzle.&lt;/p&gt;

&lt;h3 id="improving-our-definition-of-generic"&gt;Improving our definition of &lt;code&gt;Generic&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;You may note that the definition of &lt;code&gt;Generic&lt;/code&gt; provided above does not match the one in &lt;code&gt;GHC.Generic&lt;/code&gt;. Indeed, our naïve approach suffers from several flaws that the real version does not. This is not a &lt;code&gt;GHC.Generics&lt;/code&gt; tutorial, so I will not discuss every detail of the full implementation, but I will highlight a few improvements relevant to the broader theme of TMP.&lt;/p&gt;

&lt;h4 id="distinguishing-leaves-from-the-spine"&gt;Distinguishing leaves from the spine&lt;/h4&gt;

&lt;p&gt;One problem with our version of &lt;code&gt;Generic&lt;/code&gt; is that it provides no way to distinguish an &lt;code&gt;Either&lt;/code&gt; or pair that should be considered a “leaf”, as in a type like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;A&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;B&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Given this type, &lt;code&gt;Rep Foo&lt;/code&gt; should be &lt;code&gt;Either (Either Int String) (Char, Bool)&lt;/code&gt;, and &lt;code&gt;numFields (Right ('a', True))&lt;/code&gt; will erroneously return &lt;code&gt;2&lt;/code&gt; rather than &lt;code&gt;1&lt;/code&gt;. To fix this, we can introduce a simple wrapper newtype that distinguishes leaves specifically:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;getLeaf&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now our &lt;code&gt;Generic&lt;/code&gt; instances look like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="kt"&gt;Username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthBasic&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthSSH&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;A&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;B&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Since the &lt;code&gt;Leaf&lt;/code&gt; constructor now distinguishes a leaf, rather than the absence of an &lt;code&gt;Either&lt;/code&gt; or &lt;code&gt;(,)&lt;/code&gt; constructor, we’ll have to update our &lt;code&gt;GNumFields&lt;/code&gt; instances as well. However, this has the additional pleasant effect of eliminating the need for overlapping instances:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;  
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is a good example of why overlapping instances can be so seductive, but they often have unintended consequences. Even when doing TMP, explicit tags are almost always preferable.&lt;/p&gt;

&lt;h4 id="handling-empty-constructors"&gt;Handling empty constructors&lt;/h4&gt;

&lt;p&gt;Suppose we have a type with nullary data constructors, like the standard &lt;code&gt;Bool&lt;/code&gt; type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;How do we write a &lt;code&gt;Generic&lt;/code&gt; instance for &lt;code&gt;Bool&lt;/code&gt;? Using just &lt;code&gt;Either&lt;/code&gt;, &lt;code&gt;(,)&lt;/code&gt;, and &lt;code&gt;Leaf&lt;/code&gt;, we can’t, but if we are willing to add a case for &lt;code&gt;()&lt;/code&gt;, we can use it to denote nullary constructors:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In a similar vein, we could use &lt;code&gt;Void&lt;/code&gt; to represent datatypes that don’t have any constructors at all.&lt;/p&gt;

&lt;h3 id="continuing-from-here"&gt;Continuing from here&lt;/h3&gt;

&lt;p&gt;The full version of &lt;code&gt;Generic&lt;/code&gt; has a variety of further improvements useful for generic programming, including:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Support for converting from &lt;code&gt;Rep a&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Special indication of self-recursive datatypes, making generic tree traversals possible.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Type-level information about datatype constructor and record accessor names, allowing them to be used in serialization.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Fully automatic generation of &lt;code&gt;Generic&lt;/code&gt; instances via &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/generics.html#extension-DeriveGeneric"&gt;the &lt;code&gt;DeriveGeneric&lt;/code&gt; extension&lt;/a&gt;, which reduces the per-type boilerplate to essentially nothing.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Generics.html"&gt;module documentation for &lt;code&gt;GHC.Generics&lt;/code&gt;&lt;/a&gt; discusses the full system in detail, and it provides an additional example that uses the same essential TMP techniques discussed here.&lt;/p&gt;

&lt;h1 id="part-3-dependent-typing"&gt;Part 3: Dependent typing&lt;/h1&gt;

&lt;p&gt;It’s time for the third and final part of this blog post: an introduction to dependently typed programming in Haskell. A full treatment of dependently typed programming is far, far too vast to be contained in a single blog post, so I will not attempt to do so here. Rather, I will cover some basic idioms for doing dependent programming and highlight how TMP can be valuable when doing so.&lt;/p&gt;

&lt;h2 id="datatype-promotion"&gt;Datatype promotion&lt;/h2&gt;

&lt;p&gt;In part 1, we used uninhabited datatypes like &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;S a&lt;/code&gt; to define new type-level constants. This works, but it is awkward. Imagine for a moment that we wanted to work with type-level booleans. Using our previous approach, we could define two empty datatypes, &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we could define type families to provide operations on these types, such as &lt;code&gt;Not&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
  &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, this has some frustrating downsides:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;First, it’s simply inconvenient that we have to define these new &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; “dummy” types, which are completely distinct from the &lt;code&gt;Bool&lt;/code&gt; type provided by the prelude.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;More significantly, it means &lt;code&gt;Not&lt;/code&gt; has a very unhelpful kind:&lt;/p&gt;
  &lt;div class="brush: haskell"&gt;
   &lt;div class="source"&gt;
    &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kind&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt;
&lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
  &lt;p&gt;Even though &lt;code&gt;Not&lt;/code&gt; is only &lt;em&gt;supposed&lt;/em&gt; to be applied to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;, its kind allows it to be applied to any type at all. You can see this in practice if you try to evaluate something like &lt;code&gt;Not Char&lt;/code&gt;:&lt;/p&gt;
  &lt;div class="brush: haskell"&gt;
   &lt;div class="source"&gt;
    &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kind&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;
&lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
  &lt;p&gt;Rather than getting an error, GHC simply spits &lt;code&gt;Not Char&lt;/code&gt; back at us. This is a somewhat unintuitive property of closed type families: if none of the clauses match, the type family just gets “stuck,” not reducing any further. This can lead to very confusing type errors later in the typechecking process.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;One way to think about &lt;code&gt;Not&lt;/code&gt; is that it is largely &lt;em&gt;dynamically kinded&lt;/em&gt; in the same way some languages are dynamically typed. That isn’t entirely true, as we technically &lt;em&gt;will&lt;/em&gt; get a kind error if we try to apply &lt;code&gt;Not&lt;/code&gt; to a type constructor rather than a type, such as &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ghci&amp;gt; :kind! Not Maybe

&amp;lt;interactive&amp;gt;:1:5: error:
    • Expecting one more argument to ‘Maybe’
      Expected a type, but ‘Maybe’ has kind ‘* -&amp;gt; *’&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…but &lt;code&gt;*&lt;/code&gt; is still a very big kind, much bigger than we would like to permit for &lt;code&gt;Not&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To help with both these problems, GHC provides &lt;em&gt;datatype promotion&lt;/em&gt; via &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/data_kinds.html"&gt;the &lt;code&gt;DataKinds&lt;/code&gt; language extension&lt;/a&gt;. The idea is that for each normal, non-GADT type definition like&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;then in addition to the normal type constructor and value constructors, GHC also defines several &lt;em&gt;promoted&lt;/em&gt; constructors:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;Bool&lt;/code&gt; is allowed as both a type and a kind.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;'True&lt;/code&gt; and &lt;code&gt;'False&lt;/code&gt; are defined as new types of kind &lt;code&gt;Bool&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;We can see this in action if we remove our &lt;code&gt;data True&lt;/code&gt; and &lt;code&gt;data False&lt;/code&gt; declarations and adjust our definition of &lt;code&gt;Not&lt;/code&gt; to use promoted constructors:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;{-# LANGUAGE DataKinds #-}&lt;/span&gt;

&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;True&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;False&lt;/span&gt;
  &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;False&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now the inferred kind of &lt;code&gt;Not&lt;/code&gt; is no longer &lt;code&gt;* -&amp;gt; *&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kind&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt;
&lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Consequently, we will now get a kind error if we attempt to apply &lt;code&gt;Not&lt;/code&gt; to anything other than &lt;code&gt;'True&lt;/code&gt; or &lt;code&gt;'False&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ghci&amp;gt; :kind! Not Char

&amp;lt;interactive&amp;gt;:1:5: error:
    • Expected kind ‘Bool’, but ‘Char’ has kind ‘*’&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a nice improvement. We can make a similar change to our definitions involving type-level natural numbers:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Z&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;&amp;#39;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that we need to add an explicit kind signature on the definition of the &lt;code&gt;ReifyNat&lt;/code&gt; typeclass, since otherwise GHC will assume &lt;code&gt;a&lt;/code&gt; has kind &lt;code&gt;*&lt;/code&gt;, since nothing in the types of the typeclass methods suggests otherwise. In addition to making it clearer that &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt; are related, this prevents someone from coming along and defining a nonsensical instance like &lt;code&gt;ReifyNat Char&lt;/code&gt;, which previously would have been allowed but will now be rejected with a kind error.&lt;/p&gt;

&lt;p&gt;Datatype promotion is not strictly required to do TMP, but makes the process significantly less painful. It makes Haskell’s kind language extensible in the same way its type language is, which allows type-level programming to enjoy static typechecking (or more accurately, static kindchecking) in the same way term-level programming does.&lt;/p&gt;

&lt;h2 id="gadts-and-proof-terms"&gt;GADTs and proof terms&lt;/h2&gt;

&lt;p&gt;So far in this blog post, we have discussed several different function-like things:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Ordinary Haskell functions are functions from terms to terms.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Type families are functions from types to types.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Typeclasses are functions from types to terms.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;A curious reader may wonder about the existence of a fourth class of function:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;em&gt;???&lt;/em&gt; are functions from terms to types.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;To reason about what could go in the &lt;em&gt;???&lt;/em&gt; above, we must consider what “a function from terms to types” would even mean. Functions from terms to terms and types to types are straightforward enough. Functions from types to terms are a little trickier, but they make intuitive sense: we use information known at compile-time to generate runtime behavior. But how could information possibly flow in the other direction? How could we possibly turn runtime information into compile-time information without being able to predict the future?&lt;/p&gt;

&lt;p&gt;In general, we cannot. However, one feature of Haskell allows a restricted form of seemingly doing the impossible—turning runtime information into compile-time information—and that’s GADTs.&lt;/p&gt;

&lt;p&gt;GADTs&lt;sup&gt;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-4-definition" name="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-4-return"&gt;4&lt;/a&gt;&lt;/sup&gt; are &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/gadt.html"&gt;described in detail in the GHC User’s Guide&lt;/a&gt;, but the key idea for our purposes is that &lt;em&gt;pattern-matching on a GADT constructor can refine type information&lt;/em&gt;. Here’s a simple, silly example:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;ABool&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
  &lt;span class="kt"&gt;AnInt&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;

&lt;span class="nf"&gt;doSomething&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;doSomething&lt;/span&gt; &lt;span class="kt"&gt;ABool&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;doSomething&lt;/span&gt; &lt;span class="kt"&gt;AnInt&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;WhatIsIt&lt;/code&gt; is a datatype with two nullary constructors, &lt;code&gt;ABool&lt;/code&gt; and &lt;code&gt;AnInt&lt;/code&gt;, similar to a normal, non-GADT datatype like this one:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ABool&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;AnInt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;What’s special about GADTs is that each constructor is given an explicit type signature. With the plain ADT definition above, &lt;code&gt;ABool&lt;/code&gt; and &lt;code&gt;AnInt&lt;/code&gt; would both have the type &lt;code&gt;forall a. WhatIsIt a&lt;/code&gt;, but in the GADT definition, we explicitly fix &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;Bool&lt;/code&gt; in the type of &lt;code&gt;ABool&lt;/code&gt; and to &lt;code&gt;Int&lt;/code&gt; in the type of &lt;code&gt;AnInt&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This simple feature allows us to do very interesting things. The &lt;code&gt;doSomething&lt;/code&gt; function is polymorphic in &lt;code&gt;a&lt;/code&gt;, but on the right-hand side of the first equation, &lt;code&gt;x&lt;/code&gt; has type &lt;code&gt;Bool&lt;/code&gt;, while on the right-hand side of the second equation, &lt;code&gt;x&lt;/code&gt; has type &lt;code&gt;Int&lt;/code&gt;. This is because the &lt;code&gt;WhatIsIt a&lt;/code&gt; argument effectively constrains the type of &lt;code&gt;a&lt;/code&gt;, as we can see by experimenting with &lt;code&gt;doSomething&lt;/code&gt; in GHCi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ghci&amp;gt; doSomething ABool True
False
ghci&amp;gt; doSomething AnInt 10
11
ghci&amp;gt; doSomething AnInt True

error:
    • Couldn't match expected type ‘Int’ with actual type ‘Bool’
    • In the second argument of ‘doSomething’, namely ‘True’
      In the expression: doSomething AnInt True
      In an equation for ‘it’: it = doSomething AnInt True&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One way to think about GADTs is as “proofs” or “witnesses” of type equalities. The &lt;code&gt;ABool&lt;/code&gt; constructor is a proof of &lt;code&gt;a ~ Bool&lt;/code&gt;, while the &lt;code&gt;AnInt&lt;/code&gt; constructor is a proof of &lt;code&gt;a ~ Int&lt;/code&gt;. When you construct &lt;code&gt;ABool&lt;/code&gt; or &lt;code&gt;AnInt&lt;/code&gt;, you must be able to satisfy the equality, and it is in a sense “packed into” the constructor value. When code pattern-matches on the constructor, the equality is “unpacked from” the value, and the equality becomes available on the right-hand side of the pattern match.&lt;/p&gt;

&lt;p&gt;GADTs can be much more sophisticated than our simple &lt;code&gt;WhatIsIt&lt;/code&gt; type above. Just like normal ADTs, GADT constructors can have parameters, which makes it possible to write inductive datatypes that carry type equality proofs with them:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;infixr&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;

&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;HNil&lt;/span&gt;  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;
  &lt;span class="kt"&gt;HCons&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This type is a &lt;em&gt;heterogenous list&lt;/em&gt;, a list that can contain elements of different types:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
&lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Num&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[Bool, [Char]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;An &lt;code&gt;HList&lt;/code&gt; is parameterized by a type-level list that keeps track of the types of its elements, which allows us to highlight another interesting property of GADTs: if we restrict that type information, the GHC pattern exhaustiveness checker will take the restriction into account. For example, we can write a completely total &lt;code&gt;head&lt;/code&gt; function on &lt;code&gt;HList&lt;/code&gt;s like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) -&amp;gt; a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Remarkably, GHC does not complain that this definition of &lt;code&gt;head&lt;/code&gt; is non-exhaustive. Since we specified that the argument must be of type &lt;code&gt;HList (a ': as)&lt;/code&gt; in the type signature for &lt;code&gt;head&lt;/code&gt;, GHC knows that the argument &lt;em&gt;cannot&lt;/em&gt; be &lt;code&gt;HNil&lt;/code&gt; (which would have the type &lt;code&gt;HList '[]&lt;/code&gt;), so it doesn’t ask us to handle that case.&lt;/p&gt;

&lt;p&gt;These examples illustrate the way GADTs serve as a general-purpose construct for relating type- and term-level information. Information flows bidirectionally: type information refines the set of type constructors that can be matched on, and matching on type constructors exposes new type equalities.&lt;/p&gt;

&lt;h3 id="proofs-that-work-together"&gt;Proofs that work together&lt;/h3&gt;

&lt;p&gt;This interplay is wonderfully compositional. Suppose we wanted to write a function that accepts an &lt;code&gt;HList&lt;/code&gt; of exactly 1, 2, or 3 elements. There’s no easy way to express that in the type signature the way we did with &lt;code&gt;head&lt;/code&gt;, so it might seem like all we can do is write an entirely new container datatype that has three constructors, one for each case.&lt;/p&gt;

&lt;p&gt;However, a more interesting solution exists that takes advantage of the bidirectional nature of GADTs. We can start by writing a &lt;em&gt;proof term&lt;/em&gt; that contains no values, it just encapsulates type equalities on a type-level list:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;One&lt;/span&gt;   &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[a]&lt;/span&gt;
  &lt;span class="kt"&gt;Two&lt;/span&gt;   &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[a, b]&lt;/span&gt;
  &lt;span class="kt"&gt;Three&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[a, b, c]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We call it a proof term because a value of type &lt;code&gt;OneToThree a b c as&lt;/code&gt; constitutes a &lt;em&gt;proof&lt;/em&gt; that &lt;code&gt;as&lt;/code&gt; has exactly 1, 2, or 3 elements. Using &lt;code&gt;OneToThree&lt;/code&gt;, we can write a function that accepts an &lt;code&gt;HList&lt;/code&gt; accompanied by a proof term:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;sumUpToThree&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="nf"&gt;sumUpToThree&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;sumUpToThree&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;           &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="nf"&gt;sumUpToThree&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;As with &lt;code&gt;head&lt;/code&gt;, this function is completely exhaustive, in this case because we take full advantage of the bidirectional nature of GADTs:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;When we match on the &lt;code&gt;OneToThree&lt;/code&gt; proof term, information flows from the term level to the type level, refining the type of &lt;code&gt;as&lt;/code&gt; in that branch.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The refined type of &lt;code&gt;as&lt;/code&gt; then flows back down to the term level, restricting the shape the &lt;code&gt;HList&lt;/code&gt; can take and refinine the set of patterns we have to match.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Of course, this example is not especially useful, but in general proof terms can encode any number of useful properties. For example, we can write a proof term that ensures an &lt;code&gt;HList&lt;/code&gt; has an even number of elements:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;EvenNil&lt;/span&gt;  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;
  &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is a proof which itself has inductive structure: &lt;code&gt;EvenCons&lt;/code&gt; takes a proof that &lt;code&gt;as&lt;/code&gt; has an even number of elements and produces a proof that adding two more elements preserves the evenness. We can combine this with a type family to write a function that “pairs up” elements in an &lt;code&gt;HList&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;            &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;
  &lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: PairUp as&lt;/span&gt;

&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;         &lt;span class="kt"&gt;HNil&lt;/span&gt;                     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;pairUp&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Once again, this definition is completely exhaustive, and we can show that it works in GHCi:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This ability to capture properties of a type using auxiliary proof terms, rather than having to define an entirely new type, is one of the things that makes dependently typed programming so powerful.&lt;/p&gt;

&lt;h3 id="proof-inference"&gt;Proof inference&lt;/h3&gt;

&lt;p&gt;While our definition of &lt;code&gt;pairUp&lt;/code&gt; is interesting, you may be skeptical of its practical utility. It’s fiddly and inconvenient to have to pass the &lt;code&gt;Even&lt;/code&gt; proof term explicitly, since it must be updated every time the length of the list changes. Fortunately, this is where TMP comes in.&lt;/p&gt;

&lt;p&gt;Remember that typeclasses are functions from types to terms. As its happens, a value of type &lt;code&gt;Even as&lt;/code&gt; can be mechanically produced from the structure of the type &lt;code&gt;as&lt;/code&gt;. This suggests that we could use TMP to automatically generate &lt;code&gt;Even&lt;/code&gt; proofs, and indeed, we can. In fact, it’s not at all complicated:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;evenProof&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We can now adjust our &lt;code&gt;pairUp&lt;/code&gt; function to use &lt;code&gt;IsEven&lt;/code&gt; instead of an explicit &lt;code&gt;Even&lt;/code&gt; argument:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;         &lt;span class="kt"&gt;HNil&lt;/span&gt;                     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
  &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is essentially identical to its old definition, but by acquiring the proof via &lt;code&gt;IsEven&lt;/code&gt; rather than passing it explicitly, we can call &lt;code&gt;pairUp&lt;/code&gt; without having to construct a proof manually:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is rather remarkable. Using TMP, we are able to get GHC to &lt;em&gt;automatically construct a proof that a list is even&lt;/em&gt;, with no programmer guidance beyond writing the &lt;code&gt;IsEven&lt;/code&gt; typeclass. This relies once more on the perspective that typeclasses are functions that accept types and generate term-level code: &lt;code&gt;IsEven&lt;/code&gt; is a function that accepts a type-level list and generates an &lt;code&gt;Even&lt;/code&gt; proof term.&lt;/p&gt;

&lt;p&gt;From this perspective, &lt;strong&gt;typeclasses are a way of specifying a proof search algorithm&lt;/strong&gt; to the compiler. In the case of &lt;code&gt;IsEven&lt;/code&gt;, the proofs being generated are rather simple, so the proof search algorithm is quite mechanical. But in general, typeclasses can be used to perform proof search of significant complexity, given a sufficiently clever encoding into the type system.&lt;/p&gt;

&lt;h2 id="aside-gadts-versus-type-families"&gt;Aside: GADTs versus type families&lt;/h2&gt;

&lt;p&gt;Before moving on, I want to explicitly call attention to the relationship between GADTs and type families. Though at first glance they may seem markedly different, there are some similarities between the two, and sometimes they may be used to accomplish similar things.&lt;/p&gt;

&lt;p&gt;Consider again the type of the &lt;code&gt;pairUp&lt;/code&gt; function above (without the typeclass for simplicity):&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We used both a GADT, &lt;code&gt;Even&lt;/code&gt;, and a type family, &lt;code&gt;PairUp&lt;/code&gt;. But we could have, in theory, used &lt;em&gt;only&lt;/em&gt; a GADT and eliminated the type family altogether. Consider this variation on the &lt;code&gt;Even&lt;/code&gt; proof term:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;EvenNil&lt;/span&gt;  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;
  &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: bs)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This type has two type parameters rather than one, and though there’s no distinction between the two from GHC’s point of view, it can be useful to think of &lt;code&gt;as&lt;/code&gt; as an “input” parameter and &lt;code&gt;bs&lt;/code&gt; as an “output” parameter. The idea is that any &lt;code&gt;EvenPairs&lt;/code&gt; proof relates both an even-length list type and its paired up equivalent:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;EvenNil&lt;/code&gt; has type &lt;code&gt;EvenPairs '[] '[]&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;EvenCons EvenNil&lt;/code&gt; has type &lt;code&gt;EvenPairs '[a, b] '[(a, b)]&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;EvenCons (EvenCons EvenNil)&lt;/code&gt; has type &lt;code&gt;EvenPairs '[a, b, c, d] '[(a, b), (c, d)]&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;…and so on.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This allows us to reformulate our &lt;code&gt;pairUp&lt;/code&gt; type signature this way:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The definition is otherwise unchanged. The &lt;code&gt;PairUp&lt;/code&gt; type family is completely gone, because now &lt;code&gt;EvenPairs&lt;/code&gt; itself defines the relation. In this way, GADTs can be used like type-level functions!&lt;/p&gt;

&lt;p&gt;The inverse, however, is not true, at least not directly: we cannot eliminate the GADT altogether and exclusively use type families. One way to attempt doing so would be to define a type family that returns a constraint rather than a type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Data.Kind&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Constraint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Constraint&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;            &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: _&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The idea here is that &lt;code&gt;IsEvenTF as&lt;/code&gt; produces a constraint can only be satisfied if &lt;code&gt;as&lt;/code&gt; has an even number of elements, since that’s the only way it will eventually reduce to &lt;code&gt;()&lt;/code&gt;, which in this case means the empty set of constraints, not the unit type (yes, the syntax for that is confusing). And in fact, it’s true that putting &lt;code&gt;IsEvenTF as =&amp;gt;&lt;/code&gt; in a type signature successfully restricts &lt;code&gt;as&lt;/code&gt; to be an even-length list, but it doesn’t allow us to write &lt;code&gt;pairUp&lt;/code&gt;. To see why, we can try the following definition:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;                     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;pairUp&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Unlike the version using the GADT, this version of &lt;code&gt;pairUp&lt;/code&gt; is not considered exhaustive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for ‘pairUp’: Patterns not matched: HCons _ HNil&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is because type families don’t provide the same bidirectional flow of information that GADTs do, they’re only type-level functions. The constraint generated by &lt;code&gt;IsEvenTF&lt;/code&gt; provides no term-level evidence about the shape of &lt;code&gt;as&lt;/code&gt;, so we can’t branch on it the way we can branch on the &lt;code&gt;Even&lt;/code&gt; GADT.&lt;sup&gt;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-5-definition" name="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-5-return"&gt;5&lt;/a&gt;&lt;/sup&gt; (In a sense, &lt;code&gt;IsEvenTF&lt;/code&gt; is doing &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;validation, not parsing&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;For this reason, I caution against overuse of type families. Their simplicity is seductive, but all too often you pay for that simplicity with inflexibility. GADTs combined with TMP for proof inference can provide the best of both worlds: complete control over the term-level proof that gets generated while still letting the compiler do most of the work for you.&lt;/p&gt;

&lt;h2 id="guiding-type-inference"&gt;Guiding type inference&lt;/h2&gt;

&lt;p&gt;So far, this blog post has given relatively little attention to type inference. That is in some part a testament to the robustness of GHC’s type inference algorithm: even when fairly sophisticated TMP is involved, GHC often manages to propagate enough type information that type annotations are rarely needed.&lt;/p&gt;

&lt;p&gt;However, when doing TMP, it would be irresponsible to not at least consider the type inference properties of programs. Type inference is what drives the whole typeclass resolution process to begin with, so poor type inference can easily make your fancy TMP construction next to useless. To take advantage of GHC to the fullest extent, programs should proactively guide the typechecker to help it infer as much as possible as often as possible.&lt;/p&gt;

&lt;p&gt;To illustrate what that can look like, suppose we want to use TMP to generate an &lt;code&gt;HList&lt;/code&gt; full of &lt;code&gt;()&lt;/code&gt; values of an arbitrary length:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Testing in GHCi, we can see it behaves as desired:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[(), (), ()]&lt;/span&gt;
&lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now suppose we write a function that accepts a list containing exactly one element and returns it:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;unsingleton&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[a]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;unsingleton&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Naturally, we would expect these to compose without a hitch. If we write &lt;code&gt;unsingleton unitList&lt;/code&gt;, our TMP should generate a list of length 1, and we should get back &lt;code&gt;()&lt;/code&gt;. However, it may surprise you to learn that &lt;em&gt;isn’t&lt;/em&gt;, in fact, what happens:&lt;sup&gt;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-6-definition" name="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-6-return"&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ghci&amp;gt; unsingleton unitList

error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘unitList’
      prevents the constraint ‘(UnitList '[a0])’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance UnitList as =&amp;gt; UnitList (() : as)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What went wrong? The type error says that &lt;code&gt;a0&lt;/code&gt; is ambiguous, but it only lists a single matching &lt;code&gt;UnitList&lt;/code&gt; instance—the one we want—so how can it be ambiguous which one to select?&lt;/p&gt;

&lt;p&gt;The problem stems from the way we defined &lt;code&gt;UnitList&lt;/code&gt;. When we wrote the instance&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) where&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;we said the first element of the type-level list must be &lt;code&gt;()&lt;/code&gt;, so there’s nothing stopping someone from coming along and defining another instance:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In that case, GHC would have no way to know which instance to pick. Nothing in the type of &lt;code&gt;unsingleton&lt;/code&gt; forces the element in the list to have type &lt;code&gt;()&lt;/code&gt;, so both instances are equally valid. To hedge against this future possibility, GHC rejects the program as ambiguous from the start.&lt;/p&gt;

&lt;p&gt;Of course, this isn’t what we want. The &lt;code&gt;UnitList&lt;/code&gt; class is supposed to &lt;em&gt;always&lt;/em&gt; return a list of &lt;code&gt;()&lt;/code&gt; values, so how can we force GHC to pick our instance anyway? The answer is to play a trick:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Here we’ve changed the instance so that it has the shape &lt;code&gt;UnitList (a ': as)&lt;/code&gt;, with a type variable in place of the &lt;code&gt;()&lt;/code&gt;, but we also added an equality constraint that forces &lt;code&gt;a&lt;/code&gt; to be &lt;code&gt;()&lt;/code&gt;. Intuitively, you might think these two instances are completely identical, but in fact they are not! As proof, our example now typechecks:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;unsingleton&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt;
&lt;span class="nb"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;To understand why, it’s important to understand how GHC’s typeclass resolution algorithm works. Let’s start by establishing some terminology. Note that every instance declaration has the following shape:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;constraints&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;C&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The part to the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; is known as the &lt;em&gt;instance context&lt;/em&gt;, while the part to the right is known as the &lt;em&gt;instance head&lt;/em&gt;. Now for the important bit: when GHC attempts to pick which typeclass instance to use to solve a typeclass constraint, &lt;strong&gt;only the instance head matters, and the instance context is completely ignored&lt;/strong&gt;. Once GHC picks an instance, it commits to its choice, and only then does it consider the instance context.&lt;/p&gt;

&lt;p&gt;This explains why our two &lt;code&gt;UnitList&lt;/code&gt; instances behave differently:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Given the instance head &lt;code&gt;UnitList (() ': as)&lt;/code&gt;, GHC won’t select the instance unless it knows the first element of the list is &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;But given the instance head &lt;code&gt;UnitList (a ': as)&lt;/code&gt;, GHC will pick the instance regardless of the type of the first element. All that matters is that the list is at least one element long.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;After the &lt;code&gt;UnitList (a ': as)&lt;/code&gt; instance is selected, GHC attempts to solve the constraints in the instance context, including the &lt;code&gt;a ~ ()&lt;/code&gt; constraint. This &lt;em&gt;forces&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; to be &lt;code&gt;()&lt;/code&gt;, resolving the ambiguity and allowing type inference to proceed.&lt;/p&gt;

&lt;p&gt;This distinction might seem excessively subtle, but in practice it is enormously useful. It means you, the programmer, have direct control over the type inference process:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;If you put a type in the instance head, you’re asking GHC to figure out how to make the types match up by some other means. Sometimes that’s very useful, since perhaps you want that type to inform which instance to pick.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;But if you put an equality constraint in the instance context, the roles are reversed: you’re saying to the compiler “you don’t tell me, I’ll tell &lt;em&gt;you&lt;/em&gt; what type this is,” effectively giving you a role in type inference itself.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;From this perspective, typeclass instances with equality constraints make GHC’s type inference algorithm extensible. You get to pick which decisions are made and when, and crucially, you can use knowledge of your own program structure to expose more information to the typechecker.&lt;/p&gt;

&lt;p&gt;Given all of the above, consider again the definition of &lt;code&gt;IsEven&lt;/code&gt; from earlier:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;evenProof&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Though it didn’t cause any problems in the examples we tried, this definition isn’t optimized for type inference. If GHC needed to solve an &lt;code&gt;IsEven (a ': b0)&lt;/code&gt; constraint, where &lt;code&gt;b0&lt;/code&gt; is an ambiguous type variable, it would get stuck, since it doesn’t know that someone won’t come along and define an &lt;code&gt;IsEven '[a]&lt;/code&gt; instance in the future.&lt;/p&gt;

&lt;p&gt;To fix this, we can apply the same trick we used for &lt;code&gt;UnitList&lt;/code&gt;, just in a slightly different way:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: bs), IsEven bs) =&amp;gt; IsEven (a&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;evenProof&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Again, the idea is to move the type information we &lt;em&gt;learn&lt;/em&gt; from picking this instance into the instance context, allowing it to guide type inference rather than making type inference figure it out from some other source. Consistently applying this transformation can &lt;strong&gt;dramatically&lt;/strong&gt; improve type inference in programs that make heavy use of TMP.&lt;/p&gt;

&lt;h2 id="example-3-subtyping-constraints"&gt;Example 3: Subtyping constraints&lt;/h2&gt;

&lt;p&gt;At last, we have reached the final example of this blog post. For this one, I have the pleasure of providing a real-world example from a production Haskell codebase: while I was working at &lt;a href="https://hasura.io/"&gt;Hasura&lt;/a&gt;, I had the opportunity to design an internal parser combinator library that captures aspects of the &lt;a href="https://graphql.org/"&gt;GraphQL&lt;/a&gt; type system. One such aspect of that type system is a form of subtyping; GraphQL essentially has two “kinds” of types—input types and output types—but some types can be used as both.&lt;/p&gt;

&lt;p&gt;Haskell has no built-in support for subtyping, so most Haskell programs do their best to get away with parametric polymorphism instead. However, in our case, we actually need to distinguish (at runtime) types in the “both” category from those that are exclusively input or exclusively output types. Consequently, our &lt;code&gt;GQLKind&lt;/code&gt; datatype has three cases:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;GQLKind&lt;/span&gt;
  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Both&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Input&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We use &lt;code&gt;DataKind&lt;/code&gt;-promoted versions of this &lt;code&gt;GQLKind&lt;/code&gt; type as a parameter to a &lt;code&gt;GQLType&lt;/code&gt; GADT:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;GQLType&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;TScalar&lt;/span&gt;      &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;GQLType&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Both&lt;/span&gt;
  &lt;span class="kt"&gt;TInputObject&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;InputObjectInfo&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLType&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt;
  &lt;span class="kt"&gt;TIObject&lt;/span&gt;     &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ObjectInfo&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLType&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Output&lt;/span&gt;
  &lt;span class="c1"&gt;-- ...and so on...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This allows us to write functions that only accept input types or only accept output types, which is a wonderful property to be able to guarantee at compile-time! But there’s a problem: if we write a function that only accepts values of type &lt;code&gt;GQLType 'Input&lt;/code&gt;, we can’t pass a &lt;code&gt;GQLType 'Both&lt;/code&gt;, even though we really ought to be able to.&lt;/p&gt;

&lt;p&gt;To fix this, we can use a little dependently typed programming. First, we’ll define a type to represent proof terms that witness a subkinding relationship:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;SubKind&lt;/span&gt; &lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="n"&gt;k2&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;KRefl&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;SubKind&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
  &lt;span class="kt"&gt;KBoth&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;SubKind&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Both&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The first case, &lt;code&gt;KRefl&lt;/code&gt;, states that every kind is trivially a subkind of itself. The second case, &lt;code&gt;KBoth&lt;/code&gt;, states that &lt;code&gt;Both&lt;/code&gt; is a subkind of any kind at all. (This is a particularly literal example of &lt;a href="/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/"&gt;using a type to define axioms&lt;/a&gt;.) The next step is to use TMP to implement proof inference:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="n"&gt;k2&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;SubKind&lt;/span&gt; &lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="n"&gt;k2&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Both&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;KBoth&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;KRefl&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Output&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Output&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;KRefl&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;These instances use the type equality trick described in the previous section to guide type inference, ensuring that if we ever need to prove that &lt;code&gt;k&lt;/code&gt; is a superkind of &lt;code&gt;'Input&lt;/code&gt; or &lt;code&gt;'Output&lt;/code&gt;, type inference will force them to be equal.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;IsSubKind&lt;/code&gt;, we can easily resolve the problem described above. Rather than write a function with a type like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;nullable&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…we simply use an &lt;code&gt;IsSubKind&lt;/code&gt; constraint, instead:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;nullable&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now both &lt;code&gt;'Input&lt;/code&gt; and &lt;code&gt;'Both&lt;/code&gt; kinds are accepted. In my experience, this caused no trouble at all for callers of these functions; everything worked completely automatically. &lt;em&gt;Consuming&lt;/em&gt; the &lt;code&gt;SubKind&lt;/code&gt; proofs was slightly more involved, but only ever so slightly. For example, we have a type family that looks like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Both&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;InputValue&lt;/span&gt;
  &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;InputValue&lt;/span&gt;
  &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Output&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;SelectionSet&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This type family is used to determine what a &lt;code&gt;GQLParser k a&lt;/code&gt; actually consumes as input, based on the kind of the GraphQL type it corresponds to. In some functions, we need to prove to GHC that &lt;code&gt;IsSubKind k 'Input&lt;/code&gt; implies &lt;code&gt;ParserInput k ~ InputValue&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Fortunately, that is very easy to do using &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Type-Equality.html"&gt;the &lt;code&gt;(:~:)&lt;/code&gt; type from &lt;code&gt;Data.Type.Equality&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt;&lt;/a&gt; to capture a term-level witness of a type equality. It’s an ordinary Haskell GADT that happens to have an infix type constructor, and this is its definition:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:~:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;Refl&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:~:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Just as with any other GADT, &lt;code&gt;(:~:)&lt;/code&gt; can be used to pack up type equalities and unpack them later; &lt;code&gt;a :~: b&lt;/code&gt; just happens to be the GADT that corresponds precisely to the equality &lt;code&gt;a ~ b&lt;/code&gt;. Using &lt;code&gt;(:~:)&lt;/code&gt;, we can write a reusable proof that &lt;code&gt;IsSubKind k 'Input&lt;/code&gt; implies &lt;code&gt;ParserInput k ~ InputValue&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;inputParserInput&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kt"&gt;:~:&lt;/span&gt; &lt;span class="kt"&gt;InputValue&lt;/span&gt;
&lt;span class="nf"&gt;inputParserInput&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;KRefl&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Refl&lt;/span&gt;
  &lt;span class="kt"&gt;KBoth&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Refl&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This function is a very simple proof by cases, where &lt;code&gt;Refl&lt;/code&gt; can be read as “Q.E.D.”:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;In the first case, matching on &lt;code&gt;KRefl&lt;/code&gt; refines &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;'Input&lt;/code&gt;, and &lt;code&gt;ParserInput 'Input&lt;/code&gt; is &lt;code&gt;InputValue&lt;/code&gt; by definition of &lt;code&gt;ParserInput&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Likewise, in the second case, matching on &lt;code&gt;KBoth&lt;/code&gt; refines &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;'Both&lt;/code&gt;, and &lt;code&gt;ParserInput 'Both&lt;/code&gt; is also &lt;code&gt;InputValue&lt;/code&gt; by definition of &lt;code&gt;ParserInput&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This &lt;code&gt;inputParserInput&lt;/code&gt; helper allows functions like &lt;code&gt;nullable&lt;/code&gt;, which internally need &lt;code&gt;ParserInput k ~ InputValue&lt;/code&gt;, to take the form&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;nullable&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;nullable&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;inputParserInput&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Refl&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="cm"&gt;{- ...implementation goes here... -}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Overall, this burden is quite minimal, so the additional type safety is more than worth the effort. The same could not be said without &lt;code&gt;IsSubKind&lt;/code&gt; doing work to infer the proofs at each use site, so in this case, TMP has certainly paid its weight!&lt;/p&gt;

&lt;h1 id="wrapping-up-and-closing-thoughts"&gt;Wrapping up and closing thoughts&lt;/h1&gt;

&lt;p&gt;So concludes my introduction to Haskell TMP. As seems to happen all too often with my blog posts, this one has grown rather long, so allow me to provide a summary of the most important points:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Typeclass metaprogramming is a powerful technique for performing type-directed code generation, making it a form of “value inference” that infers values from types.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Unlike most other metaprogramming mechanisms, TMP has a wonderful synergy with type inference, which allows it to take advantage of information the programmer may not have even written explicitly.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Though I’ve called the technique “&lt;em&gt;typeclass&lt;/em&gt; metaprogramming,” TMP really leverages the entirety of the modern GHC type system. Type families, GADTs, promoted types, and more all have their place in usefully applying type-level programming.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, since TMP relies so heavily on type inference to do its job, it’s crucial to be thoughtful about how you design type-level code to give the typechecker as many opportunities to succeed as you possibly can.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The individual applications of TMP covered in this blog post—type-level computation, generic programming, and dependent typing—are all useful in their own right, and this post does not linger on any of them long enough to do any of them justice. That is, perhaps, the cost one pays when trying to discuss such an abstract, general technique. However, I hope that readers can see the forest for the trees and understand how TMP can be a set of techniques in their own right, applicable to the topics described above and more.&lt;/p&gt;

&lt;p&gt;Readers may note that this blog post targets a slightly different audience than my other recent writing has been. That is a conscious choice: there is an unfortunate dearth of resources to help intermediate Haskell programmers become advanced Haskell programmers, in part because it’s hard to write them. The lack of resources makes tackling topics like this rather difficult, as too often it feels as though an entire web of concepts must be explained all at once, with no obvious incremental path that provides sufficient motivation every step of the way.&lt;/p&gt;

&lt;p&gt;It remains to be seen whether my stab at the problem will be successful. But on the chance that it is, I suspect some readers will be curious about where to go next. Here are some ideas:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;As mentioned earlier in this blog post, &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Generics.html"&gt;the &lt;code&gt;GHC.Generics&lt;/code&gt; module documentation&lt;/a&gt; is a great resource if you want to explore generic programming further, and generic programming is a great way to put TMP to practical use.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;I have long believed that &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/"&gt;the GHC User’s Guide&lt;/a&gt; is a criminally under-read and underappreciated piece of documentation. It is a treasure trove of knowledge, and I highly recommend reading through the sections on type-related language extensions if you want to get a better grasp of the mechanics of the Haskell type system.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, if dependently typed programming in Haskell intrigues you, and you don’t mind staring into the sun, the &lt;a href="https://hackage.haskell.org/package/singletons"&gt;singletons&lt;/a&gt; library provides abstractions and design patterns that can considerably cut down on the boilerplate. (Also, &lt;a href="https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf"&gt;the accompanying paper&lt;/a&gt; is definitely worth a read if you’d like to go down that route.)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Even if you don’t decide to pursue type-level programming in Haskell, I hope this blog post helps make some of the concepts involved less mystical and intimidating. I, for one, think this stuff is worth the effort involved in understanding. After all, you never know when it might come in handy.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Not to be confused with C++’s &lt;a href="https://en.wikipedia.org/wiki/Template_metaprogramming"&gt;&lt;em&gt;template&lt;/em&gt; metaprogramming&lt;/a&gt;, though there are significant similarities between the two techniques.&amp;nbsp;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;There have been proposals to introduce ordered instances, known in the literature as &lt;a href="https://homepage.cs.uiowa.edu/~jgmorrs/pubs/morris-icfp2010-instances.pdf"&gt;&lt;em&gt;instance chains&lt;/em&gt;&lt;/a&gt;, but as of this writing, GHC does not implement them.&amp;nbsp;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;Note that this also preserves an important property of the Haskell type system, parametricity. A function like &lt;code&gt;id :: a -&amp;gt; a&lt;/code&gt; shouldn’t be allowed to do different things depending on which type is chosen for &lt;code&gt;a&lt;/code&gt;, which our first version of &lt;code&gt;guardUnit&lt;/code&gt; tried to violate. Typeclasses, being functions on types, can naturally do different things given different types, so a typeclass constraint is precisely what gives us the power to violate parametricity.&amp;nbsp;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-4-definition" class="footnote-definition"&gt;
   &lt;p&gt;Short for &lt;em&gt;generalized algebraic datatypes&lt;/em&gt;, which is a rather unhelpful name for actually understanding what they are or what they’re for.&amp;nbsp;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-4-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-5-definition" class="footnote-definition"&gt;
   &lt;p&gt;If GHC allowed lightweight existential quantification, we could make that term-level evidence available with a sufficiently clever definition for &lt;code&gt;IsEvenTF&lt;/code&gt;:&lt;/p&gt;
   &lt;div class="brush: haskell"&gt;
    &lt;div class="source"&gt;
     &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Constraint&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;       &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) = exists b a&lt;/span&gt;&lt;span class="sc"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: a&lt;/span&gt;&lt;span class="sc"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
   &lt;p&gt;The type refinement provided by matching on &lt;code&gt;HCons&lt;/code&gt; would be enough for the second case of &lt;code&gt;IsEvenTF&lt;/code&gt; to be selected, which would provide an equality proof that &lt;code&gt;as&lt;/code&gt; has at least two elements. Sadly, GHC does not support anything of this sort, and it’s unclear if it would be tractable to implement at all.&amp;nbsp;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-5-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-6-definition" class="footnote-definition"&gt;
   &lt;p&gt;Actually, I’ve cheated a little bit here, because &lt;code&gt;unsingleton unitList&lt;/code&gt; really does typecheck in GHCi under normal circumstances. That’s because &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/ghci.html#extension-ExtendedDefaultRules"&gt;the &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; extension&lt;/a&gt; is enabled in GHCi by default, which defaults ambiguous type variables to &lt;code&gt;()&lt;/code&gt;, which happens to be exactly what’s needed to make this contrived example typecheck. However, that doesn’t say anything very useful, since the same expression really would fail to typecheck inside a Haskell module, so I’ve turned &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; off to illustrate the problem.&amp;nbsp;&lt;a href="#2021-03-25-an-introduction-to-typeclass-metaprogramming-footnote-6-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Names are not type safety</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2020/11/01/names-are-not-type-safety/?utm_source=functional-programming&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2020-11-01-names-are-not-type-safety</id>
  <published>2020-11-01T18:00:00Z</published>
  <updated>2020-11-01T18:00:00Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;Haskell programmers spend a lot of time talking about &lt;em&gt;type safety&lt;/em&gt;. The Haskell school of program construction advocates “capturing invariants in the type system” and “making illegal states unrepresentable,” both of which sound like compelling goals, but are rather vague on the techniques used to achieve them. Almost exactly one year ago, I published &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;Parse, Don’t Validate&lt;/a&gt; as an initial stab towards bridging that gap.&lt;/p&gt;

&lt;p&gt;The ensuing discussions were largely productive and right-minded, but one particular source of confusion quickly became clear: Haskell’s &lt;code&gt;newtype&lt;/code&gt; construct. The idea is simple enough—the &lt;code&gt;newtype&lt;/code&gt; keyword declares a wrapper type, nominally distinct from but representationally equivalent to the type it wraps—and on the surface this &lt;em&gt;sounds&lt;/em&gt; like a simple and straightforward path to type safety. For example, one might consider using a &lt;code&gt;newtype&lt;/code&gt; declaration to define a type for an email address:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;EmailAddress&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EmailAddress&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This technique can provide &lt;em&gt;some&lt;/em&gt; value, and when coupled with a smart constructor and an encapsulation boundary, it can even provide some safety. But it is a meaningfully distinct &lt;em&gt;kind&lt;/em&gt; of type safety from the one I highlighted a year ago, one that is far weaker. On its own, a newtype is just a name.&lt;/p&gt;

&lt;p&gt;And names are not type safety.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="intrinsic-and-extrinsic-safety"&gt;Intrinsic and extrinsic safety&lt;/h1&gt;

&lt;p&gt;To illustrate the difference between constructive data modeling (discussed at length in my &lt;a href="/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/"&gt;previous blog post&lt;/a&gt;) and newtype wrappers, let’s consider an example. Suppose we want a type for “an integer between 1 and 5, inclusive.” The natural constructive modeling would be an enumeration with five cases:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt;
  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Four&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Five&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We could then write some functions to convert between &lt;code&gt;Int&lt;/code&gt; and our &lt;code&gt;OneToFive&lt;/code&gt; type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Four&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Five&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;

&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;Four&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;Five&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This would be perfectly sufficient for achieving our stated goal, but you’d be forgiven for finding it odd: it would be rather awkward to work with in practice. Because we’ve invented an entirely new type, we can’t reuse any of the usual numeric functions Haskell provides. Consequently, many programmers would gravitate towards a newtype wrapper, instead:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Just as before, we can provide &lt;code&gt;toOneToFive&lt;/code&gt; and &lt;code&gt;fromOneToFive&lt;/code&gt; functions, with identical types:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;otherwise&lt;/span&gt;        &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;

&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If we put these declarations in their own module and choose not to export the &lt;code&gt;OneToFive&lt;/code&gt; constructor, these APIs might appear entirely interchangeable. Naïvely, it seems that the newtype version is both simpler and equally type-safe. However—perhaps surprisingly—this is not actually true.&lt;/p&gt;

&lt;p&gt;To see why, suppose we write a function that consumes a &lt;code&gt;OneToFive&lt;/code&gt; value as an argument. Under the constructive modeling, such a function need only pattern-match against each of the five constructors, and GHC will accept the definition as exhaustive:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"first"&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"second"&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"third"&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;Four&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"fourth"&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;Five&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"fifth"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The same is not true given the newtype encoding. The newtype is opaque, so the only way to observe it is to convert it back to an &lt;code&gt;Int&lt;/code&gt;—after all, it &lt;em&gt;is&lt;/em&gt; an &lt;code&gt;Int&lt;/code&gt;. An &lt;code&gt;Int&lt;/code&gt; can of course contain many other values besides &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;5&lt;/code&gt;, so we are forced to add an error case to satisfy the exhaustiveness checker:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromOneToFive&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"first"&lt;/span&gt;
  &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"second"&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"third"&lt;/span&gt;
  &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"fourth"&lt;/span&gt;
  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"fifth"&lt;/span&gt;
  &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"impossible: bad OneToFive value"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this highly contrived example, this may not seem like much of a problem to you. But it nonetheless illustrates a key difference in the guarantees afforded by the two approaches:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The constructive datatype captures its invariants in such a way that they are &lt;em&gt;accessible&lt;/em&gt; to downstream consumers. This frees our &lt;code&gt;ordinal&lt;/code&gt; function from worrying about handling illegal values, as they have been made unutterable.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The newtype wrapper provides a smart constructor that &lt;em&gt;validates&lt;/em&gt; the value, but the boolean result of that check is used only for control flow; it is not preserved in the function’s result. Accordingly, downstream consumers cannot take advantage of the restricted domain; they are functionally accepting &lt;code&gt;Int&lt;/code&gt;s.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Losing exhaustiveness checking might seem like small potatoes, but it absolutely is not: our use of &lt;code&gt;error&lt;/code&gt; has punched a hole right through our type system. If we were to add another constructor to our &lt;code&gt;OneToFive&lt;/code&gt; datatype,&lt;sup&gt;&lt;a href="#2020-11-01-names-are-not-type-safety-footnote-1-definition" name="2020-11-01-names-are-not-type-safety-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; the version of &lt;code&gt;ordinal&lt;/code&gt; that consumes a constructive datatype would be immediately detected non-exhaustive at compile-time, while the version that consumes a newtype wrapper would continue to compile yet fail at runtime, dropping through to the “impossible” case.&lt;/p&gt;

&lt;p&gt;All of this is a consequence of the fact that the constructive modeling is &lt;em&gt;intrinsically&lt;/em&gt; type-safe; that is, the safety properties are enforced by the type declaration itself. Illegal values truly are unrepresentable: there is simply no way to represent &lt;code&gt;6&lt;/code&gt; using any of the five constructors. The same is not true of the newtype declaration, which has no intrinsic semantic distinction from that of an &lt;code&gt;Int&lt;/code&gt;; its meaning is specified extrinsically via the &lt;code&gt;toOneToFive&lt;/code&gt; smart constructor. Any semantic distinction intended by a newtype is thoroughly invisible to the type system; it exists only in the programmer’s mind.&lt;/p&gt;

&lt;h2 id="revisiting-non-empty-lists"&gt;Revisiting non-empty lists&lt;/h2&gt;

&lt;p&gt;Our &lt;code&gt;OneToFive&lt;/code&gt; datatype is rather artificial, but identical reasoning applies to other datatypes that are significantly more practical. Consider the &lt;code&gt;NonEmpty&lt;/code&gt; datatype I’ve repeatedly highlighted in recent blog posts:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It may be illustrative to imagine a version of &lt;code&gt;NonEmpty&lt;/code&gt; represented as a newtype over ordinary lists. We can use the usual smart constructor strategy to enforce the desired non-emptiness property:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Foldable&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;toList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Just as with &lt;code&gt;OneToFive&lt;/code&gt;, we quickly discover the consequences of failing to preserve this information in the type system. Our motivating use case for &lt;code&gt;NonEmpty&lt;/code&gt; was the ability to write a safe version of &lt;code&gt;head&lt;/code&gt;, but the newtype version requires another assertion:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;toList&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="kt"&gt;[]&lt;/span&gt;  &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"impossible: empty NonEmpty value"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This might not seem like a big deal, since it seems unlikely such a case would ever happen. But that reasoning hinges entirely on trusting the correctness of the module that defines &lt;code&gt;NonEmpty&lt;/code&gt;, while the constructive definition only requires trusting the GHC typechecker. As we generally trust that the typechecker works correctly, the latter is a much more compelling proof.&lt;/p&gt;

&lt;h1 id="newtypes-as-tokens"&gt;Newtypes as tokens&lt;/h1&gt;

&lt;p&gt;If you are fond of newtypes, this whole argument may seem a bit troubling. It may seem like I’m implying newtypes are scarcely better than comments, albeit comments that happen to be meaningful to the typechecker. Fortunately, the situation is not quite that grim—newtypes &lt;em&gt;can&lt;/em&gt; provide a sort of safety, just a weaker one.&lt;/p&gt;

&lt;p&gt;The primary safety benefit of newtypes is derived from abstraction boundaries. If a newtype’s constructor is not exported, it becomes opaque to other modules. The module that defines the newtype—its “home module”—can take advantage of this to create a &lt;em&gt;trust boundary&lt;/em&gt; where internal invariants are enforced by restricting clients to a safe API.&lt;/p&gt;

&lt;p&gt;We can use the &lt;code&gt;NonEmpty&lt;/code&gt; example from above to illustrate how this works. We refrain from exporting the &lt;code&gt;NonEmpty&lt;/code&gt; constructor, and we provide &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; operations that we trust to never actually fail:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Data.List.NonEmpty.Newtype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;cons&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;nonEmpty&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;head&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;tail&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;

&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;

&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"impossible: empty NonEmpty value"&lt;/span&gt;

&lt;span class="nf"&gt;tail&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;tail&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
&lt;span class="nf"&gt;tail&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"impossible: empty NonEmpty value"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Since the only way to construct or consume &lt;code&gt;NonEmpty&lt;/code&gt; values is to use the functions in &lt;code&gt;Data.List.NonEmpty.Newtype&lt;/code&gt;’s exported API, the above implementation makes it impossible for clients to violate the non-emptiness invariant. In a sense, values of opaque newtypes are like &lt;em&gt;tokens&lt;/em&gt;: the implementing module issues tokens via its constructor functions, and those tokens have no intrinsic value. The only way to do anything useful with them is to “redeem” them to the issuing module’s accessor functions, in this case &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, to obtain the values contained within.&lt;/p&gt;

&lt;p&gt;This approach is significantly weaker than using a constructive datatype, since it is theoretically possible to screw up and accidentally provide a means to construct an invalid &lt;code&gt;NonEmpty []&lt;/code&gt; value. For this reason, the newtype approach to type safety does not on its own constitute a &lt;em&gt;proof&lt;/em&gt; that a desired invariant holds. However, it restricts the “surface area” where an invariant violation can occur to the defining module, so reasonable confidence the invariant really does hold can be achieved by thoroughly testing the module’s API using fuzzing or property-based testing techniques.&lt;sup&gt;&lt;a href="#2020-11-01-names-are-not-type-safety-footnote-2-definition" name="2020-11-01-names-are-not-type-safety-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;This tradeoff may not seem all that bad, and indeed, it is often a very good one! Guaranteeing invariants using constructive data modeling can, in general, be quite difficult, which often makes it impractical. However, it is easy to dramatically underestimate the care needed to avoid accidentally providing a mechanism that permits violating the invariant. For example, the programmer may choose to take advantage of GHC’s convenient typeclass deriving to derive a &lt;code&gt;Generic&lt;/code&gt; instance for &lt;code&gt;NonEmpty&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;{-# LANGUAGE DeriveGeneric #-}&lt;/span&gt;

&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;GHC.Generics&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Generic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Generic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, this innocuous line provides a trivial mechanism to circumvent the abstraction boundary:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GHC&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Generics&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;M1&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;M1&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;M1&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;K1&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is a particularly extreme example, since derived &lt;code&gt;Generic&lt;/code&gt; instances are fundamentally abstraction-breaking, but this problem can crop up in less obvious ways, too. The same problem occurs with a derived &lt;code&gt;Read&lt;/code&gt; instance:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"NonEmpty []"&lt;/span&gt;
&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;To some readers, these pitfalls may seem obvious, but safety holes of this sort are remarkably common in practice. This is especially true for datatypes with more sophisticated invariants, as it may not be easy to determine whether the invariants are actually upheld by the module’s implementation. Proper use of this technique demands caution and care:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;All invariants must be made clear to maintainers of the trusted module. For simple types, such as &lt;code&gt;NonEmpty&lt;/code&gt;, the invariant is self-evident, but for more sophisticated types, comments are not optional.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Every change to the trusted module must be carefully audited to ensure it does not somehow weaken the desired invariants.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Discipline is needed to resist the temptation to add unsafe trapdoors that allow compromising the invariants if used incorrectly.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Periodic refactoring may be needed to ensure the trusted surface area remains small. It is all too easy for the responsibility of the trusted module to accumulate over time, dramatically increasing the likelihood of some subtle interaction causing an invariant violation.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;In contrast, datatypes that are correct by construction suffer none of these problems. The invariant cannot be violated without changing the datatype definition itself, which has rippling effects throughout the rest of the program to make the consequences immediately clear. Discipline on the part of the programmer is unnecessary, as the typechecker enforces the invariants automatically. There is no “trusted code” for such datatypes, since all parts of the program are equally beholden to the datatype-mandated constraints.&lt;/p&gt;

&lt;p&gt;In libraries, the newtype-afforded notion of safety via encapsulation is useful, as libraries often provide the building blocks used to construct more complicated data structures. Such libraries generally receive more scrutiny and care than application code does, especially given they change far less frequently. In application code, these techniques are still useful, but the churn of a production codebase tends to weaken encapsulation boundaries over time, so correctness by construction should be preferred whenever practical.&lt;/p&gt;

&lt;h1 id="other-newtype-use-abuse-and-misuse"&gt;Other newtype use, abuse, and misuse&lt;/h1&gt;

&lt;p&gt;The previous section covers the primary means by which newtypes are useful. However, in practice, newtypes are routinely used in ways that do not fit the above pattern. Some such uses are reasonable:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Haskell’s notion of typeclass coherency limits each type to a single instance of any given class. For types that permit more than one useful instance, newtypes are the traditional solution, and this can be used to good effect. For example, the &lt;code&gt;Sum&lt;/code&gt; and &lt;code&gt;Product&lt;/code&gt; newtypes from &lt;code&gt;Data.Monoid&lt;/code&gt; provide useful &lt;code&gt;Monoid&lt;/code&gt; instances for numeric types.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In a similar vein, newtypes can be useful for introducing or rearranging type parameters. The &lt;code&gt;Flip&lt;/code&gt; newtype from &lt;code&gt;Data.Bifunctor.Flip&lt;/code&gt; is a simple example, flipping the arguments of a &lt;code&gt;Bifunctor&lt;/code&gt; so the &lt;code&gt;Functor&lt;/code&gt; instance may operate on the other side:&lt;/p&gt;
  &lt;div class="brush: haskell"&gt;
   &lt;div class="source"&gt;
    &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Flip&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Flip&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;runFlip&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
  &lt;p&gt;Newtypes are needed to do this sort of juggling, as Haskell does not (yet) support type-level lambdas.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;More simply, transparent newtypes can be useful to discourage misuse when the value needs to be passed between distant parts of the program and the intermediate code has no reason to inspect the value. For example, a &lt;code&gt;ByteString&lt;/code&gt; containing a secret key may be wrapped in a newtype (with a &lt;code&gt;Show&lt;/code&gt; instance omitted) to discourage code from accidentally logging or otherwise exposing it.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;All of these applications are good ones, but they have little to do with &lt;em&gt;type safety.&lt;/em&gt; The last bullet in particular is often confused for safety, and to be fair, it does in fact take advantage of the type system to help avoid logical mistakes. However, it would be a mischaracterization to claim such usage actually &lt;em&gt;prevents&lt;/em&gt; misuse; any part of the program may inspect the value at any time.&lt;/p&gt;

&lt;p&gt;Too often, this illusion of safety leads to outright newtype abuse. For example, here’s a definition from the very codebase I work on for a living:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;ArgumentName&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ArgumentName&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;unArgumentName&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;GraphQL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FromJSONKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSONKey&lt;/span&gt;
           &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Hashable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToTxt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Lift&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;NFData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Cacheable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This newtype is useless noise. Functionally, it is completely interchangeable with its underlying &lt;code&gt;Name&lt;/code&gt; type, so much so that it derives a dozen typeclasses! In every location it’s used, it’s immediately unwrapped the instant it’s extracted from its enclosing record, so there is no type safety benefit whatsoever. Worse, there isn’t even any clarity added by labeling it an &lt;code&gt;ArgumentName&lt;/code&gt;, since the enclosing field name already makes its role clear.&lt;/p&gt;

&lt;p&gt;Newtypes like these seem to arise from a desire to use the type system as a taxonomy of the external world. An “argument name” is a more specific concept than a generic “name,” so surely it ought to have its own type. This makes some intuitive sense, but it’s rather misguided: taxonomies are useful for documenting a domain of interest, but not necessarily helpful for modeling it. When programming, we use types for a different end:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Primarily, types distinguish &lt;em&gt;functional&lt;/em&gt; differences between values. A value of type &lt;code&gt;NonEmpty a&lt;/code&gt; is &lt;em&gt;functionally&lt;/em&gt; distinct from a value of type &lt;code&gt;[a]&lt;/code&gt;, since it is fundamentally structurally different and permits additional operations. In this sense, types are &lt;em&gt;structural&lt;/em&gt;; they describe what values &lt;em&gt;are&lt;/em&gt; in the internal world of the programming language.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Secondarily, we sometimes use types to help ourselves avoid making logical mistakes. We might use separate &lt;code&gt;Distance&lt;/code&gt; and &lt;code&gt;Duration&lt;/code&gt; types to avoid accidentally doing something nonsensical like adding them together, even though they’re both representationally real numbers.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Note that both these uses are &lt;em&gt;pragmatic&lt;/em&gt;; they look at the type system as a tool. This is a rather natural perspective to take, seeing as a static type system &lt;em&gt;is&lt;/em&gt; a tool in a literal sense. Nevertheless, that perspective seems surprisingly unusual, even though the use of types to classify the world routinely yields unhelpful noise like &lt;code&gt;ArgumentName&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If a newtype is completely transparent, and it is routinely wrapped and unwrapped at will, it is likely not very helpful. In this particular case, I would eliminate the distinction altogether and use &lt;code&gt;Name&lt;/code&gt;, but in situations where the different label adds genuine clarity, one can always use a type alias:&lt;sup&gt;&lt;a href="#2020-11-01-names-are-not-type-safety-footnote-3-definition" name="2020-11-01-names-are-not-type-safety-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;ArgumentName&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;GraphQL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Newtypes like these are security blankets. Forcing programmers to jump through a few hoops is not type safety—trust me when I say they will happily jump through them without a second thought.&lt;/p&gt;

&lt;h1 id="final-thoughts-and-related-reading"&gt;Final thoughts and related reading&lt;/h1&gt;

&lt;p&gt;I’ve been wanting to write this blog post for a long time. Ostensibly, it’s a very specific critique of Haskell newtypes, and I’ve chosen to frame things this way because I write Haskell for a living and this is the way I encounter this problem in practice. Really, though, the core idea is much bigger than that.&lt;/p&gt;

&lt;p&gt;Newtypes are one particular mechanism of defining &lt;em&gt;wrapper types&lt;/em&gt;, a concept that exists in almost any language, even those that are dynamically typed. Even if you don’t write Haskell, much of the reasoning in this blog post is likely still relevant in your language of choice. More broadly, this is a continuation of a theme I’ve been trying to convey from different angles over the past year: type systems are tools, and we should be more conscious and intentional about what they actually do and how to use them effectively.&lt;/p&gt;

&lt;p&gt;The catalyst that got me to finally sit down and write this was the recently-published &lt;a href="https://tech.freckle.com/2020/10/26/tagged-is-not-a-newtype/"&gt;Tagged is not a Newtype&lt;/a&gt;. It’s a good blog post, and I wholeheartedly agree with its general thrust, but I thought it was a missed opportunity to make a larger point. Indeed, &lt;code&gt;Tagged&lt;/code&gt; &lt;em&gt;is&lt;/em&gt; a newtype, definitionally, so the title of the blog post is something of a misdirection. The real problem is a little deeper.&lt;/p&gt;

&lt;p&gt;Newtypes are useful when carefully applied, but their safety is not intrinsic, no more than the safety of a traffic cone is somehow contained within the plastic it’s made of. What matters is being placed in the right context—without that, newtypes are just a labeling scheme, a way of giving something a name.&lt;/p&gt;

&lt;p&gt;And a name is not type safety.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2020-11-01-names-are-not-type-safety-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Admittedly rather unlikely given its name, but bear with me through the contrived example.&amp;nbsp;&lt;a href="#2020-11-01-names-are-not-type-safety-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-11-01-names-are-not-type-safety-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;In theory, it is still possible to thoroughly prove the invariant holds using external verification techniques, such as by writing a pen-and-paper proof or by using program extraction in combination with a proof assistant/theorem prover. However, these techniques are extremely uncommon in general programming practice.&amp;nbsp;&lt;a href="#2020-11-01-names-are-not-type-safety-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-11-01-names-are-not-type-safety-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;As it happens, I think type aliases are often also more harmful than helpful, so I would caution against overusing them, too, but that is outside the scope of this blog post.&amp;nbsp;&lt;a href="#2020-11-01-names-are-not-type-safety-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Types as axioms, or: playing god with static types</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/?utm_source=functional-programming&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2020-08-13-types-as-axioms-or-playing-god-with-static-types</id>
  <published>2020-08-13T13:51:57Z</published>
  <updated>2020-08-13T13:51:57Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;Just what exactly &lt;em&gt;is&lt;/em&gt; a type?&lt;/p&gt;

&lt;p&gt;A common perspective is that types are &lt;em&gt;restrictions&lt;/em&gt;. Static types restrict the set of values a variable may contain, capturing some subset of the space of “all possible values.” Under this worldview, a typechecker is sort of like an oracle, predicting which values will end up where when the program runs and making sure they satisfy the constraints the programmer wrote down in the type annotations. Of course, the typechecker can’t &lt;em&gt;really&lt;/em&gt; predict the future, so when the typechecker gets it wrong—it can’t “figure out” what a value will be—static types can feel like self-inflicted shackles.&lt;/p&gt;

&lt;p&gt;But that is not the &lt;em&gt;only&lt;/em&gt; perspective. There is another way—a way that puts you, the programmer, back in the driver’s seat. You make the rules, you call the shots, you set the objectives. You need not be limited any longer by what the designers of your programming language decided the typechecker can and cannot prove. You do not serve the typechecker; the typechecker serves &lt;em&gt;you.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;…no, I’m not trying to sell you a dubious self-help book for programmers who feel like they’ve lost control of their lives. If the above sounds too good to be true, well… I won’t pretend it’s all actually as easy as I make it sound. Nevertheless, it’s well within the reach of the working programmer, and most remarkably, all it takes is a change in perspective.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="seeing-the-types-half-empty"&gt;Seeing the types half-empty&lt;/h1&gt;

&lt;p&gt;Let’s talk a little about TypeScript.&lt;/p&gt;

&lt;p&gt;TypeScript is a &lt;em&gt;gradually-typed&lt;/em&gt; language, which means it’s possible to mix statically- and dynamically-typed code. The original intended use case of gradual typing was to &lt;em&gt;gradually&lt;/em&gt; add static types to an existing dynamically-typed codebase, which imposes some interesting design constraints. For one, a valid JavaScript program must also be a valid TypeScript program; for another, TypeScript must be accommodating of traditional JavaScript idioms.&lt;/p&gt;

&lt;p&gt;Gradually typed languages like TypeScript are particularly good illustrations of the way type annotations can be viewed as constraints. A function with no explicit type declarations&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-1-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; can accept &lt;em&gt;any&lt;/em&gt; JavaScript value, so adding a type annotation fundamentally restricts the set of legal values.&lt;/p&gt;

&lt;p&gt;Furthermore, languages like TypeScript tend to have subtyping. This makes it easy to classify certain types as “more restrictive” than others. For example, a type like &lt;code&gt;string | number&lt;/code&gt; clearly includes more values than just &lt;code&gt;number&lt;/code&gt;, so &lt;code&gt;number&lt;/code&gt; is a more restrictive type—a &lt;em&gt;subtype&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;An exceptionally concrete way to illustrate this “types are restrictions” mentality is to write a function with an unnecessarily specific type. Here’s a TypeScript function that returns the first element in an array of numbers:&lt;/p&gt;

&lt;div class="brush: typescript"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;getFirst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arr&lt;/span&gt;: &lt;span class="kt"&gt;number&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;number&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kc"&gt;undefined&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If we ignore the type annotations and consider only the dynamic semantics of JavaScript, this function would work perfectly well given a list of strings. However, if we write &lt;code&gt;getFirst(["hello", "world"])&lt;/code&gt;, the typechecker will complain. In this example, the restriction is thoroughly self-imposed—it would be easy to give this function a more generic type—but it’s not always that easy. For example, suppose we wrote a function where the return type depends upon the type of the argument:&lt;/p&gt;

&lt;div class="brush: typescript"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;emptyLike&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;val&lt;/span&gt;: &lt;span class="kt"&gt;number&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;number&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="s2"&gt;"number"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now if we write &lt;code&gt;emptyLike(42) * 10&lt;/code&gt;, the typechecker will once again complain, claiming the result might be a string—it can’t “figure out” that when we pass a number, we always get a number back.&lt;/p&gt;

&lt;p&gt;When type systems are approached from this perspective, the result is often frustration. The programmer knows that the equivalent untyped JavaScript is perfectly well-behaved, so the typechecker comes off as being the highly unfortunate combination of stubborn yet dim-witted. What’s more, the programmer likely has little mental model of the typechecker’s internal operation, so when types like the above are inferred (not explicitly written), it can be unclear what solutions exist to make the error go away.&lt;/p&gt;

&lt;p&gt;At this point, the programmer may give up. “Stupid typechecker,” they grumble, changing the return type of &lt;code&gt;emptyLike&lt;/code&gt; to &lt;code&gt;any&lt;/code&gt;. “If it can’t even figure this out, can it &lt;em&gt;really&lt;/em&gt; be all that useful?”&lt;/p&gt;

&lt;p&gt;Sadly, this relationship with the typechecker is all too common, and gradually-typed languages in particular tend to create a vicious cycle of frustration:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Gradual type systems are intentionally designed to “just work” on idiomatic code as much as possible, so programmers may not think much about the types except when they get type errors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Furthermore, many programmers using gradually-typed languages are already adept at programming in the underlying dynamically-typed language, so they have working mental models of program operation in terms of the dynamic semantics alone. They are much less likely to develop a rich mental model of the static semantics of the type system because they are used to reasoning without one.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Gradually typed languages must support idioms from their dynamically-typed heritage, so they often include ad-hoc special cases (such as, for example, special treatment of &lt;code&gt;typeof&lt;/code&gt; checks) that obscure the rules the typechecker follows and make them seem semi-magical.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Builtin types are deeply blessed in the type system, strongly encouraging programmers to embrace their full flexibility, but leaving little recourse when they run up against their limits.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All this frustration breeds a readiness to override the typechecker using casts or &lt;code&gt;any&lt;/code&gt;, which ultimately creates a self-fulfilling prophecy in which the typechecker rarely catches any interesting mistakes because it has been so routinely disabled.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The end result of all of this is a defeatist attitude that views the typechecker as a minor tooling convenience at best (i.e. a fancy autocomplete provider) or an active impediment at worst. Who can really blame them? The type system has (unintentionally of course) been designed in such a way so as to lead them into this dead end. The public perception of type systems settles into that of a strikingly literal nitpicker we endure rather than as a tool we actively leverage.&lt;/p&gt;

&lt;h1 id="taking-back-types"&gt;Taking back types&lt;/h1&gt;

&lt;p&gt;After everything I said above, it may be hard to imagine seeing types any other way. Indeed, through the lens of TypeScript, the “types are restrictions” mentality is incredibly natural, so much so that it seems self-evident. But let’s move away from TypeScript for a moment and focus on a different language, Haskell, which encourages a somewhat different perspective. If you aren’t familiar with Haskell, that’s alright—I’m going to try to keep the examples in this blog post as accessible as possible whether you’ve written any Haskell or not.&lt;/p&gt;

&lt;p&gt;Though Haskell and TypeScript are both statically-typed—and both of their type systems are fairly sophisticated—Haskell’s type system is almost completely different philosophically:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Haskell does not have subtyping,&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-2-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; which means that every value belongs to exactly one type.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;While JavaScript is built around a small handful of flexible builtin datatypes (booleans, numbers, strings, arrays, and objects), Haskell has essentially no blessed, built-in datatypes other than numbers. Key types such as booleans, lists, and tuples are ordinary datatypes defined in the standard library, no different from types users could define.&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-3-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In particular, Haskell is built around the idea that datatypes can be defined with multiple &lt;em&gt;cases&lt;/em&gt;, and branching is done via pattern-matching (more on this shortly).&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Let’s look at a basic Haskell datatype declaration. Suppose we want to define a type that represents a season:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Spring&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Summer&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Fall&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Winter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If you are familiar with TypeScript, this may look rather similar to a union type; if you’re familiar with a C-family language, this may remind you more of an enum. Both are on the right track: this defines a new type named &lt;code&gt;Season&lt;/code&gt; with four possible values, &lt;code&gt;Spring&lt;/code&gt;, &lt;code&gt;Summer&lt;/code&gt;, &lt;code&gt;Fall&lt;/code&gt;, and &lt;code&gt;Winter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But what exactly &lt;em&gt;are&lt;/em&gt; those values?&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;In TypeScript, we’d represent this type with a union of strings, like this:&lt;/p&gt;
  &lt;div class="brush: ts"&gt;
   &lt;div class="source"&gt;
    &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"spring"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"summer"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"fall"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"winter"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
  &lt;p&gt;Here, &lt;code&gt;Season&lt;/code&gt; is a type that can be one of those four strings, but nothing else.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In C, we’d represent this type with an enum, like this:&lt;/p&gt;
  &lt;div class="brush: c"&gt;
   &lt;div class="source"&gt;
    &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;SPRING&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SUMMER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FALL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;WINTER&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
  &lt;p&gt;Here, &lt;code&gt;SPRING&lt;/code&gt;, &lt;code&gt;SUMMER&lt;/code&gt;, &lt;code&gt;FALL&lt;/code&gt;, and &lt;code&gt;WINTER&lt;/code&gt; are essentially defined to be global aliases for the integers &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;, and the type &lt;code&gt;enum season&lt;/code&gt; is essentially an alias for &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;So in TypeScript, the values are strings, and in C, the values are numbers. What are they in Haskell? Well… they simply &lt;em&gt;are&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The Haskell declaration invents four completely new constants out of thin air, &lt;code&gt;Spring&lt;/code&gt;, &lt;code&gt;Summer&lt;/code&gt;, &lt;code&gt;Fall&lt;/code&gt;, and &lt;code&gt;Winter&lt;/code&gt;. They aren’t aliases for numbers, nor are they symbols or strings. The compiler doesn’t expose anything about how it chooses to represent these values at runtime; that’s an implementation detail. In Haskell, &lt;code&gt;Spring&lt;/code&gt; is now a value &lt;em&gt;distinct from all other values&lt;/em&gt;, even if someone in a different module were to also use the name &lt;code&gt;Spring&lt;/code&gt;. Haskell type declarations let us play god, creating something from nothing.&lt;/p&gt;

&lt;p&gt;Since these values are totally unique, abstract constants, what can we actually do with them? The answer is one thing and &lt;em&gt;exactly&lt;/em&gt; one thing: we can branch on them. For example, we can write a function that takes a &lt;code&gt;Season&lt;/code&gt; as an argument and returns whether or not Christmas occurs during it:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;containsChristmas&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="nf"&gt;containsChristmas&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Spring&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
  &lt;span class="kt"&gt;Summer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="c1"&gt;-- southern hemisphere&lt;/span&gt;
  &lt;span class="kt"&gt;Fall&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
  &lt;span class="kt"&gt;Winter&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="c1"&gt;-- northern hemisphere&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;case&lt;/code&gt; expressions are, to a first approximation, a lot like C-style &lt;code&gt;switch&lt;/code&gt; statements (though they can do a lot more than this simple example suggests). Using &lt;code&gt;case&lt;/code&gt;, we can also define conversions from our totally unique &lt;code&gt;Season&lt;/code&gt; constants to other types, if we want:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;seasonToString&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;span class="nf"&gt;seasonToString&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Spring&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"spring"&lt;/span&gt;
  &lt;span class="kt"&gt;Summer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"summer"&lt;/span&gt;
  &lt;span class="kt"&gt;Fall&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"fall"&lt;/span&gt;
  &lt;span class="kt"&gt;Winter&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"winter"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We can also go the other way around, converting a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Season&lt;/code&gt;, but if we try, we run into a problem: what do we return for a string like, say, &lt;code&gt;"cheesecake"&lt;/code&gt;? In other languages, we might throw an error or return &lt;code&gt;null&lt;/code&gt;, but Haskell does not have &lt;code&gt;null&lt;/code&gt;, and errors are generally reserved for truly catastrophic failures. What can we do instead?&lt;/p&gt;

&lt;p&gt;A particularly naïve solution would be to create a type called &lt;code&gt;MaybeASeason&lt;/code&gt; that has two cases—it can be a valid &lt;code&gt;Season&lt;/code&gt;, or it can be &lt;code&gt;NotASeason&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;MaybeASeason&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;NotASeason&lt;/span&gt;

&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MaybeASeason&lt;/span&gt;
&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="s"&gt;"spring"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Spring&lt;/span&gt;
  &lt;span class="s"&gt;"summer"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Summer&lt;/span&gt;
  &lt;span class="s"&gt;"fall"&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Fall&lt;/span&gt;
  &lt;span class="s"&gt;"winter"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Winter&lt;/span&gt;
  &lt;span class="kr"&gt;_&lt;/span&gt;        &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;NotASeason&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This shows a feature of Haskell datatypes that C-style enums do &lt;em&gt;not&lt;/em&gt; have: they aren’t just constants, they can contain other values. A &lt;code&gt;MaybeASeason&lt;/code&gt; can be one of five different values: &lt;code&gt;IsASeason Spring&lt;/code&gt;, &lt;code&gt;IsASeason Summer&lt;/code&gt;, &lt;code&gt;IsASeason Fall&lt;/code&gt;, &lt;code&gt;IsASeason Winter&lt;/code&gt;, or &lt;code&gt;NotASeason&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In TypeScript, we’d write &lt;code&gt;MaybeASeason&lt;/code&gt; more like this:&lt;/p&gt;

&lt;div class="brush: ts"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;MaybeASeason&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"not-a-season"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is kind of nice, because we don’t have to wrap all our &lt;code&gt;Season&lt;/code&gt; values with &lt;code&gt;IsASeason&lt;/code&gt; like we have to do in Haskell. But remember that Haskell doesn’t have subtyping—every value must belong to exactly one type—so the Haskell code needs the &lt;code&gt;IsASeason&lt;/code&gt; wrapper to distinguish the value as a &lt;code&gt;MaybeASeason&lt;/code&gt; rather than a &lt;code&gt;Season&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, you may rightly point out that having to invent a type like &lt;code&gt;MaybeASeason&lt;/code&gt; every time we need to create a variant of a type with a failure case is absurd, so fortunately we can define a type like &lt;code&gt;MaybeASeason&lt;/code&gt; that works for &lt;em&gt;any&lt;/em&gt; underlying type. In Haskell, it looks like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This defines a generic type, where the &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;Maybe a&lt;/code&gt; is a stand-in for some other type, much like the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; in other languages. We can change our &lt;code&gt;stringToSeason&lt;/code&gt; function to use &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt;
&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="s"&gt;"spring"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Spring&lt;/span&gt;
  &lt;span class="s"&gt;"summer"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Summer&lt;/span&gt;
  &lt;span class="s"&gt;"fall"&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Fall&lt;/span&gt;
  &lt;span class="s"&gt;"winter"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Winter&lt;/span&gt;
  &lt;span class="kr"&gt;_&lt;/span&gt;        &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; gets us something a lot like nullable types, but it isn’t built into the type system, it’s just an ordinary type defined in the standard library.&lt;/p&gt;

&lt;h2 id="positive-versus-negative-space"&gt;Positive versus negative space&lt;/h2&gt;

&lt;p&gt;At this point, you may be wondering to yourself why I am talking about all of this, seeing as everything in the previous section is information you could find in a basic Haskell tutorial. But the point of this blog post is not to teach you Haskell, it’s to focus on a particular philosophical approach to modeling data.&lt;/p&gt;

&lt;p&gt;In TypeScript, when we write a type declaration like&lt;/p&gt;

&lt;div class="brush: ts"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"summer"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"spring"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"fall"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"winter"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;we are defining a type that can be one of those four strings &lt;em&gt;and nothing else&lt;/em&gt;. All the other strings that &lt;em&gt;aren’t&lt;/em&gt; one of those four make up &lt;code&gt;Season&lt;/code&gt;’s “negative space”—values that exist, but that we have intentionally excluded. In contrast, the Haskell type does not really have any “negative space” because we pulled four new values out of thin air.&lt;/p&gt;

&lt;p&gt;Of course, I suspect you don’t really buy this argument. What makes a string like &lt;code&gt;"cheesecake"&lt;/code&gt; “negative space” in TypeScript but not in Haskell? Well… nothing, really. The distinction I’m drawing here doesn’t really exist, it’s just a different perspective, and arguably a totally contrived and arbitrary one. But now that I’ve explained the premise and set up some context, let me provide a more compelling example.&lt;/p&gt;

&lt;p&gt;Suppose you are writing a TypeScript program, and you want a function that only accepts &lt;em&gt;non-empty&lt;/em&gt; arrays. What can you do? Your first instinct is that you need a way to somehow further restrict the function’s input type to exclude empty arrays. And indeed, there &lt;em&gt;is&lt;/em&gt; a trick for doing that:&lt;/p&gt;

&lt;div class="brush: ts"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;NonEmptyArray&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;[]];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Great! But what if the constraint was more complicated: what if you needed an array containing an even number of elements? Unfortunately, there isn’t really a trick for that one. At this point, you might start wishing the type system had support for something really fancy, like refinement types, so you could write something like this:&lt;/p&gt;

&lt;div class="brush: ts"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;EvenArray&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="nx"&gt;satisfies&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But TypeScript doesn’t support anything like that, so for now you’re stuck. You need a way to restrict the function’s domain in a way the type system does not have any special support for, so your conclusion might be “I guess the type system just can’t do this.” People tend to call this “running up against the limits of the type system.”&lt;/p&gt;

&lt;p&gt;But what if we took a different perspective? Recall that in Haskell, lists aren’t built-in datatypes, they’re just ordinary datatypes defined in the standard library:&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-4-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-4-return"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Cons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This type might be a bit confusing at first if you have not written any Haskell, since it’s &lt;em&gt;recursive&lt;/em&gt;. All of these are valid values of type &lt;code&gt;List Int&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;Nil&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;Cons 1 Nil&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;Cons 1 (Cons 2 Nil)&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;Cons 1 (Cons 2 (Cons 3 Nil))&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The recursive nature of &lt;code&gt;Cons&lt;/code&gt; is what gives our user-defined datatype the ability to hold any number of values: we can have any number of nested &lt;code&gt;Cons&lt;/code&gt;es we want before we terminate the list with a final &lt;code&gt;Nil&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we wanted to define an &lt;code&gt;EvenList&lt;/code&gt; type in Haskell, we might end up thinking along the same lines we did before, that we need some fancy type system extension so we can restrict &lt;code&gt;List&lt;/code&gt; to exclude lists with odd numbers of elements. But that’s focusing on the negative space of things we want to exclude… what if instead, we focused on the &lt;em&gt;positive&lt;/em&gt; space of things we want to &lt;em&gt;include?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;What do I mean by that? Well, we could define an entirely new type that’s just like &lt;code&gt;List&lt;/code&gt;, but we make it &lt;em&gt;impossible&lt;/em&gt; to ever include an odd number of elements:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Here are some valid values of type &lt;code&gt;EvenList Int&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;EvenNil&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;EvenCons 1 2 EvenNil&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;EvenCons 1 2 (EvenCons 3 4 EvenNil)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Lo and behold, a datatype that can only ever include even numbers of elements!&lt;/p&gt;

&lt;p&gt;Now, at this point you might realize that this is kind of silly. We don’t need to invent an entirely new datatype for this! We could just create a list of pairs:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now values like &lt;code&gt;Cons (1, 2) (Cons (3, 4) Nil)&lt;/code&gt; would be valid values of type &lt;code&gt;EvenList Int&lt;/code&gt;, and we wouldn’t have to reinvent lists. But again, this is an approach based on thinking not on which values we want to exclude, but rather how to structure our data such that those illegal values aren’t even &lt;em&gt;constructible.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This is the essence of the Haskeller’s mantra, “Make illegal states unrepresentable,”&lt;/strong&gt; and sadly it is often misinterpreted. It’s much easier to think “hm, I want to make these states illegal, how can I add some post-hoc restrictions to rule them out?” And indeed, this is why refinement types really &lt;em&gt;are&lt;/em&gt; awesome, and when they’re available, by all means use them! But checking totally arbitrary properties at the type level is not tractable in general, and sometimes you need to think a little more outside the box.&lt;/p&gt;

&lt;h2 id="types-as-axiom-schemas"&gt;Types as axiom schemas&lt;/h2&gt;

&lt;p&gt;So far in this blog post, I’ve repeatedly touched upon a handful of different ideas in a few different ways:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Instead of thinking about how to &lt;em&gt;restrict&lt;/em&gt;, it can be useful to think about how to &lt;em&gt;correctly construct&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In Haskell, datatype declarations invent new values out of thin air.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;We can represent a &lt;em&gt;lot&lt;/em&gt; of different data structures using the incredibly simple framework of “datatypes with several possibilities.”&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Independently, those ideas might not seem deeply related, but in fact, they’re all essential to the Haskell school of data modeling. I want to now explore how we can unify them into a single framework that makes this seem less magical and more like an iterative design process.&lt;/p&gt;

&lt;p&gt;In Haskell, when you define a datatype, you’re really defining a new, self-contained set of &lt;em&gt;axioms&lt;/em&gt; and &lt;em&gt;inference rules.&lt;/em&gt; That is rather abstract, so let’s make it more concrete. Consider the &lt;code&gt;List&lt;/code&gt; type again:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Cons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Viewed as an axiom schema, this type has one axiom and one inference rule:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The empty list is a list.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If you have a list, and you add an element to the beginning, the result is also a list.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The axiom is &lt;code&gt;Nil&lt;/code&gt;, and the inference rule is &lt;code&gt;Cons&lt;/code&gt;. Every list&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-5-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-5-return"&gt;5&lt;/a&gt;&lt;/sup&gt; is constructed by starting with the axiom, &lt;code&gt;Nil&lt;/code&gt;, followed by some number of applications of the inference rule, &lt;code&gt;Cons&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can take a similar approach when designing the &lt;code&gt;EvenList&lt;/code&gt; type. The axiom is the same:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The empty list is a list with an even number of elements.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;But our inference rule must preserve the invariant that the list always contains an even number of elements. We can do this by always adding two elements at a time:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;If you have a list with an even number of elements, and you add two elements to the beginning, the result is also a list with an even number of elements.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This corresponds precisely to our &lt;code&gt;EvenList&lt;/code&gt; declaration:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We can also go through this same reasoning process to come up with a type that represents non-empty lists. That type has just one inference rule:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;If you have a list, and you add an element to the beginning, the result is a non-empty list.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;That inference rule corresponds to the following datatype:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;NonEmptyList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmptyCons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Of course, it’s possible to do this with much more than just lists. A particularly classic example is the constructive definition of natural numbers:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Zero is a natural number.&lt;/li&gt;
 &lt;li&gt;If you have a natural number, its successor (i.e. that number plus one) is also a natural number.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;These are two of the &lt;a href="https://en.wikipedia.org/wiki/Peano_axioms"&gt;Peano axioms&lt;/a&gt;, which can be represented in Haskell as the following datatype:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Zero&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Succ&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Using this type, &lt;code&gt;Zero&lt;/code&gt; represents 0, &lt;code&gt;Succ Zero&lt;/code&gt; represents 1, &lt;code&gt;Succ (Succ Zero)&lt;/code&gt; represents 2, and so on. Just as &lt;code&gt;EvenList&lt;/code&gt; allowed us to represent any list with an even number of elements but made other values impossible to even express, this &lt;code&gt;Natural&lt;/code&gt; type allows us to represent all natural numbers, while other numbers (such as, for example, negative integers) are impossible to express.&lt;/p&gt;

&lt;p&gt;Now, of course, all this hinges on our interpretation of the values we’ve invented! We have chosen to interpret &lt;code&gt;Zero&lt;/code&gt; as &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;Succ n&lt;/code&gt; as &lt;code&gt;n + 1&lt;/code&gt;, but that interpretation is not inherent to &lt;code&gt;Natural&lt;/code&gt;’s definition—it’s all in our heads! We could choose to interpret &lt;code&gt;Succ n&lt;/code&gt; as &lt;code&gt;n - 1&lt;/code&gt; instead, in which case we would only be able to represent non-positive integers, or we could interpret &lt;code&gt;Zero&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;Succ n&lt;/code&gt; as &lt;code&gt;n * 2&lt;/code&gt;, in which case we could only represent powers of two.&lt;/p&gt;

&lt;p&gt;I find that people sometimes find this approach troubling, or at least counterintuitive. Is &lt;code&gt;Succ (Succ Zero)&lt;/code&gt; &lt;em&gt;really&lt;/em&gt; 2? It certainly doesn’t look like a number we’re used to writing. When someone thinks “I need a datatype for a number greater than or equal to zero,” they’re going to reach for the type in their programming language called &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;, not think to invent a recursive datatype. And admittedly, the &lt;code&gt;Natural&lt;/code&gt; type defined here is not very practical: it’s an incredibly inefficient representation of natural numbers.&lt;/p&gt;

&lt;p&gt;But in less contrived situations, this approach &lt;em&gt;is&lt;/em&gt; practical, and in fact it’s highly useful! The quibble that an &lt;code&gt;EvenList Int&lt;/code&gt; isn’t “really” a &lt;code&gt;List Int&lt;/code&gt; is rather meaningless, seeing as our definition of &lt;code&gt;List&lt;/code&gt; was just as arbitrary. A great deal of our jobs as programmers is imbuing arbitrary symbols with meaning; at some point someone decided that the number 65 would correspond to the capital letter A, and it was no less arbitrary then.&lt;/p&gt;

&lt;p&gt;So when you have a property you want to capture in your types, take a step back and think about it for a little bit. Is there a way you can structure your data so that, no matter how you build it, the result is always a valid value? In other words, don’t try to add post-hoc restrictions to exclude bad values, &lt;strong&gt;make your datatypes correct by construction&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id="but-what-if-i-dont-write-haskell-and-other-closing-thoughts"&gt;“But what if I don’t write Haskell?” And other closing thoughts&lt;/h1&gt;

&lt;p&gt;I write Haskell for a living, and I wrote this blog post with both my coworkers and the broader Haskell community in mind, but if I had &lt;em&gt;only&lt;/em&gt; written it with those people in mind, it wouldn’t make sense to have spent so much time explaining basic Haskell. These techniques can be used in almost any statically typed programming language, though it’s certainly easier in some than others.&lt;/p&gt;

&lt;p&gt;I don’t want people to come away from this blog post with an impression that I think TypeScript is a bad language, or that I’m claiming Haskell can do things TypeScript can’t. In fact, TypeScript &lt;em&gt;can&lt;/em&gt; do all the things I’ve talked about in this blog post! As proof, here are TypeScript definitions of both &lt;code&gt;EvenList&lt;/code&gt; and &lt;code&gt;Natural&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: typescript"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;EvenList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;EvenList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Natural&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"zero"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;succ&lt;/span&gt;: &lt;span class="kt"&gt;Natural&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If anything, &lt;strong&gt;the real point of this blog post is that a type system does not have a well-defined list of things it “can prove” and “can’t prove.”&lt;/strong&gt; Languages like TypeScript don’t really encourage this approach to data modeling, where you restructure your values in a certain way so as to guarantee certain properties. Rather, they prefer to add increasingly sophisticated constraints and type system features that can capture the properties people want to capture without having to change their data representation.&lt;/p&gt;

&lt;p&gt;And in general, &lt;em&gt;that’s great!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Being able to reuse the same data representation is &lt;em&gt;hugely&lt;/em&gt; beneficial. Functions like &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; already exist for ordinary lists/arrays, but a home-grown &lt;code&gt;EvenList&lt;/code&gt; type needs its own versions. Passing an &lt;code&gt;EvenList&lt;/code&gt; to a function that expects a list requires explicitly converting between the two. All these things have both code complexity and performance costs, and type system features that make these issues just invisibly disappear are &lt;em&gt;obviously&lt;/em&gt; a good thing.&lt;/p&gt;

&lt;p&gt;But the danger of treating the type system this way is that it means you may find yourself unsure what to do when suddenly you have a new requirement that the type system doesn’t provide built-in support for. What then? Do you start punching holes through your type system? The more you do that, the less useful the type system becomes: type systems are great at detecting how changes in one part of a codebase can impact seemingly-unrelated areas in surprising ways, but every unsafe cast or use of &lt;code&gt;any&lt;/code&gt; is a hard stop, a point past which the typechecker cannot propagate information. Do that once or twice in a leaf function, it’s okay, but do that even just a half dozen times in your application’s connective tissue, and your type system might not be able to catch those things anymore.&lt;/p&gt;

&lt;p&gt;Even if it isn’t a technique you use every day, it’s worth getting comfortable tweaking your data representation to preserve those guarantees. It’s a magical experience having the typechecker teach you things about your domain you hadn’t even considered simply because you got a type error and started thinking through why. Yes, it’s extra work, but trust me: it’s a lot more pleasant to work for your typechecker when you know exactly how much your typechecker is working for you.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Sort of. TypeScript will try to infer type annotations based on how variables and functions are used, but by default, it falls back on the dynamic, unchecked &lt;code&gt;any&lt;/code&gt; type if it can’t find a solution that makes the program typecheck. That behavior can be changed via a configuration option, but that isn’t relevant here: I’m just trying to illustrate a perspective, not make any kind of value judgment about TypeScript specifically.&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;Sort of. Haskell does have a limited notion of subtyping when polymorphism is involved; for example, the type &lt;code&gt;forall a. a -&amp;gt; a&lt;/code&gt; is a subtype of the type &lt;code&gt;Int -&amp;gt; Int&lt;/code&gt;. But Haskell does not have anything resembling inheritance (e.g. there is no common &lt;code&gt;Number&lt;/code&gt; supertype that includes both &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt;) nor does it have untagged unions (e.g. the argument to a function cannot be something like &lt;code&gt;Int | String&lt;/code&gt;, you must define a wrapper type like &lt;code&gt;data IntOrString = AnInt Int | AString String&lt;/code&gt;).&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;Lists, tuples, and strings do technically have special &lt;em&gt;syntax&lt;/em&gt;, which is built into the compiler, but there is truly nothing special about their semantics. They would work exactly the same way without the syntax, the code would just look less pretty.&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-4-definition" class="footnote-definition"&gt;
   &lt;p&gt;Haskell programmers will notice that this is not actually the definition of the list type, since the real list type uses special syntax, but I wanted to keep things as simple as possible for this blog post.&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-4-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-5-definition" class="footnote-definition"&gt;
   &lt;p&gt;Ignoring infinite lists, but the fact that infinite lists are representable in Haskell is outside the scope of this blog post.&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-5-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">No, dynamic type systems are not inherently more open</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/?utm_source=functional-programming&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open</id>
  <published>2020-01-19T00:00:00Z</published>
  <updated>2020-01-19T00:00:00Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;Internet debates about typing disciplines continue to be plagued by a pervasive myth that dynamic type systems are inherently better at modeling “open world” domains. The argument usually goes like this: the goal of static typing is to pin everything down as much as possible, but in the real world, that just isn’t practical. Real systems should be loosely coupled and worry about data representation as little as possible, so dynamic types lead to a more robust system in the large.&lt;/p&gt;

&lt;p&gt;This story sounds compelling, but it isn’t true. The flaw is in the premise: static types are &lt;em&gt;not&lt;/em&gt; about “classifying the world” or pinning down the structure of every value in a system. The reality is that static type systems allow specifying exactly how much a component needs to know about the structure of its inputs, and conversely, how much it doesn’t. Indeed, in practice static type systems excel at processing data with only a partially-known structure, as they can be used to ensure application logic doesn’t accidentally assume too much.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="two-typing-fallacies"&gt;Two typing fallacies&lt;/h1&gt;

&lt;p&gt;I’ve wanted to write this blog post for a while, but what finally made me decide to do it were misinformed comments responding to &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;my previous blog post&lt;/a&gt;. Two comments in particular caught my eye, &lt;a href="https://www.reddit.com/r/programming/comments/dt0w63/parse_dont_validate/f6ulpsy/"&gt;the first of which was posted on /r/programming&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Strongly disagree with the post […] it promotes a fundamentally entangled and static view of the world. It assumes that we can or should theorize about what is &amp;ldquo;valid&amp;rdquo; input at the edge between the program and the world, thus introducing a strong sense of coupling through the entire software, where failure to conform to some schema will automatically crash the program.&lt;/p&gt;
 &lt;p&gt;This is touted as a feature here but imagine if the internet worked like this. A server changes their JSON output, and we need to recompile and reprogram the entire internet. This is the static view that is promoted as a feature here. […] The &amp;ldquo;parser mentality&amp;rdquo; is fundamentally rigid and global, whereas robust system design should be decentralised and leave interpretation of data to the receiver.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Given the argument being made in the blog post—that you should use precise types whenever possible—one can see where this misinterpretation comes from. How could a proxy server possibly be written in such a style, since it cannot anticipate the structure of its payloads? The commenter’s conclusion is that strict static typing is at odds with programs that don’t know the structure of their inputs ahead of time.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://news.ycombinator.com/item?id=21479933"&gt;The second comment was left on Hacker News&lt;/a&gt;, and it is significantly shorter than the first one:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;What would be the type signature of, say, Python&amp;rsquo;s &lt;code&gt;pickle.load()&lt;/code&gt;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is a different kind of argument, one that relies on the fact that the types of reflective operations may depend on runtime values, which makes them challenging to capture with static types. This argument suggests that static types limit expressiveness because they forbid such operations outright.&lt;/p&gt;

&lt;p&gt;Both these arguments are fallacious, but in order to show why, we have to make explicit an implicit claim. The two comments focus primarily on illustrating how static type systems can’t process data of an unknown shape, but they simultaneously advance an implicit belief: that dynamically typed languages &lt;em&gt;can&lt;/em&gt; process data of an unknown shape. As we’ll see, this belief is misguided; programs are not capable of processing data of a truly unknown shape regardless of typing discipline, and static type systems only make already-present assumptions explicit.&lt;/p&gt;

&lt;h1 id="you-cant-process-what-you-dont-know"&gt;You can’t process what you don’t know&lt;/h1&gt;

&lt;p&gt;The claim is simple: in a static type system, you must declare the shape of data ahead of time, but in a dynamic type system, the type can be, well, dynamic! It sounds self-evident, so much so that Rich Hickey has practically built a speaking career upon its emotional appeal. The only problem is it isn’t true.&lt;/p&gt;

&lt;p&gt;The hypothetical scenario usually goes like this. Say you have a distributed system, and services in the system emit events that can be consumed by any other service that might need them. Each event is accompanied by a payload, which listening services can use to inform further action. The payload itself is minimally-structured, schemaless data encoded using a generic interchange format such as JSON or &lt;a href="https://github.com/edn-format/edn"&gt;EDN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a simple example, a login service might emit an event like this one whenever a new user signs up:&lt;/p&gt;

&lt;div class="brush: json"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;"event_type"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"signup"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;"timestamp"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"2020-01-19T05:37:09Z"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;"data"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;"user"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;"id"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;"name"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Alyssa"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;"email"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"alyssa@example.com"&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Some downstream services might listen for these &lt;code&gt;signup&lt;/code&gt; events and take further action whenever they are emitted. For example, a transactional email service might send a welcome email whenever a new user signs up. If the service were written in JavaScript, the handler might look something like this:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;login&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="cm"&gt;/* ... */&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;signup&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="nx"&gt;sendEmail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;email&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sb"&gt;`Welcome to Blockchain Emporium, &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;!`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But what if this service were written in Haskell instead? Being good, reality-fearing Haskell programmers who &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;parse, not validate&lt;/a&gt;, the Haskell code might look something like this, instead:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Event&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;Event&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;parseJSON&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;withObject&lt;/span&gt; &lt;span class="s"&gt;"Event"&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;eventType&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"event_type"&lt;/span&gt;
    &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;eventType&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
      &lt;span class="s"&gt;"login"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"data"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="s"&gt;"signup"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"signup"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"unknown event_type: "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;eventType&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromJSON&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Success&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="cm"&gt;{- ... -}&lt;/span&gt;
  &lt;span class="kt"&gt;Success&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;sendEmail&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"Welcome to Blockchain Emporium, "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"!"&lt;/span&gt;
  &lt;span class="kt"&gt;Error&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"could not parse event: "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It’s definitely more boilerplate, but some extra overhead for type definitions is to be expected (and is greatly exaggerated in such tiny examples), and the arguments we’re discussing aren’t about boilerplate, anyway. The &lt;em&gt;real&lt;/em&gt; problem with this version of the code, according to the Reddit comment from earlier, is that the Haskell code has to be updated whenever a service adds a new event type! A new case has to be added to the &lt;code&gt;Event&lt;/code&gt; datatype, and it must be given new parsing logic. And what about when new fields get added to the payload? What a maintenance nightmare.&lt;/p&gt;

&lt;p&gt;In comparison, the JavaScript code is much more permissive. If a new event type is added, it will just fall through the &lt;code&gt;switch&lt;/code&gt; and do nothing. If extra fields are added to the payload, the JavaScript code will just ignore them. Seems like a win for dynamic typing.&lt;/p&gt;

&lt;p&gt;Except that no, it isn’t. The only reason the statically typed program fails if we don’t update the &lt;code&gt;Event&lt;/code&gt; type is that we wrote &lt;code&gt;handleEvent&lt;/code&gt; that way. We could just have easily done the same thing in the JavaScript code, adding a default case that rejects unknown event types:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* ... */&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sb"&gt;`unknown event_type: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We didn’t do that, since in this case it would clearly be silly. If a service receives an event it doesn’t know about, it should just ignore it. This is a case where being permissive is clearly the correct behavior, and we can easily implement that in the Haskell code too:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromJSON&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="cm"&gt;{- ... -}&lt;/span&gt;
  &lt;span class="kt"&gt;Error&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is still in the spirit of “parse, don’t validate” because we’re still parsing the values we &lt;em&gt;do&lt;/em&gt; care about as early as possible, so we don’t fall into the double-validation trap. At no point do we take a code path that depends on a value being well-formed without first ensuring (with the help of the type system) that it is, in fact, actually well-formed. We don’t have to respond to an ill-formed value by raising an error! We just have to be explicit about ignoring it.&lt;/p&gt;

&lt;p&gt;This illustrates an important point: the &lt;code&gt;Event&lt;/code&gt; type in this Haskell code doesn’t describe “all possible events,” it describes all the events that the application cares about. Likewise, the code that parses those events’ payloads only worries about the fields the application needs, and it ignores extraneous ones. A static type system doesn’t require you eagerly write a schema for the whole universe, it simply requires you to be up front about the things you need.&lt;/p&gt;

&lt;p&gt;This turns out to have a lot of pleasant benefits even though knowledge about inputs is limited:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;It’s easy to discover the assumptions of the Haskell program just by looking at the type definitions. We know, for example, that this application doesn’t care about the &lt;code&gt;timestamp&lt;/code&gt; field, since it never appears in any of the payload types. In the dynamically-typed program, we’d have to audit every code path to see whether or not it inspects that field, which would be a lot of error-prone work!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;What’s more, it turns out the Haskell code doesn’t actually &lt;em&gt;use&lt;/em&gt; the &lt;code&gt;userId&lt;/code&gt; field inside the &lt;code&gt;SignupPayload&lt;/code&gt; type, so that type is overly conservative. If we want to ensure it isn’t actually needed (since, for example, maybe we’re phasing out providing the user ID in that payload entirely), we need only delete that record field; if the code typechecks, we can be confident it really doesn’t depend on that field.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, we neatly avoid all the gotchas related to shotgun parsing &lt;a href="/blog/2019/11/05/parse-don-t-validate/#the-danger-of-validation"&gt;mentioned in the previous blog post&lt;/a&gt;, since we still haven’t compromised on any of those principles.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;We’ve already invalidated the first half of the claim: that statically typed languages can’t deal with data where the structure isn’t completely known. Let’s now look at the other half, which states that dynamically typed languages can process data where the structure isn’t known at all. Maybe that still sounds right, but if you slow down and think about it more carefully, you’ll find it can’t be.&lt;/p&gt;

&lt;p&gt;The above JavaScript code makes all the same assumptions our Haskell code does: it assumes event payloads are JSON objects with an &lt;code&gt;event_type&lt;/code&gt; field, and it assumes &lt;code&gt;signup&lt;/code&gt; payloads include &lt;code&gt;data.user.name&lt;/code&gt; and &lt;code&gt;data.user.email&lt;/code&gt; fields. It certainly can’t do anything useful with truly unknown input! If a new event payload is added, our JavaScript code can’t magically adapt to handle it simply because it is dynamically typed. Dynamic typing just means the types of values are carried alongside them at runtime and checked as the program executes; the types are still there, and this program still implicitly relies on them being particular things.&lt;/p&gt;

&lt;h1 id="keeping-opaque-data-opaque"&gt;Keeping opaque data opaque&lt;/h1&gt;

&lt;p&gt;In the previous section, we debunked the idea that statically typed systems can’t process partially-known data, but if you have been paying close attention, you may have noticed it did not fully refute the original claim.&lt;/p&gt;

&lt;p&gt;Although we were able to handle unknown data, we always simply discarded it, which would not fly if we were trying to implement some sort of proxying. For example, suppose we have a forwarding service that broadcasts events over a public network, attaching a signature to each payload to ensure it can’t be spoofed. We might implement this in JavaScript this way:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;signedPayload&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="nx"&gt;retransmitEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;signedPayload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this case, we don’t care about the structure of the payload at all (the &lt;code&gt;signature&lt;/code&gt; function just works on any valid JSON object), but we still have to preserve all the information. How could we do that in a statically typed language, since a statically-typed language would have to assign the payload a precise type?&lt;/p&gt;

&lt;p&gt;Once again, the answer involves rejecting the premise: there’s no need to give data a type that’s any more precise than the application needs. The same logic could be written in a straightforward way in Haskell:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;signedPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"signature"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;
  &lt;span class="n"&gt;retransmitEvent&lt;/span&gt; &lt;span class="n"&gt;signedPayload&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"event payload was not an object "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this case, since we don’t care about the structure of the payload, we manipulate a value of type &lt;code&gt;JSON.Value&lt;/code&gt; directly. This type is extremely imprecise compared to our &lt;code&gt;Event&lt;/code&gt; type from earlier—it can hold any legal JSON value, of any shape—but in this case, we &lt;em&gt;want&lt;/em&gt; it to be imprecise.&lt;/p&gt;

&lt;p&gt;Thanks to that imprecision, the type system helped us here: it caught the fact that we’re assuming the payload is a JSON object, not some other JSON value, and it made us handle the non-object cases explicitly. In this case we chose to raise an error, but of course, as before, you could choose some other form of recovery if you wanted to. You just have to be explicit about it.&lt;/p&gt;

&lt;p&gt;Once more, note that the assumption we were forced to make explicit in Haskell is &lt;em&gt;also&lt;/em&gt; made by the JavaScript code! If our JavaScript &lt;code&gt;handleEvent&lt;/code&gt; function were called with a string rather than an object, it’s unlikely the behavior would be desirable, since an object spread on a string results in the following surprise:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="s2"&gt;"payload"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"sig"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"y"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"l"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"o"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"d"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"sig"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Oops. Once again, the parsing style of programming has helped us out, since if we didn’t “parse” the JSON value into an object by matching on the &lt;code&gt;Object&lt;/code&gt; case explicitly, our code would not compile, and if we left off the fallthrough case, we’d get a warning about inexhaustive patterns.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let’s look at one more example of this phenomenon before moving on. Suppose we’re consuming an API that returns user IDs, and suppose those IDs happen to be UUIDs. A straightforward interpretation of “parse, don’t validate” might suggest we represent user IDs in our Haskell API client using a &lt;code&gt;UUID&lt;/code&gt; type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UUID&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, our Reddit commenter would likely take umbrage with this! Unless the API contract explicitly states that all user IDs will be UUIDs, this representation is overstepping our bounds. Although user IDs might be UUIDs today, perhaps they won’t be tomorrow, and then our code would break for no reason! Is this the fault of static type systems?&lt;/p&gt;

&lt;p&gt;Again, the answer is no. This is a case of improper data modeling, but the static type system is not at fault—it has simply been misused. The appropriate way to represent a &lt;code&gt;UserId&lt;/code&gt; is to define a new, opaque type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Unlike the type alias defined above which simply creates a new name for the existing &lt;code&gt;UUID&lt;/code&gt; type, this declaration creates a totally new &lt;code&gt;UserId&lt;/code&gt; type that is distinct from all other types, including &lt;code&gt;Text&lt;/code&gt;. If we keep the datatype’s constructor private (that is, we don’t export it from the module that defines this type), then the &lt;em&gt;only&lt;/em&gt; way to produce a &lt;code&gt;UserId&lt;/code&gt; will be to go through its &lt;code&gt;FromJSON&lt;/code&gt; parser. Dually, the only things you can do with a &lt;code&gt;UserId&lt;/code&gt; are compare it with other &lt;code&gt;UserId&lt;/code&gt;s for equality or serialize it using the &lt;code&gt;ToJSON&lt;/code&gt; instance. Nothing else is permitted: the type system will prevent you from depending on the remote service’s internal representation of user IDs.&lt;/p&gt;

&lt;p&gt;This illustrates another way that static type systems can provide strong, useful guarantees when manipulating completely opaque data. The runtime representation of a &lt;code&gt;UserId&lt;/code&gt; is really just a string, but the type system does not allow you to accidentally use it like it’s a string, nor does it allow you to forge a new &lt;code&gt;UserId&lt;/code&gt; out of thin air from an arbitrary string.&lt;sup&gt;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-definition" name="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The type system is not a ball and chain forcing you to describe the representation of every value that enters and leaves your program in exquisite detail. Rather, it’s a tool that you can use in whatever way best suits your needs.&lt;/p&gt;

&lt;h1 id="reflection-is-not-special"&gt;Reflection is not special&lt;/h1&gt;

&lt;p&gt;We’ve now thoroughly debunked the claims made by the first commenter, but the question posed by the second commenter may still seem like a loophole in our logic. What &lt;em&gt;is&lt;/em&gt; the type of Python’s &lt;code&gt;pickle.load()&lt;/code&gt;? For those unfamiliar, &lt;a href="https://docs.python.org/3/library/pickle.html"&gt;Python’s cutely-named &lt;code&gt;pickle&lt;/code&gt; library&lt;/a&gt; allows serializing and deserializing entire Python object graphs. Any object can be serialized and stored in a file using &lt;code&gt;pickle.dump()&lt;/code&gt;, and it can be deserialized at a later point in time using &lt;code&gt;pickle.load()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What makes this appear challenging to our static type system is that the type of value produced by &lt;code&gt;pickle.load()&lt;/code&gt; is difficult to predict—it depends entirely on whatever happened to be written to that file using &lt;code&gt;pickle.dump()&lt;/code&gt;. This seems inherently dynamic, since we cannot possibly know what type of value it will produce at compile-time. At first blush, this is something a dynamically typed system can pull off, but a statically-typed one just can’t.&lt;/p&gt;

&lt;p&gt;However, it turns out this situation is actually identical to the previous examples using JSON, and the fact that Python’s pickling serializes native Python objects directly does not change things. Why? Well, consider what happens &lt;em&gt;after&lt;/em&gt; a program calls &lt;code&gt;pickle.load()&lt;/code&gt;. Say you write the following function:&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;load_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="c1"&gt;# do something with `val`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The trouble is that &lt;code&gt;val&lt;/code&gt; can now be of &lt;em&gt;any&lt;/em&gt; type, and just as you can’t do anything useful with truly unknown, unstructured input, you can’t do anything with a value unless you know at least something about it. If you call any method or access any field on the result, then you’ve already made an assumption about what sort of thing &lt;code&gt;pickle.load(f)&lt;/code&gt; returned—and it turns out those assumptions &lt;em&gt;are&lt;/em&gt; &lt;code&gt;val&lt;/code&gt;’s type!&lt;/p&gt;

&lt;p&gt;For example, imagine the only thing you do with &lt;code&gt;val&lt;/code&gt; is call the &lt;code&gt;val.foo()&lt;/code&gt; method and return its result, which is expected to be a string. If we were writing Java, then the expected type of &lt;code&gt;val&lt;/code&gt; would be quite straightforward—we’d expect it to be an instance of the following interface:&lt;/p&gt;

&lt;div class="brush: java"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Serializable&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And indeed, it turns out a &lt;code&gt;pickle.load()&lt;/code&gt;-like function can be given a perfectly reasonable type in Java:&lt;/p&gt;

&lt;div class="brush: java"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;load&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Nitpickers will complain that this isn’t the same as &lt;code&gt;pickle.load()&lt;/code&gt;, since you have to pass a &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; token to choose what type of thing you want ahead of time. However, nothing is stopping you from passing &lt;code&gt;Serializable.class&lt;/code&gt; and branching on the type later, after the object has been loaded. And that’s the key point: the instant you do &lt;em&gt;anything&lt;/em&gt; with the object, you must know something about its type, even in a dynamically typed language! The statically-typed language just forces you to be more explicit about it, just as it did when we were talking about JSON payloads.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Can we do this in Haskell, too? Absolutely—we can use &lt;a href="https://hackage.haskell.org/package/serialise"&gt;the &lt;code&gt;serialise&lt;/code&gt; library&lt;/a&gt;, which has a similar API to the Java one mentioned above. It also happens to have a very similar interface to &lt;a href="https://hackage.haskell.org/package/aeson"&gt;the Haskell JSON library, aeson&lt;/a&gt;, as it turns out the problem of dealing with unknown JSON data is not terribly different from dealing with an unknown Haskell value—at some point, you have to do a little bit of parsing to do anything with the value.&lt;/p&gt;

&lt;p&gt;That said, while you &lt;em&gt;can&lt;/em&gt; emulate the dynamic typing of &lt;code&gt;pickle.load()&lt;/code&gt; if you really want to by deferring the type check until the last possible moment, the reality is that doing so is almost never actually useful. At some point, you have to make assumptions about the structure of the value in order to use it, and you know what those assumptions are because &lt;em&gt;you wrote the code&lt;/em&gt;. While there are extremely rare exceptions to this that require true dynamic code loading (such as, say, implementing a REPL for your programming language), they do not occur in day-to-day programming, and programmers in statically-typed languages are perfectly happy to supply their assumptions up front.&lt;/p&gt;

&lt;p&gt;This is one of the fundamental disconnects between the static typing camp and the dynamic typing camp. Programmers working in statically-typed languages are perplexed when a programmer suggests they can do something in a dynamically typed language that a statically-typed language “fundamentally” prevents, since a programmer in a statically-typed language may reply the value has simply not been given a sufficiently precise type. From the perspective of a programmer working in a dynamically-typed language, the type system restricts the space of legal behaviors, but from the perspective of a programmer working in a statically-typed language, the set of legal behaviors &lt;em&gt;is&lt;/em&gt; a value’s type.&lt;/p&gt;

&lt;p&gt;Neither of these perspectives are actually inaccurate, from the appropriate point of view. Static type systems &lt;em&gt;do&lt;/em&gt; impose restrictions on program structure, as it is provably impossible to reject &lt;em&gt;all&lt;/em&gt; bad programs in a Turing-complete language without also rejecting some good ones (this is &lt;a href="https://en.wikipedia.org/wiki/Rice's_theorem"&gt;Rice’s theorem&lt;/a&gt;). But it is simultaneously true that the impossibility of solving the general problem does not preclude solving a slightly more restricted version of the problem in a useful way, and a lot of the so-called “fundamental” inabilities of static type systems are not fundamental at all.&lt;/p&gt;

&lt;h1 id="appendix-the-reality-behind-the-myths"&gt;Appendix: the reality behind the myths&lt;/h1&gt;

&lt;p&gt;The key thesis of this blog post has now been delivered: static type systems are not fundamentally worse than dynamic type systems at processing data with an open or partially-known structure. The sorts of claims made in the comments cited at the beginning of this blog post are not accurate depictions of what statically-typed program construction is like, and they misunderstand the limitations of static typing disciplines while exaggerating the capabilities of dynamically typed disciplines.&lt;/p&gt;

&lt;p&gt;However, although greatly exaggerated, these myths do have some basis in reality. They appear to have developed at least in part from a misunderstanding about the differences between structural and nominal typing. This difference is unfortunately too big to address in this blog post, as it could likely fill several blog posts of its own. About six months ago I attempted to write a blog post on the subject, but I didn’t think it came out very compelling, so I scrapped it. Maybe someday I’ll find a better way to communicate the ideas.&lt;/p&gt;

&lt;p&gt;Although I can’t give it the full treatment it deserves right now, I’d still like to touch on the idea briefly so that interested readers may be able to find other resources on the subject should they wish to do so. The key idea is that many dynamically typed languages idiomatically reuse simple data structures like hashmaps to represent what in statically-typed languages are often represented by bespoke datatypes (usually defined as classes or structs).&lt;/p&gt;

&lt;p&gt;These two styles facilitate very different flavors of programming. A JavaScript or Clojure program may represent a record as a hashmap from string or symbol keys to values, written using object or hash literals and manipulated using ordinary functions from the standard library that manipulate keys and values in a generic way. This makes it straightforward to take two records and union their fields or to take an arbitrary (or even dynamic) subselection of fields from an existing record.&lt;/p&gt;

&lt;p&gt;In contrast, most static type systems do not allow such free-form manipulation of records because records are not maps at all but unique types distinct from all other types. These types are uniquely identified by their (fully-qualified) name, hence the term &lt;em&gt;nominal typing&lt;/em&gt;. If you wish to take a subselection of a struct’s fields, you must define an entirely new struct; doing this often creates an explosion of awkward boilerplate.&lt;/p&gt;

&lt;p&gt;This is one of the main ideas that Rich Hickey has discussed in many of his talks that criticize static typing. He has advanced the idea that this ability to fluidly merge, separate, and transform records makes dynamic typing particularly suited to the domain of distributed, open systems. Unfortunately, this rhetoric has two significant flaws:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;It skirts too close to calling this a fundamental limitation of type systems, suggesting that it is not simply inconvenient but &lt;em&gt;impossible&lt;/em&gt; to model such systems in a nominal, static type system. Not only is this not true (as this blog post has demonstrated), it misdirects people away from the point of his that actually has value: the practical, pragmatic advantage of a more structural approach to data modeling.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;It confuses the structural/nominal distinction with the dynamic/static distinction, incorrectly creating the impression that the fluid merging and splitting of records represented as key-value maps is only possible in a dynamically typed language. In fact, not only can statically-typed languages support structural typing, many dynamically-typed languages also support nominal typing. These axes have historically loosely correlated, but they are theoretically orthogonal.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For counterexamples to these claims, consider Python classes, which are quite nominal despite being dynamic, and TypeScript interfaces, which are structural despite being static. Indeed, modern statically-typed languages are increasingly acquiring native support for structurally-typed records. In these systems, record types work much like hashes in Clojure—they are not distinct, named types but rather anonymous collections of key-value pairs—and they support many of the same expressive manipulation operations that Clojure’s hashes do, all within a statically-typed framework.&lt;/p&gt;

&lt;p&gt;If you are interested in exploring static type systems with strong support for structural typing, I would recommend taking a look at any of TypeScript, Flow, PureScript, Elm, OCaml, or Reason, all of which have some sort of support for structurally typed records. What I would &lt;em&gt;not&lt;/em&gt; recommend for this purpose is Haskell, which has abysmal support for structural typing; Haskell is (for various reasons outside the scope of this blog post) aggressively nominal.&lt;sup&gt;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-definition" name="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Does this mean Haskell is bad, or that it cannot be practically used to solve these kinds of problems? No, certainly not; there are many ways to model these problems in Haskell that work well enough, though some of them suffer from significant boilerplate. The core thesis of this blog post applies just as much to Haskell as it does to any of the other languages I mentioned above. However, I would be remiss not to mention this distinction, as it may give programmers from a dynamically-typed background who have historically found statically-typed languages much more frustrating to work with a better understanding of the &lt;em&gt;real&lt;/em&gt; reason they feel that way. (Essentially all mainstream, statically-typed OOP languages are even more nominal than Haskell!)&lt;/p&gt;

&lt;p&gt;As closing thoughts: this blog post is not intended to start a flame war, nor is it intended to be an assault on dynamically typed programming. There are many patterns in dynamically-typed languages that are genuinely difficult to translate into a statically-typed context, and I think discussions of those patterns can be productive. The purpose of this blog post is to clarify why one particular discussion is &lt;em&gt;not&lt;/em&gt; productive, so please: stop making these arguments. There are much more productive conversations to have about typing than this.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Technically, you could abuse the &lt;code&gt;FromJSON&lt;/code&gt; instance to convert an arbitrary string to a &lt;code&gt;UserId&lt;/code&gt;, but this would not be as easy as it sounds, since &lt;code&gt;fromJSON&lt;/code&gt; can fail. This means you’d somehow have to handle that failure case, so this trick would be unlikely to get you very far unless you’re already in a context where you’re doing input parsing… at which point it would be easier to just do the right thing. So yes, the type system doesn’t prevent you from going out of your way to shoot yourself in the foot, but it guides you towards the right solution (and there is no safeguard in existence that can completely protect a programmer from making their own life miserable if they are determined to do so).&amp;nbsp;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;I consider this to be Haskell’s most significant flaw at the time of this writing.&amp;nbsp;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Parse, don’t validate</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/?utm_source=functional-programming&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2019-11-05-parse-don-t-validate</id>
  <published>2019-11-05T17:09:58Z</published>
  <updated>2019-11-05T17:09:58Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;Historically, I’ve struggled to find a concise, simple way to explain what it means to practice type-driven design. Too often, when someone asks me “How did you come up with this approach?” I find I can’t give them a satisfying answer. I know it didn’t just come to me in a vision—I have an iterative design process that doesn’t require plucking the “right” approach out of thin air—yet I haven’t been very successful in communicating that process to others.&lt;/p&gt;

&lt;p&gt;However, about a month ago, &lt;a href="https://twitter.com/lexi_lambda/status/1182242561655746560"&gt;I was reflecting on Twitter&lt;/a&gt; about the differences I experienced parsing JSON in statically- and dynamically-typed languages, and finally, I realized what I was looking for. Now I have a single, snappy slogan that encapsulates what type-driven design means to me, and better yet, it’s only three words long:&lt;/p&gt;

&lt;div style="text-align: center; font-size: larger"&gt;&lt;strong&gt;Parse, don’t validate.&lt;/strong&gt;&lt;/div&gt;
&lt;!-- more--&gt;

&lt;h1 id="the-essence-of-type-driven-design"&gt;The essence of type-driven design&lt;/h1&gt;

&lt;p&gt;Alright, I’ll confess: unless you already know what type-driven design is, my catchy slogan probably doesn’t mean all that much to you. Fortunately, that’s what the remainder of this blog post is for. I’m going to explain precisely what I mean in gory detail—but first, we need to practice a little wishful thinking.&lt;/p&gt;

&lt;h2 id="the-realm-of-possibility"&gt;The realm of possibility&lt;/h2&gt;

&lt;p&gt;One of the wonderful things about static type systems is that they can make it possible, and sometimes even easy, to answer questions like “is it possible to write this function?” For an extreme example, consider the following Haskell type signature:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Is it possible to implement &lt;code&gt;foo&lt;/code&gt;? Trivially, the answer is &lt;em&gt;no&lt;/em&gt;, as &lt;code&gt;Void&lt;/code&gt; is a type that contains no values, so it’s impossible for &lt;em&gt;any&lt;/em&gt; function to produce a value of type &lt;code&gt;Void&lt;/code&gt;.&lt;sup&gt;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-1-definition" name="2019-11-05-parse-don-t-validate-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; That example is pretty boring, but the question gets much more interesting if we choose a more realistic example:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This function returns the first element from a list. Is it possible to implement? It certainly doesn’t sound like it does anything very complicated, but if we attempt to implement it, the compiler won’t be satisfied:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for ‘head’: Patterns not matched: []&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This message is helpfully pointing out that our function is &lt;em&gt;partial&lt;/em&gt;, which is to say it is not defined for all possible inputs. Specifically, it is not defined when the input is &lt;code&gt;[]&lt;/code&gt;, the empty list. This makes sense, as it isn’t possible to return the first element of a list if the list is empty—there’s no element to return! So, remarkably, we learn this function isn’t possible to implement, either.&lt;/p&gt;

&lt;h2 id="turning-partial-functions-total"&gt;Turning partial functions total&lt;/h2&gt;

&lt;p&gt;To someone coming from a dynamically-typed background, this might seem perplexing. If we have a list, we might very well want to get the first element in it. And indeed, the operation of “getting the first element of a list” isn’t impossible in Haskell, it just requires a little extra ceremony. There are two different ways to fix the &lt;code&gt;head&lt;/code&gt; function, and we’ll start with the simplest one.&lt;/p&gt;

&lt;h3 id="managing-expectations"&gt;Managing expectations&lt;/h3&gt;

&lt;p&gt;As established, &lt;code&gt;head&lt;/code&gt; is partial because there is no element to return if the list is empty: we’ve made a promise we cannot possibly fulfill. Fortunately, there’s an easy solution to that dilemma: we can weaken our promise. Since we cannot guarantee the caller an element of the list, we’ll have to practice a little expectation management: we’ll do our best return an element if we can, but we reserve the right to return nothing at all. In Haskell, we express this possibility using the &lt;code&gt;Maybe&lt;/code&gt; type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This buys us the freedom we need to implement &lt;code&gt;head&lt;/code&gt;—it allows us to return &lt;code&gt;Nothing&lt;/code&gt; when we discover we can’t produce a value of type &lt;code&gt;a&lt;/code&gt; after all:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;    &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Problem solved, right? For the moment, yes… but this solution has a hidden cost.&lt;/p&gt;

&lt;p&gt;Returning &lt;code&gt;Maybe&lt;/code&gt; is undoubtably convenient when we’re &lt;em&gt;implementing&lt;/em&gt; &lt;code&gt;head&lt;/code&gt;. However, it becomes significantly less convenient when we want to actually use it! Since &lt;code&gt;head&lt;/code&gt; always has the potential to return &lt;code&gt;Nothing&lt;/code&gt;, the burden falls upon its callers to handle that possibility, and sometimes that passing of the buck can be incredibly frustrating. To see why, consider the following code:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirsString&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getEnv&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS"&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;configDirsString&lt;/span&gt;
  &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
    &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS cannot be empty"&lt;/span&gt;
  &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt;

&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirs&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getConfigurationDirectories&lt;/span&gt;
  &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;configDirs&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;cacheDir&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;initializeCache&lt;/span&gt; &lt;span class="n"&gt;cacheDir&lt;/span&gt;
    &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"should never happen; already checked configDirs is non-empty"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;When &lt;code&gt;getConfigurationDirectories&lt;/code&gt; retrieves a list of file paths from the environment, it proactively checks that the list is non-empty. However, when we use &lt;code&gt;head&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt; to get the first element of the list, the &lt;code&gt;Maybe FilePath&lt;/code&gt; result still requires us to handle a &lt;code&gt;Nothing&lt;/code&gt; case that we know will never happen! This is terribly bad for several reasons:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;First, it’s just annoying. We already checked that the list is non-empty, why do we have to clutter our code with another redundant check?&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Second, it has a potential performance cost. Although the cost of the redundant check is trivial in this particular example, one could imagine a more complex scenario where the redundant checks could add up, such as if they were happening in a tight loop.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, and worst of all, this code is a bug waiting to happen! What if &lt;code&gt;getConfigurationDirectories&lt;/code&gt; were modified to stop checking that the list is empty, intentionally or unintentionally? The programmer might not remember to update &lt;code&gt;main&lt;/code&gt;, and suddenly the “impossible” error becomes not only possible, but probable.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The need for this redundant check has essentially forced us to punch a hole in our type system. If we could statically &lt;em&gt;prove&lt;/em&gt; the &lt;code&gt;Nothing&lt;/code&gt; case impossible, then a modification to &lt;code&gt;getConfigurationDirectories&lt;/code&gt; that stopped checking if the list was empty would invalidate the proof and trigger a compile-time failure. However, as-written, we’re forced to rely on a test suite or manual inspection to catch the bug.&lt;/p&gt;

&lt;h3 id="paying-it-forward"&gt;Paying it forward&lt;/h3&gt;

&lt;p&gt;Clearly, our modified version of &lt;code&gt;head&lt;/code&gt; leaves some things to be desired. Somehow, we’d like it to be smarter: if we already checked that the list was non-empty, &lt;code&gt;head&lt;/code&gt; should unconditionally return the first element without forcing us to handle the case we know is impossible. How can we do that?&lt;/p&gt;

&lt;p&gt;Let’s look at the original (partial) type signature for &lt;code&gt;head&lt;/code&gt; again:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The previous section illustrated that we can turn that partial type signature into a total one by weakening the promise made in the return type. However, since we don’t want to do that, there’s only one thing left that can be changed: the argument type (in this case, &lt;code&gt;[a]&lt;/code&gt;). Instead of weakening the return type, we can &lt;em&gt;strengthen&lt;/em&gt; the argument type, eliminating the possibility of &lt;code&gt;head&lt;/code&gt; ever being called on an empty list in the first place.&lt;/p&gt;

&lt;p&gt;To do this, we need a type that represents non-empty lists. Fortunately, the existing &lt;code&gt;NonEmpty&lt;/code&gt; type from &lt;code&gt;Data.List.NonEmpty&lt;/code&gt; is exactly that. It has the following definition:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that &lt;code&gt;NonEmpty a&lt;/code&gt; is really just a tuple of an &lt;code&gt;a&lt;/code&gt; and an ordinary, possibly-empty &lt;code&gt;[a]&lt;/code&gt;. This conveniently models a non-empty list by storing the first element of the list separately from the list’s tail: even if the &lt;code&gt;[a]&lt;/code&gt; component is &lt;code&gt;[]&lt;/code&gt;, the &lt;code&gt;a&lt;/code&gt; component must always be present. This makes &lt;code&gt;head&lt;/code&gt; completely trivial to implement:&lt;sup&gt;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-2-definition" name="2019-11-05-parse-don-t-validate-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:|&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Unlike before, GHC accepts this definition without complaint—this definition is &lt;em&gt;total&lt;/em&gt;, not partial. We can update our program to use the new implementation:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirsString&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getEnv&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS"&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;configDirsString&lt;/span&gt;
  &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;nonEmpty&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;nonEmptyConfigDirsList&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;nonEmptyConfigDirsList&lt;/span&gt;
    &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS cannot be empty"&lt;/span&gt;

&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirs&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getConfigurationDirectories&lt;/span&gt;
  &lt;span class="n"&gt;initializeCache&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;configDirs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that the redundant check in &lt;code&gt;main&lt;/code&gt; is now completely gone! Instead, we perform the check exactly once, in &lt;code&gt;getConfigurationDirectories&lt;/code&gt;. It constructs a &lt;code&gt;NonEmpty a&lt;/code&gt; from a &lt;code&gt;[a]&lt;/code&gt; using the &lt;code&gt;nonEmpty&lt;/code&gt; function from &lt;code&gt;Data.List.NonEmpty&lt;/code&gt;, which has the following type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;Maybe&lt;/code&gt; is still there, but this time, we handle the &lt;code&gt;Nothing&lt;/code&gt; case very early in our program: right in the same place we were already doing the input validation. Once that check has passed, we now have a &lt;code&gt;NonEmpty FilePath&lt;/code&gt; value, which preserves (in the type system!) the knowledge that the list really is non-empty. Put another way, you can think of a value of type &lt;code&gt;NonEmpty a&lt;/code&gt; as being like a value of type &lt;code&gt;[a]&lt;/code&gt;, plus a &lt;em&gt;proof&lt;/em&gt; that the list is non-empty.&lt;/p&gt;

&lt;p&gt;By strengthening the type of the argument to &lt;code&gt;head&lt;/code&gt; instead of weakening the type of its result, we’ve completely eliminated all the problems from the previous section:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The code has no redundant checks, so there can’t be any performance overhead.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Furthermore, if &lt;code&gt;getConfigurationDirectories&lt;/code&gt; changes to stop checking that the list is non-empty, its return type must change, too. Consequently, &lt;code&gt;main&lt;/code&gt; will fail to typecheck, alerting us to the problem before we even run the program!&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;What’s more, it’s trivial to recover the old behavior of &lt;code&gt;head&lt;/code&gt; from the new one by composing &lt;code&gt;head&lt;/code&gt; with &lt;code&gt;nonEmpty&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fmap&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;nonEmpty&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that the inverse is &lt;em&gt;not&lt;/em&gt; true: there is no way to obtain the new version of &lt;code&gt;head&lt;/code&gt; from the old one. All in all, the second approach is superior on all axes.&lt;/p&gt;

&lt;h2 id="the-power-of-parsing"&gt;The power of parsing&lt;/h2&gt;

&lt;p&gt;You may be wondering what the above example has to do with the title of this blog post. After all, we only examined two different ways to validate that a list was non-empty—no parsing in sight. That interpretation isn’t wrong, but I’d like to propose another perspective: in my mind, the difference between validation and parsing lies almost entirely in how information is preserved. Consider the following pair of functions:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;validateNonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;validateNonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;validateNonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"list cannot be empty"&lt;/span&gt;

&lt;span class="nf"&gt;parseNonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;parseNonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:|&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;parseNonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"list cannot be empty"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;These two functions are nearly identical: they check if the provided list is empty, and if it is, they abort the program with an error message. The difference lies entirely in the return type: &lt;code&gt;validateNonEmpty&lt;/code&gt; always returns &lt;code&gt;()&lt;/code&gt;, the type that contains no information, but &lt;code&gt;parseNonEmpty&lt;/code&gt; returns &lt;code&gt;NonEmpty a&lt;/code&gt;, a refinement of the input type that preserves the knowledge gained in the type system. Both of these functions check the same thing, but &lt;code&gt;parseNonEmpty&lt;/code&gt; gives the caller access to the information it learned, while &lt;code&gt;validateNonEmpty&lt;/code&gt; just throws it away.&lt;/p&gt;

&lt;p&gt;These two functions elegantly illustrate two different perspectives on the role of a static type system: &lt;code&gt;validateNonEmpty&lt;/code&gt; obeys the typechecker well enough, but only &lt;code&gt;parseNonEmpty&lt;/code&gt; takes full advantage of it. If you see why &lt;code&gt;parseNonEmpty&lt;/code&gt; is preferable, you understand what I mean by the mantra “parse, don’t validate.” Still, perhaps you are skeptical of &lt;code&gt;parseNonEmpty&lt;/code&gt;’s name. Is it really &lt;em&gt;parsing&lt;/em&gt; anything, or is it merely validating its input and returning a result? While the precise definition of what it means to parse or validate something is debatable, I believe &lt;code&gt;parseNonEmpty&lt;/code&gt; is a bona-fide parser (albeit a particularly simple one).&lt;/p&gt;

&lt;p&gt;Consider: what is a parser? Really, a parser is just a function that consumes less-structured input and produces more-structured output. By its very nature, a parser is a partial function—some values in the domain do not correspond to any value in the range—so all parsers must have some notion of failure. Often, the input to a parser is text, but this is by no means a requirement, and &lt;code&gt;parseNonEmpty&lt;/code&gt; is a perfectly cromulent parser: it parses lists into non-empty lists, signaling failure by terminating the program with an error message.&lt;/p&gt;

&lt;p&gt;Under this flexible definition, parsers are an incredibly powerful tool: they allow discharging checks on input up-front, right on the boundary between a program and the outside world, and once those checks have been performed, they never need to be checked again! Haskellers are well-aware of this power, and they use many different types of parsers on a regular basis:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The &lt;a href="https://hackage.haskell.org/package/aeson"&gt;aeson&lt;/a&gt; library provides a &lt;code&gt;Parser&lt;/code&gt; type that can be used to parse JSON data into domain types.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Likewise, &lt;a href="https://hackage.haskell.org/package/optparse-applicative"&gt;optparse-applicative&lt;/a&gt; provides a set of parser combinators for parsing command-line arguments.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Database libraries like &lt;a href="https://hackage.haskell.org/package/persistent"&gt;persistent&lt;/a&gt; and &lt;a href="https://hackage.haskell.org/package/postgresql-simple"&gt;postgresql-simple&lt;/a&gt; have a mechanism for parsing values held in an external data store.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The &lt;a href="https://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; ecosystem is built around parsing Haskell datatypes from path components, query parameters, HTTP headers, and more.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The common theme between all these libraries is that they sit on the boundary between your Haskell application and the external world. That world doesn’t speak in product and sum types, but in streams of bytes, so there’s no getting around a need to do some parsing. Doing that parsing up front, before acting on the data, can go a long way toward avoiding many classes of bugs, some of which might even be security vulnerabilities.&lt;/p&gt;

&lt;p&gt;One drawback to this approach of parsing everything up front is that it sometimes requires values be parsed long before they are actually used. In a dynamically-typed language, this can make keeping the parsing and processing logic in sync a little tricky without extensive test coverage, much of which can be laborious to maintain. However, with a static type system, the problem becomes marvelously simple, as demonstrated by the &lt;code&gt;NonEmpty&lt;/code&gt; example above: if the parsing and processing logic go out of sync, the program will fail to even compile.&lt;/p&gt;

&lt;h2 id="the-danger-of-validation"&gt;The danger of validation&lt;/h2&gt;

&lt;p&gt;Hopefully, by this point, you are at least somewhat sold on the idea that parsing is preferable to validation, but you may have lingering doubts. Is validation really so bad if the type system is going to force you to do the necessary checks eventually anyway? Maybe the error reporting will be a little bit worse, but a bit of redundant checking can’t hurt, right?&lt;/p&gt;

&lt;p&gt;Unfortunately, it isn’t so simple. Ad-hoc validation leads to a phenomenon that the &lt;a href="http://langsec.org"&gt;language-theoretic security&lt;/a&gt; field calls &lt;em&gt;shotgun parsing&lt;/em&gt;. In the 2016 paper, &lt;a href="http://langsec.org/papers/langsec-cwes-secdev2016.pdf"&gt;The Seven Turrets of Babel: A Taxonomy of LangSec Errors and How to Expunge Them&lt;/a&gt;, its authors provide the following definition:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Shotgun parsing is a programming antipattern whereby parsing and input-validating code is mixed with and spread across processing code—throwing a cloud of checks at the input, and hoping, without any systematic justification, that one or another would catch all the “bad” cases.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;They go on to explain the problems inherent to such validation techniques:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Shotgun parsing necessarily deprives the program of the ability to reject invalid input instead of processing it. Late-discovered errors in an input stream will result in some portion of invalid input having been processed, with the consequence that program state is difficult to accurately predict.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In other words, a program that does not parse all of its input up front runs the risk of acting upon a valid portion of the input, discovering a different portion is invalid, and suddenly needing to roll back whatever modifications it already executed in order to maintain consistency. Sometimes this is possible—such as rolling back a transaction in an RDBMS—but in general it may not be.&lt;/p&gt;

&lt;p&gt;It may not be immediately apparent what shotgun parsing has to do with validation—after all, if you do all your validation up front, you mitigate the risk of shotgun parsing. The problem is that validation-based approaches make it extremely difficult or impossible to determine if everything was actually validated up front or if some of those so-called “impossible” cases might actually happen. The entire program must assume that raising an exception anywhere is not only possible, it’s regularly necessary.&lt;/p&gt;

&lt;p&gt;Parsing avoids this problem by stratifying the program into two phases—parsing and execution—where failure due to invalid input can only happen in the first phase. The set of remaining failure modes during execution is minimal by comparison, and they can be handled with the tender care they require.&lt;/p&gt;

&lt;h1 id="parsing-not-validating-in-practice"&gt;Parsing, not validating, in practice&lt;/h1&gt;

&lt;p&gt;So far, this blog post has been something of a sales pitch. “You, dear reader, ought to be parsing!” it says, and if I’ve done my job properly, at least some of you are sold. However, even if you understand the “what” and the “why,” you might not feel especially confident about the “how.”&lt;/p&gt;

&lt;p&gt;My advice: focus on the datatypes.&lt;/p&gt;

&lt;p&gt;Suppose you are writing a function that accepts a list of tuples representing key-value pairs, and you suddenly realize you aren’t sure what to do if the list has duplicate keys. One solution would be to write a function that asserts there aren’t any duplicates in the list:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;checkNoDuplicateKeys&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="kt"&gt;AppError&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Eq&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, this check is fragile: it’s extremely easy to forget. Because its return value is unused, it can always be omitted, and the code that needs it would still typecheck. A better solution is to choose a data structure that disallows duplicate keys by construction, such as a &lt;code&gt;Map&lt;/code&gt;. Adjust your function’s type signature to accept a &lt;code&gt;Map&lt;/code&gt; instead of a list of tuples, and implement it as you normally would.&lt;/p&gt;

&lt;p&gt;Once you’ve done that, the call site of your new function will likely fail to typecheck, since it is still being passed a list of tuples. If the caller was given the value via one of its arguments, or if it received it from the result of some other function, you can continue updating the type from list to &lt;code&gt;Map&lt;/code&gt;, all the way up the call chain. Eventually, you will either reach the location the value is created, or you’ll find a place where duplicates actually ought to be allowed. At that point, you can insert a call to a modified version of &lt;code&gt;checkNoDuplicateKeys&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;checkNoDuplicateKeys&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="kt"&gt;AppError&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Eq&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now the check &lt;em&gt;cannot&lt;/em&gt; be omitted, since its result is actually necessary for the program to proceed!&lt;/p&gt;

&lt;p&gt;This hypothetical scenario highlights two simple ideas:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Use a data structure that makes illegal states unrepresentable.&lt;/strong&gt; Model your data using the most precise data structure you reasonably can. If ruling out a particular possibility is too hard using the encoding you are currently using, consider alternate encodings that can express the property you care about more easily. Don’t be afraid to refactor.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Push the burden of proof upward as far as possible, but no further.&lt;/strong&gt; Get your data into the most precise representation you need as quickly as you can. Ideally, this should happen at the boundary of your system, before &lt;em&gt;any&lt;/em&gt; of the data is acted upon.&lt;sup&gt;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-3-definition" name="2019-11-05-parse-don-t-validate-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
  &lt;p&gt; If one particular code branch eventually requires a more precise representation of a piece of data, parse the data into the more precise representation as soon as the branch is selected. Use sum types judiciously to allow your datatypes to reflect and adapt to control flow.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;In other words, write functions on the data representation you &lt;em&gt;wish&lt;/em&gt; you had, not the data representation you are given. The design process then becomes an exercise in bridging the gap, often by working from both ends until they meet somewhere in the middle. Don’t be afraid to iteratively adjust parts of the design as you go, since you may learn something new during the refactoring process!&lt;/p&gt;

&lt;p&gt;Here are a handful of additional points of advice, arranged in no particular order:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Let your datatypes inform your code, don’t let your code control your datatypes.&lt;/strong&gt; Avoid the temptation to just stick a &lt;code&gt;Bool&lt;/code&gt; in a record somewhere because it’s needed by the function you’re currently writing. Don’t be afraid to refactor code to use the right data representation—the type system will ensure you’ve covered all the places that need changing, and it will likely save you a headache later.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Treat functions that return &lt;code&gt;m ()&lt;/code&gt; with deep suspicion.&lt;/strong&gt; Sometimes these are genuinely necessary, as they may perform an imperative effect with no meaningful result, but if the primary purpose of that effect is raising an error, it’s likely there’s a better way.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Don’t be afraid to parse data in multiple passes.&lt;/strong&gt; Avoiding shotgun parsing just means you shouldn’t act on the input data before it’s fully parsed, not that you can’t use some of the input data to decide how to parse other input data. Plenty of useful parsers are context-sensitive.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Avoid denormalized representations of data, &lt;em&gt;especially&lt;/em&gt; if it’s mutable.&lt;/strong&gt; Duplicating the same data in multiple places introduces a trivially representable illegal state: the places getting out of sync. Strive for a single source of truth.&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;&lt;strong&gt;Keep denormalized representations of data behind abstraction boundaries.&lt;/strong&gt; If denormalization is absolutely necessary, use encapsulation to ensure a small, trusted module holds sole responsibility for keeping the representations in sync.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Use abstract datatypes to make validators “look like” parsers.&lt;/strong&gt; Sometimes, making an illegal state truly unrepresentable is just plain impractical given the tools Haskell provides, such as ensuring an integer is in a particular range. In that case, use an abstract &lt;code&gt;newtype&lt;/code&gt; with a smart constructor to “fake” a parser from a validator.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;As always, use your best judgement. It probably isn’t worth breaking out &lt;a href="https://hackage.haskell.org/package/singletons"&gt;singletons&lt;/a&gt; and refactoring your entire application just to get rid of a single &lt;code&gt;error "impossible"&lt;/code&gt; call somewhere—just make sure to treat those situations like the radioactive substance they are, and handle them with the appropriate care. If all else fails, at least leave a comment to document the invariant for whoever needs to modify the code next.&lt;/p&gt;

&lt;h1 id="recap-reflection-and-related-reading"&gt;Recap, reflection, and related reading&lt;/h1&gt;

&lt;p&gt;That’s all, really. Hopefully this blog post proves that taking advantage of the Haskell type system doesn’t require a PhD, and it doesn’t even require using the latest and greatest of GHC’s shiny new language extensions—though they can certainly sometimes help! Sometimes the biggest obstacle to using Haskell to its fullest is simply being aware what options are available, and unfortunately, one downside of Haskell’s small community is a relative dearth of resources that document design patterns and techniques that have become tribal knowledge.&lt;/p&gt;

&lt;p&gt;None of the ideas in this blog post are new. In fact, the core idea—“write total functions”—is conceptually quite simple. Despite that, I find it remarkably challenging to communicate actionable, practicable details about the way I write Haskell code. It’s easy to spend lots of time talking about abstract concepts—many of which are quite valuable!—without communicating anything useful about &lt;em&gt;process&lt;/em&gt;. My hope is that this is a small step in that direction.&lt;/p&gt;

&lt;p&gt;Sadly, I don’t know very many other resources on this particular topic, but I do know of one: I never hesitate to recommend Matt Parson’s fantastic blog post &lt;a href="https://www.parsonsmatt.org/2017/10/11/type_safety_back_and_forth.html"&gt;Type Safety Back and Forth&lt;/a&gt;. If you want another accessible perspective on these ideas, including another worked example, I’d highly encourage giving it a read. For a significantly more advanced take on many of these ideas, I can also recommend Matt Noonan’s 2018 paper &lt;a href="https://kataskeue.com/gdp.pdf"&gt;Ghosts of Departed Proofs&lt;/a&gt;, which outlines a handful of techniques for capturing more complex invariants in the type system than I have described here.&lt;/p&gt;

&lt;p&gt;As a closing note, I want to say that doing the kind of refactoring described in this blog post is not always easy. The examples I’ve given are simple, but real life is often much less straightforward. Even for those experienced in type-driven design, it can be genuinely difficult to capture certain invariants in the type system, so do not consider it a personal failing if you cannot solve something the way you’d like! Consider the principles in this blog post ideals to strive for, not strict requirements to meet. All that matters is to try.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-11-05-parse-don-t-validate-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Technically, in Haskell, this ignores “bottoms,” constructions that can inhabit &lt;em&gt;any&lt;/em&gt; value. These aren’t “real” values (unlike &lt;code&gt;null&lt;/code&gt; in some other languages)—they’re things like infinite loops or computations that raise exceptions—and in idiomatic Haskell, we usually try to avoid them, so reasoning that pretends they don’t exist still has value. But don’t take my word for it—I’ll let Danielsson et al. convince you that &lt;a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf"&gt;Fast and Loose Reasoning is Morally Correct&lt;/a&gt;.&amp;nbsp;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-11-05-parse-don-t-validate-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;In fact, &lt;code&gt;Data.List.NonEmpty&lt;/code&gt; already provides a &lt;code&gt;head&lt;/code&gt; function with this type, but just for the sake of illustration, we’ll reimplement it ourselves.&amp;nbsp;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-11-05-parse-don-t-validate-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;Sometimes it is necessary to perform some kind of authorization before parsing user input to avoid denial of service attacks, but that’s okay: authorization should have a relatively small surface area, and it shouldn’t cause any significant modifications to the state of your system.&amp;nbsp;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Rascal: a Haskell with more parentheses</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/?utm_source=functional-programming&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2017-01-02-rascal-a-haskell-with-more-parentheses</id>
  <published>2017-01-02T09:16:42Z</published>
  <updated>2017-01-02T09:16:42Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;blockquote&gt;
 &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: since the writing of this blog post, Rascal has been renamed to Hackett. You can read about why in &lt;a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/"&gt;the followup blog post&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;“Hey! You got your Haskell in my Racket!”&lt;/p&gt;

&lt;p&gt;“No, you got &lt;em&gt;your&lt;/em&gt; Racket in &lt;em&gt;my&lt;/em&gt; Haskell!”&lt;/p&gt;

&lt;p&gt;Welcome to the &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Rascal&lt;/a&gt; programming language.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="why-rascal"&gt;Why Rascal?&lt;/h1&gt;

&lt;p&gt;Why yet &lt;em&gt;another&lt;/em&gt; programming language? Anyone who knows me knows that I already have two programming languages that I &lt;em&gt;really&lt;/em&gt; like: Haskell and Racket. Really, I think they’re both great! Each brings some things to the table that aren’t really available in any other programming language I’ve ever used.&lt;/p&gt;

&lt;p&gt;Haskell, in many ways, is a programming language that fits my mental model of how to structure programs better than any other programming language I’ve used. Some people would vehemently disagree, and it seems that there is almost certainly some heavy subjectivity in how people think about programming. I think Haskell’s model is awesome once you get used to it, though, but this blog post is not really going to try and convince you why you should care about Haskell (though that &lt;em&gt;is&lt;/em&gt; something I want to write at some point). What you &lt;em&gt;should&lt;/em&gt; understand, though, is that to me, Haskell is pretty close to what I want in a programming language.&lt;/p&gt;

&lt;p&gt;At the same time, though, Haskell has problems, and a lot of that revolves around its story for metaprogramming. “Metaprogramming” is another M word that people seem to be very afraid of, and for good reason: most metaprogramming systems are ad-hoc, unsafe, unpredictable footguns that require delicate care to use properly, and &lt;em&gt;even then&lt;/em&gt; the resulting code is brittle and difficult to understand. Haskell doesn’t suffer from this problem as much as some languages, but it isn’t perfect by any means: Haskell has at least two different metaprogramming systems (generics and Template Haskell) that are designed for different tasks, but they’re both limited in scope and both tend to be pretty complicated to use.&lt;/p&gt;

&lt;p&gt;Discussing the merits and drawbacks of Haskell’s various metaprogramming capabilities is also outside the scope of this blog post, but there’s one &lt;em&gt;fact&lt;/em&gt; that I want to bring up, which is that &lt;strong&gt;Haskell does not provide any mechanism for adding syntactic abstractions to the language&lt;/strong&gt;. What do I mean by this? Well, in order to understand what a “syntactic abstraction” is and why you should care about it, I want to shift gears a little and take a look at why Racket is so amazing.&lt;/p&gt;

&lt;h2 id="a-programmable-programming-language-theory-and-practice"&gt;A programmable programming language: theory and practice&lt;/h2&gt;

&lt;p&gt;I feel confident in saying that Racket has &lt;em&gt;the&lt;/em&gt; most advanced macro system in the world, and it is pretty much unparalleled in that space. There are many languages with powerful type systems, but Racket is more or less alone in many of the niches it occupies. Racket has a large number of innovations that I don’t know of in any other programming language, and a significant portion of them focus on making Racket a &lt;a href="http://www.ccs.neu.edu/home/matthias/manifesto/"&gt;programmable programming language, a language for building languages&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This lofty goal is backed up by decades of research, providing Racket with an unparalleled toolkit for creating languages that can communicate, be extended, and even cooperate with tooling to provide introspection and error diagnostics. Working in Haskell feels like carefully designing a mould that cleanly and precisely fits your domain, carefully carving, cutting, and whittling. In contrast, working with Racket feels like moulding your domain until it looks the way &lt;em&gt;you&lt;/em&gt; want it to look, poking and prodding at a pliable substrate. The sheer &lt;em&gt;ease&lt;/em&gt; of it all is impossible for me to convey in words, so &lt;a href="https://twitter.com/andmkent_/status/724036694773628930"&gt;you will have to see it for yourself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All this stuff is super abstract, though. What does it mean for practical programming, and why should you care? Well, I’m not going to try and sell you if you’re extremely skeptical, but if you’re interested, &lt;a href="https://www.youtube.com/watch?v=TfehOLha-18"&gt;I gave a talk on some of Racket’s linguistic capabilities last year called &lt;em&gt;Languages in an Afternoon&lt;/em&gt;&lt;/a&gt;. If you’re curious, give it a watch, and you might find yourself (hopefully) a little impressed. If you prefer reading, well, I have some &lt;a href="/blog/2015/12/21/adts-in-typed-racket-with-macros/"&gt;blog posts&lt;/a&gt; on this very blog that &lt;a href="/blog/2015/08/30/managing-application-configuration-with-envy/"&gt;demonstrate what Racket can do&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The basic idea, though, is that by having a simple syntax and a powerful macro system with a formalization of lexical scope, users can effectively invent entirely new language constructs as ordinary libraries, constructs that would have to be core forms in other programming languages. For example, Racket supports pattern-matching, but it isn’t built into the compiler: it’s simply implemented in the &lt;code&gt;racket/match&lt;/code&gt; module distributed with Racket. Not only is it defined in ordinary Racket code, it’s actually &lt;em&gt;extensible&lt;/em&gt;, so users can add their own pattern-matching forms that cooperate with &lt;code&gt;match&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is the power of a macro system to produce “syntactic abstractions”, things that can transform the way a user thinks of the code they’re writing. Racket has the unique capability of making these abstractions both easy to write and watertight, so instead of being a scary tool you have to handle with extreme care, you can easily whip up a powerful, user-friendly embedded domain specific language in a matter of &lt;em&gt;minutes&lt;/em&gt;, and it’ll be safe, provide error reporting for misuse, and cooperate with existing tooling pretty much out of the box.&lt;/p&gt;

&lt;h2 id="fusing-haskell-and-racket"&gt;Fusing Haskell and Racket&lt;/h2&gt;

&lt;p&gt;So, let’s assume that we &lt;em&gt;do&lt;/em&gt; want Haskell’s strong type system and that we &lt;em&gt;also&lt;/em&gt; want a powerful metaprogramming model that permits syntactic extensions. What would that look like? Well, one way we could do it is to put one in front of the other: macro expansion is, by nature, a compile-time pass, so we could stick a macroexpander in front of the typechecker. This leads to a simple technique: first, macroexpand the program to erase the macros, then typecheck it and erase the types, then send the resulting code off to be compiled. This technique has the following properties:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;First of all, &lt;strong&gt;it’s easy to implement&lt;/strong&gt;. Racket’s macroexpander, while complex, is well-documented in academic literature and works extremely well in practice. In fact, this strategy has already been implemented! Typed Racket, the gradually-typed sister language of Racket, expands every program before typechecking. It would be possible to effectively create a “Lisp-flavored Haskell” by using this technique, and it might not even be that hard.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Unfortunately, there’s a huge problem with this approach: &lt;strong&gt;type information is not available at macroexpansion time&lt;/strong&gt;. This is the real dealbreaker with the “expand, then typecheck” model, since static type information is some of the most useful information possibly available to a macro writer. In an ideal world, macros should not only have access to type information, they should be able to manipulate it and metaprogram the typechecker as necessary, but if macroexpansion is a separate phase from typechecking, then that information simply doesn’t exist yet.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For me, the second option is unacceptable. I am &lt;em&gt;not&lt;/em&gt; satisfied by a “Lisp-flavored Haskell”; I want my types and macros to be able to cooperate and communicate with each other. The trouble, though, is that solving that problem is really, really hard! For a couple years now, I’ve been wishing this ideal language existed, but I’ve had no idea how to make it actually work. Template Haskell implements a highly restricted system of interweaving typechecking and splice evaluation, but it effectively does it by running the typechecker and the splice expander alternately, splitting the source into chunks and typechecking them one at a time. This works okay for Template Haskell, but for the more powerful macro system I am looking for, it wouldn’t scale.&lt;/p&gt;

&lt;p&gt;There’s something a little bit curious, though, about the problem as I just described it. The processes of “macroexpanding the program to erase the macros” and “typechecking the program to erase the types” sound awfully similar. It seems like maybe these are two sides of the same coin, and it would be wonderful if we could encode one in terms of the other, effectively turning the two passes into a single, unified pass. Unfortunately, while this sounds great, I had no idea how to do this (and it didn’t help that I really had no idea how existing type systems were actually implemented).&lt;/p&gt;

&lt;p&gt;Fortunately, last year, Stephen Chang, Alex Knauth, and Ben Greenman put together a rather exciting paper called &lt;a href="http://www.ccs.neu.edu/home/stchang/popl2017/"&gt;&lt;em&gt;Type Systems as Macros&lt;/em&gt;&lt;/a&gt;, which does precisely what I just described, and it delivers it all in a remarkably simple and elegant presentation. The idea is to “distribute” the task of typechecking over the individual forms of the language, leveraging existing macro communication facilities avaiable in the Racket macroexpander to propagate type information as macros are expanded. To me, it was exactly what I was looking for, and I almost immediately started playing with it and seeing what I could do with it.&lt;/p&gt;

&lt;p&gt;The result is &lt;a href="https://github.com/lexi-lambda/hackett"&gt;&lt;em&gt;Rascal&lt;/em&gt;&lt;/a&gt;, a programming language built in the Racket ecosystem that attempts to implement a Haskell-like type system.&lt;/p&gt;

&lt;h1 id="a-first-peek-at-rascal"&gt;A first peek at Rascal&lt;/h1&gt;

&lt;p&gt;Rascal is a very new programming language I’ve only been working on over the past few months. It is extremely experimental, riddled with bugs, half-baked, and may turn your computer into scrambled eggs. Still, while I might not recommend that you actually &lt;em&gt;use&lt;/em&gt; it just yet, I want to try and share what it is I’m working on, since I’d bet at least a few other people will find it interesting, too.&lt;/p&gt;

&lt;p&gt;First, let me say this up front: &lt;strong&gt;Rascal is probably a lot closer to Haskell than Racket&lt;/strong&gt;. That might come as a surprise, given that Rascal has very Lisp-y syntax, it’s written in Racket, and it runs on the Racket platform, but semantically, Rascal is mostly just Haskell 98. This is important, because it may come as a surprise, given that there are so few statically typed Lisps, but there’s obviously no inherent reason that Lisps need to be dynamically typed. They just seem to have mostly evolved that way.&lt;/p&gt;

&lt;p&gt;Taking a look at a snippet of Rascal code, it’s easy to see that the language doesn’t work quite like a traditional Lisp, though:&lt;sup&gt;&lt;a href="#2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-definition" name="2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def+ map-every-other : (forall [a] {{a -&amp;gt; a} -&amp;gt; (List a) -&amp;gt; (List a)})
  [_ nil            -&amp;gt; nil]
  [_ {x :: nil}     -&amp;gt; {x :: nil}]
  [f {x :: y :: ys} -&amp;gt; {x :: (f y) :: (map-every-other f ys)}])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a Lisp with all the goodies you would expect out of Haskell: static types, parametric polymorphism, automatically curried functions, algebraic datatypes, pattern-matching, infix operators, and of course, &lt;em&gt;typeclasses&lt;/em&gt;. Yes, with Rascal you can have your monads in all their statically dispatched glory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(data (Maybe a)
  (just a)
  nothing)

(instance (Monad Maybe)
  [join (case-lambda
          [(just (just x)) (just x)]
          [_               nothing])])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, though, this really &lt;em&gt;is&lt;/em&gt; just “Haskell with parentheses”. As alluded to above, however, Rascal is a bit more than that.&lt;/p&gt;

&lt;h2 id="core-forms-can-be-implemented-as-derived-concepts"&gt;Core forms can be implemented as derived concepts&lt;/h2&gt;

&lt;p&gt;Rascal’s type system is currently very simple, being nothing more than Hindley-Milner plus ad-hoc polymorphism in the form of typeclasses. Something interesting to note about it is that it does not implement ADTs or pattern-matching anywhere in the core! In fact, ADTs are defined as two macros &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt;, in an entirely separate module, which can be imported just like any other library.&lt;/p&gt;

&lt;p&gt;The main &lt;code&gt;rascal&lt;/code&gt; language provides ADTs by default, of course, but it would be perfectly possible to produce a &lt;code&gt;rascal/kernel&lt;/code&gt; language which does not include them at all. In this particular case, it seems unlikely that Rascal programmers would want their own implementation of ADTs, but it’s an interesting proof of concept, and it hints at other “core” features that could be implemented using macros.&lt;/p&gt;

&lt;p&gt;Simple syntactic transformations are, of course, trivially defined as macros. Haskell &lt;code&gt;do&lt;/code&gt; notation is defined as &lt;a href="https://github.com/lexi-lambda/hackett/blob/87d001a82c86fb66544d25c37ffba9be1ac63464/rascal-lib/rascal/monad.rkt#L48-L58"&gt;an eleven-line macro in &lt;code&gt;rascal/monad&lt;/code&gt;&lt;/a&gt;, and GHC’s useful &lt;code&gt;LambdaCase&lt;/code&gt; extension is also possible to implement without modifying Rascal at all. This is useful, because there are many syntactic shorthands that are extremely useful to implement, but don’t make any sense to be in GHC because they are specific to certain libraries or applications. Racket’s macro system makes those not only possible, but actually pretty easy.&lt;/p&gt;

&lt;p&gt;While the extent of what is possible to implement as derived forms remains to be seen, many useful GHC features seem quite possible to implement without touching the core language, including things like &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; and other generic deriving mechanisms like &lt;code&gt;GHC.Generics&lt;/code&gt;, &lt;code&gt;DeriveGeneric&lt;/code&gt;, and &lt;code&gt;DeriveAnyClass&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="the-language-is-not-enough"&gt;The language is not enough&lt;/h2&gt;

&lt;p&gt;No language is perfect. Most people would agree with this, but I would take it a step further: no language is even sufficient! This makes a lot of sense, given that general-purpose programming languages are designed to do &lt;em&gt;everything&lt;/em&gt;, and it’s impossible to do everything well.&lt;/p&gt;

&lt;p&gt;Haskell programmers know this, and they happily endorse the creation of embedded domain specific languages. These are fantastic, and we need more of them. Things like &lt;a href="http://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; let me write a third of the code I might otherwise need to, and the most readable code is the code you didn’t have to write in the first place. DSLs are good.&lt;/p&gt;

&lt;p&gt;Unfortunately, building DSLs is traditionally difficult, largely in part because building embedded DSLs means figuring out a way to encode your domain into your host language of choice. Sometimes, your domain simply does not elegantly map to your host language’s syntax or semantics, and you have to come up with a compromise. This is easy to see with servant, which, while it does a remarkably good job, still has to resort to some very clever type magic to create some semblance of an API description in Haskell types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type UserAPI = "users" :&amp;gt; Get '[JSON] [User]
          :&amp;lt;|&amp;gt; "users" :&amp;gt; ReqBody '[JSON] User :&amp;gt; Post '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; Get '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; ReqBody '[JSON] User
                       :&amp;gt; Put '[JSON] User&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code is &lt;em&gt;remarkably&lt;/em&gt; readable for what it is, but what if we didn’t have to worry about working within the constraints of Haskell’s syntax? What if we could design a syntax that was truly the best for the job? Perhaps we would come up with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-api User-API
  #:content-types [JSON]
  [GET  "users"                    =&amp;gt; (List User)]
  [POST "users"                    =&amp;gt; User -&amp;gt; User]
  [GET  "users" [userid : Integer] =&amp;gt; User]
  [PUT  "users" [userid : Integer] =&amp;gt; User -&amp;gt; User])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would be extremely easy to write with Racket’s macro-writing utilities, and it could even be made extensible. This could also avoid having to do the complicated typeclass trickery servant has to perform to then generate code from the above specification, since it would be much easier to just generate the necessary code directly (which still maintaining type safety).&lt;/p&gt;

&lt;p&gt;In addition to the type-level hacks that Haskell programmers often have to pull in order to make these kinds of fancy DSLs work, free monads tend to be used to create domain-specific languages. This works okay for some DSLs, but remember that when you use a free monad, you are effectively writing a &lt;em&gt;runtime interpreter&lt;/em&gt; for your language! Macros, on the other hand, are compiled, and you get ability to &lt;em&gt;compile&lt;/em&gt; your DSL to code that can be optimized by all the existing facilities of the compiler toolchain.&lt;/p&gt;

&lt;h1 id="rascal-is-embryonic"&gt;Rascal is embryonic&lt;/h1&gt;

&lt;p&gt;I’m pretty excited about Rascal. I think that it could have the potential to do some pretty interesting things, and I have some ideas in my head for how having macros in a Haskell-like language could change things. I also think that, based on what I’ve seen so far, having both macros and a Haskell-like type system could give rise to &lt;em&gt;completely&lt;/em&gt; different programming paradigms than exist in either Haskell or Racket today. My gut tells me that this is a case where the whole might actually be greater than the sum of its parts.&lt;/p&gt;

&lt;p&gt;That said, Rascal doesn’t really exist yet. Yes, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;there is a GitHub repository&lt;/a&gt;, and it has some code in it that does… something. Unfortunately, the code is also currently extremely buggy, to the point of being borderline broken, and it’s also in such early stages that you can’t really do &lt;em&gt;anything&lt;/em&gt; interesting with it, aside from some tiny toy programs.&lt;/p&gt;

&lt;p&gt;As I have worked on Rascal, I’ve come to a somewhat unfortunate conclusion, which is that I really have almost zero interest in implementing type systems. I felt that way before I started the project, but I was hoping that maybe once I got into them, I would find them more interesting. Unfortunately, as much as I love working with powerful type systems (and really, I adore working with Haskell and using all the fancy features GHC provides), I find implementing the software that makes them tick completely dull.&lt;/p&gt;

&lt;p&gt;Still, I’m willing to invest the time to get something that I can use. Even so, resources for practical type system implementation are scarce. I want to thank &lt;a href="https://web.cecs.pdx.edu/~mpj/"&gt;Mark P Jones&lt;/a&gt; for his wonderful resource &lt;a href="https://web.cecs.pdx.edu/~mpj/thih/"&gt;Typing Haskell in Haskell&lt;/a&gt;, without which getting to where I am now would likely have been impossible. I also want to thank &lt;a href="http://www.stephendiehl.com"&gt;Stephen Diehl&lt;/a&gt; for his wonderful &lt;a href="http://dev.stephendiehl.com/fun/"&gt;Write You a Haskell&lt;/a&gt; series, which was also wonderfully useful to study, even if it is unfinished and doesn’t cover anything beyond ML just yet.&lt;/p&gt;

&lt;p&gt;Even with these wonderful resources, I’ve come to the realization that &lt;strong&gt;I probably can’t do all of this on my own&lt;/strong&gt;. I consider myself pretty familiar with macros and macro expanders at this point, but I don’t know much about type systems (at least not their implementation), and I could absolutely use some help. So if you’re interested in Rascal and think you might be able to pitch in, please: I would appreciate even the littlest bits of help or guidance!&lt;/p&gt;

&lt;p&gt;In the meantime, I will try to keep picking away at Rascal in the small amount of free time I currently have. Thanks, as always, to all the amazing people who have contributed to the tools I’ve been using for this project: special thanks to the authors of &lt;em&gt;Type Systems as Macros&lt;/em&gt; for their help as well as the people I mentioned just above, and also to all of the people who have built Racket and Haskell and made them what they are today. Without them, Rascal would most definitely not exist.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Note that most of the Rascal code in this blog post probably doesn’t actually work on the current Rascal implementation. Pretty much all of it can be implemented in the current implementation, the syntax just isn’t quite as nice yet.&amp;nbsp;&lt;a href="#2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Four months with Haskell</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2016/06/12/four-months-with-haskell/?utm_source=functional-programming&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2016-06-12-four-months-with-haskell</id>
  <published>2016-06-12T16:02:27Z</published>
  <updated>2016-06-12T16:02:27Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;At the end of January of this year, I switched to a new job, almost exclusively because I was enticed by the idea of being able to write Haskell. The concept of using such an interesting programming language every day instead of what I’d been doing before (mostly Rails and JavaScript) was very exciting, and I’m pleased to say that the switch seems to have been well worth it.&lt;/p&gt;

&lt;p&gt;Haskell was a language I had played with in the past but never really used for anything terribly practical, but lately I think I can confidently say that it really is an &lt;em&gt;incredible&lt;/em&gt; programming language. At the same time, it has some significant drawbacks, too, though probably not the ones people expect. I certainly wasn’t prepared for some of the areas where Haskell would blow me away, nor was I capable of realizing which parts would leave me hopelessly frustrated until I actually sat down and started writing lots and lots of code.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="dispelling-some-myths"&gt;Dispelling some myths&lt;/h1&gt;

&lt;p&gt;Before moving on and discussing my experiences in depth, I want to take a quick detour to dispel some frequent rumors I hear about why Haskell is at least potentially problematic. These are things I hear a &lt;em&gt;lot&lt;/em&gt;, and nothing in my experience so far would lead me to believe these are actually true. Ultimately, I don’t want to spend too much time on these—I think that, for the most part, they are nitpicks that people complain about to avoid understanding the deeper and more insidious problems with the language—but I think it’s important to at least mention them.&lt;/p&gt;

&lt;h2 id="hiring-haskell-developers-is-not-hard"&gt;Hiring Haskell developers is not hard&lt;/h2&gt;

&lt;p&gt;I am on the first Haskell team in my company, and I am among the first Haskell developers we ever hired. Not only were we hiring without much experience with Haskell at all, we explicitly &lt;em&gt;did not&lt;/em&gt; want to hire remote. Debate all you like about whether or not permitting remote work is a good idea, but I don’t think anyone would dispute that this constraint makes hiring much harder. We didn’t have any trouble finding a very large stream of qualified applicants, and it definitely seems to have dispelled any fears that we would have trouble finding new candidates in the future.&lt;/p&gt;

&lt;h2 id="performing-io-in-haskell-is-easy"&gt;Performing I/O in Haskell is easy&lt;/h2&gt;

&lt;p&gt;Haskell’s purity is a point of real contention, and it’s one of the most frustrating complaints I often hear about Haskell. It is surprisingly common to hear concerns along the lines of “I don’t want to use Haskell because its academic devotion to purity sounds like it would make it very hard to get anything done”. There are very valid reasons to avoid Haskell, but in practice, I/O is not one of them. In fact, I found that isolating I/O in Haskell was much the same as isolating I/O in every other language, which I need to do anyway to permit unit testing.&lt;/p&gt;

&lt;p&gt;&amp;hellip;you &lt;em&gt;do&lt;/em&gt; write deterministic unit tests for your impure logic, right?&lt;/p&gt;

&lt;h2 id="working-with-lots-of-monads-is-not-very-difficult"&gt;Working with lots of monads is not very difficult&lt;/h2&gt;

&lt;p&gt;The “M word” has ended up being a running joke &lt;em&gt;about&lt;/em&gt; Haskell that actually ends up coming up fairly rarely &lt;em&gt;within&lt;/em&gt; the Haskell community. To be clear, there is &lt;em&gt;no doubt&lt;/em&gt; in my mind that monads make Haskell intimidating and provide a steep learning curve for new users. The proliferation of the joke that monads are impossible to explain, to the point of becoming mythologized, is absolutely indicative of a deeper problem about Haskell’s accessibility. However, once people learn the basics about monads, I’ve found that applying them is just as natural as applying any other programming pattern.&lt;/p&gt;

&lt;p&gt;Monads are used to assist the programmer, not impede them, and they really do pay off in practice. When something has a monadic interface, there’s a decent chance I already know what that interface is going to do, and that makes working with lots of different monads surprisingly easy. Admittedly, I do rely very, very heavily on tooling to help me out here, but with things like mouseover type tooltips, I’ve actually found that working with a variety of different monads and monad transformers is actually quite pleasant, and it makes things very readable!&lt;/p&gt;

&lt;h1 id="haskell-the-good-parts"&gt;Haskell: the good parts&lt;/h1&gt;

&lt;p&gt;With the disclaimers out of the way, I really just want to gush for a little bit. This is not going to be an objective, reasoned survey of why Haskell is good. I am not even really going to touch upon why types are so great and why purity is so wonderful—I’d love to discuss those in depth, but that’s for a different blog post. For now, I just want to touch upon the real surprises, the real things that made me &lt;em&gt;excited&lt;/em&gt; about Haskell in ways I didn’t expect. These are the things that my subjective little experience has found fun.&lt;/p&gt;

&lt;h2 id="language-extensions-are-haskell"&gt;Language extensions &lt;em&gt;are&lt;/em&gt; Haskell&lt;/h2&gt;

&lt;p&gt;There was a time in my life when I spent a lot of time writing C. There are a lot of compilers for C, and they all implement the language in subtly different but often incompatible ways, especially on different platforms. The only way to maintain a modicum of predictability was to adhere to the standards &lt;em&gt;religiously&lt;/em&gt;, even when certain GCC or MSVC extensions seem tantalizingly useful. I was actually bitten a few times by real instances where I figured I’d just use a harmless extension that was implemented everywhere, then found out it worked slightly differently across different compilers in a particular edge case. It was a learning experience.&lt;/p&gt;

&lt;p&gt;It seems that this fear provides a very real distrust for using GHC’s numerous &lt;em&gt;language extensions&lt;/em&gt;, and indeed, for a long time, I felt that it was probably an admirable goal to stick to Haskell 98 or Haskell 2010 as closely as possible. Sometimes I chose a slightly more verbose solution that was standard Haskell to avoid turning on a trivial extension that would make the code look a little bit cleaner.&lt;/p&gt;

&lt;p&gt;About a year later, I’m finding that attitude was not only a mistake, but it forced me to often completely miss out on a lot of Haskell’s core value. GHC &lt;em&gt;won&lt;/em&gt;, and now GHC and Haskell are basically synonymous. With that in mind, the portability concerns of language extensions are a bit of a non-issue, and turning them on is a very good idea! Some extensions are more than a little dangerous, so they cannot all be turned on without thinking, but the question is absolutely not “Is using language extensions a good idea?” and more “Is using &lt;em&gt;this&lt;/em&gt; language extension a good idea?”&lt;/p&gt;

&lt;p&gt;This is important, and I bring it up for a reason: so much of the awesomeness of Haskell is locked behind language extensions. Turning a lot of these on is one of the main things that made me really start to see how incredibly powerful Haskell actually is.&lt;/p&gt;

&lt;h2 id="phantom-types"&gt;Phantom types&lt;/h2&gt;

&lt;p&gt;I’m going to start out by talking about &lt;em&gt;phantom types&lt;/em&gt;, which are a pretty simple concept but a powerful one, and they serve as the foundation for a lot of other cool type-level tricks that can make Haskell extremely interesting. The basic idea of a phantom type is simple; it’s a type parameter that isn’t actually used to represent any particular runtime value:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This type represents an id for some kind of value, but although the kind of value is specified in the type as the &lt;code&gt;a&lt;/code&gt; type parameter, it isn’t actually used anywhere on the data definition—no matter what &lt;code&gt;a&lt;/code&gt; is, an &lt;code&gt;Id&lt;/code&gt; is just a piece of text. This makes it possible to write functions that operate on specific kinds of ids, and those invariants will be statically checked by the compiler, even though the runtime representation is entirely identical:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;fetchUser&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadDB&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Using &lt;code&gt;FlexibleInstances&lt;/code&gt;, it’s also possible to create different instances for different kinds of ids. For example, it would be possible to have different &lt;code&gt;Show&lt;/code&gt; instances depending on the type of id in question.&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"user #"&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;unpack&lt;/span&gt; &lt;span class="n"&gt;txt&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"post #"&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;unpack&lt;/span&gt; &lt;span class="n"&gt;txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This provides a simple framework for encoding entirely arbitrary information into the type system, then asking the compiler to actually check assertions about that information. This is made even more powerful with some other extensions, which I’ll talk about shortly.&lt;/p&gt;

&lt;h2 id="letting-the-compiler-write-code"&gt;Letting the compiler write code&lt;/h2&gt;

&lt;p&gt;One of the things I really dislike, more than most things, is boilerplate. A little bit of boilerplate is fine—even necessary at times—but as soon as I start wondering if a code generator would improve things, I think the programming language has pretty much failed me.&lt;/p&gt;

&lt;p&gt;I write a lot of Racket because, in a sense, Racket is the ultimate boilerplate killer: the macro system is a first-class code generator integrated with the rest of the language, and it means that boilerplate is almost never an issue. Of course, that’s not always true: sometimes a bit of boilerplate &lt;em&gt;is&lt;/em&gt; still necessary because macros cannot deduce enough information about the program to generate the code entirely on their own, and in Haskell, some of that information is actually present in the type system.&lt;/p&gt;

&lt;p&gt;This leads to two absolutely incredible extensions, both of which are simple and related, but which actually &lt;em&gt;completely change&lt;/em&gt; how I approach problems when programming. These two extensions are &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; and &lt;code&gt;StandaloneDeriving&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="newtypes-and-type-safety"&gt;Newtypes and type safety&lt;/h3&gt;

&lt;p&gt;The basic idea is that “newtypes” are just simple wrapper types in Haskell. This turns out to be extremely important when trying to find the value of Haskell because they allow you to harden type safety by specializing types to &lt;em&gt;your&lt;/em&gt; domain. For example, consider a type representing a user’s name:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This type is extremely simple, and in fact isn’t even at all different from a simple &lt;code&gt;Text&lt;/code&gt; value with respect to its representation, since all combinations of unicode characters are allowed in a name. Therefore, what’s the point of a separate type? Well, this allows Haskell to introduce actual compilation failures when two different kinds of textual data are mixed. This is not a new idea, and even in languages that don’t support this sort of thing, Joel Spolsky’s old blog post &lt;a href="http://www.joelonsoftware.com/articles/Wrong.html"&gt;Making Wrong Code Look Wrong&lt;/a&gt; describes how it can be done by convention. Still, almost every modern language makes this possible: in C, it would be a single-member &lt;code&gt;struct&lt;/code&gt;, in class-based OO languages, it would be a single-member class&amp;hellip; this is not a complicated idea.&lt;/p&gt;

&lt;p&gt;The difference lies in its usage. In other languages, this strategy is actually not very frequently employed for the simple reason that it is almost always extremely annoying. You are forced to do tons of wrapping/unwrapping, and at that point it isn’t really clear if you’re even getting all that much value out of the distinction when your first solution to a type mismatch is wrapping or unwrapping the value without a second thought. In Haskell, however, this can be heavily mitigated by asking the compiler to &lt;em&gt;automatically derive typeclass implementations&lt;/em&gt;, which allow the unwrapping/wrapping to effectively happen implicitly for a constrained set of operations.&lt;/p&gt;

&lt;h3 id="using-generalizednewtypederiving"&gt;Using &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Consider the &lt;code&gt;Name&lt;/code&gt; type once again, but this time, let’s derive a class:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IsString&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;IsString&lt;/code&gt; typeclass in Haskell allows custom types to automatically be created from string literals. It is &lt;em&gt;not&lt;/em&gt; handled specially by Haskell’s &lt;code&gt;deriving&lt;/code&gt; mechanism. Since &lt;code&gt;Text&lt;/code&gt; implements &lt;code&gt;IsString&lt;/code&gt;, an instance will be generated that simply defers to the underlying type, automatically generating the code to wrap the result up in a &lt;code&gt;Name&lt;/code&gt; box at the end. This means that code like this will now just magically work:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt;
&lt;span class="nf"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Alyssa P. Hacker"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;No boilerplate needs to be written! This is a neat trick, but it actually turns out to be far more useful than that simple example in practice. What really makes this functionality shine is when you want to derive &lt;em&gt;some&lt;/em&gt; kinds of functionality but disallow some others. For example, using the &lt;a href="https://hackage.haskell.org/package/text-conversions"&gt;&lt;code&gt;text-conversions&lt;/code&gt;&lt;/a&gt; package, it’s possible to do something like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToText&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This creates an opaque &lt;code&gt;Id&lt;/code&gt; type, but it automatically generates conversions &lt;em&gt;to&lt;/em&gt; textual formats. However, it does &lt;em&gt;not&lt;/em&gt; automatically create &lt;code&gt;FromText&lt;/code&gt; or &lt;code&gt;FromJSON&lt;/code&gt; instances, which would be dangerous because decoding &lt;code&gt;Id&lt;/code&gt;s can potentially fail. It’s then possible to write out those instances manually to preserve a type safety:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromText&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;fromText&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="n"&gt;isValidId&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="kr"&gt;then&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;else&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;parseJSON&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="s"&gt;"invalid id"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fromText&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;parseJSON&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt;            &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="s"&gt;"invalid id"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;h3 id="using-standalonederiving"&gt;Using &lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The ordinary &lt;code&gt;deriving&lt;/code&gt; mechanism is extremely useful, especially when paired with the above, but sometimes it is desirable to have a little bit more flexibility. In these cases, &lt;code&gt;StandaloneDeriving&lt;/code&gt; can help.&lt;/p&gt;

&lt;p&gt;Take the &lt;code&gt;Id&lt;/code&gt; example again: it has a phantom type, and simply adding something like &lt;code&gt;deriving (ToText)&lt;/code&gt; with derive &lt;code&gt;ToText&lt;/code&gt; instances for &lt;em&gt;all&lt;/em&gt; kinds of ids. It is potentially useful, however, to derive instances for more specific id types. Using standalone &lt;code&gt;deriving&lt;/code&gt; constructs permits this sort of flexibility.&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ToText&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ToText&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;toText&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;postIdToText&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is an example where GHC language extensions end up becoming significantly more than the sum of their parts, which seems to be a fairly frequent realization. The &lt;code&gt;StandaloneDeriving&lt;/code&gt; mechanism is a little bit useful without &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;, but when combined, they are incredibly powerful tools for getting a very fine-grained kind of type safety &lt;em&gt;without&lt;/em&gt; writing any boilerplate.&lt;/p&gt;

&lt;h2 id="datakinds-are-super-cool-with-caveats"&gt;DataKinds are super cool, with caveats&lt;/h2&gt;

&lt;p&gt;Phantom types are quite wonderful, but they can only encode &lt;em&gt;types&lt;/em&gt;, not arbitrary data. That’s where &lt;code&gt;DataKinds&lt;/code&gt; and &lt;code&gt;KindSignatures&lt;/code&gt; come in: they allow lifting arbitrary datatypes to the type level so that things that would normally be purely runtime values can be used at compile-time as well.&lt;/p&gt;

&lt;p&gt;The way this works is pretty simple—when you define a datatype, you also define a “datakind”:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;RegistrationStatus&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Registered&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Anonymous&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Normally, the above declaration declares a &lt;em&gt;type&lt;/em&gt;, &lt;code&gt;RegistrationStatus&lt;/code&gt;, and two &lt;em&gt;data constructors&lt;/em&gt;, &lt;code&gt;Registered&lt;/code&gt; and &lt;code&gt;Anonymous&lt;/code&gt;. With &lt;code&gt;DataKinds&lt;/code&gt;, it also defines a &lt;em&gt;kind&lt;/em&gt;, &lt;code&gt;RegistrationStatus&lt;/code&gt;, and two &lt;em&gt;type constructors&lt;/em&gt;, &lt;code&gt;Registered&lt;/code&gt; and &lt;code&gt;Anonymous.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If that’s confusing, the way to understand that is to realize there is a sort of natural ordering here: types describe values, and kinds describe types. Therefore, turning on &lt;code&gt;DataKinds&lt;/code&gt; “lifts” each definition by a single level, so types become kinds and values become types. This permits using these things at the type level:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;RegistrationStatus&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this example, &lt;code&gt;UserId&lt;/code&gt; still has a single phantom type variable, &lt;code&gt;s&lt;/code&gt;, but this time it is constrained to the &lt;code&gt;RegistrationStatus&lt;/code&gt; kind. Therefore, it can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;Registered&lt;/code&gt; or &lt;code&gt;Anonymous&lt;/code&gt;. This cooperates well with the aforementioned &lt;code&gt;StandaloneDeriving&lt;/code&gt; mechanism, and it mostly provides a convenient way to constrain type variables to custom kinds.&lt;/p&gt;

&lt;p&gt;In general, &lt;code&gt;DataKinds&lt;/code&gt; is a much more powerful extension, allowing things like type-level natural numbers or strings, which can be used to perform actual type-level computation (especially in combination with &lt;code&gt;TypeFamilies&lt;/code&gt;) or a sort of metaprogramming. In some cases, they can even be used to implement things emulating things you can do with dependent types.&lt;/p&gt;

&lt;p&gt;I think &lt;code&gt;DataKinds&lt;/code&gt; are a very cool Haskell extension, but there are a couple caveats. One of the main ones is how new kinds are defined: &lt;code&gt;DataKinds&lt;/code&gt; “hijacks” the existing datatype declaration syntax by making every single datatype declaration define a type &lt;em&gt;and&lt;/em&gt; a kind. This is a little confusing, and it would be nice if a different syntax was used so that each could be defined independently.&lt;/p&gt;

&lt;p&gt;Similarly, it seems that a lot of work is being done to allow using runtime values at the type level, but I wonder if people will ever need to use, say, runtime values at the &lt;em&gt;kind&lt;/em&gt; level. This immediately evokes thoughts of Racket’s phase-based macro system, and I wonder if some of this duplication would be unnecessary with something similar.&lt;/p&gt;

&lt;p&gt;Food for thought, but overall, &lt;code&gt;DataKinds&lt;/code&gt; are a very nice addition to help with precisely and specifically typing particular problems.&lt;/p&gt;

&lt;h2 id="typeclasses-can-emulate-effects"&gt;Typeclasses can emulate effects&lt;/h2&gt;

&lt;p&gt;This is something that I’ve found interesting in my time writing Haskell because I have &lt;em&gt;no idea&lt;/em&gt; if it’s idiomatic or not, but it seems pretty powerful. The initial motivator for this idea was figuring out how to test our code without constantly dropping into &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;More generally, we wanted to be able to unit test by “mocking” out collaborators, as it would be described in object oriented programming. I was always semi-distrustful of mocking, and indeed, it seems likely that it is heavily abused in certain circles, but I’ve come to appreciate the need that sometimes it is important to stub things out, &lt;em&gt;even in pure code&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;As an example, consider some code that needs access to the current time. This is something that would normally require &lt;code&gt;IO&lt;/code&gt;, but we likely want to be able to use the value in a pure context without “infecting” the entire program with &lt;code&gt;IO&lt;/code&gt; types. In Haskell, I have generally seen three ways of handling this sort of thing:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;Just inject the required values into the function and produce them “higher up” where I/O is okay. If threading the value around becomes too burdensome, use a Reader monad.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Use a free monad or similar to create a pure DSL of sorts, then write interpreters for various implementations, one of which uses &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Create custom monadic typeclasses that provide interfaces to the functionality you want to perform, then create instances, one of which is an instance over &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;This last approach seems to be less common in Haskell, but it’s the approach we took, and it seems to work out remarkably well. Returning to the need to get the current time, we could pretty easily write such a typeclass to encode that need:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;getCurrentTime&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;UTCTime&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we can write functions that use the current time:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;validateToken&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Token&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="nf"&gt;validateToken&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;currentTime&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getCurrentTime&lt;/span&gt;
  &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tokenExpirationDate&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentTime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, we can write instances for &lt;code&gt;CurrentTime&lt;/code&gt; that will allow us to run the same code in different contexts:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;AppM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;AppM&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;runAppM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadIO&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Identity&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;runTestM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;runTestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;runIdentity&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="kt"&gt;AppM&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;getCurrentTime&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftIO&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Clock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCurrentTime&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;getCurrentTime&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;posixSecondsToUTCTime&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Where this really starts to shine is when adding additional effects. For example, the above token validation function might also need information about some kind of secret used for signing. Under this model, it’s just another typeclass:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TokenSecret&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;getTokenSecret&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Secret&lt;/span&gt;

&lt;span class="nf"&gt;validateToken&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;TokenSecret&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Token&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="nf"&gt;validateToken&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;currentTime&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getCurrentTime&lt;/span&gt;
  &lt;span class="n"&gt;secret&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getTokenSecret&lt;/span&gt;
  &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tokenExpirationDate&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentTime&lt;/span&gt;
       &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;verifySignature&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Of course, so far all of these functions have been extremely simple, and we’ve basically been using them as a glorified reader monad. In practice, though, we use this pattern for lots more than just retrieving values. For example, we might have a typeclass for database interactions:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Persistence&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;fetchUser&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;insertUser&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;PersistenceError&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With all of this done, it becomes incredibly easy to see which functions are using which effects:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;postUsers&lt;/span&gt;
  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Persistence&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;TokenSecret&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Response&lt;/span&gt;
&lt;span class="nf"&gt;postUsers&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="nf"&gt;getHealthcheck&lt;/span&gt;
  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Response&lt;/span&gt;
&lt;span class="nf"&gt;getHealthcheck&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;There’s no need to perform any lifting, and this all seems to scale quite nicely. We’ve written some additional utilities to help write tests against functions using these kinds of monadic interfaces, and even though there’s a little bit of annoying boilerplate in a few spots, overall it seems to work quite elegantly.&lt;/p&gt;

&lt;p&gt;I’m not entirely sure how common this is in the Haskell community, but it’s certainly pretty neat how easy it is to get nearly all of the benefits of effect types in other languages simply by composing some of Haskell’s simplest features.&lt;/p&gt;

&lt;h2 id="atoms-ide-haskell-tooling-is-invaluable"&gt;Atom’s ide-haskell tooling is invaluable&lt;/h2&gt;

&lt;p&gt;Alright, so, confession time: I don’t use Emacs.&lt;/p&gt;

&lt;p&gt;I know, I know, how is that possible? I write Lisp, after all. Well, honestly, I tried picking it up a number of times, but none of those times did I get far enough to ditch my other tools. For Racket work, I use DrRacket, but for almost everything else, I use Atom.&lt;/p&gt;

&lt;p&gt;Atom has a lot of flaws, but it’s also pretty amazing in places, and I absolutely &lt;em&gt;love&lt;/em&gt; the Haskell tooling written by the wonderful &lt;a href="https://github.com/atom-haskell"&gt;atom-haskell&lt;/a&gt; folks. I use it constantly, and even though it doesn’t always work perfectly, it works pretty well. When it has problems, I’ve at least figured out how to get it working correctly.&lt;/p&gt;

&lt;p&gt;This is probably hard to really explain without seeing it for yourself, but I’ve found that I basically &lt;em&gt;depend&lt;/em&gt; on this sort of tooling to be fully productive in Haskell, and I have no problem admitting that. The ability to get instant feedback about type errors tied to visual source locations, to be able to directly manipulate the source by selecting expressions and getting type information, and even the option to get inline linter suggestions means I spend a lot less time glancing at the terminal, and even less time in the REPL.&lt;/p&gt;

&lt;p&gt;The tooling is far from perfect, and it leaves a lot to be desired in places (the idea of using that static information for automated, project-wide refactoring &lt;em&gt;a la&lt;/em&gt; Java is tantalizing), but most of those things are ideas of what amazing things could be, not broken or missing essentials. I am pretty satisfied with ide-haskell right now, and I can only hope it continues to get better and better.&lt;/p&gt;

&lt;h1 id="frustrations-drawbacks-and-pain-points"&gt;Frustrations, drawbacks, and pain points&lt;/h1&gt;

&lt;p&gt;Haskell is not perfect. In fact, far from it. There is a vast array of little annoyances that I have with the language, as is the case with any language. Still, there are a few overarching problems that I would really like to at least mention. These are the biggest sources of frustration for me so far.&lt;/p&gt;

&lt;h2 id="purity-failure-and-exception-handling"&gt;Purity, failure, and exception-handling&lt;/h2&gt;

&lt;p&gt;One of Haskell’s defining features is its purity—I don’t think many would disagree with that. Some people consider it a drawback, others consider it one of its greatest boons. Personally, I like it a lot, and I think one of the best parts about it is how it requires the programmer to be incredibly deliberate about failure.&lt;/p&gt;

&lt;p&gt;In many languages, when looking up a value from a container where the key doesn’t exist, there are really two ways to go about expressing this failure:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Throw an exception.&lt;/li&gt;
 &lt;li&gt;Return &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The former is scary because it means &lt;em&gt;any&lt;/em&gt; call to any function can make the entire program blow up, and it’s often impossible to know which functions even have the potential to throw. This creates a certain kind of non-local control flow that can sometimes cause a lot of unpredictability. The second option is much the same, especially when any value in a program might be &lt;code&gt;null&lt;/code&gt;; it just defers the failure.&lt;/p&gt;

&lt;p&gt;In languages with option types, this is somewhat mitigated. Java now has option types, too, but they are still frequently cumbersome to use because there is nothing like monads to use to simply chain operations together. Haskell, in comparison, has an incredible complement of tools to simply handle errors without a whole lot of burden on the programmer, and I have found that, in practice, this is &lt;em&gt;actually helpful&lt;/em&gt; and I really do write better error-handling code.&lt;/p&gt;

&lt;h3 id="first-the-good-parts"&gt;First, the good parts&lt;/h3&gt;

&lt;p&gt;I have seen a comparison drawn between throwing checked exceptions and returning &lt;code&gt;Maybe&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt; types, but in practice the difference is massive. Handling checked exceptions is a monotonous chore because they are not first-class values, they are actually entirely separate linguistic constructs. Consider a library that throws a &lt;code&gt;LibraryException&lt;/code&gt;, and you want to wrap that library and convert those exceptions to &lt;code&gt;ApplicationException&lt;/code&gt;s. Well, have fun writing this code dozens of times:&lt;/p&gt;

&lt;div class="brush: java"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LibraryException&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;ApplicationException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fromLibraryException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// ...&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;doSomethingElse&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LibraryException&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;ApplicationException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fromLibraryException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In Haskell, failure is just represented by first-class values, and it’s totally possible to write helper functions to abstract over that kind of boilerplate:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;libraryToApplication&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;LibraryError&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ApplicationError&lt;/span&gt;
&lt;span class="nf"&gt;libraryToApplication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="nf"&gt;liftLibrary&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;LibraryError&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;ApplicationError&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;liftLibrary&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mapLeft&lt;/span&gt; &lt;span class="n"&gt;libraryToApplication&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, that same boilerplate-y code becomes nearly invisible:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftLibrary&lt;/span&gt; &lt;span class="n"&gt;doSomething&lt;/span&gt;

&lt;span class="c1"&gt;-- ...&lt;/span&gt;

&lt;span class="nf"&gt;y&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftLibrary&lt;/span&gt; &lt;span class="n"&gt;doSomethingElse&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This might not &lt;em&gt;seem&lt;/em&gt; like much, but it really cuts down on the amount of visual noise, which ends up making all the difference. Boilerplate incurs a cost much bigger than simply taking the time to type it all out (though that’s important, too): the cognitive overhead of parsing which parts of a program are boilerplate has a significant impact on readability.&lt;/p&gt;

&lt;h3 id="so-whats-the-problem"&gt;So what’s the problem?&lt;/h3&gt;

&lt;p&gt;If error handling is so great in Haskell, then why am I putting it under the complaints section? Well, it turns out that not everyone seems to think it’s as great as I make it out to be because people seem to keep writing Haskell APIs that throw exceptions!&lt;/p&gt;

&lt;p&gt;Despite what some purists would have you believe, Haskell has exceptions, and they are not uncommon. Lots of things can throw exceptions, some of which are probably reasonable. Failing to connect to a database is a pretty catastrophic error, so it seems fair that it would throw. On the other hand, inserting a duplicate record is pretty normal operation, so it seems like that should &lt;em&gt;not&lt;/em&gt; throw.&lt;/p&gt;

&lt;p&gt;I mostly treat exceptions in Haskell as unrecoverable catastrophes. If I throw an error in &lt;em&gt;my&lt;/em&gt; code, I do not intend to catch it. That means something horrible happened, and I just want that horribleness to show up in a log somewhere so I can fix the problem. If I care about failure, there are better ways to handle that failure gracefully.&lt;/p&gt;

&lt;p&gt;It’s also probably worth noting that exceptions in Haskell can be thrown from anywhere, even pure code, but can only be &lt;em&gt;caught&lt;/em&gt; within the &lt;code&gt;IO&lt;/code&gt; monad. This is especially scary, but I’ve seen it happen in actual libraries out in the wild, even ones that the entire Haskell ecosystem is built on. One of the crowning examples of this is the &lt;code&gt;text&lt;/code&gt; package, which provides a function called &lt;code&gt;decodeUtf8&lt;/code&gt; to convert bytestrings into text. Its type is very simple:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;decodeUtf8&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ByteString&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But wait, what if the bytestring is not actually a valid UTF&amp;ndash;8 string?&lt;/p&gt;

&lt;p&gt;Boom. There goes the application.&lt;/p&gt;

&lt;p&gt;Okay, okay, well, at least the &lt;code&gt;text&lt;/code&gt; package provides another function, this one called &lt;code&gt;decodeUtf8'&lt;/code&gt;, which returns an &lt;code&gt;Either&lt;/code&gt;. This is good, and I’ve trained myself to only ever use &lt;code&gt;decodeUtf8'&lt;/code&gt;, but it still has some pretty significant problems:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The &lt;em&gt;safe&lt;/em&gt; version of this function is the “prime” version, rather than the other way around, which encourages people to use the unsafe one. Ideally, the unsafe one should be explicitly labeled as such&amp;hellip; maybe call it &lt;code&gt;unsafeDecodeUtf8&lt;/code&gt;?&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;This is not a hypothetical problem. When using a Haskell JWT library, we found a function that converts a string into a JWT. Since not all strings are JWTs, the library intelligently returns a &lt;code&gt;Maybe&lt;/code&gt;. Therefore, we figured we were safe.&lt;/p&gt;
  &lt;p&gt;A couple weeks later, we found that providing this function with invalid data was returning HTTP 500 errors. Why? Our error handling was meticulous! Well, the answer was a &lt;code&gt;decodeUtf8&lt;/code&gt; call, hidden inside of the JWT library. This is especially egregious, given that the API it exposed returned a &lt;code&gt;Maybe&lt;/code&gt; anyway! It would have been trivial to use the safe version there, instead, but the poor, misleading name led the library developer to overlook the bug lurking in the otherwise innocuous function.&lt;/p&gt;
  &lt;p&gt;Even worse, this function was totally pure, and we used it in pure code, so we could not simply wrap the function and catch the exception. We had two options: use &lt;code&gt;unsafePerformIO&lt;/code&gt; (yuck!) or perform a check before handing the data to the buggy function. We chose the latter, but in some cases, I imagine that could be too difficult to do in order to make it feasible.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The point I’m trying to make is that this is a real problem, and it seems to me that throwing exceptions invalidates one of the primary advantages of Haskell. It disappointed me to realize that a significant amount of code written by FP Complete, one of the primary authors of some of the most important “modern Haskell” code in existence (including Stack), seem to very frequently expose APIs that will throw.&lt;/p&gt;

&lt;p&gt;I’m not sure how much of this stems from a fundamental divide in the Haskell ecosystem and how much it is simply due to Michael Snoyman’s coding style, given that he is the primary author of a number of these tools and libraries that seem very eager to throw exceptions. As just one example of a real situation in which we were surprised by this behavior, we used Snoyman’s http-client library and found that it mysteriously throws upon nearly &lt;em&gt;any&lt;/em&gt; failure state:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;A note on exceptions: for the most part, all actions that perform I/O should be assumed to throw an &lt;code&gt;HttpException&lt;/code&gt; in the event of some problem, and all pure functions will be total. For example, &lt;code&gt;withResponse&lt;/code&gt;, &lt;code&gt;httpLbs&lt;/code&gt;, and &lt;code&gt;BodyReader&lt;/code&gt; can all throw exceptions.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This doesn’t seem entirely unreasonable—after all, isn’t a failure to negotiate TLS fairly catastrophic?—until you consider our use case. We needed to make a subrequest during the extent of another HTTP request to our server, and if that subrequest fails, we absolutely need to handle that failure gracefully. Of course, this is not &lt;em&gt;terrible&lt;/em&gt; given that we are in &lt;code&gt;IO&lt;/code&gt; so we can actually catch these exceptions, but since this behavior was only noted in a single aside at the top of the documentation, we didn’t realize we were forgetting error handling until far too late and requests were silently failing.&lt;/p&gt;

&lt;p&gt;Exceptions seem to devalue one of the most powerful concepts in Haskell: if I don’t consider all the possibilities, my code &lt;em&gt;does not compile&lt;/em&gt;. In practice, when working with APIs that properly encode these possibilities into the type system, this value proposition seems to be real. I really do find myself writing code that works correctly as soon as it compiles. It’s almost magical.&lt;/p&gt;

&lt;p&gt;Using exceptions throws that all out the window, and I wish the Haskell ecosystem was generally more cautious about when to use them.&lt;/p&gt;

&lt;h2 id="the-string-problem"&gt;The String problem&lt;/h2&gt;

&lt;p&gt;I sort of alluded to this a tiny bit in the last section, and that is probably indicative of how bad this issue is. I’m just going to be blunt: &lt;strong&gt;In Haskell, strings suck.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is always a bit of an amusing point whenever it is discussed because of how silly it seems. Haskell is a research language with a cutting-edge type system and some of the fanciest features of any language in existence. When everyday programming might use things like “profunctors”, “injective type families”, and “generalized algebraic datatypes”, you would think that dealing with &lt;em&gt;strings&lt;/em&gt; would be a well-solved problem.&lt;/p&gt;

&lt;p&gt;But it isn’t. Haskell libraries frequently use not one, not two, but &lt;strong&gt;&lt;em&gt;five&lt;/em&gt;&lt;/strong&gt; kinds of strings. Let’s list them off, shall we?&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;First off, there’s the built-in &lt;code&gt;String&lt;/code&gt; type, which is actually an alias for the &lt;code&gt;[Char]&lt;/code&gt; type. For those not intimately familiar with Haskell, that’s a &lt;em&gt;linked list of characters&lt;/em&gt;. As &lt;a href="http://www.stephendiehl.com/"&gt;Stephen Diehl&lt;/a&gt; recently put it in &lt;a href="http://www.stephendiehl.com/posts/strings.html"&gt;a blog post describing the disaster that is Haskell string types&lt;/a&gt;:&lt;/p&gt;
  &lt;blockquote&gt;
   &lt;p&gt;This is not only a bad representation, it’s quite possibly the least efficient (non-contrived) representation of text data possible and has horrible performance in both time and space. &lt;em&gt;And it’s used everywhere in Haskell.&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
  &lt;p&gt;The point is, it’s really bad. This type is not a useful representation for textual data in practical applications.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Moving on, we have a fairly decent type, &lt;code&gt;Text&lt;/code&gt;, which comes from &lt;code&gt;Data.Text&lt;/code&gt; in the &lt;code&gt;text&lt;/code&gt; package. This is a decent representation of text, and it’s probably the one that everything should use. Well, maybe. Because &lt;code&gt;Text&lt;/code&gt; comes in two varieties: lazy and strict. Nobody seems to agree on which of those two should be used, though, and they are totally incompatible types: functions that work with one kind of text won’t work with the other. You have to manually convert between them.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, we have &lt;code&gt;ByteString&lt;/code&gt;, which is horribly misnamed because it really isn’t a string at all, at least not in the textual sense. A better name for this type would have simply been &lt;code&gt;Bytes&lt;/code&gt;, which sounds a lot scarier. And that would be good, because data typed as a &lt;code&gt;ByteString&lt;/code&gt; is as close as you can get in Haskell to not assigning a type at all: a bytestring holds arbitrary bytes without assigning them any meaning whatsoever!&lt;/p&gt;
  &lt;p&gt;Or at least, that’s the intention. The trouble is that people &lt;em&gt;don’t&lt;/em&gt; treat bytestrings like that—they just use them to toss pieces of text around, even when those pieces of text have a well-defined encoding and represent textual data. This leads to the &lt;code&gt;decodeUtf8&lt;/code&gt; problem mentioned above, but it’s bigger than that because it often ends up with some poor APIs that assign some interpretation to &lt;code&gt;ByteString&lt;/code&gt; data without assigning it a different type.&lt;/p&gt;
  &lt;p&gt;Again, this is throwing away so much of Haskell’s safety. It would be like using &lt;code&gt;Int&lt;/code&gt; to keep track of boolean data (“just use 0 and 1!”) or using empty and singleton lists instead of using &lt;code&gt;Maybe&lt;/code&gt;. When you use the precise type, you encode invariants and contracts into statically-checked assertions, but when you use general types like &lt;code&gt;ByteString&lt;/code&gt;, you give that up.&lt;/p&gt;
  &lt;p&gt;Oh, and did I mention that &lt;code&gt;ByteString&lt;/code&gt;s also come in incompatible lazy and strict versions, too?&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;So, obviously, the answer is to just stop using the bad types and to just use (one kind of) &lt;code&gt;Text&lt;/code&gt; everywhere. Great! Except that the other types are totally inescapable. The entire standard library uses &lt;code&gt;String&lt;/code&gt; exclusively—after all, &lt;code&gt;text&lt;/code&gt; is a separate package—and small libraries often use &lt;code&gt;String&lt;/code&gt; instead of &lt;code&gt;text&lt;/code&gt; because they have no need to bring in the dependency. Of course, this just means every real application pays the performance hit of converting between all these different kinds of strings.&lt;/p&gt;

&lt;p&gt;Similarly, those that &lt;em&gt;do&lt;/em&gt; use &lt;code&gt;Text&lt;/code&gt; often use different kinds of text, so code ends up littered with &lt;code&gt;fromStrict&lt;/code&gt; or &lt;code&gt;toStrict&lt;/code&gt; coercions, which (again) have a cost. I’ve already ranted enough about &lt;code&gt;ByteString&lt;/code&gt;, but basically, if you’re using &lt;code&gt;ByteString&lt;/code&gt; in your API to pass around data that is semantically text, you are causing me pain. Please stop.&lt;/p&gt;

&lt;p&gt;It seems that the way &lt;code&gt;Data.Text&lt;/code&gt; probably &lt;em&gt;should&lt;/em&gt; have been designed was by making &lt;code&gt;Text&lt;/code&gt; a typeclass, then making the lazy and strict implementations instances of that typeclass. Still, the fact that both of them exist would always cause problems. I’m actually unsure which one is the “correct” choice—I don’t know enough about how the two perform in practice—but it seems likely that picking &lt;em&gt;either&lt;/em&gt; one would be a performance improvement over the current system, which is constantly spending time converting between the two.&lt;/p&gt;

&lt;p&gt;This issue has been ranted about plenty, so I won’t ramble on, but if you’re designing new libraries, please, &lt;em&gt;please&lt;/em&gt; use &lt;code&gt;Text&lt;/code&gt;. Your users will thank you.&lt;/p&gt;

&lt;h2 id="documentation-is-nearly-worthless"&gt;Documentation is nearly worthless&lt;/h2&gt;

&lt;p&gt;Finally, let’s talk about documentation.&lt;/p&gt;

&lt;p&gt;One of my favorite programming languages is Racket. Racket has a documentation tool called Scribble. Scribble is special because it is a totally separate domain-specific language for writing documentation, and it makes it fun and easy to write good explanations. There are even forms for typesetting automatically-rendered examples that look like a REPL. If the examples ever break or become incorrect, the docs don’t even compile.&lt;/p&gt;

&lt;p&gt;All of the Racket core library documentation makes sure to set a good example about what good documentation should look like. The vast majority of the documentation is paragraphs of prose and simple but practical examples. There are also type signatures (in the form of contracts), and those are super important, but they are so effective because of how the prose explains what each function does, when to use it, &lt;em&gt;why&lt;/em&gt; you’d use it, and &lt;em&gt;why you wouldn’t use it&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Everything is cross-referenced automatically. The documentation is completely searchable locally out of the box. As soon as you install a package, its docs are automatically indexed. User-written libraries tend to have pretty good docs, too, because the standard libraries set such a good example &lt;em&gt;and&lt;/em&gt; because the tools are so fantastic. Racket docs are really nice, and they’re so good they actually make things like Stack Overflow or even Google mostly irrelevant. It’s all there in the manual.&lt;/p&gt;

&lt;p&gt;Haskell documentation is the opposite of everything I just said.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The core libraries are poorly documented. Most functions include a sentence of description, and almost none include examples. At their worst, the descriptions simply restate the type signature.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Third-party libraries’ documentation is even worse, going frequently completely undocumented and actually only including type signatures and nothing else.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Haddock is an incredibly user-hostile tool for writing anything other than tiny snippets of documentation and is not very good at supporting prose. Notably, Haddock’s documentation is not generated using Haddock (and it still manages to be almost unusable). Forcing all documentation into inline comments makes users unlikely to write much explanation, and there is no ability for abstraction.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Reading documentation locally is very difficult because there is no easy way to open documentation for a particular package in a web browser, and it’s &lt;em&gt;certainly&lt;/em&gt; not searchable. This is especially ridiculous given that Hoogle exists, which is one of best ways to search API docs in existence. There should be a &lt;code&gt;stack hoogle&lt;/code&gt; command that just opens a Hoogle page for all locally-installed packages and Just Works, but there isn’t.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Most valuable information exists outside of documentation, so Google becomes a go-to immediately after a quick glance at the docs, and information is spread across blog posts, mailing lists, and obscure reddit posts.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This is a problem that cannot be fixed by just making Haddock better, nor can it be fixed simply by improving the existing standard library documentation. There is a fundamental problem with Haskell documentation (which, to be completely fair, is not unique to Haskell), which is that its tools do not support anything more than API docs.&lt;/p&gt;

&lt;p&gt;Good documentation is so much more than “here’s what this function does”; it’s about guides and tutorials and case studies and common pitfalls. &lt;a href="http://docs.racket-lang.org/lens/lens-guide.html"&gt;This is documentation for someone new to lenses.&lt;/a&gt; &lt;a href="https://hackage.haskell.org/package/lens#readme"&gt;This is not.&lt;/a&gt; Take note of the difference.&lt;/p&gt;

&lt;h1 id="conclusion-and-other-thoughts"&gt;Conclusion and other thoughts&lt;/h1&gt;

&lt;p&gt;Haskell is an incredible programming platform, and indeed, it is sometimes mind-boggling how complete it is. It also has a lot of rough edges, sometimes in places that feel like they need a lot more care, or perhaps they’re even simply unfinished.&lt;/p&gt;

&lt;p&gt;I could spend weeks writing about all the things I really like or dislike about the language, discussing in fine detail all the things that have made me excited or all the little bits that have made me want to tear my hair out. Heck, I could probably spend a month writing about strings alone. That’s not the point, though&amp;hellip; I took a risk with Haskell, and it’s paid off. I’m not yet sure exactly how I feel about it, or when I would chose it relative to other tools, but it is currently very high on my list of favorite technologies.&lt;/p&gt;

&lt;p&gt;I did not come to Haskell with a distaste for static typing, despite the fact that I write so much Racket, a dynamically typed language (by default, at least). I don’t really use Typed Racket, and despite my love for Haskell and its type system, I am not sure I will use much more of it than I did before. Haskell and Racket are very different languages, which is justified in some places and probably sort of circumstantial in others.&lt;/p&gt;

&lt;p&gt;The future of Haskell seems bright, and a lot of the changes in the just-released GHC 8 are extremely exciting. I did not list records as a pain point because the changes in GHC 8 appear to make them a &lt;em&gt;lot&lt;/em&gt; more palatable, although whether or not they solve that problem completely remains to be seen. I will absolutely continue to write Haskell and push it to its limits where I can, and hopefully try and take as much as I can from it along the way.&lt;/p&gt;</content></entry></feed>