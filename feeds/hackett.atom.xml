<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">Alexis King's Blog: Posts tagged 'hackett'</title>
 <link rel="self" href="http://lexi-lambda.github.io/feeds/hackett.atom.xml" />
 <link href="http://lexi-lambda.github.io/tags/hackett.html" />
 <id>urn:http-lexi-lambda-github-io:-tags-hackett-html</id>
 <updated>2018-04-15T00:00:00Z</updated>
 <entry>
  <title type="text">Reimplementing Hackett’s type language: expanding to custom core forms in Racket</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/?utm_source=hackett&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2018-04-15-reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket</id>
  <published>2018-04-15T00:00:00Z</published>
  <updated>2018-04-15T00:00:00Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;In the past couple of weeks, I &lt;a href="https://github.com/lexi-lambda/hackett/commit/ba64193da38f63dab2523f42c1b7614cdfa8c935"&gt;completely rewrote the implementation of Hackett’s type language&lt;/a&gt; to improve the integration between the type representation and Racket’s macro system. The new type language effectively implements a way to reuse as much of the Racket macroexpanding infrastructure as possible while expanding a completely custom language, which uses a custom set of core forms. The fundamental technique used to do so is not novel, and it seems to be periodically rediscovered every so often, but it has never been published or documented anywhere, and getting it right involves understanding a great number of subtleties about the Racket macro system. While I cannot entirely eliminate the need to understand those subtleties, in this blog post, I hope to make the secret sauce considerably less secret.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;This blog post is both a case study on how I implemented the expander for Hackett’s new type language and a discussion of how such a technique can apply more generally. Like &lt;a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/"&gt;my previous blog post on Hackett&lt;/a&gt;, which covered the implementation of its namespace system, the implementation section of this blog post is highly technical and probably requires significant experience with Racket’s macro system to completely comprehend. However, the surrounding material is written to be more accessible, so even if you are not a Racket programmer, you should hopefully be able to understand the big ideas behind this change.&lt;/p&gt;

&lt;h1 id="what-are-core-forms"&gt;What are core forms?&lt;/h1&gt;

&lt;p&gt;Before we can get started writing &lt;em&gt;custom core forms&lt;/em&gt;, we need to understand the meaning of Racket’s plain old &lt;em&gt;core forms&lt;/em&gt;. What is a core form? In order to answer that question, we need to think about how Racket’s expansion and compilation model works.&lt;/p&gt;

&lt;p&gt;To start, let’s consider a simple Racket program. Racket programs are organized into modules, which are usually written with a &lt;code&gt;#lang&lt;/code&gt; line at the top. In this case, we’ll use &lt;code&gt;#lang racket&lt;/code&gt; to keep things simple:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;How does Racket see this program? Well, before it can do anything with it, it must parse the program text, which is known in Racket as &lt;em&gt;reading&lt;/em&gt; the program. The &lt;code&gt;#lang&lt;/code&gt; line controls how the program is read—some &lt;code&gt;#lang&lt;/code&gt;s provide parsers that allow syntax that is very different from the parser used for &lt;code&gt;#lang racket&lt;/code&gt;—but no matter which reader is used, the result is an s-expression (actually a syntax object, but essentially an s-expression) representing a module. In the case of the above program, the result looks like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;racket&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%module-begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note the introduction of &lt;code&gt;#%module-begin&lt;/code&gt;. Despite the fancy name, this is really just an ordinary macro provided by the &lt;code&gt;racket&lt;/code&gt; language. By convention, the reader and expander cooperate to ensure the body of every module is wrapped with &lt;code&gt;#%module-begin&lt;/code&gt;; as we’ll see shortly, this allows languages to add functionality that affects the entire contents of the module.&lt;/p&gt;

&lt;p&gt;One the program has been read, it is subsequently &lt;em&gt;expanded&lt;/em&gt; by the macroexpander. As the name implies, this is the phase that expands all the macros in a module. What does the above module look like after expansion? Well, it doesn’t look unrecognizable, but it certainly does look different:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;racket&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-module-begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="nb"&gt;call-with-values&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="n"&gt;print-values&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Let’s note the things that changed:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;#%module-begin&lt;/code&gt; was replaced with &lt;code&gt;#%plain-module-begin&lt;/code&gt;. &lt;code&gt;#%plain-module-begin&lt;/code&gt; is a binding that wraps the body of every expanded module, and all definitions of &lt;code&gt;#%module-begin&lt;/code&gt; in any language must eventually expand to &lt;code&gt;#%plain-module-begin&lt;/code&gt;. However, &lt;code&gt;#lang racket&lt;/code&gt;’s &lt;code&gt;#%module-begin&lt;/code&gt; doesn’t &lt;em&gt;just&lt;/em&gt; expand to &lt;code&gt;#%plain-module-begin&lt;/code&gt;, it also wraps bare expressions at the top level of a module so that their results are printed. This is why running the above program prints &lt;code&gt;5&lt;/code&gt; even though there is no code related to printing in the original program!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The lambda shorthand used with &lt;code&gt;define&lt;/code&gt; was converted to an explicit use of &lt;code&gt;lambda&lt;/code&gt;, and it was expanded to &lt;code&gt;define-values&lt;/code&gt;. In Racket, &lt;code&gt;define&lt;/code&gt; and &lt;code&gt;define-syntax&lt;/code&gt; are really just macros for &lt;code&gt;define-values&lt;/code&gt; and &lt;code&gt;define-syntaxes&lt;/code&gt; that only bind a single identifier.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All function applications were tagged explicitly with &lt;code&gt;#%plain-app&lt;/code&gt;. This syntactically distinguishes function applications from uses of forms like &lt;code&gt;define-values&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;. It also allows languages to customize function application by providing their own macros named &lt;code&gt;#%app&lt;/code&gt; (just like languages can provide their own macros named &lt;code&gt;#%module-begin&lt;/code&gt; that expand to &lt;code&gt;#%plain-module-begin&lt;/code&gt;), but that is outside the scope of this blog post.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All literals have been wrapped with &lt;code&gt;quote&lt;/code&gt;, so &lt;code&gt;2&lt;/code&gt; became &lt;code&gt;'2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; became &lt;code&gt;'3&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Importantly, the resulting program contains &lt;strong&gt;no macros&lt;/strong&gt;. Such programs are called &lt;em&gt;fully expanded&lt;/em&gt;, since all macros have been eliminated and no further expansion can take place.&lt;/p&gt;

&lt;p&gt;So what’s left behind? Well, some of the things in the program are literal data, like the numbers &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt;. There are also some variable references, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;add2&lt;/code&gt;. Most of the program, however, is built out of primitives like &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;#%plain-module-begin&lt;/code&gt;, &lt;code&gt;#%plain-app&lt;/code&gt;, &lt;code&gt;define-values&lt;/code&gt;, and &lt;code&gt;lambda&lt;/code&gt;. These primitives are &lt;em&gt;core forms&lt;/em&gt;—they are not variables, since they do not represent bindings that contain values at runtime, but they are also not macros, since they cannot be expanded any further.&lt;/p&gt;

&lt;p&gt;In this sense, a fully-expanded program is just like a program in most languages that do not have macros. Core forms in Racket correspond to the syntax of other languages. We can imagine a JavaScript program similar to the above fully-expanded Racket program:&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Just as this JavaScript program is internally transformed into an AST containing a definition node, a function abstraction node, and some function application nodes, a fully-expanded Racket program represents an AST ready to be sent off to be &lt;em&gt;compiled&lt;/em&gt;. The Racket compiler has built-in rules for how to compile core forms like &lt;code&gt;define-values&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;, and &lt;code&gt;#%plain-app&lt;/code&gt;, and the result is optimized Racket bytecode.&lt;/p&gt;

&lt;p&gt;In the remainder of this blog post, as most discussions of macros do, we’ll ignore the &lt;em&gt;read&lt;/em&gt; and &lt;em&gt;compile&lt;/em&gt; steps of the Racket program pipeline and focus exclusively on the &lt;em&gt;expand&lt;/em&gt; step. It’s useful, however, to keep the other steps in mind, since we’re going to be discussing what it means to implement custom core forms, and core forms really only make sense in the context of the subsequent compilation step that consumes them.&lt;/p&gt;

&lt;h2 id="rackets-default-core-forms"&gt;Racket’s default core forms&lt;/h2&gt;

&lt;p&gt;So, now that we know what core forms are in an abstract sense, what are they in practice? We’ve already encountered &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;#%plain-module-begin&lt;/code&gt;, &lt;code&gt;#%plain-app&lt;/code&gt;, &lt;code&gt;define-values&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;, and &lt;code&gt;quote&lt;/code&gt;, but there are many more. The full list is available in the section of the Racket reference named &lt;a href="http://docs.racket-lang.org/reference/syntax-model.html#%28part._fully-expanded%29"&gt;Fully Expanded Programs&lt;/a&gt;, and I will not list all of them here. In general, they are more or less what you’d expect. The list of Racket’s core forms also includes things like &lt;code&gt;define-syntaxes&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, &lt;code&gt;letrec-values&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;quote-syntax&lt;/code&gt;, and &lt;code&gt;set!&lt;/code&gt;. Fundamentally, these correspond to the basic operations the Racket compiler understands, and it allows the remainder of Racket’s compilation pipeline to ignore the complexities of macroexpansion.&lt;/p&gt;

&lt;p&gt;These forms are fairly versatile, and it’s easy to build high-level abstractions on top of them. For example, &lt;code&gt;#lang racket&lt;/code&gt; implements &lt;code&gt;cond&lt;/code&gt; as a macro that eventually expands into &lt;code&gt;if&lt;/code&gt;, and it implements &lt;code&gt;syntax&lt;/code&gt; as a macro that eventually expands into function calls and &lt;code&gt;quote-syntax&lt;/code&gt;. The real power comes in the way new macros can be built out of other macros, not just core forms, so Racket’s &lt;code&gt;match&lt;/code&gt; can expand into uses of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt;, and it doesn’t need to concern itself with using &lt;code&gt;let-values&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt;. For this reason, Racket’s core forms are quite capable of representing any language imaginable, since fully-expanded programs are essentially instructions for the Racket virtual machine, and macros are mini-compilers that can be mixed and matched.&lt;/p&gt;

&lt;h2 id="the-need-for-custom-core-forms"&gt;The need for custom core forms&lt;/h2&gt;

&lt;p&gt;With that in mind, why might we wish to define &lt;em&gt;custom&lt;/em&gt; core forms? In fact, what would such a thing even mean? By their very nature, &lt;em&gt;all&lt;/em&gt; Racket programs eventually expand into Racket’s core forms; new core forms cannot be added because Racket’s underlying compiler infrastructure is not (currently) extensible. New forms can be added that are defined in terms of other forms, but adding new primitives doesn’t make any sense, since the compiler would not know what to do with them.&lt;/p&gt;

&lt;p&gt;Despite this, there &lt;em&gt;are&lt;/em&gt; at least two use-cases in which a programmer might wish to customize the set of core forms produced by the macroexpander. Each situation is slightly different, but they both revolve around the same idea.&lt;/p&gt;

&lt;h3 id="supporting-multiple-backends"&gt;Supporting multiple backends&lt;/h3&gt;

&lt;p&gt;The most commonly discussed use case for customizing the set of core forms is for languages that wish to use the Racket macroexpander, but target backends that are not the Racket compiler. For example, a user might implement a Racket &lt;code&gt;#lang&lt;/code&gt; that describes electronic circuits, and they might even implement a way to execute such a program in Racket, but they might &lt;em&gt;also&lt;/em&gt; wish to compile the result to a more traditional hardware description language. Like other languages in the Racket ecosystem, such a language would be made up of a tower of macros built on top of core forms; unlike other languages, the core forms might need to be more abstract than the ones provided by Racket to efficiently compile to other targets.&lt;/p&gt;

&lt;p&gt;In the case of a hardware description language, the custom core forms might include things like &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; for declaring circuit inputs and outputs, and expressions might be built out of hardware operations rather than high-level things like function calls. The Racket macroexpander would expand the input program into the custom set of core forms, at which point an external compiler program could compile the resutling AST in a more traditional way. If the language author wished, they could &lt;em&gt;additionally&lt;/em&gt; define implementations of these core forms as Racket macros that eventually expand into Racket, which would allow them to emulate their circuits in Racket at little cost, but this would be a wholly optional step.&lt;/p&gt;

&lt;p&gt;Essentially, this use case stems from a desire to reuse Racket’s advanced language-development technology, such as the macroexpander, the module system, and editor tooling, without also committing to using Racket as a runtime, which is not always appropriate for all languages. This use case is not nearly as easy as it ought to be, but it is a common request, and it is possible that future improvements to the Racket toolchain will be designed specifically to address this problem.&lt;/p&gt;

&lt;h3 id="compiling-an-extensible-embedded-language"&gt;Compiling an extensible embedded language&lt;/h3&gt;

&lt;p&gt;A second use case for custom core forms is less frequently discussed, but I think it might actually be significantly more common in practice were it available in a form accessible to working macro programmers. In this scenario, users might wish to remain within Racket, but still want to define a custom language that other macros can consume.&lt;/p&gt;

&lt;p&gt;This concept is a little more vague and fuzzily-defined than the case of developing a separate backend, so allow me to propose an example. Imagine a Racket programmer decides to build an embedded DSL for asynchronously producing and consuming events, similar to first-order functional reactive programming. In this case, the DSL is designed to be used in larger Racket programs, so it &lt;em&gt;will&lt;/em&gt; eventually expand to Racket’s core forms. However, it’s possible that such a language might wish to enforce static invariants about the network graph, and in doing so, it might be able to produce significantly more optimal Racket code via a compile-time analysis.&lt;/p&gt;

&lt;p&gt;Performing such a compile-time analysis is essentially writing a custom optimizer as part of a macro, which has been done numerous times already within the Racket ecosystem. One of the most prominent examples of such a thing is the &lt;code&gt;match&lt;/code&gt; macro, which parses users’ patterns into compile-time data structures, performs a fairly traditional optimization pass designed to efficiently compile pattern matching, and it emits optimized Racket code as a result. This approach works well for fairly contained problems like pattern-matching, but it works less well for entirely new embedded languages that include everything from their own notion of evaluation to their own binding forms.&lt;/p&gt;

&lt;p&gt;Existing DSLs of this type are rare, but they do exist. &lt;code&gt;syntax/parse&lt;/code&gt; provides an expressive, specialized pattern-matching language designed specifically for matching syntax objects, and it uses a different model from &lt;code&gt;racket/match&lt;/code&gt; to be more suitable for that task. It allows backtracking with cuts, an extensible pattern language, an abstraction language for defining reusable parsers that can accept inputs and produce outputs, and fine-grained control over both parsing and binding. While &lt;code&gt;match&lt;/code&gt; is essentially just a traditional pattern-matcher, albeit an extensible one, &lt;code&gt;syntax-parse&lt;/code&gt; is its own programming language, closer in some ways to Prolog than to Racket.&lt;/p&gt;

&lt;p&gt;For this reason, &lt;code&gt;syntax/parse&lt;/code&gt; has an extensive language to do everything from creating new bindings to controlling when and how parsing fails. This language is represented in two ways: an inline pattern language, and an alternate syntax known as &lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#%28part._.Pattern_.Directives%29"&gt;&lt;em&gt;pattern directives&lt;/em&gt;&lt;/a&gt;. Here is an example of pattern directives in action, from my own &lt;code&gt;threading&lt;/code&gt; library:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;ex:expr&lt;/span&gt; &lt;span class="n"&gt;cl:clause&lt;/span&gt; &lt;span class="n"&gt;remaining:clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl.call&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;split-at&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;cl.insertion-point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Each directive is represented by a keyword, in this case &lt;code&gt;#:do&lt;/code&gt; and &lt;code&gt;#:with&lt;/code&gt;. Each directive has a corresponding keyword in the pattern language, in this case &lt;code&gt;~do&lt;/code&gt; and &lt;code&gt;~parse&lt;/code&gt;. Therefore, the above pattern could equivalently be written this way:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;ex:expr&lt;/span&gt; &lt;span class="n"&gt;cl:clause&lt;/span&gt; &lt;span class="n"&gt;remaining:clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~do&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl.call&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;split-at&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;cl.insertion-point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))))}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~parse&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~parse&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~parse&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)}}&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The transformation can go in the other direction, too—each syntax class annotation on each pattern variable can be extracted into the directive language using &lt;code&gt;#:declare&lt;/code&gt;, so this is also equivalent:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;
 &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt; &lt;span class="n"&gt;clause&lt;/span&gt;
 &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="n"&gt;clause&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl.call&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;split-at&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;cl.insertion-point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is very much a programming language, but it has very different semantics from programming in Racket! Failure to match against a &lt;code&gt;#:with&lt;/code&gt; or &lt;code&gt;~parse&lt;/code&gt; pattern causes pattern-matching to backtrack, and though it’s possible to escape to Racket using &lt;code&gt;#:do&lt;/code&gt; or &lt;code&gt;~do&lt;/code&gt;, practical uses of &lt;code&gt;syntax/parse&lt;/code&gt; really do involve quite a lot of programming in its pattern DSL.&lt;/p&gt;

&lt;p&gt;But the Racket programmer might not find this DSL wholly satisfying. Why? Well, it isn’t extensible! The pattern directives—&lt;code&gt;#:declare&lt;/code&gt;, &lt;code&gt;#:do&lt;/code&gt;, and &lt;code&gt;#:with&lt;/code&gt;, among others—are essentially the core forms of &lt;code&gt;syntax/parse&lt;/code&gt;’s pattern-matching language, but new ones cannot be defined. The desire to make this language easy to analyze statically in order to emit optimal pattern-matching code meant its author opted to define the language in terms of a specific grammar rather than a tower of macros.&lt;/p&gt;

&lt;p&gt;But what if &lt;code&gt;syntax/parse&lt;/code&gt; could define its own core forms? What if, instead of &lt;code&gt;#:do&lt;/code&gt;, &lt;code&gt;#:declare&lt;/code&gt;, and &lt;code&gt;#:with&lt;/code&gt; being implemented as keyword options specially recognized by the &lt;code&gt;syntax-parse&lt;/code&gt; grammar, it defined &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;declare&lt;/code&gt;, and &lt;code&gt;with&lt;/code&gt; as core forms for a new, macro-enabled language? A user of the language could then define a completely ordinary Racket macro and use it with this new language as long as it eventually expanded into the &lt;code&gt;syntax/parse&lt;/code&gt; core forms. The implementation of &lt;code&gt;syntax/parse&lt;/code&gt; could then invoke the macroexpander to request each clause be expanded into its core forms, perform its static analysis on the result, and finally emit optimized Racket code.&lt;/p&gt;

&lt;p&gt;Now, to be fair, &lt;code&gt;syntax/parse&lt;/code&gt; is not actually entirely inextensible. While new directives cannot be defined, new patterns can be added through a pattern-expander API that was added to the library after its initial design. However, pattern expanders are still not ideal because they are not ordinary Racket macros—users must explicitly define each pattern expander differently from how they would a macro—and they cannot use existing Racket forms, even ones that would theoretically be compatible with an arbitrary set of core forms.&lt;/p&gt;

&lt;p&gt;The technique described in this blog post avoids all those problems. In the following sections, I’ll show that it’s possible to define an embedded language with a custom set of core forms that works well with the rest of the Racket ecosystem and still permits arbitrary static analysis.&lt;/p&gt;

&lt;h1 id="the-need-for-a-custom-type-language-in-hackett"&gt;The need for a custom type language in Hackett&lt;/h1&gt;

&lt;p&gt;In the previous section, I described two use cases for custom core forms. Hackett, in fact, has uses for &lt;em&gt;both&lt;/em&gt; of them:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Hackett can definitely make use of custom core forms to compile to multiple backends. Eventually, it would be nice to compile Hackett to an intermediate language that can target both the Racket runtime and Haskell or GHC Core. This would allow Hackett to take advantage of GHC’s advanced optimizing compiler that already has decades of tuning for a pure, lazy, functional programming language, at the cost of not having access to the rest of Racket’s ecosystem of libraries at runtime.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Hackett can &lt;em&gt;also&lt;/em&gt; make use of custom core forms for an embedded DSL. In this case, that embedded DSL is actually Hackett’s type language.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The second of those two use cases is simpler, and it’s what I ended up implementing first, so it’s what I will focus on in this blog post. Hackett’s type language is fundamentally quite simple, so its set of custom core forms is small as well. Everything in the type language eventually compiles into only seven core forms:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;(#%type:con
    &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; — Type constructors, like &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;. These are one of the fundamental building blocks of Hackett types.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;(#%type:app
    &lt;i&gt;type&lt;/i&gt;
    &lt;i&gt;type&lt;/i&gt;)&lt;/code&gt; — Type application, such as &lt;code&gt;(Maybe Integer)&lt;/code&gt;. Types are curried, so type constructors that accept multiple arguments are represented by nested uses of &lt;code&gt;#%type:app&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;(#%type:forall
    &lt;i&gt;id&lt;/i&gt;
    &lt;i&gt;type&lt;/i&gt;)&lt;/code&gt; — Universal quantification. This is essentially a binding form, which binds any uses of &lt;code&gt;(#%type:bound-var
    &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; in &lt;code&gt;
    &lt;i&gt;type&lt;/i&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;code&gt;(#%type:qual
    &lt;i&gt;type&lt;/i&gt;
    &lt;i&gt;type&lt;/i&gt;)&lt;/code&gt; — Qualified types, aka types with typeclass constraints. Constraints in Hackett, like in GHC, are represented by types, so typeclass names like &lt;code&gt;Eq&lt;/code&gt; are bound as type constructors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, Hackett types support three different varieties of type variables:&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;code&gt;(#%type:bound-var
      &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; — Bound type variables. These are only legal under a corresponding &lt;code&gt;#%type:forall&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;code&gt;(#%type:wobbly-var
      &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; — Solver variables, which may unify with any other type as part of the typechecking process.&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;
    &lt;p&gt;&lt;code&gt;(#%type:rigid-var
      &lt;i&gt;id&lt;/i&gt;)&lt;/code&gt; — Rigid variables, aka skolem variables, which only unify with themselves. They represent a unique, anonymous type used to ensure types are suitably polymorphic.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;To implement our custom core forms in Racket, we need to somehow define them, but how? Intentionally, these should never be expanded, since we want the expander to stop expanding whenever it encounters one of these identifiers. While we can’t encode this directly, we &lt;em&gt;can&lt;/em&gt; bind them to macros that do nothing but raise an exception if something attempts to expand them:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
                  &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="s2"&gt;"cannot be used as an expression"&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;
            &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This will ensure our core forms are never accidentally expanded, and we’ll instruct the macroexpander to stop whenever it sees one of them via a separate mechanism.&lt;/p&gt;

&lt;h2 id="expanding-types-in-our-type-language"&gt;Expanding types in our type language&lt;/h2&gt;

&lt;p&gt;We’ve now defined our core forms, but we’ve intentionally left them meaningless. How do we actually inform the expander about how our types ought to be expanded? While it’s true that we don’t want the core forms themselves to be eliminated, we &lt;em&gt;do&lt;/em&gt; want to expand some of their subforms. For example, in the type &lt;code&gt;(#%type:app a b)&lt;/code&gt;, we want to recursively expand &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In order to do this, we’ll use the API made available by the expander for manually invoking macroexpansion from within another macro. This API is called &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._local-expand%29%29"&gt;&lt;code&gt;local-expand&lt;/code&gt;&lt;/a&gt;, and it has an option relevant to our needs: the stop list.&lt;/p&gt;

&lt;p&gt;Often, &lt;code&gt;local-expand&lt;/code&gt; is used to force the expander to completely, recursively expand a form. For example, by using &lt;code&gt;local-expand&lt;/code&gt;, we can produce a fragment of a fully-expanded program from a piece of syntax that still includes macros:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; (let-values ([(x) &amp;#39;1]) (#%plain-app + x &amp;#39;2))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The third argument to &lt;code&gt;local-expand&lt;/code&gt; is the &lt;em&gt;stop list&lt;/em&gt;, which controls how deep the expander ought to expand a given form. By providing an empty list, we ask for a complete, recursive expansion. In this case, however, we don’t want a complete expansion! We can inform the expander to stop whenever it sees any of our custom core forms by passing a list of our core form identifiers instead of an empty list:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt;
          &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;; =&amp;gt; (#%type:forall x t)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Of course, this isn’t very interesting, since it just gives us back exactly what we gave it. It spotted the &lt;code&gt;#%type:forall&lt;/code&gt; identifier, which is in our stop list, and immediately halted expansion. It didn’t attempt to continue expanding &lt;code&gt;t&lt;/code&gt; since the expander has no way of knowing which pieces of &lt;code&gt;(#%type:forall x t)&lt;/code&gt; it should expand! In this case, we want it to recur to expand &lt;code&gt;t&lt;/code&gt;, since it should be a type, but not &lt;code&gt;x&lt;/code&gt;, since &lt;code&gt;#%type:forall&lt;/code&gt; essentially puts &lt;code&gt;x&lt;/code&gt; in binding position.&lt;/p&gt;

&lt;p&gt;Therefore, we have to get more clever. We need to call &lt;code&gt;local-expand&lt;/code&gt; to produce a type, then we have to pattern-match on it and subsequently call &lt;code&gt;local-expand&lt;/code&gt; &lt;em&gt;again&lt;/em&gt; on any of the pieces of syntax we want to keep expanding. Eventually, we’ll run out of things to expand, and our type will be fully-expanded.&lt;/p&gt;

&lt;p&gt;One good way to do this is to use &lt;code&gt;syntax/parse&lt;/code&gt; syntax classes, since they provide a convenient way for other macros to invoke the type expander. To implement our type expander, we’ll use two mutually recursive syntax classes: one to perform the actual expansion using &lt;code&gt;local-expand&lt;/code&gt; and a second to pattern-match on the resulting expanded type. For example, here’s what these two classes would look like if they only handled &lt;code&gt;#%type:con&lt;/code&gt; and &lt;code&gt;#%type:app&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-literal-set&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
     &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"type"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;:expanded-type&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;expanded-type&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;a:type&lt;/span&gt; &lt;span class="n"&gt;b:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This blog post is definitely &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;syntax/parse&lt;/code&gt; tutorial, so I will not explain in detail everything that’s going on here, but the gist of it is that the above code defines two syntax classes, both of which produce a single output attribute named &lt;code&gt;expansion&lt;/code&gt;. This attribute contains the fully expanded version of the type currently being parsed. In the &lt;code&gt;#%type:con&lt;/code&gt; case, &lt;code&gt;expansion&lt;/code&gt; is just &lt;code&gt;this-syntax&lt;/code&gt;, which holds the current piece of syntax being parsed. This makes sense, since uses of &lt;code&gt;#%type:con&lt;/code&gt; just expand to themselves—expanding &lt;code&gt;(#%type:con Maybe)&lt;/code&gt; should not perform any additional expansion on &lt;code&gt;Maybe&lt;/code&gt;. This is one of Hackett’s atomic types.&lt;/p&gt;

&lt;p&gt;In contrast, &lt;code&gt;#%type:app&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; recursively expand its arguments. By annotating its two subforms with &lt;code&gt;:type&lt;/code&gt;, the &lt;code&gt;type&lt;/code&gt; syntax class will invoke &lt;code&gt;local-expand&lt;/code&gt; on each subform, which will in turn use &lt;code&gt;expanded-type&lt;/code&gt; to parse the resulting type. This is what implements the expansion loop that will eventually expand each type completely. Once &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have been expanded, &lt;code&gt;#%type:app&lt;/code&gt; reassembles them into a new syntax object using &lt;code&gt;#'(#%type:app a.expansion b.expansion)&lt;/code&gt;, which replaces their unexpanded versions with their new, expanded versions.&lt;/p&gt;

&lt;p&gt;We can see this behavior by writing a small &lt;code&gt;expand-type&lt;/code&gt; function that will expand its argument:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;t:type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we can use it to observe what happens when we try expanding a type using &lt;code&gt;#%type:app&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; #%type:app: expected type&lt;/span&gt;
&lt;span class="c1"&gt;;      at: Maybe&lt;/span&gt;
&lt;span class="c1"&gt;;      in: (#%type:app Maybe Integer)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Okay, it failed with an error, which is not ideal, but it makes sense. We haven’t actually defined &lt;code&gt;Maybe&lt;/code&gt; or &lt;code&gt;Integer&lt;/code&gt; anywhere. Let’s do so! We can define them as simple macros that expand into uses of &lt;code&gt;#%type:con&lt;/code&gt;, which can be done easily using &lt;a href="http://docs.racket-lang.org/syntax/transformer-helpers.html#%28def._%28%28lib._syntax%2Ftransformer..rkt%29._make-variable-like-transformer%29%29"&gt;&lt;code&gt;make-variable-like-transformer&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;syntax/transformer&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, if we try expanding that same type again:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; (#%type:app (#%type:con Maybe) (#%type:con Integer))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…it works! Neat. Now we just need to add the cases for the remaining forms in our type language:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;expanded-type&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;a:type&lt;/span&gt; &lt;span class="n"&gt;b:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;t:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;a:type&lt;/span&gt; &lt;span class="n"&gt;b:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is pretty good already, and to a first approximation, it’s done! However, it doesn’t actually work as well as we’d really like it to. One of the whole points of doing things this way is to allow other macros like &lt;code&gt;let-syntax&lt;/code&gt; to work in types. For example, we ought to be able to create a local type binding with &lt;code&gt;let-syntax&lt;/code&gt; and have it just work. Unfortunately, it doesn’t:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; let-syntax: expected one of these identifiers: `#%type:con&amp;#39;, `#%type:app&amp;#39;, `#%type:forall&amp;#39;, `#%type:qual&amp;#39;, `#%type:bound-var&amp;#39;, `#%type:wobbly-var&amp;#39;, or `#%type:rigid-var&amp;#39;&lt;/span&gt;
&lt;span class="c1"&gt;;     at: letrec-syntaxes+values&lt;/span&gt;
&lt;span class="c1"&gt;;     in: (let-syntax ((Bool (make-variable-like-transformer (syntax Bool)))) (#%type:app Maybe Bool))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;What went wrong? And why is it complaining about &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;? Well, if you read the documentation for &lt;code&gt;local-expand&lt;/code&gt;, you’ll find that its behavior is a little more complicated than you might at first believe:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;If &lt;em&gt;&lt;code&gt;stop-ids&lt;/code&gt;&lt;/em&gt; is [a nonempty list containing more than just &lt;code&gt;module*&lt;/code&gt;], then &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;set!&lt;/code&gt;, &lt;code&gt;#%plain-lambda&lt;/code&gt;, &lt;code&gt;case-lambda&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, &lt;code&gt;letrec-values&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;begin0&lt;/code&gt;, &lt;code&gt;with-continuation-mark&lt;/code&gt;, &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, &lt;code&gt;#%plain-app&lt;/code&gt;, &lt;code&gt;#%expression&lt;/code&gt;, &lt;code&gt;#%top&lt;/code&gt;, and &lt;code&gt;#%variable-reference&lt;/code&gt; are implicitly added to &lt;em&gt;&lt;code&gt;stop-ids&lt;/code&gt;&lt;/em&gt;. Expansion stops when the expander encounters any of the forms in &lt;em&gt;&lt;code&gt;stop-ids&lt;/code&gt;&lt;/em&gt;, and the result is the partially-expanded form.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That’s a little strange, isn’t it? I am not completely sure why the behavior works quite this way, though I’m sure backwards compatibility plays a significant part, but while some of the behavior seems unnecessary, the issue with &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; (which &lt;code&gt;let-syntax&lt;/code&gt; expands to) is a reasonable one. If the expander naïvely expanded &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; in the presence of a nonempty stop list, it could cause some significant problems!&lt;/p&gt;

&lt;p&gt;Allow me to illustrate with an example. Let’s imagine we are the expander, and we are instructed to expand the following program:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We see &lt;code&gt;let-syntax&lt;/code&gt;, so we start by evaluating the expression on the right hand side of the &lt;code&gt;Bool&lt;/code&gt; binding. This produces a transformer expression, so we bind &lt;code&gt;Bool&lt;/code&gt; to the transformer in the local environment, then move onto expanding the body. At this point, the expander is looking at this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;; local bindings:&lt;/span&gt;
&lt;span class="c1"&gt;;   Bool -&amp;gt; #&amp;lt;variable-like-transformer&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, the identifier in application position is &lt;code&gt;#%type:app&lt;/code&gt;, and &lt;code&gt;#%type:app&lt;/code&gt; is in the stop list. Therefore, expansion must stop, and it does not attempt to expand any further. But what should the result of expansion be? Well, the &lt;code&gt;let-syntax&lt;/code&gt; needs to go away when we expand it—local syntax bindings are erased as part of macroexpansion—so the logical thing to expand into is &lt;code&gt;(#%type:app Maybe Bool)&lt;/code&gt;. But this is a problem, because when we then go to expand &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt; isn’t in the local binding table anymore! The &lt;code&gt;let-syntax&lt;/code&gt; was already erased, and &lt;code&gt;Bool&lt;/code&gt; is unbound!&lt;/p&gt;

&lt;p&gt;When expanding recursively, this isn’t a problem, since the entire expression is guaranteed to be expanded while the local binding is still in the expander’s environment. As soon as we introduce partial expansion, however, we run the risk of a binding getting erased too early. So we’re stuck: we can’t recursively expand, or we’ll expand too much, but we can’t partially expand, since we might expand too little.&lt;/p&gt;

&lt;p&gt;Confronted with this problem, there is some good news and some bad news. The good news is that, while the macroexpander can’t help us, we can help the macroexpander by doing some of the necessary bookkeeping for it. We can do this using first-class definition contexts, which allow us to manually extend the local environment when we call &lt;code&gt;local-expand&lt;/code&gt;. The bad news is that first-class definition contexts are &lt;em&gt;complicated&lt;/em&gt;, and using them properly is a surprisingly subtle problem.&lt;/p&gt;

&lt;p&gt;Fortunately, I’ve already spent a lot of time figuring out what needs to be done to properly manipulate the necessary definition contexts in this particular situation. The first step is to parameterize our &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;expanded-type&lt;/code&gt; syntax classes so that we may thread a definition context around as we recursively expand:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"type"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;||&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, we can add an additional case to &lt;code&gt;expanded-type&lt;/code&gt; to handle &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, which will explicitly create a new definition context, add bindings to it, and use it when parsing the body:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
         &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But even this isn’t quite right. The problem with this implementation is that it throws away the existing &lt;code&gt;intdef-ctx&lt;/code&gt; argument to &lt;code&gt;expanded-type&lt;/code&gt;, which means those bindings will be lost as soon as we introduce a new set. To fix this, we have to make the new definition context a &lt;em&gt;child&lt;/em&gt; of the previous definition context by passing the old context as an argument to &lt;code&gt;syntax-local-make-definition-context&lt;/code&gt;. This will ensure the parent bindings are brought into scope when expanding using the child context:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
         &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With this in place, our example using &lt;code&gt;let-syntax&lt;/code&gt; actually works!&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; (#%type:app (#%type:con Maybe) (#%type:con Bool))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Pretty cool, isn’t it?&lt;/p&gt;

&lt;h2 id="preserving-syntax-properties-and-source-locations"&gt;Preserving syntax properties and source locations&lt;/h2&gt;

&lt;p&gt;We’ve now managed to essentially implement an expander for our custom language by periodically yielding to the Racket macroexpander, and for the most part, it works. However, our implementation isn’t perfect. The real Racket macroexpander takes great care to preserve source locations and syntax properties on syntax objects wherever possible, which our implementation does not do. Normally we don’t have to worry so much about such things, since the macroexpander automatically copies properties when expanding macros, but since we’re circumventing the expander, we don’t get that luxury. In order to properly preserve this information, we’ll have to be a little more careful.&lt;/p&gt;

&lt;p&gt;To start, we really ought to copy the identifier in application position into the output wherever we can. In addition to preserving source location information and syntax properties, it also preserves the even more visible renamings. For example, if a user imports &lt;code&gt;#%type:app&lt;/code&gt; under a different name, like &lt;code&gt;#%type:apply&lt;/code&gt;, we should expand to a piece of syntax that still has &lt;code&gt;#%type:apply&lt;/code&gt; in application position instead of replacing it with &lt;code&gt;#%type:app&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To do this, we just need to bind each of the identifiers in application position, then use that binding when we produce output. For example, we would adjust the &lt;code&gt;#%type:app&lt;/code&gt; clause to the following:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But even after doing this, some source locations and syntax properties are lost, since we’re still reconstructing the pair from scratch. To ensure we copy &lt;em&gt;everything&lt;/em&gt;, we can define two helper macros, &lt;code&gt;syntax/loc/props&lt;/code&gt; and &lt;code&gt;quasisyntax/loc/props&lt;/code&gt;, which are like &lt;code&gt;syntax/loc&lt;/code&gt; and &lt;code&gt;quasisyntax/loc&lt;/code&gt; but copy properties in addition to source location information:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;syntax-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
          &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr:expr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~describe&lt;/span&gt; &lt;span class="s2"&gt;"template"&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
           &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax?&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-argument-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;#,&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt; &lt;span class="s2"&gt;"syntax?"&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;syntax-id&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-disarm&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-rearm&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-e&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)))]))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;quasisyntax&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Using &lt;code&gt;syntax/loc/props&lt;/code&gt;, we can be truly thorough about ensuring all properties are preserved:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Applying this to the other relevant clauses, we get an updated version of the &lt;code&gt;expanded-type&lt;/code&gt; syntax class:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                         &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we’re getting closer, but if you can believe it, even &lt;em&gt;this&lt;/em&gt; isn’t good enough. The real expander’s implementation of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; does two things our implementation does not: it copies properties and updates the &lt;code&gt;'origin&lt;/code&gt; property to indicate the syntax came from a use of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, and it adds a &lt;code&gt;'disappeared-use&lt;/code&gt; property to record the erased bindings for use by tools like DrRacket. We can apply &lt;code&gt;syntax-track-origin&lt;/code&gt; and &lt;code&gt;internal-definition-context-track&lt;/code&gt; to the resulting syntax to add the same properties the expander would:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
         &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;internal-definition-context-track&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we’ve &lt;em&gt;finally&lt;/em&gt; dotted all our i’s and crossed our t’s. While it does take a lot to properly emulate what the macroexpander is doing, the important thing is that it’s actually possible! The end result of all this definition context juggling and property copying is that we’ve effectively managed to move some of the macroexpander’s logic into userspace code, which allows us to manipulate it as we see fit.&lt;/p&gt;

&lt;h2 id="connecting-our-custom-language-to-hackett"&gt;Connecting our custom language to Hackett&lt;/h2&gt;

&lt;p&gt;It took a lot of work, but we finally managed to write a custom type language, and while the code is not exactly simple, it’s not actually very long. The entire implementation of our custom type language is less than 80 lines of code:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket/base&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-meta&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/intdef&lt;/span&gt;
                     &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;syntax-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
          &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr:expr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~describe&lt;/span&gt; &lt;span class="s2"&gt;"template"&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
           &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax?&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-argument-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;#,&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt; &lt;span class="s2"&gt;"syntax?"&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;syntax-id&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-disarm&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-rearm&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-e&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)))]))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;quasisyntax&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
                  &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="s2"&gt;"cannot be used as an expression"&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;
            &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt;
          &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-literal-set&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
     &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"type"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;||&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                         &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;internal-definition-context-track&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;t:type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But what now? Just as Racket fully-expanded programs are useless without a compiler to turn them into something useful, our custom type language doesn’t do anything at all in isolation. As it happens, in the case of the type language, we don’t have a compiler at all—we have a &lt;em&gt;typechecker&lt;/em&gt;. The Hackett typechecker consumes fully-expanded types as input and uses them to perform its typechecking process. The actual implementation of Hackett’s typechecker is outside the scope of this blog post, since it’s really an entirely separate problem, but you can probably imagine what such a thing might look like, in an extremely vague, handwavy sense.&lt;/p&gt;

&lt;p&gt;But we don’t &lt;em&gt;just&lt;/em&gt; need a typechecker. Just as the authors of Racket don’t expect users to write programs using the core forms directly, we also don’t expect users to write their types using the fully-expanded syntax. If we did, all this fancy expansion machinery would be pretty pointless! Hackett provides a custom &lt;code&gt;#%app&lt;/code&gt; binding that converts n-ary type applications to nested uses of &lt;code&gt;#%type:app&lt;/code&gt;, as well as a nicer &lt;code&gt;forall&lt;/code&gt; macro that supports specifying multiple type variables and multiple typeclass constraints all at once. The best part, though, is that these macros can be defined in a completely straightforward way, just as any ordinary Racket macro would be written, and the machinery will work precisely as intended. It’s also perfectly okay to have two different versions of &lt;code&gt;#%app&lt;/code&gt;—one for types and one for values—since &lt;a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/"&gt;Hackett supports multiple namespaces&lt;/a&gt;, and each can have its own &lt;code&gt;#%app&lt;/code&gt; binding.&lt;/p&gt;

&lt;p&gt;The real implementation of Hackett’s type language is a little bit longer than the one in this blog post because it includes some extra definitions to provide custom &lt;code&gt;syntax/parse&lt;/code&gt; pattern expanders for matching types and some template metafunctions for producing them, which are used by the typechecker, but if you’d like to see the whole thing, &lt;a href="https://github.com/lexi-lambda/hackett/blob/ba64193da38f63dab2523f42c1b7614cdfa8c935/hackett-lib/hackett/private/type-language.rkt"&gt;it’s available on GitHub here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id="evaluation-limitations-and-acknowledgements"&gt;Evaluation, limitations, and acknowledgements&lt;/h1&gt;

&lt;p&gt;Reimplementing Hackett’s type language took about a week and a half, about half of which was supplemented by the extra time I had before I started &lt;a href="https://twitter.com/lexi_lambda/status/976533916596097024"&gt;my new job&lt;/a&gt; this past week. A portion of that time was spent deciding what I actually wanted to do, and a lot of it was spent hunting down fiddly bugs. All told, the rewrite resulted in a net addition of 250 lines of code to the Hackett codebase. However, 350 of the added lines reside in a new, self-contained module dedicated to Hackett’s type language, so the change actually resulted in a net &lt;em&gt;removal&lt;/em&gt; of 100 lines from the rest of the codebase, which I consider an organizational win.&lt;/p&gt;

&lt;p&gt;As for whether or not the change will accomplish the goals I had in mind, I think signs currently point to a strong likelihood of the answer being yes. The very same night I finalized and merged the changes to the type language, I dusted off an old prototype of typeclass deriving I had not been able to get working due to insufficiencies of the old type representation. Not only was I &lt;a href="https://twitter.com/lexi_lambda/status/985051504867446786"&gt;able to get it working&lt;/a&gt; quickly and easily, I was able to do it in &lt;a href="https://twitter.com/lexi_lambda/status/985052476473856000"&gt;no more than 20 lines of code&lt;/a&gt;. While the implementation is not as robust as it should ideally be, nor is it safe or simple enough yet to be easy for Hackett users to write themselves, making the impossible possible is usually a sign of motion in the right direction.&lt;/p&gt;

&lt;p&gt;Unfortunately, the technique outlined in this blog post is not completely flawless. Due to its reliance on the &lt;code&gt;local-expand&lt;/code&gt; stop list, this technique is incompatible with macros that force recursive expansion using an empty stop list. In the upcoming reimplementation of the Racket macroexpander to be released in Racket 7, this includes &lt;code&gt;syntax-parameterize&lt;/code&gt;, which unfortunately means syntax parameters don’t work in the type language. This is a problem, and while it’s not a dealbreaker, it is something that will almost certainly have to be fixed at some point. Fortunately, it isn’t intractable, and I’ve been discussing some potential approaches to fixing the problem, whether via changes to the macroexpander or by making macros like &lt;code&gt;syntax-parameterize&lt;/code&gt; cooperate better with things like Hackett’s type language.&lt;/p&gt;

&lt;p&gt;Finally, as seems to be the case more and more with my blog posts, I cannot express enough thanks to &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, without whose help I would probably not have been able to get everything working (not to mention that the Racket macro system would not exist without Matthew inventing and implementing it nearly singlehandedly). Matthew does an almost unfathomable number of things for Racket already without me pestering him with questions, bug reports, and feature requests, but he’s always patient and helpful all the same. Also, once again, I’d like to thank &lt;a href="http://www.ccs.neu.edu/home/ryanc/"&gt;Ryan Culpepper&lt;/a&gt; for &lt;a href="https://www2.ccs.neu.edu/racket/pubs/dissertation-culpepper.pdf"&gt;his incredible work on constructing tools for the working macro developer&lt;/a&gt;, including writing the fantastic &lt;code&gt;syntax/parse&lt;/code&gt; library that powers essentially everything I do. Thank you both.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">A space of their own: adding a type namespace to Hackett</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/?utm_source=hackett&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett</id>
  <published>2017-10-27T17:41:17Z</published>
  <updated>2017-10-27T17:41:17Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;As previously discussed on this blog, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;my programming language, Hackett&lt;/a&gt;, is a fusion of two languages, Haskell and Racket. What happens when two distinctly different programming languages collide? Hackett recently faced that very problem when it came to the question of namespacing: Haskell has two namespaces, one for values and another for types, but Racket is a staunch Lisp&amp;ndash;1 with a single namespace for all bindings. Which convention should Hackett adopt?&lt;/p&gt;

&lt;p&gt;For now, at least, the answer is that Hackett will emulate Haskell: &lt;strong&gt;Hackett now has two namespaces&lt;/strong&gt;. Of course, Hackett is embedded in Racket, so what did it take to add an entirely new namespace to a language that possesses only one? The answer was a little more than I had hoped, but it was still remarkably simple given the problem: after two weeks of hacking, I’ve managed to get something working.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="why-two-namespaces"&gt;Why two namespaces?&lt;/h1&gt;

&lt;p&gt;Before delving into the mechanics of how multi-namespace Hackett is implemented, it’s important to understand what Hackett’s namespaces actually are and why they exist in the first place. Its host language, Racket, is a descendant of Scheme, a Lisp derivative that famously chose to only use a single namespace. This means everything—from values to functions to classes—lives in a single namespace in Racket.&lt;/p&gt;

&lt;p&gt;This is in stark contrast to Common Lisp, which opts to divide bindings into many namespaces, most notably pushing functions into a separate namespace from other variables. You can see this difference most strikingly when applying higher-order functions. In Racket, Clojure, and Scheme, functions can be passed freely as values:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ss"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ss"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ss"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In Common Lisp and other languages with two namespaces, functions may still be passed as values, but the programmer must explicitly &lt;em&gt;annotate&lt;/em&gt; when they wish to use a value from a different namespace:&lt;/p&gt;

&lt;div class="brush: lisp"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcar&lt;/span&gt; &lt;span class="nf"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The Common Lisp &lt;code&gt;#'x&lt;/code&gt; reader abbreviation is equivalent to &lt;code&gt;(function x)&lt;/code&gt;, and &lt;code&gt;function&lt;/code&gt; is a special form that references a value in the function namespace.&lt;/p&gt;

&lt;p&gt;While this distinction is somewhat arbitrary, it is generally my belief that the Scheme approach was, indeed, the right one. Runtime values are values, whether they are numbers, strings, or functions, and they ought to all be treated as equal citizens. After all, if a programmer wishes to define their own function-like thing, they should not be forced to make their abstraction a second-class citizen merely because it is slightly different from the built-in notion of a function. Higher-order functional programming encourages treating functions as ordinary values, and an arbitrary stratification of the namespace is antithetical to that mental model.&lt;/p&gt;

&lt;p&gt;However, Hackett is a little different from all of the aforementioned languages because Hackett has &lt;em&gt;types&lt;/em&gt;. Types are rather different from runtime values because they do not exist at all at runtime. One cannot use a type where a value is expected, nor can one use a value where a type is expected, so this distinction is &lt;em&gt;always&lt;/em&gt; syntactically unambiguous.&lt;sup&gt;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-1-definition" name="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; Even if types and values live in separate namespaces, there is no need for a &lt;code&gt;type&lt;/code&gt; form a la CL’s &lt;code&gt;function&lt;/code&gt; because it can always be determined implicitly.&lt;/p&gt;

&lt;p&gt;For this reason, it makes a great deal of sense for Hackett to have separate type and value namespaces, permitting declarations such as the following:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tuple&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tuple&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This defines a binding named &lt;code&gt;Tuple&lt;/code&gt; at the type level, which is a &lt;em&gt;type constructor&lt;/em&gt; of two arguments that produces a type of kind &lt;code&gt;*&lt;/code&gt;,&lt;sup&gt;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-2-definition" name="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; and another binding named &lt;code&gt;Tuple&lt;/code&gt; at the value level, which is a &lt;em&gt;value constructor&lt;/em&gt; of two arguments that produces a value of type &lt;code&gt;(Tuple a b)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But why do we want to overload names in this way, anyway? How hard would it really be to just name the value constructor &lt;code&gt;tuple&lt;/code&gt; instead of &lt;code&gt;Tuple&lt;/code&gt;? Well, it wouldn’t be hard at all, if it weren’t for the unpleasant ambiguity such a naming convention introduces when pattern-matching. Consider the following code snippet:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;foo-&amp;gt;integer&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;    &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This works fine. But what happens if the programmer decides to change the name of the &lt;code&gt;bar&lt;/code&gt; value?&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;qux&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;foo-&amp;gt;integer&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;    &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Can you spot the bug? Disturbingly, this code &lt;em&gt;still compiles&lt;/em&gt;! Even though &lt;code&gt;bar&lt;/code&gt; is not a member of &lt;code&gt;Foo&lt;/code&gt; anymore, it’s still a valid pattern, since names used as patterns match anything, just as the &lt;code&gt;y&lt;/code&gt; pattern matches against any integer inside the &lt;code&gt;baz&lt;/code&gt; constructor. If Hackett had a pattern redundancy checker, it could at least hopefully catch this mistake, but as things are, this could would silently compile and do the wrong thing: &lt;code&gt;(foo-&amp;gt;integer (baz 42))&lt;/code&gt; will still produce &lt;code&gt;0&lt;/code&gt;, not &lt;code&gt;42&lt;/code&gt;, since the first case always matches.&lt;/p&gt;

&lt;p&gt;Haskell escapes this flaw by syntactically distinguishing between patterns and ordinary bindings by requiring all constructors start with an uppercase letter. This means that programmers often want to define data constructors and type constructors with the same name, such as the &lt;code&gt;Tuple&lt;/code&gt; example above, which is illegal if a programming language only supports a single namespace.&lt;/p&gt;

&lt;p&gt;Although Hackett now supports two namespaces, it does not currently enforce this naming convention, but it seems like an increasingly good idea. Separating the namespaces is the biggest hurdle needed to implement such a feature, and happily, it is now complete. The &lt;code&gt;Tuple&lt;/code&gt; example from above is perfectly legal Hackett.&lt;/p&gt;

&lt;h1 id="adding-namespaces-to-a-language"&gt;Adding namespaces to a language&lt;/h1&gt;

&lt;p&gt;Hopefully, we now agree that it would be nice if Hackett had two namespaces, but that doesn’t really get us any closer to being able to &lt;em&gt;implement&lt;/em&gt; such a feature. At its core, Hackett is still a Racket language, and Racket’s binding structure has no notion of namespaces. How can it possibly support a language with more than one namespace?&lt;/p&gt;

&lt;p&gt;Fortunately, Racket is no ordinary language—it is a language with a highly formalized notion of lexical scope, and many of its low-level scope control features are accessible to ordinary programmers. Before we get into the details, however, a forewarning: &lt;strong&gt;the remainder of this blog post is &lt;em&gt;highly technical&lt;/em&gt;, and some of it involves some of the more esoteric corners of Racket’s macro system&lt;/strong&gt;. This blog post is &lt;em&gt;not&lt;/em&gt; representative of most macros written in Racket, nor is it at all necessary to understand these things to be a working Racket or Hackett macrologist. It is certainly not a tutorial on any of these concepts, so if you find it intimidating, there is no shame in skipping the rest of this post! If, however, you think you can handle it, or if you simply want to stare into the sun, by all means, read on.&lt;/p&gt;

&lt;h2 id="namespaces-as-scopes"&gt;Namespaces as scopes&lt;/h2&gt;

&lt;p&gt;With that disclaimer out of the way, let’s begin. As of this writing, the current Racket macroexpander uses a scoping model known as &lt;a href="https://www.cs.utah.edu/plt/scope-sets/"&gt;&lt;em&gt;sets of scopes&lt;/em&gt;&lt;/a&gt;, which characterizes the binding structure of a program by annotating identifiers with sets of opaque markers known as “scopes”. The details of Racket’s macro system are well outside the scope of this blog post, but essentially, two identifiers with the same name can be made to refer to different bindings by adding a unique scope to each identifier.&lt;/p&gt;

&lt;p&gt;Using this system of scopes, it is surprisingly simple to create a system of two namespaces: we only need to arrange for all identifiers in a value position to have a particular scope, which we will call the &lt;em&gt;value scope&lt;/em&gt;, and all identifiers in type position must have a different scope, which we will call the &lt;em&gt;type scope&lt;/em&gt;. How do we create these scopes and apply them to identifiers? In Racket, we use a function called &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._make-syntax-introducer%29%29"&gt;&lt;code&gt;make-syntax-introducer&lt;/code&gt;&lt;/a&gt;, which produces a function that encapsulates a fresh scope. This function can be applied to any syntax object (Racket’s structured representation of code that includes lexical binding information) to do one of three things: it can &lt;em&gt;add&lt;/em&gt; the scope to all pieces of the syntax object, &lt;em&gt;remove&lt;/em&gt; the scope, or &lt;em&gt;flip&lt;/em&gt; the scope (that is, add it to pieces of the syntax object that do not have it and remove it from pieces that do have it). In practice, this means we need to call &lt;code&gt;make-syntax-introducer&lt;/code&gt; once for each namespace:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We define these in a &lt;code&gt;begin-for-syntax&lt;/code&gt; block because these definitions will be used in our compile-time macros (aka “phase 1”), not in runtime code (aka “phase 0”). Now, we can write some macros that use these introducer functions to apply the proper scopes to their contents:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Each of these two forms is like &lt;code&gt;begin&lt;/code&gt;, which is a Racket form that is, for our purposes, essentially a no-op, but it applies &lt;code&gt;value-introducer&lt;/code&gt; or &lt;code&gt;type-introducer&lt;/code&gt; to add the appropriate scope. We can test that this works by writing a program that uses the two namespaces:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;value-x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;type-x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This program produces the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'value-x
'type-x&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works! Normally, if you try to define two bindings with the same name in Racket, it will produce a compile-time error, but by assigning them different scopes, we have essentially managed to create two separate namespaces.&lt;/p&gt;

&lt;p&gt;However, although this is close, it isn’t &lt;em&gt;quite&lt;/em&gt; right. What happens if we nest the two inside each other?&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;x: identifier's binding is ambiguous
  context...:
   #(189267 module) #(189268 module anonymous-module 0) #(189464 use-site)
   #(189465 use-site) #(190351 use-site) #(190354 use-site) #(190358 local)
   #(190359 intdef)
  matching binding...:
   #&amp;lt;module-path-index:()&amp;gt;
   #(189267 module) #(189268 module anonymous-module 0) #(189464 use-site)
  matching binding...:
   #&amp;lt;module-path-index:()&amp;gt;
   #(189267 module) #(189268 module anonymous-module 0) #(189465 use-site)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh no! That didn’t work at all. The error is a bit of a scary one, but the top of the error message is essentially accurate: the use of &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;ambiguous&lt;/em&gt; because it has both scopes on it, so it could refer to either binding. What we really want is for nested uses of &lt;code&gt;begin/value&lt;/code&gt; or &lt;code&gt;begin/type&lt;/code&gt; to &lt;em&gt;override&lt;/em&gt; outer ones, ensuring that a use can only be in a single namespace at a time.&lt;/p&gt;

&lt;p&gt;To do this, we simply need to adjust &lt;code&gt;begin/value&lt;/code&gt; and &lt;code&gt;begin/type&lt;/code&gt; to remove the other scope in addition to adding the appropriate one:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now our nested program runs, and it produces &lt;code&gt;'type-x&lt;/code&gt;, which is exactly what we want—the “nearest” scope wins.&lt;/p&gt;

&lt;p&gt;With just a few lines of code, we’ve managed to implement the two-namespace system Hackett needs: we simply maintain two scopes, one for each namespace, and arrange for all the types to have the type scope applied and everything else to have the value scope applied. Easy, right? Well, not quite. Things start to get a lot more complicated once our programs span more than a single module.&lt;/p&gt;

&lt;h2 id="namespaces-that-cross-module-boundaries"&gt;Namespaces that cross module boundaries&lt;/h2&gt;

&lt;p&gt;The system of using two syntax introducers to manage scopes is wonderfully simple as long as all of our programs are contained within a single module, but obviously, that is never true in practice. It is critical that users are able to export both values and types from one module and import them into another, as that is a pretty fundamental feature of any language. This is, unfortunately, where we start to run into problems.&lt;/p&gt;

&lt;p&gt;Racket’s notion of hygiene is pervasive, but it is still essentially scoped to a single module. This makes sense, since each module conceptually has its own “module scope”, and it wouldn’t be very helpful to inject a binding from a different module with the &lt;em&gt;other&lt;/em&gt; module’s scope—it would be impossible to reference the binding in the importing module. Instead, Racket’s modules essentially export &lt;em&gt;symbols&lt;/em&gt;, not identifiers (which, in Racket terminology, are symbols packaged together with their lexical scope). When a Racket module provides a binding named &lt;code&gt;foo&lt;/code&gt;, there is no other information attached to that binding. It does not have any scopes attached to it, since it is the &lt;code&gt;require&lt;/code&gt; form’s job to attach the correct scopes to imported identifiers.&lt;/p&gt;

&lt;p&gt;This completely makes sense for all normal uses of the Racket binding system, but it has unfortunate implications for our namespace system: Racket modules cannot export more than one binding with a given symbolic name!&lt;sup&gt;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-3-definition" name="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt; This won’t work at all, since a Hackett programmer might very well want to export a type and value with the same name from a single module. Indeed, this capability is one of the primary &lt;em&gt;points&lt;/em&gt; of having multiple namespaces.&lt;/p&gt;

&lt;p&gt;What to do? Sadly, Racket does not have nearly as elegant a solution for this problem, at least not at the time of this writing. Fortunately, hope is not lost. While far from perfect, we can get away with a relatively simple name-mangling scheme to prefix types upon export and unprefix them upon import. Since Racket’s &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;provide&lt;/code&gt; forms are extensible, it’s even possible to implement this mangling in a completely invisible way.&lt;/p&gt;

&lt;p&gt;Currently, the scheme that Hackett uses is to prefix &lt;code&gt;#%hackett-type:&lt;/code&gt; onto the beginning of any type exports. This can be defined in terms of a &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28tech._provide._pre._transformer%29"&gt;&lt;em&gt;provide pre-transformer&lt;/em&gt;&lt;/a&gt;, which is essentially a macro that cooperates with Racket’s &lt;code&gt;provide&lt;/code&gt; form to control the export process. In this case, we can define our &lt;code&gt;type-out&lt;/code&gt; provide pre-transformer in terms of &lt;a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prefix-out%29%29"&gt;&lt;code&gt;prefix-out&lt;/code&gt;&lt;/a&gt;, a form built-in to Racket that allows prefixing the names of exports:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;type-out&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-provide-pre-transformer&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="n"&gt;modes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
       &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;provide-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre-expand-export&lt;/span&gt;
         &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-out&lt;/span&gt; &lt;span class="n"&gt;#%hackett-type:&lt;/span&gt;
                       &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt;
                          &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;combine-out&lt;/span&gt; &lt;span class="n"&gt;provide-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="n"&gt;modes&lt;/span&gt;&lt;span class="p"&gt;)]))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that we call &lt;code&gt;type-introducer&lt;/code&gt; in this macro! That’s because we want to ensure that, when a user writes &lt;code&gt;(provide (type-out Foo))&lt;/code&gt;, we look for &lt;code&gt;Foo&lt;/code&gt; in the module’s type namespace. Of course, once it is provided, all that scoping information is thrown away, but we still need it around so that &lt;code&gt;provide&lt;/code&gt; knows &lt;em&gt;which&lt;/em&gt; &lt;code&gt;Foo&lt;/code&gt; is being provided.&lt;/p&gt;

&lt;p&gt;Once we have referenced the correct binding, the use of &lt;code&gt;prefix-out&lt;/code&gt; will appropriately add the &lt;code&gt;#%hackett-type:&lt;/code&gt; prefix, so the exporting side is already done. Users do need to explicitly write &lt;code&gt;(type-out ....)&lt;/code&gt; if they are exporting a particular type-level binding, but this is rarely necessary, since most users use &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; to export datatypes or typeclasses respectively, which can be modified to use &lt;code&gt;type-out&lt;/code&gt; internally. Very little user code actually needs to change to support this adjustment.&lt;/p&gt;

&lt;p&gt;Handling imports is, comparatively, tricky. When exporting, we can just force the user to annotate which exports are types, but we don’t have that luxury when importing, since it is merely whether or not a binding has the &lt;code&gt;#%hackett-type:&lt;/code&gt; prefix that indicates which namespace it should be imported into. This means we’ll need to explicitly iterate through every imported binding and check if it has the prefix or not. If it does, we need to strip it off and add the type namespace; otherwise, we just pass it through unchanged.&lt;/p&gt;

&lt;p&gt;Just as we extended &lt;code&gt;provide&lt;/code&gt; with a provide pre-transformer, we can extend &lt;code&gt;require&lt;/code&gt; using a &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28tech._require._transformer%29"&gt;&lt;em&gt;require transformer&lt;/em&gt;&lt;/a&gt;. In code, this entire process looks like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unmangle-type-name&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;and~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;regexp-match&lt;/span&gt; &lt;span class="sr"&gt;#rx"^#%hackett-type:(.+)$"&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;unmangle-types-in&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-require-transformer&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
     &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;imports&lt;/span&gt; &lt;span class="n"&gt;sources&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-import&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;combine-in&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match-lambda&lt;/span&gt;
              &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;local-id&lt;/span&gt; &lt;span class="n"&gt;src-sym&lt;/span&gt; &lt;span class="n"&gt;src-mod-path&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;req-mode&lt;/span&gt; &lt;span class="n"&gt;orig-mode&lt;/span&gt; &lt;span class="n"&gt;orig-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;local-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol-&amp;gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-e&lt;/span&gt; &lt;span class="n"&gt;local-id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;unmangled-type-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unmangle-type-name&lt;/span&gt; &lt;span class="n"&gt;local-name&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;unmangled-type-name&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;unmangled-id&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;local-id&lt;/span&gt;
                                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;string-&amp;gt;symbol&lt;/span&gt; &lt;span class="n"&gt;unmangled-type-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                            &lt;span class="n"&gt;local-id&lt;/span&gt;
                                            &lt;span class="n"&gt;local-id&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="n"&gt;unmangled-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                               &lt;span class="n"&gt;src-sym&lt;/span&gt; &lt;span class="n"&gt;src-mod-path&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;req-mode&lt;/span&gt; &lt;span class="n"&gt;orig-mode&lt;/span&gt; &lt;span class="n"&gt;orig-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                     &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
            &lt;span class="n"&gt;imports&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;sources&lt;/span&gt;&lt;span class="p"&gt;)])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is a little intimidating if you are not familiar with the intricacies of Racket’s low-level macro system, but the bulk of the code isn’t as scary as it may seem. It essentially does three things:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;It iterates over each import and calls &lt;code&gt;unmangle-type-name&lt;/code&gt; on the imported symbol. If the result is &lt;code&gt;#f&lt;/code&gt;, that means the import does not have the &lt;code&gt;#%hackett-type:&lt;/code&gt; prefix, and it can be safely passed through unchanged.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If &lt;code&gt;unmangle-type-name&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; return &lt;code&gt;#f&lt;/code&gt;, then it returns the unprefixed name, which is then provided to &lt;code&gt;datum-&amp;gt;syntax&lt;/code&gt;, which allows users to forge new identifiers in an &lt;em&gt;unhygienic&lt;/em&gt; (or “hygiene-bending”) way. In this case, we want to forge a new identifier with the name we get back from &lt;code&gt;unmangle-type-name&lt;/code&gt;, but with the lexical context of the original identifier.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, we pass the new identifier to &lt;code&gt;type-introducer&lt;/code&gt; to properly add the type scope, injecting the fresh binding into the type namespace.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;With this in place, we now have a way for Hackett users to import and export type bindings, but while it is not much of a burden to write &lt;code&gt;type-out&lt;/code&gt; when exporting types, it is unlikely that users will want to write &lt;code&gt;unmangle-types-in&lt;/code&gt; around each and every import in their program. For that reason, we can define a slightly modified version of &lt;code&gt;require&lt;/code&gt; that implicitly wraps all of its subforms with &lt;code&gt;unmangle-types-in&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;rename-out&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;require/unmangle&lt;/span&gt; &lt;span class="k"&gt;require&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;require/unmangle&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unmangle-types-in&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…and we’re done. Now, Hackett modules can properly import and export type-level bindings.&lt;/p&gt;

&lt;h2 id="namespaces-plus-submodules-the-devils-in-the-details"&gt;Namespaces plus submodules: the devil’s in the details&lt;/h2&gt;

&lt;p&gt;Up until this point, adding namespaces has required some understanding of the nuances of Racket’s macro system, but it hasn’t been particularly difficult to implement. However, getting namespaces right is a bit trickier than it appears. One area where namespaces are less than straightforward is Racket’s system of &lt;em&gt;submodules&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Submodules are a Racket feature that allows the programmer to arbitrarily nest modules. Each file always corresponds to a single outer module, but that module can contain an arbitrary number of submodules. Each submodule can have its own “module language”, which even allows different languages to be mixed within a single file.&lt;/p&gt;

&lt;p&gt;Submodules in Racket come in two flavors: &lt;code&gt;module&lt;/code&gt; and &lt;code&gt;module*&lt;/code&gt;. The difference is what order, semantically, they are defined in. Submodules defined with &lt;code&gt;module&lt;/code&gt; are essentially defined &lt;em&gt;before&lt;/em&gt; their enclosing module, so they cannot import their enclosing module, but their enclosing module can import them. Modules defined with &lt;code&gt;module*&lt;/code&gt; are the logical dual to this: they are defined after their enclosing module, so they can import their enclosing module, but the enclosing module cannot import them.&lt;/p&gt;

&lt;p&gt;How do submodules interact with namespaces? Well, for the most part, they work totally fine. This is because submodules are really, for the most part, treated like any other module, so the same machinery that works for ordinary Racket modules works fine with submodules.&lt;/p&gt;

&lt;p&gt;However, there is &lt;a href="https://docs.racket-lang.org/guide/Module_Syntax.html#%28part._submodules%29"&gt;a special sort of &lt;code&gt;module*&lt;/code&gt; submodule that uses &lt;code&gt;#f&lt;/code&gt; in place of a module language&lt;/a&gt;, which gives a module access to &lt;em&gt;all&lt;/em&gt; of its enclosing module’s bindings, even ones that aren’t exported! This is commonly used to create a &lt;code&gt;test&lt;/code&gt; submodule that contains unit tests, and functions can be tested in such a submodule even if they are not part of the enclosing module’s public API:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="c1"&gt;; not provided&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;private-add1&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module*&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;rackunit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-equal?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;private-add1&lt;/span&gt; &lt;span class="mi"&gt;41&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It would be nice to be able to use these sorts of submodules in Hackett, too, but if we try, we’ll find that types from the enclosing module mysteriously can’t be referenced by the submodule. Why? Well, the issue is in how we naïvely create our type and value introducers:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Remember that &lt;code&gt;make-syntax-introducer&lt;/code&gt; is generative—each time it is called, it produces a function that operates on a fresh scope. This is a problem, since those functions will be re-evaluated on every module &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28tech._instantiate%29"&gt;instantiation&lt;/a&gt;, as ensured by Racket’s &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._separate-compilation%29"&gt;separate compilation guarantee&lt;/a&gt;. This means that each module gets its &lt;em&gt;own&lt;/em&gt; pair of scopes. This means the body of a &lt;code&gt;module*&lt;/code&gt; submodule will have different scopes from its enclosing module, and the enclosing modules bindings will not be accessible.&lt;/p&gt;

&lt;p&gt;Fortunately, there is a way to circumvent this. While we cannot directly preserve syntax introducers across module instantiations, we &lt;em&gt;can&lt;/em&gt; preserve syntax objects by embedding them in the expanded program, and we can attach scopes to syntax objects. Using &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._make-syntax-delta-introducer%29%29"&gt;&lt;code&gt;make-syntax-delta-introducer&lt;/code&gt;&lt;/a&gt;, we can create a syntax introducer the adds or removes the &lt;em&gt;difference&lt;/em&gt; between scopes on two syntax objects. Pairing this with a little bit of clever indirection, we can arrange for &lt;code&gt;value-introducer&lt;/code&gt; and &lt;code&gt;type-introducer&lt;/code&gt; to always operate on the same scopes on each module instantiation:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-value/type-introducers&lt;/span&gt;
                       &lt;span class="n"&gt;value-introducer:id&lt;/span&gt; &lt;span class="n"&gt;type-introducer:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;scopeless-id&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;introducer-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;value-id&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;type-id&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-delta-introducer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value-id&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-delta-introducer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;type-id&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-value/type-introducers&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The way this trick works is subtle, but to understand it, it’s important to understand that when a module is compiled, its macro uses are only evaluated once. Subsequent imports of the same module will not re-expand the module. &lt;em&gt;However&lt;/em&gt;, code inside &lt;code&gt;begin-for-syntax&lt;/code&gt; blocks is still re-evaluated every time the module is instantiated! This means we are &lt;em&gt;not&lt;/em&gt; circumventing that re-evaluation directly, we are merely arranging for each re-evaluation to always produce the same result.&lt;/p&gt;

&lt;p&gt;We still use &lt;code&gt;make-syntax-introducer&lt;/code&gt; to create our two scopes, but critically, we only call &lt;code&gt;make-syntax-introducer&lt;/code&gt; inside the &lt;code&gt;define-value/type-introducers&lt;/code&gt; macro, which is, again, only run once (when the module is expanded). The resulting compiled module embeds &lt;code&gt;value-id&lt;/code&gt; and &lt;code&gt;type-id&lt;/code&gt; as syntax objects in the fully-expanded program, so they never change on each module instantiation, and they already contain the appropriate scopes. We can use &lt;code&gt;make-syntax-delta-introducer&lt;/code&gt; to convert the “inert” scopes into introducer functions that we can use to apply the scopes to other syntax objects as we see fit.&lt;/p&gt;

&lt;p&gt;By guaranteeing each namespace’s scope is always the same, even for different modules, &lt;code&gt;module*&lt;/code&gt; submodules now work properly, and they are able to refer to bindings inherited from their enclosing module as desired.&lt;/p&gt;

&lt;h2 id="the-final-stretch-making-scribble-documentation-namespace-aware"&gt;The final stretch: making Scribble documentation namespace-aware&lt;/h2&gt;

&lt;p&gt;As discussed in &lt;a href="/blog/2017/08/28/hackett-progress-report-documentation-quality-of-life-and-snake/"&gt;my previous blog post&lt;/a&gt;, Hackett has comprehensive documentation powered by Racket’s excellent documentation tool, Scribble. Fortunately for Hackett, Scribble is incredibly flexible, and it can absolutely cope with a language with multiple namespaces. Less fortunately, it is clear that Scribble’s built-in documentation forms were not at all designed with multiple namespaces in mind.&lt;/p&gt;

&lt;p&gt;In general, documenting such a language is tricky, assuming one wishes all identifiers to be properly hyperlinked to their appropriate definition (which, of course, I do). However, documentation is far more ambiguous than code when attempting to determine which identifiers belong in which namespace. When actually writing Hackett code, forms can always syntactically deduce the appropriate namespace for their subforms and annotate them accordingly, but this is not true in documentation. Indeed, it’s entirely possible that a piece of documentation might include intentionally incorrect code, which cannot be expanded at all!&lt;/p&gt;

&lt;p&gt;Haskell’s documentation tool, Haddock, does not appear to attempt to tackle this problem at all—when given an identifier that exists in both namespaces, it will generate a hyperlink to the type, not the value. I do not know if there is a way around this, but if there is, it isn’t documented. This works alright for Haddock because Haskell’s documentation generally contains fewer examples, and Haskell programmers do not expect all examples to be appropriately hyperlinked, so a best-effort approach is accepted. Racket programmers, however, are used to a very high standard of documentation, and incorrectly hyperlinked docs are unacceptable.&lt;/p&gt;

&lt;p&gt;To work around this problem, Hackett’s documentation requires that users explicitly annotate which identifiers belong to the type namespace. Identifiers in the type namespace are prefixed with &lt;code&gt;t:&lt;/code&gt; upon import, and they are bound to Scribble &lt;a href="https://docs.racket-lang.org/scribble/scheme.html#%28tech._element._transformer%29"&gt;&lt;em&gt;element transformers&lt;/em&gt;&lt;/a&gt; that indicate they should be typeset without the &lt;code&gt;t:&lt;/code&gt; prefix. Fortunately, Scribble’s documentation forms &lt;em&gt;do&lt;/em&gt; understand Racket’s model of lexical scope (mostly), so they can properly distinguish between two identifiers with the same name but different lexical context.&lt;/p&gt;

&lt;p&gt;In practice, this means Hackett documentation must now include a proliferation of &lt;code&gt;t:&lt;/code&gt; prefixes. For example, here is the code for a typeset REPL interaction:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hackett-examples&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;square&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t:-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t:Integer&lt;/span&gt; &lt;span class="n"&gt;t:Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;}])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;square&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note the use of &lt;code&gt;t:-&amp;gt;&lt;/code&gt; and &lt;code&gt;t:Integer&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;Integer&lt;/code&gt;. When the documentation is rendered and the example is evaluated, the prefixes are stripped, resulting in properly-typeset Hackett code.&lt;/p&gt;

&lt;p&gt;This also means Hackett’s documentation forms have been updated to understand multiple namespaces. Hackett now provides &lt;code&gt;deftype&lt;/code&gt; and &lt;code&gt;deftycon&lt;/code&gt; forms for documenting types and type constructors, respectively, which will use the additional lexical information attached to &lt;code&gt;t:&lt;/code&gt;-prefixed identifiers to properly index documented forms. Similarly, &lt;code&gt;defdata&lt;/code&gt; and &lt;code&gt;defclass&lt;/code&gt; have been updated with an understanding of types.&lt;/p&gt;

&lt;p&gt;The implementation details of these changes is less interesting than the ones made to the code itself, since it mostly just involved tweaking Racket’s implementation of &lt;code&gt;defform&lt;/code&gt; slightly to cooperate with the prefixed identifiers. To summarize, Hackett defines a notion of “type binding transformers” that include information about both prefixed and unprefixed versions of types, and Hackett provides documentation forms that consume that information when typesetting. A require transformer converts imported bindings into &lt;code&gt;t:&lt;/code&gt;-prefixed ones and attaches the necessary compile-time information to them. It isn’t especially elegant, but it works.&lt;/p&gt;

&lt;h1 id="analysis-and-unsolved-problems"&gt;Analysis and unsolved problems&lt;/h1&gt;

&lt;p&gt;When laid out from top to bottom in this blog post, the amount of code it takes to actually implement multiple namespaces in Racket is surprisingly small. In hindsight, it does not feel like two weeks worth of effort, but it would be disingenuous to suggest that any of this was obvious. I tried a variety of different implementation strategies and spent a great deal of time staring at opaque error messages and begging &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt; for help before I got things working properly. Fortunately, with everything in place, the implementation seems reliable, predictable, and useful for Hackett’s users (or, as the case may be, users-to-be).&lt;/p&gt;

&lt;p&gt;For the most part, all the machinery behind multiple namespaces is invisible to the average Hackett programmer, and it seems to “just work”. For completeness, however, I must mention one unfortunate exception: remember the work needed to unmangle type names? While it’s true that all imports into Hackett modules are automatically unmangled by the custom &lt;code&gt;require&lt;/code&gt; form, types provided by a module’s &lt;em&gt;language&lt;/em&gt; are not automatically unmangled. This is because Racket does not currently provide a hook to customize how bindings from a module language are introduced, unlike &lt;code&gt;require&lt;/code&gt;’s require transformers.&lt;/p&gt;

&lt;p&gt;To circumvent this restriction, &lt;code&gt;#lang hackett&lt;/code&gt;’s reader includes a somewhat ad-hoc solution that actually inserts a &lt;code&gt;require&lt;/code&gt; into users’ programs that unmangles and imports all the types provided by the module. This mostly works, but due to the way Racket’s imports work, it isn’t possible for Racket programmers to import different types with the same names as Hackett core types; the two bindings will conflict, and there is no way for users to hide these implicitly imported bindings. Whether or not this is actually a common problem remains to be seen. If it is rare, it might be sufficient to introduce an ad-hoc mechanism to hide certain type imports, but it might be better to extend Racket in some way to better support this use-case.&lt;/p&gt;

&lt;p&gt;That issue aside, multi-namespace Hackett is now working smoothly. It’s worth nothing that I did not have to do &lt;em&gt;any&lt;/em&gt; special work to help Racket’s tooling, such as DrRacket’s Check Syntax tool, understand the binding structure of Hackett programs. Since other tools, such as racket-mode for Emacs, use the same mechanisms under the hood, Racket programmers’ existing tools will be able to properly locate the distinct definition sites for types and values with the same name, another example of how Racket successfully &lt;a href="http://www.ccs.neu.edu/home/matthias/manifesto/sec_intern.html"&gt;internalizes extra-linguistic mechanisms&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As closing notes, even if the majority of this blog post was gibberish to you, do note that Hackett has come quite a long way in just the past two months, adding much more than just a separate type namespace. I might try and give a more comprehensive update at a later date, but here’s a quick summary of the meaningful changes for those interested:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Multi-parameter typeclasses&lt;/strong&gt; are implemented, along with &lt;strong&gt;default typeclass method implementations&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Pattern-matching performs basic &lt;strong&gt;exhaustiveness checking&lt;/strong&gt;, so unmatched cases are a compile-time error.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Hackett ships with a &lt;strong&gt;larger standard library&lt;/strong&gt;, including an &lt;code&gt;Either&lt;/code&gt; type and appropriate functions, an &lt;code&gt;Identity&lt;/code&gt; type, a &lt;code&gt;MonadTrans&lt;/code&gt; typeclass, and the &lt;code&gt;ReaderT&lt;/code&gt; and &lt;code&gt;ErrorT&lt;/code&gt; monad transformers.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;More things are documented&lt;/strong&gt;, and parts of the documentation are slightly improved. Additionally, &lt;strong&gt;Hackett’s internals are much more heavily commented&lt;/strong&gt;, hopefully making the project more accessible to new contributors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Parts of the typechecker are dramatically simplified&lt;/strong&gt;, improving the mechanisms behind dictionary elaboration and clearing the way for a variety of additional long-term improvements, including multiple compilation targets and a type-aware optimizer.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;As always, various bug fixes.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Finally, special mention to two new contributors to Hackett, &lt;a href="https://github.com/iitalics"&gt;Milo Turner&lt;/a&gt; and &lt;a href="https://github.com/Shamrock-Frost"&gt;Brendan Murphy&lt;/a&gt;. Also special thanks to &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt; and &lt;a href="https://github.com/michaelballantyne"&gt;Michael Ballantyne&lt;/a&gt; for helping me overcome two of the trickiest macro-related problems I’ve encountered in Hackett to date. It has now been just over a year since Hackett’s original conception and roughly six months since the first commit of its current implementation, and the speed at which I’ve been able to work would not have been possible without the valuable help of the wonderful Racket community. Here’s hoping this is only the beginning.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;“But what about dependent types?” you may ask. Put simply, Hackett is not dependently typed, and it is not going to be dependently typed. Dependent types are currently being bolted onto Haskell, but Haskell does not have &lt;code&gt;#lang&lt;/code&gt;. Racket does. It seems likely that a dependently-typed language would be much more useful as a separate &lt;code&gt;#lang&lt;/code&gt;, not a modified version of Hackett, so Hackett can optimize its user experience for what it &lt;em&gt;is&lt;/em&gt;, not what it might be someday.&amp;nbsp;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;Hackett does not actually have a real kind system yet, but pleasantly, this same change will allow &lt;code&gt;*&lt;/code&gt; to be used to mean “type” at the kind level and “multiply” at the value level.&amp;nbsp;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;This isn’t strictly true, as readers familiar with Racket’s macro system may likely be aware that Racket modules export bindings at different “phase levels”, where phase levels above 0 correspond to compile-time macroexpansion phases. Racket modules are allowed to export a single binding per name, &lt;em&gt;per phase&lt;/em&gt;, so the same symbolic name can be bound to different things at different phases. This isn’t meaningfully relevant for Hackett, however, since types and values are both exported at phase 0, and there are reasons that must be the case, this phase separation does not make this problem any simpler.&amp;nbsp;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry>
 <entry>
  <title type="text">Hackett progress report: documentation, quality of life, and snake</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2017/08/28/hackett-progress-report-documentation-quality-of-life-and-snake/?utm_source=hackett&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2017-08-28-hackett-progress-report-documentation-quality-of-life-and-snake</id>
  <published>2017-08-28T08:00:00Z</published>
  <updated>2017-08-28T08:00:00Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;Three months ago, &lt;a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/"&gt;I wrote a blog post describing my new, prototype implementation of my programming language, Hackett&lt;/a&gt;. At the time, some things looked promising—the language already included algebraic datatypes, typeclasses, laziness, and even a mini, proof of concept web server. It was, however, clearly still rather rough around the edges—error messages were poor, features were sometimes brittle, the REPL experience was less than ideal, and there was no documentation to speak of. In the time since, while the language is still experimental, I have tackled a handful of those issues, and I am excited to announce &lt;a href="https://pkg-build.racket-lang.org/doc/hackett@hackett-doc/"&gt;&lt;strong&gt;the first (albeit quite incomplete) approach to Hackett’s documentation&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’d recommend clicking that link above and at least skimming around before reading the rest of this blog post, as its remainder will describe some of the pieces that didn’t end up in the documentation: the development process, the project’s status, a small demo, and some other details from behind the scenes.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="a-philosophy-of-documentation"&gt;A philosophy of documentation&lt;/h1&gt;

&lt;p&gt;Racket, as a project, has always had &lt;a href="http://docs.racket-lang.org"&gt;wonderful documentation&lt;/a&gt;. There are many reasons for this—Racket’s educational origins almost certainly play a part, and it helps that the core packages set the bar high—but one of the biggest reasons is undoubtably &lt;a href="http://docs.racket-lang.org/scribble/index.html"&gt;Scribble, the Racket documentation tool&lt;/a&gt;. Scribble is, in many ways, the embodiment of the Racket philosophy: it is a user-extensible, fully-featured, domain-specific programming language designed for typesetting, with &lt;a href="http://docs.racket-lang.org/scribble/plt-manuals.html"&gt;a powerful library for documenting Racket code&lt;/a&gt;. Like the Racket language itself, Scribble comes with a hygienic macro system, and in fact, all Racket libraries are trivially usable from within Scribble documents, if desired. The macro system is used to great effect to provide typesetting forms tailored to the various sorts of things a Racket programmer might wish to document, such as procedures, structures, and macros.&lt;/p&gt;

&lt;p&gt;Scribble documents are decoupled from a rendering backend, so a single Scribble document can be rendered to plain text, a PDF, or HTML, but the HTML backend is the most useful for writing docs. Scribble documents themselves use a syntax inspired by (La)TeX’s syntax, but Scribble uses an &lt;code&gt;@&lt;/code&gt; character instead of &lt;code&gt;\&lt;/code&gt;. It also generalizes and regularizes TeX in many ways, creating a much more uniform language without nearly so much magic or complexity. Since Scribble’s “at-expressions” are merely an alternate syntax for Racket’s more traditional s-expressions, Scribble documents can be built out of ordinary Racket macros. For example, to document a procedure in Racket, one would use &lt;a href="http://docs.racket-lang.org/scribble/doc-forms.html#%28form._%28%28lib._scribble%2Fmanual..rkt%29._defproc%29%29"&gt;the provided &lt;code&gt;defproc&lt;/code&gt; form&lt;/a&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;@defproc&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="nb"&gt;number?&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="nb"&gt;number?&lt;/span&gt;&lt;span class="p"&gt;]{&lt;/span&gt;
&lt;span class="n"&gt;Returns&lt;/span&gt; &lt;span class="n"&gt;@racket&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This syntax may look alien to someone more familiar with traditional, Javadoc-style documentation comments, but the results are quite impressive. The above snippet renders into &lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._add1%29%29"&gt;something like this&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._add1%29%29"&gt;&lt;img src="/img/scribble-docs-racket-add1.png" alt="" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The fact that Scribble documents are fully-fledged &lt;em&gt;programs&lt;/em&gt; equips the programmer with a lot of power. One of the most remarkable tools Scribble provides is &lt;a href="http://docs.racket-lang.org/scribble/eval.html"&gt;the &lt;code&gt;scribble/example&lt;/code&gt; module&lt;/a&gt;, a library that performs sandboxed evaluation as part of the rendering process. This allows Scribble documents to include REPL-style examples inline, automatically generated as part of typesetting, always kept up to date from a single source of truth: the implementation. It even provides a special &lt;code&gt;eval:check&lt;/code&gt; form that enables &lt;a href="https://docs.python.org/3/library/doctest.html"&gt;doctest&lt;/a&gt;-like checking, which allows documentation to serve double duty as a test suite.&lt;/p&gt;

&lt;p&gt;Of course, Hackett is not Racket, though it shares many similarities. Fortunately, all of Racket is &lt;em&gt;designed&lt;/em&gt; with the goal of supporting many different programming languages, and Scribble is no exception. Things like &lt;a href="http://docs.racket-lang.org/scribble/eval.html"&gt;&lt;code&gt;scribble/example&lt;/code&gt;&lt;/a&gt; essentially work out of the box with Hackett, and most of &lt;a href="http://docs.racket-lang.org/scribble/plt-manuals.html"&gt;&lt;code&gt;scribble/manual&lt;/code&gt;&lt;/a&gt; can be reused. However, what about documenting algebraic datatypes? What about documenting typeclasses? Well, remember: Scribble is extensible. The &lt;code&gt;defproc&lt;/code&gt; and &lt;code&gt;defstruct&lt;/code&gt; forms are hardly builtins; they are defined as part of the &lt;code&gt;scribble/manual&lt;/code&gt; library in terms of Scribble primitives, and &lt;a href="https://github.com/lexi-lambda/hackett/blob/f472859cfc03086d39563e5c0eb81dcb2ceb49dc/hackett-doc/scribble/manual/hackett.rkt"&gt;we can do the same&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hackett’s documentation already defines three new forms, &lt;code&gt;defdata&lt;/code&gt;, &lt;code&gt;defclass&lt;/code&gt;, and &lt;code&gt;defmethod&lt;/code&gt;, for documenting algebraic datatypes, typeclasses, and typeclass methods, respectively. They typeset documentation custom-tailored to Hackett’s needs, so Hackett’s documentation need not be constrained by Racket’s design decisions. For example, one could document the &lt;code&gt;Functor&lt;/code&gt; typeclass using &lt;code&gt;defclass&lt;/code&gt; like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;@defclass&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Functor&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)})]]{&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;@deftech&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;functors&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;essentially&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;mapping&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;“piercing”&lt;/span&gt; &lt;span class="n"&gt;operation.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;@racket&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;viewed&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;
&lt;span class="n"&gt;different&lt;/span&gt; &lt;span class="n"&gt;ways:&lt;/span&gt;

&lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With only a little more than the above code, &lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._.Functor%29%29"&gt;Hackett’s documentation includes a beautifully-typeset definition of the &lt;code&gt;Functor&lt;/code&gt; typeclass&lt;/a&gt;, including examples and rich prose:&lt;/p&gt;

&lt;p&gt;&lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._.Functor%29%29"&gt;&lt;img src="/img/scribble-docs-hackett-functor.png" alt="" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Scribble makes Hackett’s documentation shine.&lt;/p&gt;

&lt;h2 id="a-tale-of-two-users"&gt;A tale of two users&lt;/h2&gt;

&lt;p&gt;For a programming language, documentation is critical. Once we have grown comfortable with a language, it’s easy to take for granted our ability to work within it, but there is always a learning period, no matter how simple or familiar the language may be. When learning a new language, we often relate the languages’ concepts and features to those which we already know, which is why having a broad vocabulary of languages makes picking up new ones so much easier.&lt;/p&gt;

&lt;p&gt;A new user of a language needs a gentle introduction to its features, structured in a logical way, encouraging this period of discovery and internalization. Such an introduction should come equipped with plenty of examples, and it shouldn’t worry itself with being an authoritative reference. Some innocent simplifications are often conducive to learning, and it is unlikely to be helpful to force the full power of a language onto a user all at once.&lt;/p&gt;

&lt;p&gt;However, for experienced users, an authoritative reference is &lt;em&gt;exactly&lt;/em&gt; what they need. While learners want tutorial-style documentation that encourages experimentation and exploration, working users of a language need something closer to a dictionary or encyclopedia: a way to look up forms and functions by name and find precise definitions, complete explanations, and hopefully a couple of examples. Such a user does not want information to be scattered across multiple chapters of explanatory text; they simply need a focused, targeted, one-stop shop for the information they’re looking for.&lt;/p&gt;

&lt;p&gt;This dichotomy is rarely well-served by existing programming language documentation. Most programming languages suffer from either failing entirely to serve both types of users, or doing so in a way that enforces too strong a separation between the styles of documentation. For example:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Java ships with a quintessential example of a documentation generator: Javadoc. Java is a good case study because, although its documentation is not particularly good, it still manages to be considerably better than most languages’ docs.&lt;/p&gt;
  &lt;p&gt;&lt;a href="https://docs.oracle.com/javase/8/docs/api/"&gt;Java’s API documentation&lt;/a&gt; documents its standard library, but it doesn’t document the language. Reference-style language documentation is largely relegated to the Java Language Specification, which is highly technical and rather low-level. It is more readable than the standards for some other languages, but it’s still mostly only useful to language lawyers. For Java, this ends up being mostly okay, largely because Java is a fairly &lt;em&gt;small&lt;/em&gt; language that does not often change.&lt;/p&gt;
  &lt;p&gt;On the other hand, Java’s reference documentation is inconsistent, rarely provides any examples, and certainly does not do a good job of serving new users. Java &lt;em&gt;does&lt;/em&gt; provide guide-style documentation in the form of the &lt;a href="https://docs.oracle.com/javase/tutorial/"&gt;Java Tutorials&lt;/a&gt;, but they are of inconsistent quality.&lt;/p&gt;
  &lt;p&gt;More importantly, while the Java tutorials link to the API docs, the reverse is &lt;strong&gt;not&lt;/strong&gt; true, which is a real disservice. One of the most beautiful things about the web is how information can be extensively cross-linked, and exploring links is many times easier than turning pages of a physical book. Anyone who’s explored topics on Wikipedia for an hour (or more) at a time knows how amazing this can be.&lt;/p&gt;
  &lt;p&gt;Language documentation isn’t quite the same as an encyclopedia, but it’s a shame that Java’s documentation does not lend itself as easily to curious, open-ended learning. If the API docs frequently linked to relevant portions of the tutorials, then a user could open the Javadoc for a class or method they are using, then quickly jump to the relevant guide. As the documentation is currently organized, this is nearly impossible, and tutorials are only discovered when explicitly looking for them.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Other languages, such as JavaScript, are in even worse boats than Java when it comes to documentation. For whatever reason, structured documentation of any kind doesn’t seem to have caught on in the JavaScript world, probably largely because no documentation tool ships with the language, and no such tool ever became standard. Whatever the reason, JavaScript libraries’ documentation largely resides in markdown documents spread across version control repositories and various webpages.&lt;/p&gt;
  &lt;p&gt;The closest thing that JavaScript has to official language documentation, aside from the (largely incomprehensible) language standard, is &lt;a href="https://developer.mozilla.org/en-US/"&gt;MDN&lt;/a&gt;. MDN’s docs are actually quite good, and they tend to mix lots of examples together with reference-style documentation. They’re indexed and searchable, and they have a great Google search ranking. MDN is easily my go-to place to read about core JavaScript functions.&lt;/p&gt;
  &lt;p&gt;The trouble, of course, is that MDN only houses documentation for the standard library, and while new standards make it bigger than ever, huge amounts of critical functionality are often offloaded to separate packages. These libraries all have their own standards and styles of documentation, and virtually none of them even compare to MDN.&lt;/p&gt;
  &lt;p&gt;This means that documentation for JavaScript libraries, even the most popular ones, tends to be all over the map. &lt;a href="http://ramdajs.com/docs/"&gt;Ramda’s documentation is nothing but a reference&lt;/a&gt;, which makes it easy to look up information about a specific function, but nearly impossible to find anything if you don’t have a specific name to look for. In contrast, &lt;a href="http://passportjs.org/docs"&gt;Passport’s docs are essentially &lt;em&gt;only&lt;/em&gt; a set of tutorials&lt;/a&gt;, which is great for learners, but enormously frustrating if I just want to look up what the heck a specific function or method &lt;em&gt;does&lt;/em&gt;. Fortunately, &lt;a href="https://facebook.github.io/react/docs/hello-world.html"&gt;there are some libraries, like React&lt;/a&gt;, that absolutely &lt;em&gt;nail&lt;/em&gt; this, and they have both styles of documentation that are &lt;strong&gt;actually cross-referenced&lt;/strong&gt;. Unfortunately, those are mostly the exceptions, not the norm.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="https://docs.python.org/3/index.html"&gt;Python’s documentation is interesting&lt;/a&gt;, since it includes a set of tutorials alongside the API reference, and it &lt;em&gt;also&lt;/em&gt; ships a language reference written for ordinary users. In many ways, it does everything right, but disappointingly, it generally doesn’t link back to the tutorials from the API docs, even though the reverse is true. For example, the section in the tutorial on &lt;code&gt;if&lt;/code&gt; links to the section in the reference about &lt;code&gt;if&lt;/code&gt;, but nothing goes in the other direction, which is something of a missed opportunity.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;a href="https://hackage.haskell.org/package/base"&gt;Haskell manages to be especially bad here&lt;/a&gt; (maybe even notoriously bad) despite having an ubiquitous documentation generator, Haddock. Unfortunately, Haddock’s format makes writing prose and examples somewhat unpleasant, and very few packages provide any sort of tutorial. For those that do, the tutorial is often not included in the API docs, a common theme at this point.&lt;/p&gt;
  &lt;p&gt;It’s generally a bad sign when your documentation tool isn’t even powerful enough to document itself, and &lt;a href="https://www.haskell.org/haddock/"&gt;Haddock’s docs are pretty impressively bad, though mostly serviceable if you’re willing to look&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The takeaway here is that I just don’t think most languages’ documentation is particularly good, and programmers seem to have gotten so used to this state of affairs that the bar is set disappointingly low. Fortunately, this is another area where Racket delivers. Racket, like Python, ships with &lt;em&gt;two&lt;/em&gt; pieces of documentation: the &lt;a href="http://docs.racket-lang.org/guide/index.html"&gt;Racket Guide&lt;/a&gt; and the &lt;a href="http://docs.racket-lang.org/reference/index.html"&gt;Racket Reference&lt;/a&gt;. The guide includes over &lt;strong&gt;one hundred thousand&lt;/strong&gt; words of explanations and examples, and the reference includes roughly &lt;strong&gt;half a million&lt;/strong&gt;. Racket’s documentation is impressive on its own, but what’s equally impressive is how carefully and methodically cross-linked it is. Margin notes often provide links to corresponding sections in the relevant companion manual, so it’s easy to look up a form or function by name, then quickly jump to the section of the guide explaining it.&lt;/p&gt;

&lt;p&gt;Hackett is obviously not going to have hundreds of thousands of words worth of documentation in its first few months of existence, but it already has nearly ten thousand, and that’s not nothing. More importantly, it is structured the same way that Racket’s docs are: it’s split into the &lt;a href="http://docs.racket-lang.org/hackett/guide.html"&gt;Hackett Guide&lt;/a&gt; and the &lt;a href="http://docs.racket-lang.org/hackett/reference.html"&gt;Hackett Reference&lt;/a&gt;, and the two are cross-referenced as much as possible. Haskell is a notoriously difficult language to learn, but my hope is that does not necessarily &lt;em&gt;need&lt;/em&gt; to be the case. Documentation cannot make the language trivial, but my hope is that it can make it a &lt;em&gt;lot&lt;/em&gt; more accessible without making it any less useful for power users.&lt;/p&gt;

&lt;h1 id="rounding-hacketts-library-sanding-its-edges"&gt;Rounding Hackett’s library, sanding its edges&lt;/h1&gt;

&lt;p&gt;One of the best things about sitting down and writing documentation—whether it’s for a tool, a library, or a language—is how it forces you, the author, to think about how someone else might perceive the project when seeing it for the first time. This encompasses everything: error messages, ease of installation, completeness of a standard library, friendliness of tooling, etc. Writing Hackett’s documentation forced me to make a &lt;em&gt;lot&lt;/em&gt; of improvements, and while very few of them are flashy features, they make Hackett feel much less like a toy and more like a tool.&lt;/p&gt;

&lt;p&gt;Hackett currently has no formal changelog because it is considered alpha quality, and its API is still unstable. There is no guarantee that things won’t change at any moment. Still, it’s useful to put together an ad-hoc list of changes made in the past few months. Here’s a very brief summary:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Hackett includes a &lt;a href="http://docs.racket-lang.org/hackett/reference-datatypes.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._.Double%29%29"&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/a&gt; type for working with IEEE 754 double-precision floating-point numbers.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Local definitions are supported via the &lt;a href="http://docs.racket-lang.org/hackett/reference-syntactic-forms.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._let%29%29"&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; and &lt;a href="http://docs.racket-lang.org/hackett/reference-syntactic-forms.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._letrec%29%29"&gt;&lt;code&gt;letrec&lt;/code&gt;&lt;/a&gt; forms.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The prelude includes many more functions, especially &lt;a href="http://docs.racket-lang.org/hackett/reference-datatypes.html#%28part._reference-lists%29"&gt;functions on lists&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The Hackett reader has been adjusted to support using &lt;code&gt;.&lt;/code&gt; as a bare symbol, since &lt;a href="http://docs.racket-lang.org/hackett/reference-datatypes.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._..%29%29"&gt;&lt;code&gt;.&lt;/code&gt; is the function composition operator&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The Hackett REPL supports many more forms, including &lt;a href="http://docs.racket-lang.org/hackett/reference-datatypes.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._data%29%29"&gt;ADT&lt;/a&gt;, &lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._class%29%29"&gt;class&lt;/a&gt;, and &lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._instance%29%29"&gt;instance&lt;/a&gt; definitions. Additionally, the REPL now uses &lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._.Show%29%29"&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/a&gt; instances to display the results of expressions. To compensate for the inability to print non-&lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._.Show%29%29"&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/a&gt;able things, a new &lt;code&gt;(#:type expr)&lt;/code&gt; syntax is permitted to print the type of &lt;em&gt;any&lt;/em&gt; expression.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Missing instance errors are now dramatically improved, now correctly highlighting the source location of expressions that led to the error.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Alongside these changes are a variety of internal code improvements that make the Hackett code simpler, more readable, and hopefully more accessible to contributors. Many of the trickiest functions are now &lt;a href="https://github.com/lexi-lambda/hackett/blob/f472859cfc03086d39563e5c0eb81dcb2ceb49dc/hackett-lib/hackett/private/base.rkt#L77-L189"&gt;heavily commented&lt;/a&gt; with the hope that the codebase won’t be so intimidating to people unfamiliar with Racket or the techniques behind Hackett’s typechecker. I will continue to document the internals of Hackett as I change different places of the codebase, and I have even considered writing a separate Scribble document describing the Hackett internals. It certainly wouldn’t hurt.&lt;/p&gt;

&lt;p&gt;One of the most exciting things about documenting Hackett has been realizing just &lt;em&gt;how much&lt;/em&gt; already exists. Seriously, if you have gotten to this point in the blog post but haven’t read &lt;a href="https://pkg-build.racket-lang.org/doc/hackett@hackett-doc/"&gt;the actual documentation&lt;/a&gt; yet, I would encourage you to do so. No longer does the idea of writing real programs in this language feel out of reach; indeed, aside from potential performance problems, the language is likely extremely close to being usable for very simple things. After all, that’s the goal, isn’t it? As I’ve mentioned before, I’m writing Hackett for other people, but I’m also very much writing it for &lt;em&gt;me&lt;/em&gt;: it’s a language I’d like to use.&lt;/p&gt;

&lt;p&gt;Still, writing a general-purpose programming language is a lot of work, and I’ve known from the start that it isn’t something I can accomplish entirely on my own. While this iteration of work on Hackett is a sort of “documentation release”, it might be more accurate to call it an “accessibility release”. If you’re interested in contributing, I finally feel comfortable encouraging you to get involved!&lt;/p&gt;

&lt;h1 id="a-demo-with-pictures"&gt;A demo with pictures&lt;/h1&gt;

&lt;p&gt;Now, if you’re like me, all of this documentation stuff is already pretty exciting. Still, even I view documentation as simply a means to an end, not an end in itself. Documentation is successful when it gets out of the way and makes it possible to write good code that does cool things. Let’s write some, shall we?&lt;/p&gt;

&lt;p&gt;Hackett ships with a special package of demo libraries in the aptly-named &lt;code&gt;hackett-demo&lt;/code&gt; package, which are essentially simple, lightweight bindings to existing, dynamically-typed Racket libraries. In &lt;a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/"&gt;the previous Hackett blog post&lt;/a&gt;, I demonstrated the capabilities of &lt;code&gt;hackett/demo/web-server&lt;/code&gt;. In this blog post, we’re going to use &lt;code&gt;hackett/demo/pict&lt;/code&gt; and &lt;code&gt;hackett/demo/pict/universe&lt;/code&gt;, which make it possible to write interactive, graphical programs in Hackett with just a few lines of code!&lt;/p&gt;

&lt;p&gt;As always, we’ll start with &lt;code&gt;#lang hackett&lt;/code&gt;, and we’ll import the necessary libraries:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;hackett/demo/pict&lt;/span&gt;
         &lt;span class="n"&gt;hackett/demo/pict/universe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With that, we can start immediately with a tiny example. Just to see how &lt;code&gt;hackett/demo/pict&lt;/code&gt; works, let’s start by rendering a red square. We can do this by writing a &lt;code&gt;main&lt;/code&gt; action that calls &lt;code&gt;print-pict&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-pict&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filled-square&lt;/span&gt; &lt;span class="mf"&gt;50.0&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If you run the above program in DrRacket, you should see a 50 pixel red square printed into the interactions window!&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/hackett-pict-red-square.png" alt="" /&gt;
 &lt;p class="caption"&gt;&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Using the REPL, we can inspect the type of &lt;code&gt;print-pict&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;#:type&lt;/span&gt; &lt;span class="n"&gt;print-pict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;Unit&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Unsurprisingly, displaying a picture to the screen needs &lt;code&gt;IO&lt;/code&gt;. However, what’s interesting is that the rest of the expression is totally pure. Take a look at the type of &lt;code&gt;filled-square&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;#:type&lt;/span&gt; &lt;span class="n"&gt;filled-square&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Double&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;No &lt;code&gt;IO&lt;/code&gt; to be seen! This is because “picts” are entirely &lt;em&gt;pure&lt;/em&gt; values that represent images built out of simple shapes, and they can be put together to make more complex images. For example, we can put two squares next to one another:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-pict&lt;/span&gt; &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filled-square&lt;/span&gt; &lt;span class="mf"&gt;50.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="n"&gt;hc-append&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filled-square&lt;/span&gt; &lt;span class="mf"&gt;50.0&lt;/span&gt;&lt;span class="p"&gt;))}))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This code will print out a red square to the left of a blue one.&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/hackett-pict-red-blue-squares.png" alt="" /&gt;
 &lt;p class="caption"&gt;&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;Again, &lt;code&gt;hc-append&lt;/code&gt; is a simple, pure function, a binary composition operator that places two picts side by side to produce a new one:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;#:type&lt;/span&gt; &lt;span class="n"&gt;hc-append&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Using the various features of this toolkit, not only can we make interesting pictures and diagrams, we can even create a foundation for a game!&lt;/p&gt;

&lt;h2 id="implementing-a-snake-clone"&gt;Implementing a snake clone&lt;/h2&gt;

&lt;p&gt;This blog post is not a Hackett tutorial; it is merely a demo. For that reason, I am not going to spend much time explaining how the following program is built. This section is closer to annotated source code than a guide to the &lt;code&gt;pict&lt;/code&gt; or &lt;code&gt;universe&lt;/code&gt; libraries. Hopefully it’s still illustrative.&lt;/p&gt;

&lt;p&gt;We’ll start by writing some type definitions. We’ll need a type to represent 2D points on a grid, as well as a type to represent a cardinal direction (to keep track of which direction the player is moving, for example). We’ll also want an &lt;code&gt;Eq&lt;/code&gt; instance for our points.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Direction&lt;/span&gt; &lt;span class="n"&gt;d:left&lt;/span&gt; &lt;span class="n"&gt;d:right&lt;/span&gt; &lt;span class="n"&gt;d:up&lt;/span&gt; &lt;span class="n"&gt;d:down&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Eq&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;==&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;==&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;}})])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With these two datatypes, we can implement a &lt;code&gt;move&lt;/code&gt; function that accepts a point and a direction and produces a new point for an adjacent tile:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;move&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Direction&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d:left&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d:right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d:up&lt;/span&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d:down&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The next step is to define a type for our world state. The &lt;code&gt;big-bang&lt;/code&gt; library operates using a game loop, with a function to update the state that’s called each “tick”. Our state will need to hold all the information about our game, which in this case, is just three things:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;World-State&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt;
                   &lt;span class="n"&gt;Direction&lt;/span&gt;    &lt;span class="c1"&gt;; snake direction&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; snake blocks&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; food blocks&lt;/span&gt;
                   &lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It will also be useful to have a functional setter for the direction, which we’ll have to write ourselves, since Hackett does not (currently) have anything like Haskell’s record syntax:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Next, we’ll write some top-level constants that we’ll use in our rendering function, such as the number of tiles in the game board, the size of each tile in pixels, and some simple picts that represent the tiles we’ll use to draw our game:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;board-width&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;board-height&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;d*&lt;/span&gt; &lt;span class="mf"&gt;15.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;integer-&amp;gt;double&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;empty-board&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;blank-rect&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="n"&gt;board-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="n"&gt;board-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filled-square&lt;/span&gt; &lt;span class="mf"&gt;13.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;food-block&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;snake-block&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;black&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we can write our actual &lt;code&gt;render&lt;/code&gt; function. To do this, we simply need to render each &lt;code&gt;Point&lt;/code&gt; in our &lt;code&gt;World-State&lt;/code&gt;’s two lists as a block on an &lt;code&gt;empty-board&lt;/code&gt;. We’ll write a helper function, &lt;code&gt;render-on-board&lt;/code&gt;, which does exactly that:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;render-on-board&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Pict&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;pict&lt;/span&gt; &lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;foldr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pin-over&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pict&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="n"&gt;empty-board&lt;/span&gt; &lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This function uses &lt;code&gt;foldr&lt;/code&gt; to collect each point and place the provided pict at the right location using &lt;code&gt;pin-over&lt;/code&gt; on an empty board. Using &lt;code&gt;render-on-board&lt;/code&gt;, we can write the &lt;code&gt;render&lt;/code&gt; function in just a couple of lines:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;render&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;World-State&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pin-over&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;render-on-board&lt;/span&gt; &lt;span class="n"&gt;snake-block&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;render-on-board&lt;/span&gt; &lt;span class="n"&gt;food-block&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Next, we’ll need to handle the update logic. On each tick, the snake should advance by a single tile in the direction it’s currently moving. If it runs into a food tile, it should grow one tile larger, and we need to generate a new food tile elsewhere on the board. To help with that last part, the &lt;code&gt;big-bang&lt;/code&gt; library provides a &lt;code&gt;random-integer&lt;/code&gt; function, which we can use to write a &lt;code&gt;random-point&lt;/code&gt; action:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;random-point&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;random-integer&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;board-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;random-integer&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;board-height&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Hackett supports applicative notation using infix operators, so &lt;code&gt;random-point&lt;/code&gt; looks remarkably readable. It also runs in &lt;code&gt;IO&lt;/code&gt;, since the result is, obviously, random. Fortunately, the &lt;code&gt;on-tick&lt;/code&gt; function runs in &lt;code&gt;IO&lt;/code&gt; as well (unlike &lt;code&gt;render&lt;/code&gt;, which must be completely pure), so we can use &lt;code&gt;random-point&lt;/code&gt; when necessary to generate a new food block:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;init!&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;tail!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nb"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;on-tick&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;World-State&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;World-State&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head!&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="n"&gt;elem?&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;new-food-point&lt;/span&gt; &lt;span class="n"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;random-point&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                                &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;new-food-point&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;)})))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init!&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                            &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;))))])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This function is the most complicated one in the whole program, but it’s still not terribly complex. It figures out what the snake’s next location is and binds it to &lt;code&gt;new-snake-point&lt;/code&gt;, then checks if there is a food block at that location. If there is, it generates a &lt;code&gt;new-food-point&lt;/code&gt;, then puts it in the new world state. Otherwise, it removes the last snake point and continues as usual.&lt;/p&gt;

&lt;p&gt;The game is already almost completely written. The next step is just to handle key events, which are obviously important for allowing the player to control the snake. Fortunately, this is easy, since we can just use our &lt;code&gt;set-ws-direction&lt;/code&gt; function that we wrote earlier:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;on-key&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;KeyEvent&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;World-State&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;World-State&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ke:left&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="n"&gt;d:left&lt;/span&gt;&lt;span class="p"&gt;)}]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ke:right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="n"&gt;d:right&lt;/span&gt;&lt;span class="p"&gt;)}]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ke:up&lt;/span&gt;   &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="n"&gt;d:up&lt;/span&gt;&lt;span class="p"&gt;)}]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ke:down&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="n"&gt;d:down&lt;/span&gt;&lt;span class="p"&gt;)}]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;       &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;}])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;on-key&lt;/code&gt; function runs in &lt;code&gt;IO&lt;/code&gt;, but we don’t actually need that power, since all of our keypress update logic is completely pure, so we just wrap everything in &lt;code&gt;pure&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We’re almost done now—all we need to do is set up the &lt;em&gt;initial&lt;/em&gt; state when the game begins. We’ll write a small binding that creates a world state with the snake in the middle of the board and some random food locations scattered about:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;initial-state&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;initial-food&lt;/span&gt; &lt;span class="n"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequence&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="n"&gt;random-point&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;d:right&lt;/span&gt;
                         &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="n"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                         &lt;span class="n"&gt;initial-food&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Notably, we can use the &lt;code&gt;repeat&lt;/code&gt; function to create an infinite list of &lt;code&gt;random-point&lt;/code&gt; actions, &lt;code&gt;take&lt;/code&gt; the first five of them, then call &lt;code&gt;sequence&lt;/code&gt; to execute them from left to right. Now, all we have to do is put the pieces together in a &lt;code&gt;main&lt;/code&gt; block:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="n"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;initial-state&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;big-bang&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;
            &lt;span class="kd"&gt;#:to-draw&lt;/span&gt; &lt;span class="n"&gt;render&lt;/span&gt;
            &lt;span class="kd"&gt;#:on-tick&lt;/span&gt; &lt;span class="n"&gt;on-tick&lt;/span&gt; &lt;span class="mf"&gt;0.2&lt;/span&gt;
            &lt;span class="kd"&gt;#:on-key&lt;/span&gt; &lt;span class="n"&gt;on-key&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And that’s it! We haven’t implemented any win or loss conditions, but the basics are all there. In 80 lines of code, we’ve implemented a working snake game in Hackett.&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="/img/hackett-snake-animation.gif" alt="" /&gt;
 &lt;p class="caption"&gt;&lt;/p&gt;&lt;/div&gt;

&lt;h1 id="contributing-to-hackett"&gt;Contributing to Hackett&lt;/h1&gt;

&lt;p&gt;If you are excited enough about Hackett to be interested in contributing, your first question is very likely “What can I do?” or “Where do I start?” My answer to that is (perhaps a little unhelpfully): it depends! My general recommendation is to try and write something with Hackett, and if you run into anything that prevents you from accomplishing your goal, look into what would need to be changed to support your program. Having a use case is a great way to come up with useful improvements.&lt;/p&gt;

&lt;p&gt;On the other hand, you might not have anything in mind, or you might find Hackett’s scope a little too overwhelming to just jump right in and start contributing. Fortunately, &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;Hackett has an issue tracker&lt;/a&gt;, so feel free to take a look and pick something that looks interesting and achievable. Alternatively, the standard library can always use fleshing out, and quite a lot of that can be written without ever even touching the scary Hackett internals.&lt;/p&gt;

&lt;p&gt;Additionally, if you have any questions, please don’t hesitate to ask them! If you have a question about the codebase, get stuck implementing something, or just don’t know where to start, feel free to &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;open an issue on GitHub&lt;/a&gt;, send me a message on the &lt;code&gt;#racket&lt;/code&gt; IRC channel on Freenode, or ping me on &lt;a href="http://racket-slack.herokuapp.com"&gt;the Racket Slack team&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id="acknowledgements"&gt;Acknowledgements&lt;/h1&gt;

&lt;p&gt;Speaking of contributors, I’m excited to say that this is the first time I can truly say Hackett includes code written by someone other than me! I want to call attention to &lt;a href="https://github.com/gelisam"&gt;Samuel Gélineau, aka gelisam&lt;/a&gt;, who is officially the second contributor to Hackett. He helped to implement the new approach the Hackett REPL uses for printing expressions, which ended up being quite useful when implementing some of the other REPL improvements.&lt;/p&gt;

&lt;p&gt;Additionally, I want to specially thank &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, &lt;a href="http://eecs.northwestern.edu/~robby/"&gt;Robby Findler&lt;/a&gt;, and &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt; for being especially responsive and helpful to my many questions about Scribble and the Racket top level. Racket continues to be extremely impressive, both as a project and as a community.&lt;/p&gt;

&lt;p&gt;Finally, many thanks to the various people who have expressed interest in the project and continue to push me and ask questions. Working on Hackett is a lot of work—both time and effort—and it’s your continued enthusiasm that inspires me to put in the hours.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">User-programmable infix operators in Racket</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2017/08/12/user-programmable-infix-operators-in-racket/?utm_source=hackett&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2017-08-12-user-programmable-infix-operators-in-racket</id>
  <published>2017-08-12T16:26:05Z</published>
  <updated>2017-08-12T16:26:05Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;Lisps are not known for infix operators, quite the opposite; infix operators generally involve more syntax and parsing than Lispers are keen to support. However, in &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Hackett&lt;/a&gt;, all functions are curried, and variable-arity functions do not exist. Infix operators are almost necessary for that to be palatable, and though there are other reasons to want them, it may not be obvious how to support them without making the reader considerably more complex.&lt;/p&gt;

&lt;p&gt;Fortunately, if we require users to syntactically specify where they wish to use infix expressions, support for infix operators is not only possible, but can support be done &lt;em&gt;without&lt;/em&gt; modifying the stock &lt;code&gt;#lang racket&lt;/code&gt; reader. Futhermore, the resulting technique makes it possible for fixity information to be specified locally in a way that cooperates nicely with the Racket macro system, allowing the parsing of infix expressions to be manipulated at compile-time by users’ macros.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="our-mission"&gt;Our mission&lt;/h1&gt;

&lt;p&gt;Before we embark, let’s clarify our goal. We want to support infix operators in Racket, of course, but that could mean a lot of different things! Let’s start with what we &lt;em&gt;do&lt;/em&gt; want:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Infix operators should be user-extensible, not limited to a special set of built-in operators.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Furthermore, operators’ names should not be restricted to a separate “operator” character set. Any valid Lisp identifier should be usable as an infix operator.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;We want to be able to support fixity/associativity annotations. Some operators should associate to the left, like subtraction, but others should associate to the right, like &lt;code&gt;cons&lt;/code&gt;. This allows &lt;code&gt;5 - 1 - 2&lt;/code&gt; to be parsed as &lt;code&gt;(- (- 5 1) 2)&lt;/code&gt;, but &lt;code&gt;5 :: 1 :: nil&lt;/code&gt; to be parsed as &lt;code&gt;(:: 5 (:: 1 nil))&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;These are nice goals, but we also won’t be too ambitious. In order to keep things simple and achievable, we’ll keep the following restrictions:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;We will &lt;strong&gt;not&lt;/strong&gt; permit infix expressions in arbitrary locations, since that would be impossible to parse given how we want to allow users to pick any names for operators they wish. Instead, infix expressions must be wrapped in curly braces, e.g. replacing &lt;code&gt;(+ 1 2)&lt;/code&gt; with &lt;code&gt;{1 + 2}&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Our implementation will &lt;strong&gt;not&lt;/strong&gt; support any notion of operator precedence; all operators will have equal precedence, and it will be illegal to mix operators of different associativity in the same expression. Precedence is entirely possible to implement in theory, but it would be considerably more work, so this blog post does not include it.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All operators will be binary, and we will &lt;strong&gt;not&lt;/strong&gt; support unary or mixfix operators. My intuition is that this technique should be able to be generalized to both of those things, but it would be considerably more complicated.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;With those points in mind, what would the interface for our infix operator library look like for our users? Ideally, something like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-in&lt;/span&gt; &lt;span class="n"&gt;racket/base/&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="s2"&gt;"infix.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;racket/base/-&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; &amp;#39;(1 7)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Let’s get started.&lt;/p&gt;

&lt;h1 id="implementing-infix-operators"&gt;Implementing infix operators&lt;/h1&gt;

&lt;p&gt;Now that we know what we want, how do we get there? Well, there are a few pieces to this puzzle. We’ll need to solve a two main problems:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;How do we “hook into” expressions wrapped with curly braces so that we can perform a desugaring pass?&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;How can we associate fixity information with certain operators?&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;We’ll start by tackling the first problem, since its solution will inform the answer to the second. Since we won’t have any fixity information to start with, we’ll just assume that all operators associate left by default.&lt;/p&gt;

&lt;p&gt;So, how &lt;em&gt;do&lt;/em&gt; we detect if a Racket expression is surrounded by curly braces? Normally, in &lt;code&gt;#lang racket&lt;/code&gt;, parentheses, square brackets, and curly braces are all interchangeable. Indeed, if you use curly braces in the REPL, you will find that they are treated &lt;em&gt;exactly&lt;/em&gt; the same as parentheses:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If they are treated identically, giving them special behavior might seem hopeless, but don’t despair! Racket is no ordinary programming language, and it provides some tools to help us out here.&lt;/p&gt;

&lt;p&gt;Someone who has worked with Lisps before is likely already aware that Lisp source code is a very direct representation of its AST, composed mostly of lists, pairs, symbols, numbers, and strings. In Racket, this is also true, but Racket also wraps these datums in boxes known as &lt;a href="http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29"&gt;&lt;em&gt;syntax objects&lt;/em&gt;&lt;/a&gt;. Syntax objects contain extra metadata about the code, most notably its lexical context, necessary for Racket’s hygiene system. However, syntax objects can also contain arbitrary metadata, known as &lt;a href="http://docs.racket-lang.org/reference/stxprops.html#%28tech._syntax._property%29"&gt;&lt;em&gt;syntax properties&lt;/em&gt;&lt;/a&gt;. Macros can attach arbitrary values to the syntax objects they produce using syntax properties, and other macros can inspect them. Racket’s &lt;a href="http://docs.racket-lang.org/guide/Pairs__Lists__and_Racket_Syntax.html#%28tech._reader%29"&gt;&lt;em&gt;reader&lt;/em&gt;&lt;/a&gt; (the syntax parser that turns program text into Racket syntax objects) also attaches certain syntax properties as part of its parsing process. One of those is named &lt;a href="http://docs.racket-lang.org/reference/reader.html#%28idx._%28gentag._30._%28lib._scribblings%2Freference%2Freference..scrbl%29%29%29"&gt;&lt;code&gt;'paren-shape&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This syntax property, as the name implies, keeps track of the shape of parentheses in syntax objects. You can see that for yourself by inspecting the property’s value for different syntax objects in the REPL:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="no"&gt;#f&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="sc"&gt;#\[&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="sc"&gt;#\{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This syntax property gives us the capability to distinguish between syntax objects that use curly braces and those that don’t, which is a step in the right direction, but it still doesn’t give us any hook with which we can change the behavior of certain expressions. Fortunately, there’s something else that can.&lt;/p&gt;

&lt;h2 id="customizing-application"&gt;Customizing application&lt;/h2&gt;

&lt;p&gt;Racket is a language &lt;em&gt;designed&lt;/em&gt; to be extended, and it provides a variety of hooks in the language for the purposes of tweaking pieces in minor ways. One such hook is named &lt;a href="http://docs.racket-lang.org/reference/application.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~23~25app%29%29"&gt;&lt;code&gt;#%app&lt;/code&gt;&lt;/a&gt;, which is automatically introduced by the macroexpander whenever it encounters a function application. That means it effectively turns this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…into this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;What’s special about &lt;code&gt;#%app&lt;/code&gt; is that the macroexpander will use whichever &lt;code&gt;#%app&lt;/code&gt; is in scope in the expression’s lexical context, so if we write our own version of &lt;code&gt;#%app&lt;/code&gt;, it will be used instead of the one from &lt;code&gt;#lang racket&lt;/code&gt;. This is what we will use to hook into ordinary Racket expressions.&lt;/p&gt;

&lt;p&gt;To write our custom version of &lt;code&gt;#%app&lt;/code&gt;, we will use the usual tool: Racket’s industrial-strength macro-authoring DSL, &lt;a href="http://docs.racket-lang.org/syntax/stxparse.html"&gt;&lt;code&gt;syntax/parse&lt;/code&gt;&lt;/a&gt;. We’ll also use a helper library that provides some tools for pattern-matching on syntax objects with the &lt;code&gt;'paren-shape&lt;/code&gt; syntax property, &lt;a href="http://docs.racket-lang.org/syntax-classes/index.html#%28mod-path._syntax%2Fparse%2Fclass%2Fparen-shape%29"&gt;&lt;code&gt;syntax/parse/class/paren-shape&lt;/code&gt;&lt;/a&gt;. Using these, we can transform expressions that are surrounded in curly braces differently from how we would transform expressions surrounded by parentheses:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/class/paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-in&lt;/span&gt; &lt;span class="n"&gt;racket/base/&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="k"&gt;#%app&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~braces&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This code will transform any applications surrounded in curly braces into one that starts with &lt;code&gt;#%infix&lt;/code&gt; instead of &lt;code&gt;#%app&lt;/code&gt;, so &lt;code&gt;{1 + 2}&lt;/code&gt; will become &lt;code&gt;(#%infix 1 + 2)&lt;/code&gt;, for example. The identifier &lt;code&gt;#%infix&lt;/code&gt; isn’t actually special in any way, it just has a funny name, but we haven’t actually defined &lt;code&gt;#%infix&lt;/code&gt; yet, so we need to do that next!&lt;/p&gt;

&lt;p&gt;To start, we’ll just handle the simplest case: infix expressions with precisely three subexpressions, like &lt;code&gt;{1 + 2}&lt;/code&gt;, should be converted into the equivalent prefix expressions, in this case &lt;code&gt;(+ 1 2)&lt;/code&gt;. We can do this with a simple macro:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Due to the way Racket propagates syntax properties, we explicitly indicate that the resulting expansion should use the &lt;code&gt;#%app&lt;/code&gt; from &lt;code&gt;racket/base&lt;/code&gt;, which will avoid any accidental infinite recursion between our &lt;code&gt;#%app&lt;/code&gt; and &lt;code&gt;#%infix&lt;/code&gt;. With this in place, we can now try our code out in the REPL, and believe it or not, we now support infix expressions with just those few lines of code:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;That’s pretty cool!&lt;/p&gt;

&lt;p&gt;Of course, we probably want to support infix applications with more than just a single binary operator, such as &lt;code&gt;{1 + 2 + 3}&lt;/code&gt;. We can implement that just by adding another case to &lt;code&gt;#%infix&lt;/code&gt; that handles more subforms:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…and now, just by adding those two lines, we support arbitrarily-large sequences of infix operators:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;I don’t know about you, but I think being able to do this in less than 20 lines of code is pretty awesome. We can even mix different operators in the same expression:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Of course, all of our infix expressions currently assume that all operators associate left, as was our plan. In general, though, there are lots of useful operators that associate right, such as &lt;code&gt;cons&lt;/code&gt;, nested &lt;code&gt;-&amp;gt;&lt;/code&gt; types or contracts for curried functions, and &lt;code&gt;expt&lt;/code&gt;, the exponentiation operator.&lt;/p&gt;

&lt;h2 id="tracking-operator-fixity"&gt;Tracking operator fixity&lt;/h2&gt;

&lt;p&gt;Clearly, we need some way to associate operator fixity with certain identifiers, and we need to be able to do it at compile-time. Fortunately, Racket has a very robust mechanism for creating compile-time values. Unfortunately, simply associating metadata with an identifier is a little less convenient than it could be, but there is a general technique that can be done with little boilerplate.&lt;/p&gt;

&lt;p&gt;Essentially, Racket (like Scheme) uses a &lt;code&gt;define-syntax&lt;/code&gt; form to define macros, which is what &lt;code&gt;define-syntax-parser&lt;/code&gt; eventually expands into. However, unlike Scheme, Racket’s &lt;code&gt;define-syntax&lt;/code&gt; is not &lt;em&gt;just&lt;/em&gt; for defining macros—it’s for defining arbitrary bindings with compile-time (aka “phase 1”) values. Using this, we can define bindings that have entirely arbitrary values at compile-time, including plain data like numbers or strings:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Once a binding has been defined using &lt;code&gt;define-syntax&lt;/code&gt;, a macro can look up the value associated with it by using the &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-value%29%29"&gt;&lt;code&gt;syntax-local-value&lt;/code&gt;&lt;/a&gt; function, which returns the compile-time value associated with an identifier:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The cool thing is that &lt;code&gt;syntax-local-value&lt;/code&gt; gets the value associated with a specific &lt;em&gt;binding&lt;/em&gt;, not a specific name. This means a macro can look up the compile-time value associated with an identifier provided to it as a subform. This is close to what we want, since we could use &lt;code&gt;syntax-local-value&lt;/code&gt; to look up something associated with our infix operator bindings, but the trouble is that they would then cease to be usable as ordinary functions. For example, if you try and use the &lt;code&gt;foo&lt;/code&gt; binding from the above example as an expression, Racket will complain about an “illegal use of syntax”, which makes sense, because &lt;code&gt;foo&lt;/code&gt; is not bound to anything at runtime.&lt;/p&gt;

&lt;p&gt;To solve this problem, we can use something of a trick: any compile-time binding that happens to have a procedure as its value will be treated like a macro—that is, using it as an expression will cause the macroexpander to invoke the procedure with a syntax object representing the macro invocation, and the procedure is expected to produce a new syntax object as output. Additionally, Racket programmers can make custom datatypes valid procedures by using the &lt;a href="http://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29"&gt;&lt;code&gt;prop:procedure&lt;/code&gt;&lt;/a&gt; structure type property.&lt;/p&gt;

&lt;p&gt;If you are not familiar with the Racket macro system, this probably sounds rather complicated, but in practice, it’s not as confusing as it might seem. The trick here is to create a custom structure type at compile-time that we can use to track operator fixity alongside its runtime binding:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/transformer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runtime-binding&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:property&lt;/span&gt; &lt;span class="nb"&gt;prop:procedure&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;set!-transformer-procedure&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-runtime-binding&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is quite the magical incantation, and all the details of what is going on here are outside the scope of this blog post. Essentially, though, we can use values of this structure as a compile-time binding that will act just like the identifier provided for &lt;code&gt;runtime-binding&lt;/code&gt;, but we can also include a value of our choosing for &lt;code&gt;fixity&lt;/code&gt;. Here’s an example:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;right&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This new &lt;code&gt;::&lt;/code&gt; binding will act, in every way, just like &lt;code&gt;cons&lt;/code&gt;. If we use it in the REPL, you can see that it acts exactly the same:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, we can also use &lt;code&gt;syntax-local-value&lt;/code&gt; to extract this binding’s fixity at compile-time, and that’s what makes it interesting:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;::&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; &amp;#39;right&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Using this extra compile-time information, we can adjust our &lt;code&gt;#%infix&lt;/code&gt; macro to inspect bindings and determine their fixity, then use that to make decisions about parsing. Just like we used &lt;code&gt;syntax/parse/class/paren-shape&lt;/code&gt; to make decisions based on the &lt;code&gt;'paren-shape&lt;/code&gt; syntax property, we can use &lt;a href="http://docs.racket-lang.org/syntax-classes/index.html#%28mod-path._syntax%2Fparse%2Fclass%2Flocal-value%29"&gt;&lt;code&gt;syntax/parse/class/local-value&lt;/code&gt;&lt;/a&gt; to pattern-match on bindings with a particular compile-time value. We’ll wrap this in a syntax class of our own to make the code easier to read:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;infix-op&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"infix operator"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-value&lt;/span&gt; &lt;span class="n"&gt;infix-operator?&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.local-value&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now, we can update &lt;code&gt;#%infix&lt;/code&gt; to use our new &lt;code&gt;infix-op&lt;/code&gt; syntax class:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Notably, we now require all operators to be bound to compile-time infix operator values, and we include two conditions via &lt;code&gt;#:when&lt;/code&gt; clauses. These clauses check to ensure that the operator in question has the expected fixity before committing to that clause; if the condition fails, then parsing backtracks. Using this new definition of &lt;code&gt;#%infix&lt;/code&gt;, we can successfully use &lt;code&gt;::&lt;/code&gt; in an infix expression, and it will be parsed with the associativity that we expect:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Exciting!&lt;/p&gt;

&lt;h2 id="a-nicer-interface-for-defining-infix-operators"&gt;A nicer interface for defining infix operators&lt;/h2&gt;

&lt;p&gt;We currently have to define infix operators by explicitly using &lt;code&gt;define-syntax&lt;/code&gt;, but this is not a very good interface. Users of infix syntax probably don’t want to have to understand the internal workings of the infix operator implementation, so we just need to define one final macro to consider this done: the &lt;code&gt;define-infix-operator&lt;/code&gt; form from the example at the very beginning of this blog post.&lt;/p&gt;

&lt;p&gt;Fortunately, this macro is absolutely trivial to write. In fact, we can do it in a mere three lines of code, since it’s very minor sugar over the &lt;code&gt;define-syntax&lt;/code&gt; definitions we were already writing:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;op:id&lt;/span&gt; &lt;span class="n"&gt;value:id&lt;/span&gt;
                       &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;}}})&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With this in hand, we can define some infix operators with a much nicer syntax:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;racket/base/+&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;racket/base/-&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;racket/base/*&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="n"&gt;racket/base//&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="nb"&gt;expt&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With these simple definitions, we can write some very nice mathematical expressions that use infix syntax, in ordinary &lt;code&gt;#lang racket&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;-1&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;256&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And you know what’s most amazing about this? The entire thing is &lt;strong&gt;only 50 lines of code&lt;/strong&gt;. Here is the entire implementation of infix operators from this blog post in a single code block, with absolutely nothing hidden or omitted:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/class/local-value&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/parse/class/paren-shape&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/transformer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-in&lt;/span&gt; &lt;span class="n"&gt;racket/base/&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runtime-binding&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:property&lt;/span&gt; &lt;span class="nb"&gt;prop:procedure&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;set!-transformer-procedure&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-runtime-binding&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;infix-op&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"infix operator"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-value&lt;/span&gt; &lt;span class="n"&gt;infix-operator?&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.local-value&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="k"&gt;#%app&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~braces&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;op:id&lt;/span&gt; &lt;span class="n"&gt;value:id&lt;/span&gt;
                       &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;}}})&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;racket/base/+&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;racket/base/-&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;racket/base/*&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="n"&gt;racket/base//&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="nb"&gt;expt&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Racket is a hell of a programming language.&lt;/p&gt;

&lt;h1 id="applications-limitations-and-implications"&gt;Applications, limitations, and implications&lt;/h1&gt;

&lt;p&gt;This blog post has outlined a complete, useful model for infix operators, and it is now hopefully clear how they work, but many of the most interesting properties of this implementation are probably not obvious. As far as I can make out, this embedding of infix operators into a macro system is novel, and I am &lt;em&gt;almost certain&lt;/em&gt; that the way this implementation tracks fixity information is unique. One of the most interesting capabilities gained from this choice of implementation is the ability for macros to define infix operators and control their fixity, even &lt;em&gt;locally&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What does this mean? Well, remember that infix operators are just special syntax bindings. Racket includes a variety of forms for binding or adjusting macros locally, such as &lt;code&gt;let-syntax&lt;/code&gt; and &lt;code&gt;syntax-parameterize&lt;/code&gt;. Using these tools, it would be entirely possible to implement a &lt;code&gt;with-fixity&lt;/code&gt; macro, that could adjust the fixity of an operator within a syntactic block. This could be used, for example, to make &lt;code&gt;/&lt;/code&gt; right associative within a block of code:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;1/6&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;with-fixity&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="m"&gt;1/2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In fact, this macro is hardly theoretical, since it could be implemented in a trivial 7 lines, simply expanding to uses of &lt;code&gt;splicing-let&lt;/code&gt; and &lt;code&gt;splicing-let-syntax&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;with-fixity&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;op:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;}}}]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;op-tmp&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;generate-temporaries&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;splicing-let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;op-tmp&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;splicing-let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;op-tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is not especially useful given the current set of infix operator features, but it’s easy to imagine how useful it could be in a system that also supported a notion of precedence. It is not entirely uncommon to encounter certain expressions that could be more cleanly expressed with a local set of operator precedence rules, perhaps described as a set of relations &lt;em&gt;between&lt;/em&gt; operators rather than a global table of magic precedence numbers. With traditional approaches to infix operators, parsing such code would be difficult without a very rigid syntactic structure, but this technique makes it easy.&lt;/p&gt;

&lt;p&gt;As mentioned at the beginning of this blog post, this technique is also not merely a novelty—as of now, I am actively using this in &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Hackett&lt;/a&gt; to support infix operators with all of the features outlined here. The Hackett implementation is a little bit fancier than the one in this blog post, since it works harder to produce better error messages. It explicitly disallows mixing left associative and right associative operators in the same expression, so it does some additional validation as part of expansion, and it arranges for source location information to be copied onto the result. It also make a different design decision to allow &lt;em&gt;any&lt;/em&gt; expression to serve as an infix operator, assuming left associativity if no fixity annotation is available.&lt;/p&gt;

&lt;p&gt;If you’re interested in the code behind the additional steps Hackett takes to make infix operators more usable and complete, take a look at &lt;a href="https://github.com/lexi-lambda/hackett/blob/0d177d00a9ee96f30dd76761f1cb86f15830779f/hackett-lib/hackett/private/infix.rkt"&gt;this file for the definition of infix bindings&lt;/a&gt;, as well as &lt;a href="https://github.com/lexi-lambda/hackett/blob/0d177d00a9ee96f30dd76761f1cb86f15830779f/hackett-lib/hackett/private/kernel.rkt#L80-L101"&gt;this file for the defintion of infix application&lt;/a&gt;. My hope is to eventually add support for some sort of precedence information, though who knows—maybe infix operators will be easier to reason about if the rules are kept extremely simple. I am also considering adding support for so-called “operator sections” at some point, which would allow things like &lt;code&gt;{_ - 1}&lt;/code&gt; to serve as a shorthand for &lt;code&gt;(lambda [x] {x - 1})&lt;/code&gt;, but I haven’t yet decided if I like the tradeoffs involved.&lt;/p&gt;

&lt;p&gt;It’s possible that this implementation of infix operators might also be useful in languages in the Racket ecosystem besides Hackett. However, I’m not sure it makes a ton of sense in &lt;code&gt;#lang racket&lt;/code&gt; without modifications, as variadic functions subsume many of the cases where infix operators are needed in Haskell. If there is a clamoring for this capability, I would be happy to consider extracting the functionality into a library, but as of right now, I don’t have any plans to do so.&lt;/p&gt;

&lt;p&gt;Finally, the main point of this blog post is to showcase how easy it is to do things in Racket that would be impossible in most languages and difficult even in most Lisps. It also helps to show off how Hackett is already benefitting from those capabilities: while this particular feature is built-in to &lt;code&gt;#lang hackett&lt;/code&gt;, there’s no reason something similar but more powerful couldn’t be built as a separate library by a &lt;em&gt;user&lt;/em&gt; of Hackett. Even as Hackett’s author, I think that’s exciting, since makes it possible for users to experiment with improvements to the language on their own. Some of those improvements may eventually be rolled into the core language or standard library, but many of them can likely live effectively in separate libraries, accessible on-demand to those who need them. After all, that’s one of Racket’s most important promises—languages as libraries—and it’s why Hackett is a part of the Racket ecosystem.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Realizing Hackett, a metaprogrammable Haskell</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/?utm_source=hackett&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2017-05-27-realizing-hackett-a-metaprogrammable-haskell</id>
  <published>2017-05-27T15:30:00Z</published>
  <updated>2017-05-27T15:30:00Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;&lt;a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"&gt;Almost five months ago, I wrote a blog post about my new programming language, Hackett&lt;/a&gt;, a fanciful sketch of a programming language from a far-off land with Haskell’s type system and Racket’s macros. At that point in time, I had a little prototype that barely worked, that I barely understood, and was a little bit of a technical dead-end. People saw the post, they got excited, but development sort of stopped.&lt;/p&gt;

&lt;p&gt;Then, almost two months ago, I took a second stab at the problem in earnest. I read a lot, I asked a lot of people for help, and eventually I got something sort of working. Suddenly, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Hackett is not only real, it’s working, and you can try it out yourself&lt;/a&gt;!&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="a-first-look-at-hackett"&gt;A first look at Hackett&lt;/h1&gt;

&lt;p&gt;Hackett is still very new, very experimental, and an enormous work in progress. However, that doesn’t mean it’s useless! Hackett is already a remarkably capable programming language. Let’s take a quick tour.&lt;/p&gt;

&lt;p&gt;As Racket law decrees it, every Hackett program must begin with &lt;code&gt;#lang&lt;/code&gt;. We can start with the appropriate incantation:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If you’re using DrRacket or racket-mode with background expansion enabled, then congratulations: the typechecker is online. We can begin by writing a well-typed, albeit boring program:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="s2"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In Hackett, a use of &lt;code&gt;main&lt;/code&gt; at the top level indicates that running the module as a program should execute some &lt;code&gt;IO&lt;/code&gt; action. In this case, &lt;code&gt;println&lt;/code&gt; is a function of type &lt;code&gt;{String -&amp;gt; (IO Unit)}&lt;/code&gt;. Just like Haskell, Hackett is pure, and the runtime will figure out how to actually run an &lt;code&gt;IO&lt;/code&gt; value. If you run the above program, you will notice that it really does print out &lt;code&gt;Hello, world!&lt;/code&gt;, exactly as we would like.&lt;/p&gt;

&lt;p&gt;Of course, hello world programs are boring—so imperative! We are functional programmers, and we have our &lt;em&gt;own&lt;/em&gt; class of equally boring programs we must write when learning a new language. How about some Fibonacci numbers?&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zip-with&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail!&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;))})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Again, Hackett is just like Haskell in that it is &lt;em&gt;lazy&lt;/em&gt;, so we can construct an infinite list of Fibonacci numbers, and the runtime will happily do nothing at all. When we call &lt;code&gt;take&lt;/code&gt;, we realize the first ten numbers in the list, and when you run the program, you should see them printed out, clear as day!&lt;/p&gt;

&lt;p&gt;But these programs are boring. Printing strings and laziness may have been novel when you first learned about them, but if you’re reading this blog post, my bet is that you probably &lt;em&gt;aren’t&lt;/em&gt; new to programming. How about something more interesting, &lt;strong&gt;like a web server&lt;/strong&gt;?&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;hackett/demo/web-server&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Greeting&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greeting&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;-&amp;gt;Body&lt;/span&gt; &lt;span class="n"&gt;Greeting&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;-&amp;gt;body&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;greeting&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;"Hello, "&lt;/span&gt; &lt;span class="n"&gt;++&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;++&lt;/span&gt; &lt;span class="s2"&gt;"!"&lt;/span&gt;&lt;span class="p"&gt;})])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defserver&lt;/span&gt; &lt;span class="n"&gt;run-server&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GET&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;               &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;   &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s2"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GET&lt;/span&gt; &lt;span class="s2"&gt;"greet"&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Greeting&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="s2"&gt;"Running server on port 8080."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;run-server&lt;/span&gt; &lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;br /&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ racket my-server.rkt
Running server on port &lt;span class="m"&gt;8080&lt;/span&gt;.
^Z
$ &lt;span class="nb"&gt;bg&lt;/span&gt;
$ curl &lt;span class="s1"&gt;&amp;#39;http://localhost:8080/greet/Alexis&amp;#39;&lt;/span&gt;
Hello, Alexis!
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Welcome to Hackett.&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id="what-is-hackett"&gt;What is Hackett?&lt;/h1&gt;

&lt;p&gt;Excited yet? I hope so. I certainly am.&lt;/p&gt;

&lt;p&gt;Before you get a little &lt;em&gt;too&lt;/em&gt; excited, however, let me make a small disclaimer: the above program, while quite real, is a demo. It is certainly not a production web framework, and it actually just uses the Racket web server under the hood. It does not handle very many things right now. You cannot use it to build your super awesome webapp, and even if you could, I would not recommend attempting to do so.&lt;/p&gt;

&lt;p&gt;All that said, it is a &lt;em&gt;real&lt;/em&gt; tech demo, and it shows off the potential for Hackett to do some pretty cool things. While the server implementation is just reusing Racket’s dynamically typed web server, the Hackett interface to it is 100% statically typed, and the above example shows off a host of features:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Algebraic datatypes.&lt;/strong&gt; Hackett has support for basic ADTs, including recursive datatypes (though not yet mutually recursive datatypes).&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Typeclasses.&lt;/strong&gt; The demo web server uses a &lt;code&gt;-&amp;gt;Body&lt;/code&gt; typeclass to render server responses, and this module implements a &lt;code&gt;-&amp;gt;Body&lt;/code&gt; instance for the custom &lt;code&gt;Greeting&lt;/code&gt; datatype.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Macros.&lt;/strong&gt; The &lt;code&gt;defserver&lt;/code&gt; macro provides a concise, readable, &lt;em&gt;type safe&lt;/em&gt; way to define a simple, RESTful web server. It defines two endpoints, a homepage and a greeting, and the latter parses a segment from the URL.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Static typechecking.&lt;/strong&gt; Obviously. If you try and change the homepage endpoint to produce a number instead of a string, you will get a type error! Alternatively, try removing the &lt;code&gt;-&amp;gt;Body&lt;/code&gt; instance and see what happens.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Infix operators.&lt;/strong&gt; In Hackett, &lt;code&gt;{&lt;/code&gt; curly braces &lt;code&gt;}&lt;/code&gt; enter &lt;em&gt;infix mode&lt;/em&gt;, which permits arbitrary infix operators. Most Lisps have variadic functions, so infix operators are not strictly necessary, but Hackett only supports curried, single-argument functions, so infix operators are some especially sweet sugar.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Pure, monadic I/O.&lt;/strong&gt; The &lt;code&gt;println&lt;/code&gt; and &lt;code&gt;run-server&lt;/code&gt; functions both produce &lt;code&gt;(IO Unit)&lt;/code&gt;, and &lt;code&gt;IO&lt;/code&gt; is a monad. &lt;code&gt;do&lt;/code&gt; notation is provided as a macro, and it works with any type that implements the &lt;code&gt;Monad&lt;/code&gt; typeclass.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;All these features are already implemented, and they really work! Of course, you might look at this list and be a little confused: sure, there are macros, but all these other things are firmly Haskellisms. If you thought that, you’d be quite right! &lt;strong&gt;Hackett is much closer to Haskell than Racket, even though it is syntactically a Lisp.&lt;/strong&gt; Keep this guiding principal in mind as you read this blog post or explore Hackett. Where Haskell and Racket conflict, Hackett usually prefers Haskell.&lt;/p&gt;

&lt;p&gt;For a bit more information about what Hackett is and what it aims to be, &lt;a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"&gt;check out my blog post from a few months ago&lt;/a&gt; from back when Hackett was called Rascal. I won’t reiterate everything I said there, but I do want to give a bit of a status update, explain what I’ve been working on, and hopefully give you some idea about where Hackett is going.&lt;/p&gt;

&lt;h1 id="the-story-so-far-and-getting-to-hackett-01"&gt;The story so far, and getting to Hackett 0.1&lt;/h1&gt;

&lt;p&gt;In September of 2016, I attended &lt;a href="http://con.racket-lang.org/2016/"&gt;(sixth RacketCon)&lt;/a&gt;, where I saw a &lt;a href="https://www.youtube.com/watch?v=j5Hauz6cewM"&gt;pretty incredible and extremely exciting talk&lt;/a&gt; about implementing type systems as macros. Finally, I could realize my dream of having an elegant Lisp with a safe, reliable macro system and a powerful, expressive type system! Unfortunately, reality ensued, and I remembered I didn’t actually know any type theory.&lt;/p&gt;

&lt;p&gt;Therefore, in October, I started to learn about type systems, and I began to read through Pierce’s Types and Programming Languages, then tried to learn the things I would need to understand Haskell’s type system. I learned about Hindley-Milner and basic typeclasses, and I tried to apply these things to the Type Systems as Macros approach. Throughout October, I hacked and I hacked, and by the end of the month, I stood back and admired my handiwork!&lt;/p&gt;

&lt;p&gt;…it &lt;em&gt;sort of&lt;/em&gt; worked?&lt;/p&gt;

&lt;p&gt;The trouble was that I found myself stuck. I wasn’t sure how to proceed. My language had bugs, programs sometimes did things I didn’t understand, the typechecker was clearly unsound, and there didn’t seem to be an obvious path forward. Other things in my life became distracting or difficult, and I didn’t have the energy to work on it anymore, so I stopped. I put Hackett (then Rascal) on the shelf for a couple months, only to finally return to it in late December.&lt;/p&gt;

&lt;p&gt;At the beginning of January, I decided it would be helpful to be public about what I was working on, so I wrote a blog post! Feedback was positive, overwhelmingly so, and while it was certainly encouraging, I suddenly felt nervous about expectations I had not realized I was setting. Could I really build this? Did I have the knowledge or the time? At that point, I didn’t really, so work stalled.&lt;/p&gt;

&lt;p&gt;Fortunately, in early April, some things started to become clear. I took another look at Hackett, and I knew I needed to reimplement it from the ground up. I also knew that I needed a different technique, but this time, I knew a bit more about where to find it. I got some help from &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt; and put together &lt;a href="https://gist.github.com/lexi-lambda/045ba782c8a0d915bd8abf97167d3bb5"&gt;an implementation of Pierce and Turner’s Local Type Inference&lt;/a&gt;. Unfortunately, it didn’t really provide the amount of type inference I was looking for, but fortunately, implementing it helped me figure out how to understand the rather more complicated (though very impressive) &lt;a href="http://www.cs.cmu.edu/~joshuad/papers/bidir/"&gt;Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism&lt;/a&gt;. After that, things just sort of started falling into place:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;First, I &lt;a href="https://github.com/lexi-lambda/higher-rank"&gt;implemented the Complete and Easy paper in Haskell&lt;/a&gt;, including building a little parser and interpreter. That helped me actually understand the paper, and Haskell really is a rather wonderful language for doing such a thing.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Three days later, I &lt;a href="https://github.com/lexi-lambda/racket-higher-rank"&gt;ported the Haskell implementation to Racket&lt;/a&gt;, using (and somewhat abusing) the Type Systems as Macros techniques. It wasn’t the prettiest, but it seemed to work, and that was rather encouraging.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;After that, however, I got a little stuck again, as I wasn’t sure how to generalize what I had. I was also incredibly busy with my day job, and I wasn’t able to really make progress for a few weeks. In early May, however, I decided to &lt;a href="https://twitter.com/lexi_lambda/status/865026650487967744"&gt;take a vacation&lt;/a&gt; for a week, and with some time to focus, I &lt;a href="https://github.com/lexi-lambda/higher-rank/tree/algebraic"&gt;souped up the Haskell implementation with products and sums&lt;/a&gt;. This was progress!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The &lt;em&gt;following day&lt;/em&gt; I managed to make &lt;a href="https://github.com/lexi-lambda/racket-higher-rank/tree/type-constructors"&gt;similar changes to the Racket implementation&lt;/a&gt;, but rather than add anonymous products and sums, I added arbitrary type constructors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;A couple days later and with more than a bit of help from &lt;a href="http://functorial.com"&gt;Phil Freeman&lt;/a&gt;, I &lt;a href="https://github.com/lexi-lambda/hackett/commit/1fd7fc905b93f68e39b9d01fedc4fb52aa44c4c4"&gt;rebranded the Racket implementation as Hackett, Mk II&lt;/a&gt;, and I started working towards turning it into a real programming language.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Less than three weeks later&lt;/em&gt;, and I have a programming language with everything from laziness and typeclasses to a tiny, proof-of-concept web server with &lt;a href="https://twitter.com/lexi_lambda/status/867617563206758400"&gt;editor support&lt;/a&gt;. The future of Hackett looks bright, and though there’s a &lt;em&gt;lot&lt;/em&gt; of work left before I will be even remotely satisfied with it, I am excited and reassured that it already seems to be bearing some fruit.&lt;/p&gt;

&lt;p&gt;So what’s left? Is Hackett ready for an initial release? Can you start writing programs in it today? Well, unfortunately, the answer is mostly &lt;strong&gt;no&lt;/strong&gt;, at least if you want those programs to be at all reliable in a day or two. If everything looks so cheery, though, what’s left? What is Hackett still missing?&lt;/p&gt;

&lt;h2 id="what-hackett-still-isnt"&gt;What Hackett still &lt;em&gt;isn’t&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;I have a laundry list of features I want for Hackett. I want GADTs, indexed type families, newtype deriving, and a compiler that can target multiple backends. These things, however, are not essential. You can probably imagine writing useful software without any of them. Before I can try to tackle those, I first need to tackle some of the bits of the foundation that simply don’t exist yet (or have at least been badly neglected).&lt;/p&gt;

&lt;p&gt;Fortunately, these things are not insurmountable, nor are they necessarily especially hard. They’re things like default class methods, static detection and prevention of orphan instances, exhaustiveness checking for pattern-matching, and a real kind system. That’s right—right now, Hackett’s type system is effectively dynamically typed, and even though you can write a higher-kinded type, there is no such thing as a “kind error”.&lt;/p&gt;

&lt;p&gt;Other things are simply necessary quality of life improvements before Hackett can become truly usable. Type errors are currently rather atrocious, though they could certainly be worse. Additionally, typechecking currently just halts whenever it encounters a type error, and it makes no attempt to generate more than one type error at a time. Derivation of simple instances like &lt;code&gt;Show&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; is important, and it will also likely pave the way for a more general form of typeclass deriving (since it can most certainly be implemented via macros), so it’s uncharted territory that still needs to be explored.&lt;/p&gt;

&lt;p&gt;Bits of plumbing are still exposed in places, whether it’s unexpected behavior when interoperating with Racket or errors sometimes reported in terms of internal forms. Local bindings are, if you can believe it, still entirely unimplemented, so &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;letrec&lt;/code&gt; need to be written up. The standard library needs fleshing out, and certain bits of code need to be cleaned up and slotted into the right place.&lt;/p&gt;

&lt;p&gt;Oh, and of course, &lt;strong&gt;the whole thing needs to be documented&lt;/strong&gt;. That in and of itself is probably a pretty significant project, especially since there’s a good chance I’ll want to figure out how to best make use of Scribble for a language that’s a little bit different from Racket.&lt;/p&gt;

&lt;p&gt;All in all, there’s a lot of work to be done! I am eager to make it happen, but I also work a full-time job, and I don’t have it in me to continue at the pace I’ve been working at for the past couple of weeks. Still, if you’re interested in the project, stay tuned and keep an eye on it—if all goes as planned, I hope to make it truly useful before too long.&lt;/p&gt;

&lt;h1 id="answering-some-questions"&gt;Answering some questions&lt;/h1&gt;

&lt;p&gt;It’s possible that this blog post does not seem like much; after all, it’s not terribly long. However, if you’re anything like me, there’s a good chance you are interested enough to have some questions! Obviously, I cannot anticipate all your questions and answer them here in advance, but I will try my best.&lt;/p&gt;

&lt;h2 id="can-i-try-hackett"&gt;Can I try Hackett?&lt;/h2&gt;

&lt;p&gt;Yes! With the caveat that it’s alpha software in every sense of the word: undocumented, not especially user friendly, and completely unstable. However, if you &lt;em&gt;do&lt;/em&gt; want to give it a try, it isn’t difficult: just install Racket, then run &lt;code&gt;raco pkg install hackett&lt;/code&gt;. Open DrRacket and write &lt;code&gt;#lang hackett&lt;/code&gt; at the top of the module, then start playing around.&lt;/p&gt;

&lt;p&gt;Also, note that the demo web server used in the example at the top of this blog post is &lt;em&gt;not&lt;/em&gt; included when you install the &lt;code&gt;hackett&lt;/code&gt; package. If you want to try that out, you’ll have to run &lt;code&gt;raco pkg install hackett-demo&lt;/code&gt; to install the demo package as well.&lt;/p&gt;

&lt;h2 id="are-there-any-examples-of-hackett-code"&gt;Are there any examples of Hackett code?&lt;/h2&gt;

&lt;p&gt;Unfortunately, not a lot right now, aside from the tiny examples in this blog post. However, if you are already familiar with Haskell, the syntax likely won’t be hard to pick up. Reading the Hackett source code is not especially recommended, given that it is filled with implementation details. However, if you are interested, reading the module where most of the prelude is defined isn’t so bad. You can &lt;a href="https://github.com/lexi-lambda/hackett/blob/6ceeac05e3d2a4b2dacd39163744baf239cf65a4/hackett-lib/hackett/private/prim/base.rkt"&gt;find it on GitHub here&lt;/a&gt;, or you can open the &lt;code&gt;hackett/private/prim/base&lt;/code&gt; module on a local installation.&lt;/p&gt;

&lt;h2 id="how-can-i-learn-more--ask-questions-about-hackett"&gt;How can I learn more / ask questions about Hackett?&lt;/h2&gt;

&lt;p&gt;Feel free to ping me and ask me questions! I may not always be able to get back to you immediately, but if you hang around, I will eventually send you a response. The best ways to contact me are via the #racket IRC channel on Freenode, the snek Slack community (&lt;a href="http://snek.jneen.net"&gt;which you can sign up for here&lt;/a&gt;), sending me &lt;a href="https://twitter.com/lexi_lambda"&gt;a DM on Twitter&lt;/a&gt;, opening &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;an issue on the GitHub repo&lt;/a&gt;, or even just &lt;a href="mailto:lexi.lambda@gmail.com"&gt;sending me an email&lt;/a&gt; (though I’m usually a bit slower to respond to the latter).&lt;/p&gt;

&lt;h2 id="how-can-i-help"&gt;How can I help?&lt;/h2&gt;

&lt;p&gt;Probably the easiest way to help out is to try Hackett for yourself and &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;report any bugs or infelicities you run into&lt;/a&gt;. Of course, many issues right now are known, there’s just so much to do that I haven’t had the chance to clean everything up. For that reason, the most effective way to contribute is probably to pick an existing issue and try and implement it yourself, but I wouldn’t be surprised if most people found the existing implementation a little intimidating.&lt;/p&gt;

&lt;p&gt;If you &lt;em&gt;are&lt;/em&gt; interested in helping out, I’d be happy to give you some pointers and answer some questions, since it would be extremely nice to have some help. Please feel free to contact me using any of the methods mentioned in the previous section, and I’ll try and help you find something you could work on.&lt;/p&gt;

&lt;h2 id="how-does-hackett-compare-to-x--why-doesnt-hackett-support-y"&gt;How does Hackett compare to &lt;em&gt;X&lt;/em&gt; / why doesn’t Hackett support &lt;em&gt;Y&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;These tend to be complex questions, and I don’t always have comprehensive answers for them, especially since the language is evolving so quickly. Still, if you want to ask me about this, feel free to just send the question to me directly. In my experience, it’s usually better to have a conversation about this sort of thing rather than just answering in one big comparison, since there’s usually a fair amount of nuance.&lt;/p&gt;

&lt;h2 id="when-will-hackett-be-ready-for-me-to-use"&gt;When will Hackett be ready for me to use?&lt;/h2&gt;

&lt;p&gt;I don’t know.&lt;/p&gt;

&lt;p&gt;Obviously, there is a lot left to implement, that is certainly true, but there’s more to it than that. If all goes well, I don’t see any reason why Hackett can’t be early beta quality by the end of this year, even if it doesn’t support all of the goodies necessary to achieve perfection (which, of course, it never really can).&lt;/p&gt;

&lt;p&gt;However, there are other things to consider, too. The Racket package system is currently flawed in ways that make rapidly iterating on Hackett hard, since it is extremely difficult (if not impossible) to make backwards-incompatible changes without potentially breaking someone’s program (even if they don’t update anything about their dependencies)! This is a solvable problem, but it would take some work modifying various elements of the package system and build tools, so that might need to get done before I can recommend Hackett in good faith.&lt;/p&gt;

&lt;h1 id="appendix"&gt;Appendix&lt;/h1&gt;

&lt;p&gt;It would be unfair not to mention all the people that have made Hackett possible. I cannot list them all here, but I want to give special thanks to &lt;a href="http://www.ccs.neu.edu/home/stchang/"&gt;Stephen Chang&lt;/a&gt;, &lt;a href="http://www.cs.ubc.ca/~joshdunf/"&gt;Joshua Dunfield&lt;/a&gt;, &lt;a href="http://eecs.northwestern.edu/~robby/"&gt;Robby Findler&lt;/a&gt;, &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, &lt;a href="http://functorial.com"&gt;Phil Freeman&lt;/a&gt;, &lt;a href="http://www.ccs.neu.edu/home/types/"&gt;Ben Greenman&lt;/a&gt;, &lt;a href="https://github.com/AlexKnauth"&gt;Alex Knauth&lt;/a&gt;, &lt;a href="http://www.cl.cam.ac.uk/~nk480/"&gt;Neelakantan Krishnaswami&lt;/a&gt;, and &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt;. I’d also like to thank everyone involved in the Racket and Haskell projects as a whole, as well as everyone who has expressed interest and encouragement about what I’ve been working on.&lt;/p&gt;

&lt;p&gt;As a final point, just for fun, I thought I’d keep track of all the albums I’ve been listening to while working on Hackett, just in the past few weeks. It is &lt;a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/#whats-in-a-name"&gt;on theme with the name&lt;/a&gt;, after all. This list is not completely exhaustive, as I’m sure some slipped through the cracks, but you can thank the following artists for helping me power through a few of the hills in Hackett’s implementation:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The Beach Boys — Pet Sounds&lt;/li&gt;
 &lt;li&gt;Boards of Canada — Music Has The Right To Children, Geogaddi&lt;/li&gt;
 &lt;li&gt;Bruce Springsteen — Born to Run&lt;/li&gt;
 &lt;li&gt;King Crimson — In the Court of the Crimson King, Larks’ Tongues in Aspic, Starless and Bible Black, Red, Discipline&lt;/li&gt;
 &lt;li&gt;Genesis — Nursery Cryme, Foxtrot, Selling England by the Pound, The Lamb Lies Down on Broadway, A Trick of the Tail&lt;/li&gt;
 &lt;li&gt;Mahavishnu Orchestra — Birds of Fire&lt;/li&gt;
 &lt;li&gt;Metric — Fantasies, Synthetica, Pagans in Vegas&lt;/li&gt;
 &lt;li&gt;Muse — Origin of Symmetry, Absolution, The Resistance&lt;/li&gt;
 &lt;li&gt;Peter Gabriel — Peter Gabriel I, II, III, IV / Security, Us, Up&lt;/li&gt;
 &lt;li&gt;Pink Floyd — Wish You Were Here&lt;/li&gt;
 &lt;li&gt;Supertramp — Breakfast In America&lt;/li&gt;
 &lt;li&gt;The Protomen — The Protomen, Act II: The Father of Death&lt;/li&gt;
 &lt;li&gt;Talking Heads — Talking Heads: 77, More Songs About Buildings and Food, Fear of Music, Remain in Light&lt;/li&gt;
 &lt;li&gt;Yes — Fragile, Relayer, Going For The One&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;And of course, &lt;em&gt;Voyage of the Acolyte&lt;/em&gt;, by &lt;strong&gt;Steve Hackett&lt;/strong&gt;.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Rascal is now Hackett, plus some answers to questions</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/?utm_source=hackett&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2017-01-05-rascal-is-now-hackett-plus-some-answers-to-questions</id>
  <published>2017-01-05T05:25:32Z</published>
  <updated>2017-01-05T05:25:32Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;p&gt;Since I published &lt;a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"&gt;my blog post introducing Rascal&lt;/a&gt;, I’ve gotten some &lt;em&gt;amazing&lt;/em&gt; feedback, more than I had ever anticipated! One of the things that was pointed out, though, is that &lt;a href="http://www.rascal-mpl.org"&gt;Rascal is a language that already exists&lt;/a&gt;. Given that the name “Rascal” came from a mixture of “Racket” and “Haskell”, I always had an alternative named planned, and that’s “Hackett”. So, to avoid confusion as much as possible, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;&lt;strong&gt;Rascal is now known as Hackett&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With that out of the way, I also want to answer some of the other questions I received, both to hopefully clear up some confusion and to have something I can point to if I get the same questions in the future.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="whats-in-a-name"&gt;What’s in a name?&lt;/h1&gt;

&lt;p&gt;First, a little trivia.&lt;/p&gt;

&lt;p&gt;I’ve already mentioned that the old “Rascal” name was based on the names “Racket” and “Haskell”, which is true. However, it had a slightly deeper meaning, too: the name fit a tradition of naming languages in the Scheme family after somewhat nefarious things, such as “Gambit”, “Guile”, “Larceny”, and “Racket” itself. The name goes back a little bit further to the Planner programming language; Scheme was originally called Schemer, but it was (no joke) shorted due to filename length restrictions.&lt;/p&gt;

&lt;p&gt;Still, my language isn’t really a Scheme, so the weak connection wasn’t terribly relevant. Curious readers might be wondering if there’s any deeper meaning to the name “Hackett” than a mixture of the two language names. In fact, there is. Hackett is affectionately named after the &lt;a href="https://en.wikipedia.org/wiki/Steve_Hackett"&gt;Genesis progressive rock guitarist, Steve Hackett&lt;/a&gt;, one of my favorite musicians. The fact that the name is a homophone with “hack-it” is another convenient coincidence.&lt;/p&gt;

&lt;p&gt;Perhaps not the most interesting thing in this blog post, but there it is.&lt;/p&gt;

&lt;h1 id="why-racket-why-not-haskell"&gt;Why Racket? Why &lt;em&gt;not&lt;/em&gt; Haskell?&lt;/h1&gt;

&lt;p&gt;One of the most common questions I received is why I used Racket as the implementation language instead of Haskell. This is a decent question, and I think it likely stems at least in part from an item of common confusion: &lt;strong&gt;Racket is actually two things, a programming language and a programming language platform&lt;/strong&gt;. The fact that the two things have the same name is probably not ideal, but it’s what we’ve got.&lt;/p&gt;

&lt;p&gt;Racket-the-language is obviously the primary language used on the Racket platform, but there’s actually surprisingly little need for that to be the case; it’s simply the language that is worked on the most. Much of the Racket tooling, including the compiler, macroexpander, and IDE, are actually totally language agnostic. If someone came along and wrote a language that got more popular than &lt;code&gt;#lang racket&lt;/code&gt;, then there wouldn’t really be anything hardcoded into any existing tooling that would give the impression that &lt;code&gt;#lang racket&lt;/code&gt; was ever the more “dominant” language, aside from the name.&lt;/p&gt;

&lt;p&gt;For this reason, Racket is ideal for implementing new programming languages, moreso than pretty much any other platform out there. The talk I linked to in the previous blog post, &lt;a href="https://www.youtube.com/watch?v=TfehOLha-18"&gt;Languages in an Afternoon&lt;/a&gt;, describes this unique capability. It’s short, only ~15 minutes, but if you’re not into videos, I can try and explain why Racket is so brilliant for this sort of thing.&lt;/p&gt;

&lt;p&gt;By leveraging the Racket platform instead of implementing my language from scratch, I get the following things pretty much for free:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;I get a JIT compiler for my code, and I don’t have to implement a compiler myself.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;I also get a package manager that can cooperate with Hackett code to deliver Hackett modules.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;I get a documentation system that is fully indexed and automatically locally installed when you install Hackett or any package written in Hackett, and that documentation is automatically integrated with the editor.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The DrRacket IDE can be used out of the box with Hackett code, it automatically does syntax highlighting and indenting, and it even provides interactive tools for inspecting bindings (something that I demo in my aforementioned talk).&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If you don’t want to use DrRacket, you can use the &lt;a href="https://github.com/greghendershott/racket-mode"&gt;racket-mode&lt;/a&gt; major mode for Emacs, which uses the same sets of tools that DrRacket uses under the hood, so you get most of the same DrRacket goodies without sacrificing Emacs’s power of customization.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Reimplementing all of that in another language would take years of work, and I haven’t even mentioned Racket’s module system and macroexpander, which are the underpinnings of Hackett. GHC’s typechecker is likely roughly as complex as Racket’s macroexpander combined with its module system, but I am not currently implementing GHC’s typechecker, since I do not need all of OutsideIn(X)’s features, just Haskell 98 + some extensions.&lt;/p&gt;

&lt;p&gt;In contrast, I truly do need all of the Racket macroexpander to implement Hackett, since the &lt;em&gt;Type Systems as Macros&lt;/em&gt; paper uses pretty much every trick the Racket macro system has to offer to implement typechecking as macroexpansion. For those reasons, implementing the Racket macroexpander &lt;strong&gt;alone&lt;/strong&gt; in Haskell would likely be monumentally more work than implementing a Hindley-Milner typechecker in Racket, so it doesn’t really make sense to use Haskell for that job.&lt;/p&gt;

&lt;h2 id="actually-running-hackett-code"&gt;Actually running Hackett code&lt;/h2&gt;

&lt;p&gt;Now, it’s worth noting that GHC is much more efficient as a compiler than Racket is, for a whole host of reasons. However, since typechecking and macroexpansion are inherently strictly compile-time phases, it turns out to be totally feasible to run the typechecker/macroexpander in Racket (since in Hackett, the two things are one and the same), then compile the resulting fully-expanded, well-typed code to GHC Core. That could then be handed off to GHC itself and compiled using the full power of the GHC optimizer and compiler toolchain.&lt;/p&gt;

&lt;p&gt;This would be no small amount of work, but it seems theoretically possible, so eventually it’s something I’d love to look into. There are various complexities to making it work, but I think it would let me get the best of both worlds without reinventing the wheel, so it’s something I want long-term.&lt;/p&gt;

&lt;p&gt;There’s also the question of how “native” Hackett code would be, were it compiled to GHC Core. Would Hackett code be able to use Haskell libraries, and vice versa? My guess is that the answer is “yes, with some glue”. It probably wouldn’t be possible to do it completely seamlessly, because Hackett provides type information at macroexpansion time that likely wouldn’t exist in the same form in GHC. It might be possible to do some incredibly clever bridging to be able to use Haskell libraries in Hackett almost directly, but the inverse might not be true if a library’s interface depends on macros.&lt;/p&gt;

&lt;h1 id="how-do-template-haskell-quasiquoters-compete-with-macros"&gt;How do Template Haskell quasiquoters compete with macros?&lt;/h1&gt;

&lt;p&gt;Quasiquoters have a number of drawbacks, but the two main ones are complexity and lack of composition.&lt;/p&gt;

&lt;p&gt;S-expressions happen to be simple, and this means s-expression macros have two lovely properties: they’re easy to write, given good libraries (Racket has &lt;a href="http://docs.racket-lang.org/syntax/stxparse.html"&gt;&lt;code&gt;syntax/parse&lt;/code&gt;&lt;/a&gt;), and they’re easy for tools to understand. Quasiquoters force implementors to write their own parsers from raw strings of characters, which is quite a heavy burden, and it usually means those syntaxes are confusing and brittle. To give a good example, consider &lt;a href="http://www.yesodweb.com/book/persistent#persistent_code_generation"&gt;persistent’s quasiquoters&lt;/a&gt;: they look &lt;em&gt;sort of&lt;/em&gt; like Haskell data declarations, but they’re not really, and I honestly have no idea what their actual syntax really is. It feels pretty finicky, though. In contrast, an s-expression based version of the same syntax would basically look just like the usual datatype declaration form, plus perhaps some extra goodies.&lt;/p&gt;

&lt;p&gt;Additionally, s-expression macros &lt;em&gt;compose&lt;/em&gt;, and this should probably be valued more than anything else. If you’re writing code that doesn’t compose, it’s usually a bad sign. So much of functional programming is about writing small, reusable pieces of code that can be composed together, and macros are no different. Racket’s &lt;code&gt;match&lt;/code&gt;, for example, is an expression, and it contains expressions, so &lt;code&gt;match&lt;/code&gt; can be nested within itself, as well as other arbitrary macros that produce expressions. Similarly, many Racket macros can be extended, which is possible due to having such uniform syntax.&lt;/p&gt;

&lt;p&gt;Making macros “stand out” is an issue of some subjectivity, but in my experience such a fear of macros tends to stem from a familiarity with bad macro systems (which, to be fair, is almost all of them) and poor tooling. I’ve found that, in practice, most of the reasons people want to know “is this a macro??” is because macros are scary black boxes and people want to know which things to be suspicious of.&lt;/p&gt;

&lt;p&gt;Really, though, one of the reasons macros are complicated isn’t knowing which things are macros, but it’s knowing &lt;em&gt;which identifiers are uses and which identifiers are bindings&lt;/em&gt;, and things like that. Just knowing that something is a macro use doesn’t actually help at all there—the syntax won’t tell you. &lt;a href="http://i.imgur.com/HvYee19.png"&gt;Solve that problem with tools that address the problem head on, not by making a syntax that makes macros second-class citizens.&lt;/a&gt; One of the reasons I used the phrase “syntactic abstractions” in my previous blog post is because you specifically want them to be &lt;strong&gt;abstractions&lt;/strong&gt;. If you have to think of a macro in terms of the thing it expands to then it isn’t a very watertight abstraction. You don’t think about Haskell pattern-matching in terms of what the patterns compile to, you just use them. Macros should be (and can be) just as fluid.&lt;/p&gt;

&lt;h1 id="how-can-i-help"&gt;How can I help?&lt;/h1&gt;

&lt;p&gt;Right now, what I really need is someone who understands type system implementation. You don’t need to be up to date on what’s cutting edge—I’m not implementing anything nearly as complicated as GADTs or dependent types yet—you just need to understand how to implement Haskell 98. If you have that knowledge and you’re interested in helping, even if it just means answering some of my questions, please contact me via email, IRC (the #racket channel on Freenode is a good place for now), or Slack (I’m active in the snek Slack community, &lt;a href="http://snek.jneen.net"&gt;which you can sign up for here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;If you aren’t familiar with those things, but you’re still interested in helping out, there’s definitely plenty of work that needs doing. If you want to find somewhere you can pitch in, contacting me via any of the above means is totally fine, and I can point you in the right direction. Even if you just want to be a guinea pig, that’s useful.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">Rascal: a Haskell with more parentheses</title>
  <link rel="alternate" href="http://lexi-lambda.github.io/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/?utm_source=hackett&amp;utm_medium=Atom" />
  <id>urn:http-lexi-lambda-github-io:-blog-2017-01-02-rascal-a-haskell-with-more-parentheses</id>
  <published>2017-01-02T09:16:42Z</published>
  <updated>2017-01-02T09:16:42Z</updated>
  <author>
   <name>Alexis King</name></author>
  <content type="html">
&lt;blockquote&gt;
 &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: since the writing of this blog post, Rascal has been renamed to Hackett. You can read about why in &lt;a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/"&gt;the followup blog post&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;“Hey! You got your Haskell in my Racket!”&lt;/p&gt;

&lt;p&gt;“No, you got &lt;em&gt;your&lt;/em&gt; Racket in &lt;em&gt;my&lt;/em&gt; Haskell!”&lt;/p&gt;

&lt;p&gt;Welcome to the &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Rascal&lt;/a&gt; programming language.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="why-rascal"&gt;Why Rascal?&lt;/h1&gt;

&lt;p&gt;Why yet &lt;em&gt;another&lt;/em&gt; programming language? Anyone who knows me knows that I already have two programming languages that I &lt;em&gt;really&lt;/em&gt; like: Haskell and Racket. Really, I think they’re both great! Each brings some things to the table that aren’t really available in any other programming language I’ve ever used.&lt;/p&gt;

&lt;p&gt;Haskell, in many ways, is a programming language that fits my mental model of how to structure programs better than any other programming language I’ve used. Some people would vehemently disagree, and it seems that there is almost certainly some heavy subjectivity in how people think about programming. I think Haskell’s model is awesome once you get used to it, though, but this blog post is not really going to try and convince you why you should care about Haskell (though that &lt;em&gt;is&lt;/em&gt; something I want to write at some point). What you &lt;em&gt;should&lt;/em&gt; understand, though, is that to me, Haskell is pretty close to what I want in a programming language.&lt;/p&gt;

&lt;p&gt;At the same time, though, Haskell has problems, and a lot of that revolves around its story for metaprogramming. “Metaprogramming” is another M word that people seem to be very afraid of, and for good reason: most metaprogramming systems are ad-hoc, unsafe, unpredictable footguns that require delicate care to use properly, and &lt;em&gt;even then&lt;/em&gt; the resulting code is brittle and difficult to understand. Haskell doesn’t suffer from this problem as much as some languages, but it isn’t perfect by any means: Haskell has at least two different metaprogramming systems (generics and Template Haskell) that are designed for different tasks, but they’re both limited in scope and both tend to be pretty complicated to use.&lt;/p&gt;

&lt;p&gt;Discussing the merits and drawbacks of Haskell’s various metaprogramming capabilities is also outside the scope of this blog post, but there’s one &lt;em&gt;fact&lt;/em&gt; that I want to bring up, which is that &lt;strong&gt;Haskell does not provide any mechanism for adding syntactic abstractions to the language&lt;/strong&gt;. What do I mean by this? Well, in order to understand what a “syntactic abstraction” is and why you should care about it, I want to shift gears a little and take a look at why Racket is so amazing.&lt;/p&gt;

&lt;h2 id="a-programmable-programming-language-theory-and-practice"&gt;A programmable programming language: theory and practice&lt;/h2&gt;

&lt;p&gt;I feel confident in saying that Racket has &lt;em&gt;the&lt;/em&gt; most advanced macro system in the world, and it is pretty much unparalleled in that space. There are many languages with powerful type systems, but Racket is more or less alone in many of the niches it occupies. Racket has a large number of innovations that I don’t know of in any other programming language, and a significant portion of them focus on making Racket a &lt;a href="http://www.ccs.neu.edu/home/matthias/manifesto/"&gt;programmable programming language, a language for building languages&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This lofty goal is backed up by decades of research, providing Racket with an unparalleled toolkit for creating languages that can communicate, be extended, and even cooperate with tooling to provide introspection and error diagnostics. Working in Haskell feels like carefully designing a mould that cleanly and precisely fits your domain, carefully carving, cutting, and whittling. In contrast, working with Racket feels like moulding your domain until it looks the way &lt;em&gt;you&lt;/em&gt; want it to look, poking and prodding at a pliable substrate. The sheer &lt;em&gt;ease&lt;/em&gt; of it all is impossible for me to convey in words, so &lt;a href="https://twitter.com/andmkent_/status/724036694773628930"&gt;you will have to see it for yourself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All this stuff is super abstract, though. What does it mean for practical programming, and why should you care? Well, I’m not going to try and sell you if you’re extremely skeptical, but if you’re interested, &lt;a href="https://www.youtube.com/watch?v=TfehOLha-18"&gt;I gave a talk on some of Racket’s linguistic capabilities last year called &lt;em&gt;Languages in an Afternoon&lt;/em&gt;&lt;/a&gt;. If you’re curious, give it a watch, and you might find yourself (hopefully) a little impressed. If you prefer reading, well, I have some &lt;a href="/blog/2015/12/21/adts-in-typed-racket-with-macros/"&gt;blog posts&lt;/a&gt; on this very blog that &lt;a href="/blog/2015/08/30/managing-application-configuration-with-envy/"&gt;demonstrate what Racket can do&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The basic idea, though, is that by having a simple syntax and a powerful macro system with a formalization of lexical scope, users can effectively invent entirely new language constructs as ordinary libraries, constructs that would have to be core forms in other programming languages. For example, Racket supports pattern-matching, but it isn’t built into the compiler: it’s simply implemented in the &lt;code&gt;racket/match&lt;/code&gt; module distributed with Racket. Not only is it defined in ordinary Racket code, it’s actually &lt;em&gt;extensible&lt;/em&gt;, so users can add their own pattern-matching forms that cooperate with &lt;code&gt;match&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is the power of a macro system to produce “syntactic abstractions”, things that can transform the way a user thinks of the code they’re writing. Racket has the unique capability of making these abstractions both easy to write and watertight, so instead of being a scary tool you have to handle with extreme care, you can easily whip up a powerful, user-friendly embedded domain specific language in a matter of &lt;em&gt;minutes&lt;/em&gt;, and it’ll be safe, provide error reporting for misuse, and cooperate with existing tooling pretty much out of the box.&lt;/p&gt;

&lt;h2 id="fusing-haskell-and-racket"&gt;Fusing Haskell and Racket&lt;/h2&gt;

&lt;p&gt;So, let’s assume that we &lt;em&gt;do&lt;/em&gt; want Haskell’s strong type system and that we &lt;em&gt;also&lt;/em&gt; want a powerful metaprogramming model that permits syntactic extensions. What would that look like? Well, one way we could do it is to put one in front of the other: macro expansion is, by nature, a compile-time pass, so we could stick a macroexpander in front of the typechecker. This leads to a simple technique: first, macroexpand the program to erase the macros, then typecheck it and erase the types, then send the resulting code off to be compiled. This technique has the following properties:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;First of all, &lt;strong&gt;it’s easy to implement&lt;/strong&gt;. Racket’s macroexpander, while complex, is well-documented in academic literature and works extremely well in practice. In fact, this strategy has already been implemented! Typed Racket, the gradually-typed sister language of Racket, expands every program before typechecking. It would be possible to effectively create a “Lisp-flavored Haskell” by using this technique, and it might not even be that hard.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Unfortunately, there’s a huge problem with this approach: &lt;strong&gt;type information is not available at macroexpansion time&lt;/strong&gt;. This is the real dealbreaker with the “expand, then typecheck” model, since static type information is some of the most useful information possibly available to a macro writer. In an ideal world, macros should not only have access to type information, they should be able to manipulate it and metaprogram the typechecker as necessary, but if macroexpansion is a separate phase from typechecking, then that information simply doesn’t exist yet.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For me, the second option is unacceptable. I am &lt;em&gt;not&lt;/em&gt; satisfied by a “Lisp-flavored Haskell”; I want my types and macros to be able to cooperate and communicate with each other. The trouble, though, is that solving that problem is really, really hard! For a couple years now, I’ve been wishing this ideal language existed, but I’ve had no idea how to make it actually work. Template Haskell implements a highly restricted system of interweaving typechecking and splice evaluation, but it effectively does it by running the typechecker and the splice expander alternately, splitting the source into chunks and typechecking them one at a time. This works okay for Template Haskell, but for the more powerful macro system I am looking for, it wouldn’t scale.&lt;/p&gt;

&lt;p&gt;There’s something a little bit curious, though, about the problem as I just described it. The processes of “macroexpanding the program to erase the macros” and “typechecking the program to erase the types” sound awfully similar. It seems like maybe these are two sides of the same coin, and it would be wonderful if we could encode one in terms of the other, effectively turning the two passes into a single, unified pass. Unfortunately, while this sounds great, I had no idea how to do this (and it didn’t help that I really had no idea how existing type systems were actually implemented).&lt;/p&gt;

&lt;p&gt;Fortunately, last year, Stephen Chang, Alex Knauth, and Ben Greenman put together a rather exciting paper called &lt;a href="http://www.ccs.neu.edu/home/stchang/popl2017/"&gt;&lt;em&gt;Type Systems as Macros&lt;/em&gt;&lt;/a&gt;, which does precisely what I just described, and it delivers it all in a remarkably simple and elegant presentation. The idea is to “distribute” the task of typechecking over the individual forms of the language, leveraging existing macro communication facilities avaiable in the Racket macroexpander to propagate type information as macros are expanded. To me, it was exactly what I was looking for, and I almost immediately started playing with it and seeing what I could do with it.&lt;/p&gt;

&lt;p&gt;The result is &lt;a href="https://github.com/lexi-lambda/hackett"&gt;&lt;em&gt;Rascal&lt;/em&gt;&lt;/a&gt;, a programming language built in the Racket ecosystem that attempts to implement a Haskell-like type system.&lt;/p&gt;

&lt;h1 id="a-first-peek-at-rascal"&gt;A first peek at Rascal&lt;/h1&gt;

&lt;p&gt;Rascal is a very new programming language I’ve only been working on over the past few months. It is extremely experimental, riddled with bugs, half-baked, and may turn your computer into scrambled eggs. Still, while I might not recommend that you actually &lt;em&gt;use&lt;/em&gt; it just yet, I want to try and share what it is I’m working on, since I’d bet at least a few other people will find it interesting, too.&lt;/p&gt;

&lt;p&gt;First, let me say this up front: &lt;strong&gt;Rascal is probably a lot closer to Haskell than Racket&lt;/strong&gt;. That might come as a surprise, given that Rascal has very Lisp-y syntax, it’s written in Racket, and it runs on the Racket platform, but semantically, Rascal is mostly just Haskell 98. This is important, because it may come as a surprise, given that there are so few statically typed Lisps, but there’s obviously no inherent reason that Lisps need to be dynamically typed. They just seem to have mostly evolved that way.&lt;/p&gt;

&lt;p&gt;Taking a look at a snippet of Rascal code, it’s easy to see that the language doesn’t work quite like a traditional Lisp, though:&lt;sup&gt;&lt;a href="#2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-definition" name="2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def+ map-every-other : (forall [a] {{a -&amp;gt; a} -&amp;gt; (List a) -&amp;gt; (List a)})
  [_ nil            -&amp;gt; nil]
  [_ {x :: nil}     -&amp;gt; {x :: nil}]
  [f {x :: y :: ys} -&amp;gt; {x :: (f y) :: (map-every-other f ys)}])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a Lisp with all the goodies you would expect out of Haskell: static types, parametric polymorphism, automatically curried functions, algebraic datatypes, pattern-matching, infix operators, and of course, &lt;em&gt;typeclasses&lt;/em&gt;. Yes, with Rascal you can have your monads in all their statically dispatched glory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(data (Maybe a)
  (just a)
  nothing)

(instance (Monad Maybe)
  [join (case-lambda
          [(just (just x)) (just x)]
          [_               nothing])])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, though, this really &lt;em&gt;is&lt;/em&gt; just “Haskell with parentheses”. As alluded to above, however, Rascal is a bit more than that.&lt;/p&gt;

&lt;h2 id="core-forms-can-be-implemented-as-derived-concepts"&gt;Core forms can be implemented as derived concepts&lt;/h2&gt;

&lt;p&gt;Rascal’s type system is currently very simple, being nothing more than Hindley-Milner plus ad-hoc polymorphism in the form of typeclasses. Something interesting to note about it is that it does not implement ADTs or pattern-matching anywhere in the core! In fact, ADTs are defined as two macros &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt;, in an entirely separate module, which can be imported just like any other library.&lt;/p&gt;

&lt;p&gt;The main &lt;code&gt;rascal&lt;/code&gt; language provides ADTs by default, of course, but it would be perfectly possible to produce a &lt;code&gt;rascal/kernel&lt;/code&gt; language which does not include them at all. In this particular case, it seems unlikely that Rascal programmers would want their own implementation of ADTs, but it’s an interesting proof of concept, and it hints at other “core” features that could be implemented using macros.&lt;/p&gt;

&lt;p&gt;Simple syntactic transformations are, of course, trivially defined as macros. Haskell &lt;code&gt;do&lt;/code&gt; notation is defined as &lt;a href="https://github.com/lexi-lambda/hackett/blob/87d001a82c86fb66544d25c37ffba9be1ac63464/rascal-lib/rascal/monad.rkt#L48-L58"&gt;an eleven-line macro in &lt;code&gt;rascal/monad&lt;/code&gt;&lt;/a&gt;, and GHC’s useful &lt;code&gt;LambdaCase&lt;/code&gt; extension is also possible to implement without modifying Rascal at all. This is useful, because there are many syntactic shorthands that are extremely useful to implement, but don’t make any sense to be in GHC because they are specific to certain libraries or applications. Racket’s macro system makes those not only possible, but actually pretty easy.&lt;/p&gt;

&lt;p&gt;While the extent of what is possible to implement as derived forms remains to be seen, many useful GHC features seem quite possible to implement without touching the core language, including things like &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; and other generic deriving mechanisms like &lt;code&gt;GHC.Generics&lt;/code&gt;, &lt;code&gt;DeriveGeneric&lt;/code&gt;, and &lt;code&gt;DeriveAnyClass&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="the-language-is-not-enough"&gt;The language is not enough&lt;/h2&gt;

&lt;p&gt;No language is perfect. Most people would agree with this, but I would take it a step further: no language is even sufficient! This makes a lot of sense, given that general-purpose programming languages are designed to do &lt;em&gt;everything&lt;/em&gt;, and it’s impossible to do everything well.&lt;/p&gt;

&lt;p&gt;Haskell programmers know this, and they happily endorse the creation of embedded domain specific languages. These are fantastic, and we need more of them. Things like &lt;a href="http://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; let me write a third of the code I might otherwise need to, and the most readable code is the code you didn’t have to write in the first place. DSLs are good.&lt;/p&gt;

&lt;p&gt;Unfortunately, building DSLs is traditionally difficult, largely in part because building embedded DSLs means figuring out a way to encode your domain into your host language of choice. Sometimes, your domain simply does not elegantly map to your host language’s syntax or semantics, and you have to come up with a compromise. This is easy to see with servant, which, while it does a remarkably good job, still has to resort to some very clever type magic to create some semblance of an API description in Haskell types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type UserAPI = "users" :&amp;gt; Get '[JSON] [User]
          :&amp;lt;|&amp;gt; "users" :&amp;gt; ReqBody '[JSON] User :&amp;gt; Post '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; Get '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; ReqBody '[JSON] User
                       :&amp;gt; Put '[JSON] User&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code is &lt;em&gt;remarkably&lt;/em&gt; readable for what it is, but what if we didn’t have to worry about working within the constraints of Haskell’s syntax? What if we could design a syntax that was truly the best for the job? Perhaps we would come up with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-api User-API
  #:content-types [JSON]
  [GET  "users"                    =&amp;gt; (List User)]
  [POST "users"                    =&amp;gt; User -&amp;gt; User]
  [GET  "users" [userid : Integer] =&amp;gt; User]
  [PUT  "users" [userid : Integer] =&amp;gt; User -&amp;gt; User])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would be extremely easy to write with Racket’s macro-writing utilities, and it could even be made extensible. This could also avoid having to do the complicated typeclass trickery servant has to perform to then generate code from the above specification, since it would be much easier to just generate the necessary code directly (which still maintaining type safety).&lt;/p&gt;

&lt;p&gt;In addition to the type-level hacks that Haskell programmers often have to pull in order to make these kinds of fancy DSLs work, free monads tend to be used to create domain-specific languages. This works okay for some DSLs, but remember that when you use a free monad, you are effectively writing a &lt;em&gt;runtime interpreter&lt;/em&gt; for your language! Macros, on the other hand, are compiled, and you get ability to &lt;em&gt;compile&lt;/em&gt; your DSL to code that can be optimized by all the existing facilities of the compiler toolchain.&lt;/p&gt;

&lt;h1 id="rascal-is-embryonic"&gt;Rascal is embryonic&lt;/h1&gt;

&lt;p&gt;I’m pretty excited about Rascal. I think that it could have the potential to do some pretty interesting things, and I have some ideas in my head for how having macros in a Haskell-like language could change things. I also think that, based on what I’ve seen so far, having both macros and a Haskell-like type system could give rise to &lt;em&gt;completely&lt;/em&gt; different programming paradigms than exist in either Haskell or Racket today. My gut tells me that this is a case where the whole might actually be greater than the sum of its parts.&lt;/p&gt;

&lt;p&gt;That said, Rascal doesn’t really exist yet. Yes, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;there is a GitHub repository&lt;/a&gt;, and it has some code in it that does… something. Unfortunately, the code is also currently extremely buggy, to the point of being borderline broken, and it’s also in such early stages that you can’t really do &lt;em&gt;anything&lt;/em&gt; interesting with it, aside from some tiny toy programs.&lt;/p&gt;

&lt;p&gt;As I have worked on Rascal, I’ve come to a somewhat unfortunate conclusion, which is that I really have almost zero interest in implementing type systems. I felt that way before I started the project, but I was hoping that maybe once I got into them, I would find them more interesting. Unfortunately, as much as I love working with powerful type systems (and really, I adore working with Haskell and using all the fancy features GHC provides), I find implementing the software that makes them tick completely dull.&lt;/p&gt;

&lt;p&gt;Still, I’m willing to invest the time to get something that I can use. Even so, resources for practical type system implementation are scarce. I want to thank &lt;a href="https://web.cecs.pdx.edu/~mpj/"&gt;Mark P Jones&lt;/a&gt; for his wonderful resource &lt;a href="https://web.cecs.pdx.edu/~mpj/thih/"&gt;Typing Haskell in Haskell&lt;/a&gt;, without which getting to where I am now would likely have been impossible. I also want to thank &lt;a href="http://www.stephendiehl.com"&gt;Stephen Diehl&lt;/a&gt; for his wonderful &lt;a href="http://dev.stephendiehl.com/fun/"&gt;Write You a Haskell&lt;/a&gt; series, which was also wonderfully useful to study, even if it is unfinished and doesn’t cover anything beyond ML just yet.&lt;/p&gt;

&lt;p&gt;Even with these wonderful resources, I’ve come to the realization that &lt;strong&gt;I probably can’t do all of this on my own&lt;/strong&gt;. I consider myself pretty familiar with macros and macro expanders at this point, but I don’t know much about type systems (at least not their implementation), and I could absolutely use some help. So if you’re interested in Rascal and think you might be able to pitch in, please: I would appreciate even the littlest bits of help or guidance!&lt;/p&gt;

&lt;p&gt;In the meantime, I will try to keep picking away at Rascal in the small amount of free time I currently have. Thanks, as always, to all the amazing people who have contributed to the tools I’ve been using for this project: special thanks to the authors of &lt;em&gt;Type Systems as Macros&lt;/em&gt; for their help as well as the people I mentioned just above, and also to all of the people who have built Racket and Haskell and made them what they are today. Without them, Rascal would most definitely not exist.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Note that most of the Rascal code in this blog post probably doesn’t actually work on the current Rascal implementation. Pretty much all of it can be implemented in the current implementation, the syntax just isn’t quite as nice yet.&amp;nbsp;&lt;a href="#2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry></feed>