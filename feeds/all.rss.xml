<?xml version="1.0" encoding="utf-8"?><rss version="2.0"><channel><title>Alexis King’s Blog</title><description>Alexis King’s Blog</description><link>https://lexi-lambda.github.io/</link><pubDate>25 Mar 2021</pubDate><lastBuildDate>25 Mar 2021</lastBuildDate><ttl>60</ttl><item><title>An introduction to typeclass metaprogramming</title><link>https://lexi-lambda.github.io/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/</guid><pubDate>25 Mar 2021</pubDate><description>&lt;article&gt;&lt;p&gt;&lt;em&gt;Typeclass metaprogramming&lt;/em&gt; is a powerful technique available to Haskell programmers to automatically generate term-level code from static type information. It has been used to great effect in several popular Haskell libraries (such as the &lt;a href="https://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; ecosystem), and it is the core mechanism used to implement generic programming via &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Generics.html"&gt;GHC generics&lt;/a&gt;. Despite this, remarkably little material exists that explains the technique, relegating it to folk knowledge known only to advanced Haskell programmers.&lt;/p&gt;&lt;p&gt;This blog post attempts to remedy that by providing an overview of the foundational concepts behind typeclass metaprogramming. It does &lt;em&gt;not&lt;/em&gt; attempt to be a complete guide to type-level programming in Haskell—such a task could easily fill a book—but it does provide explanations and illustrations of the most essential components. This is also &lt;em&gt;not&lt;/em&gt; a blog post for Haskell beginners—familiarity with the essentials of the Haskell type system and several common GHC extensions is assumed—but it does not assume any prior knowledge of type-level programming.&lt;/p&gt;&lt;h2&gt;&lt;a name="part-1-basic-building-blocks"&gt;&lt;/a&gt;Part 1: Basic building blocks&lt;/h2&gt;&lt;p&gt;Typeclass metaprogramming is a big subject, which makes covering it in a blog post tricky. To break it into more manageable chunks, this post is divided into several parts, each of which introduces new type system features or type-level programming techniques, then presents an example of how they can be applied.&lt;/p&gt;&lt;p&gt;To start, we’ll cover the absolute foundations of typeclass metaprogramming.&lt;/p&gt;&lt;h3&gt;&lt;a name="typeclasses-as-functions-from-types-to-terms"&gt;&lt;/a&gt;Typeclasses as functions from types to terms&lt;/h3&gt;&lt;p&gt;As its name implies, typeclass metaprogramming (henceforth TMP&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;1&lt;/a&gt;&lt;/sup&gt;) centers around Haskell’s typeclass construct. Traditionally, typeclasses are viewed as a mechanism for principled operator overloading; for example, they underpin Haskell’s polymorphic &lt;code&gt;==&lt;/code&gt; operator via the &lt;code&gt;Eq&lt;/code&gt; class. Though that is often the most useful way to think about typeclasses, TMP encourages a different perspective: &lt;strong&gt;typeclasses are functions from types to (runtime) terms&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;What does that mean? Let’s illustrate with an example. Suppose we define a typeclass called &lt;code&gt;TypeOf&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The idea is that this typeclass will accept some value and return the name of its type as a string. To illustrate, here are a couple potential instances:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Bool"&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Char"&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"("&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;", "&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;")"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Given these instances, we can observe that they do what we expect in GHCi:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;"(Bool, Char)"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that both the &lt;code&gt;TypeOf Bool&lt;/code&gt; and &lt;code&gt;TypeOf Char&lt;/code&gt; instances ignore the argument to &lt;code&gt;typeOf&lt;/code&gt; altogether. This makes sense, as the whole point of the &lt;code&gt;TypeOf&lt;/code&gt; class is to get access to &lt;em&gt;type&lt;/em&gt; information, which is the same regardless of which value is provided. To make this more explicit, we can take advantage of some GHC extensions to eliminate the value-level argument altogether:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="cm"&gt;{-# LANGUAGE AllowAmbiguousTypes, ScopedTypeVariables, TypeApplications #-}&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This typeclass definition is a little unusual, as the type parameter &lt;code&gt;a&lt;/code&gt; doesn’t appear anywhere in the body. To understand what it means, recall that the type of each method of a typeclass is implicitly extended with the typeclass’s constraint. For example, in the definition&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;the full type of the &lt;code&gt;show&lt;/code&gt; method is implicitly extended with a &lt;code&gt;Show a&lt;/code&gt; constraint to yield:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;show&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Furthermore, if we write &lt;code&gt;forall&lt;/code&gt;s explicitly, each typeclass method is also implicitly quantified over the class’s type parameters, which makes the following the &lt;em&gt;full&lt;/em&gt; type of &lt;code&gt;show&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;show&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the same vein, we can write out the full type of &lt;code&gt;typeOf&lt;/code&gt;, as given by our new definition of &lt;code&gt;TypeOf&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This type is still unusual, as the &lt;code&gt;a&lt;/code&gt; type parameter doesn’t appear anywhere to the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow. This makes the type parameter trivially &lt;em&gt;ambiguous&lt;/em&gt;, which is to say it’s impossible for GHC to infer what &lt;code&gt;a&lt;/code&gt; should be at any call site. Fortunately, &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/type_applications.html"&gt;we can use &lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; to pass a type for &lt;code&gt;a&lt;/code&gt; directly, as we can see in the updated definition of &lt;code&gt;TypeOf (a, b)&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Bool"&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Char"&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"("&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;", "&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;")"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Once again, we can test out our new definitions in GHCi:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="s"&gt;"Bool"&lt;/span&gt;
&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;"(Bool, Char)"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This illustrates very succinctly how typeclasses can be seen as functions from types to terms. Our &lt;code&gt;typeOf&lt;/code&gt; function is, quite literally, a function that accepts a single type as an argument and returns a term-level &lt;code&gt;String&lt;/code&gt;. Of course, the &lt;code&gt;TypeOf&lt;/code&gt; typeclass is not a particularly &lt;em&gt;useful&lt;/em&gt; example of such a function, but it demonstrates how easy it is to construct.&lt;/p&gt;&lt;h3&gt;&lt;a name="type-level-interpreters"&gt;&lt;/a&gt;Type-level interpreters&lt;/h3&gt;&lt;p&gt;One important consequence of eliminating the value-level argument of &lt;code&gt;typeOf&lt;/code&gt; is that there is no need for its argument type to actually be &lt;em&gt;inhabited&lt;/em&gt;. For example, consider the &lt;code&gt;TypeOf&lt;/code&gt; instance on &lt;code&gt;Void&lt;/code&gt; from &lt;code&gt;Data.Void&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Void"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This above instance is no different from the ones on &lt;code&gt;Bool&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt; even though &lt;code&gt;Void&lt;/code&gt; is a completely uninhabited type. This is an important point: as we delve into type-level programming, it’s important to keep in mind that the language of types is mostly blind to the term-level meaning of those types. Although we usually write typeclasses that operate on values, this is not at all essential. This turns out to be quite important in practice, even in something as simple as the definition of &lt;code&gt;TypeOf&lt;/code&gt; on lists:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"["&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;typeOf&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;"]"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If &lt;code&gt;typeOf&lt;/code&gt; required a value-level argument, not just a type, our instance above would be in a pickle when given the empty list, since it would have no value of type &lt;code&gt;a&lt;/code&gt; to recursively apply &lt;code&gt;typeOf&lt;/code&gt; to. But since &lt;code&gt;typeOf&lt;/code&gt; only accepts a type-level argument, the term-level meaning of the list type poses no obstacle.&lt;/p&gt;&lt;p&gt;A perhaps unintuitive consequence of this property is that we can use typeclasses to write interesting functions on types even if none of the types are inhabited at all. For example, consider the following pair of type definitions:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is impossible to construct any values of these types, but we can nevertheless use them to construct natural numbers at the type level:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Z&lt;/code&gt; is a type that represents 0.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;S Z&lt;/code&gt; is a type that represents 1.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;S (S Z)&lt;/code&gt; is a type that represents 2.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;And so on. These types might not seem very useful, since they aren’t inhabited by any values, but remarkably, we can still use a typeclass to distinguish them and convert them to term-level values:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Numeric.Natural&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As its name implies, &lt;code&gt;reifyNat&lt;/code&gt; reifies a type-level natural number encoded using our datatypes above into a term-level &lt;code&gt;Natural&lt;/code&gt; value:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="kt"&gt;Z&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One way to think about &lt;code&gt;reifyNat&lt;/code&gt; is as an &lt;em&gt;interpreter&lt;/em&gt; of a type-level language. In this case, the type-level language is very simple, only capturing natural numbers, but in general, it could be arbitrarily complex—and typeclasses can be used to give it a useful meaning, even if it has no term-level representation.&lt;/p&gt;&lt;h3&gt;&lt;a name="overlapping-instances"&gt;&lt;/a&gt;Overlapping instances&lt;/h3&gt;&lt;p&gt;Generally, typeclass instances aren’t supposed to overlap. That is, if you write an instance for &lt;code&gt;Show (Maybe a)&lt;/code&gt;, you aren’t supposed to &lt;em&gt;also&lt;/em&gt; write an instance for &lt;code&gt;Show (Maybe Bool)&lt;/code&gt;, since it isn’t clear whether &lt;code&gt;show (Just True)&lt;/code&gt; should use the first instance or the second. For that reason, by default, GHC rejects any form of instance overlap as soon as it detects it.&lt;/p&gt;&lt;p&gt;Usually, this is the right behavior. Due to the way Haskell’s typeclass system is designed to preserve coherency—that is, the same combination of type arguments always selects the same instance—overlapping instances can be unintuitive or even cause nonsensical behavior if orphan instances are defined. However, when doing TMP, it’s useful to make exceptions to that rule of thumb, so GHC provides the option to explicitly opt-in to overlapping instances.&lt;/p&gt;&lt;p&gt;As a simple example, suppose we wanted to write a typeclass that checks whether a given type is &lt;code&gt;()&lt;/code&gt; or not:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we were to write an ordinary, value-level function, we could write something like this pseudo-Haskell:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;-- not actually valid Haskell, just an example&lt;/span&gt;
&lt;span class="nf"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="nf"&gt;isUnit&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;
&lt;span class="nf"&gt;isUnit&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But if we try to translate this to typeclass instances, we’ll get a problem:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The problem is that a function definition has a closed set of clauses matched from top to bottom, but typeclass instances are open and unordered.&lt;sup&gt;&lt;a href="#footnote-2" id="footnote-ref-2-1"&gt;2&lt;/a&gt;&lt;/sup&gt; This means GHC will complain about instance overlap if we try to evaluate &lt;code&gt;isUnit @()&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ghci&amp;gt; isUnit @()

error:
    • Overlapping instances for IsUnit ()
        arising from a use of ‘isUnit’
      Matching instances:
        instance IsUnit a
        instance IsUnit ()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To fix this, we have to explicitly mark &lt;code&gt;IsUnit ()&lt;/code&gt; as overlapping:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now GHC accepts the expression without complaint:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="kt"&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What does the &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; pragma do, exactly? The gory details are &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/instances.html#overlapping-instances"&gt;spelled out in the GHC User’s Guide&lt;/a&gt;, but the simple explanation is that &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; relaxes the overlap checker as long as the instance is &lt;em&gt;strictly more specific&lt;/em&gt; than the instance(s) it overlaps with. In this case, that is true: &lt;code&gt;IsUnit ()&lt;/code&gt; is trivially more specific than &lt;code&gt;IsUnit a&lt;/code&gt;, since the former only matches &lt;code&gt;()&lt;/code&gt; while the latter matches anything at all. That means our overlap is well-formed, and instance resolution should behave the way we’d like.&lt;/p&gt;&lt;p&gt;Overlapping instances are a useful tool when performing TMP, as they make it possible to write piecewise functions on types in the same way it’s possible to write piecewise functions on terms. However, they must still be used with care, as without understanding how they work, they can produce unintuitive results. For an example of how things can go wrong, consider the following definition:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;guardUnit&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;guardUnit&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="s"&gt;"unit is not allowed"&lt;/span&gt;
  &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The intent of &lt;code&gt;guardUnit&lt;/code&gt; is to use &lt;code&gt;isUnit&lt;/code&gt; to detect if its argument is of type &lt;code&gt;()&lt;/code&gt;, and if it is, to return an error. However, even though we marked &lt;code&gt;IsUnit ()&lt;/code&gt; overlapping, we still get an overlapping instance error:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;error:
    • Overlapping instances for IsUnit a arising from a use of ‘isUnit’
      Matching instances:
        instance IsUnit a
        instance [overlapping] IsUnit ()
    • In the expression: isUnit @a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What gives? The problem is that GHC simply doesn’t know what type &lt;code&gt;a&lt;/code&gt; is when compiling &lt;code&gt;guardUnit&lt;/code&gt;. It &lt;em&gt;could&lt;/em&gt; be instantiated to &lt;code&gt;()&lt;/code&gt; where it’s called, but it might not be. Therefore, GHC doesn’t know which instance to pick, and an overlapping instance error is still reported.&lt;/p&gt;&lt;p&gt;This behavior is actually a very, very good thing. If GHC were to blindly pick the &lt;code&gt;IsUnit a&lt;/code&gt; instance in this case, then &lt;code&gt;guardUnit&lt;/code&gt; would always take the &lt;code&gt;False&lt;/code&gt; branch, even when passed a value of type &lt;code&gt;()&lt;/code&gt;! That would certainly not be what was intended, so it’s better to reject this program than to silently do the wrong thing. However, in more complicated situations, it can be quite surprising that GHC is complaining about instance overlap even when &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; annotations are used, so it’s important to keep their limitations in mind.&lt;/p&gt;&lt;p&gt;As it happens, in this particular case, the error is easily remedied. We simply have to add an &lt;code&gt;IsUnit&lt;/code&gt; constraint to the type signature of &lt;code&gt;guardUnit&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;guardUnit&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;IsUnit&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;guardUnit&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;isUnit&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="s"&gt;"unit is not allowed"&lt;/span&gt;
  &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now picking the right &lt;code&gt;IsUnit&lt;/code&gt; instance is deferred to the place where &lt;code&gt;guardUnit&lt;/code&gt; is used, and the definition is accepted.&lt;sup&gt;&lt;a href="#footnote-3" id="footnote-ref-3-1"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name="type-families-are-functions-from-types-to-types"&gt;&lt;/a&gt;Type families are functions from types to types&lt;/h3&gt;&lt;p&gt;In the previous section, we discussed how typeclasses are functions from types to terms, but what about functions from types to types? For example, suppose we wanted to sum two type-level natural numbers and get a new type-level natural number as a result? For that, we can use a type family:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="cm"&gt;{-# LANGUAGE TypeFamilies #-}&lt;/span&gt;

&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;     &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above is a &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/type_families.html#closed-type-families"&gt;closed type family&lt;/a&gt;, which works quite a lot like an ordinary Haskell function definition, just at the type level instead of at the value level. For comparison, the equivalent value-level definition of &lt;code&gt;Sum&lt;/code&gt; would look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt;

&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt;
&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;     &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="nf"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, the two are quite similar. Both are defined via a pair of pattern-matching clauses, and though it doesn’t matter here, both closed type families and ordinary functions evaluate their clauses top to bottom.&lt;/p&gt;&lt;p&gt;To test our definition of &lt;code&gt;Sum&lt;/code&gt; in GHCi, we can use &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/ghci.html#ghci-cmd-:kind"&gt;the &lt;code&gt;:kind!&lt;/code&gt; command&lt;/a&gt;, which prints out a type and its kind after reducing it as much as possible:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kind&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also combine &lt;code&gt;Sum&lt;/code&gt; with our &lt;code&gt;ReifyNat&lt;/code&gt; class from earlier:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Type families are a useful complement to typeclasses when performing type-level programming. They allow computation to occur entirely at the type-level, which is necessarily computation that occurs entirely at compile-time, and the result can then be passed to a typeclass method to produce a term-level value from the result.&lt;/p&gt;&lt;h3&gt;&lt;a name="example-1-generalized-concat"&gt;&lt;/a&gt;Example 1: Generalized &lt;code&gt;concat&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Finally, using what we’ve discussed so far, we can do our first bit of practical TMP. Specifically, we’re going to define a &lt;code&gt;flatten&lt;/code&gt; function similar to like-named functions provided by many dynamically-typed languages. In those languages, &lt;code&gt;flatten&lt;/code&gt; is like &lt;code&gt;concat&lt;/code&gt;, but it works on a list of arbitrary depth. For example, we might use it like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="p"&gt;[[[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]]]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In Haskell, lists of different depths have different types, so multiple levels of &lt;code&gt;concat&lt;/code&gt; have to be applied explicitly. But using TMP, we can write a generic &lt;code&gt;flatten&lt;/code&gt; function that operates on lists of any depth!&lt;/p&gt;&lt;p&gt;Since this is &lt;em&gt;typeclass&lt;/em&gt; metaprogramming, we’ll unsurprisingly begin with a typeclass:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;???&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Our first challenge is writing the return type of &lt;code&gt;flatten&lt;/code&gt;. Since the argument could be a list of any depth, there’s no direct way to obtain its element type. Fortunately, we can define a type family that does precisely that:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can write our &lt;code&gt;Flatten&lt;/code&gt; instances. The base case is when the type is a list of depth 1, in which case we don’t have any flattening to do:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The inductive case is when the type is a nested list, in which case we want to apply &lt;code&gt;concat&lt;/code&gt; and recur:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concat&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, if we try to compile these definitions, GHC will reject our &lt;code&gt;Flatten [a]&lt;/code&gt; instance:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;error:
    • Couldn't match type ‘a’ with ‘ElementOf [a]’
      ‘a’ is a rigid type variable bound by
        the instance declaration
      Expected type: [ElementOf [a]]
        Actual type: [a]
    • In the expression: x
      In an equation for ‘flatten’: flatten x = x
      In the instance declaration for ‘Flatten [a]’
   |
   |   flatten x = x
   |               ^
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At first blush, this error looks very confusing. Why doesn’t GHC think &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;ElementOf [a]&lt;/code&gt; are the same type? Well, consider what would happen if we picked a type like &lt;code&gt;[Int]&lt;/code&gt; for &lt;code&gt;a&lt;/code&gt;. Then &lt;code&gt;[a]&lt;/code&gt; would be &lt;code&gt;[[Int]]&lt;/code&gt;, a nested list, so the first case of &lt;code&gt;ElementOf&lt;/code&gt; would apply. Therefore, GHC refuses to pick the second equation of &lt;code&gt;ElementOf&lt;/code&gt; so hastily.&lt;/p&gt;&lt;p&gt;In this particular case, we might think that’s rather silly. After all, if &lt;code&gt;a&lt;/code&gt; were &lt;code&gt;[Int]&lt;/code&gt;, then GHC wouldn’t have picked the &lt;code&gt;Flatten [a]&lt;/code&gt; instance to begin with, it would pick the more specific &lt;code&gt;Flatten [[a]]&lt;/code&gt; instance defined below. Therefore, the hypothetical situation above could never happen. Unfortunately, GHC does not realize this, so we find ourselves at an impasse.&lt;/p&gt;&lt;p&gt;Fortunately, we can soothe GHC’s anxiety by adding an extra constraint to our &lt;code&gt;Flatten [a]&lt;/code&gt; instance:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a &lt;em&gt;type equality constraint&lt;/em&gt;. Type equality constraints are written with the syntax &lt;code&gt;a ~ b&lt;/code&gt;, and they state that &lt;code&gt;a&lt;/code&gt; must be the same type as &lt;code&gt;b&lt;/code&gt;. Type equality constraints are mostly useful when type families are involved, since they can be used (as in this case) to require a type family reduce to a certain type. In this case, we’re asserting that &lt;code&gt;ElementOf [a]&lt;/code&gt; must always be &lt;code&gt;a&lt;/code&gt;, which allows the instance to typecheck.&lt;/p&gt;&lt;p&gt;Note that this doesn’t let us completely wriggle out of our obligation, as the type equality constraint must &lt;em&gt;eventually&lt;/em&gt; be checked when the instance is actually used, so initially this might seem like we’ve only deferred the problem to later. But in this case, that’s exactly what we need: by the time the &lt;code&gt;Flatten [a]&lt;/code&gt; instance is selected, GHC will know that &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a list type, and it will be able to reduce &lt;code&gt;ElementOf [a]&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; without difficulty. Indeed, we can see this for ourselves by using &lt;code&gt;flatten&lt;/code&gt; in GHCi:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="p"&gt;[[[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]]]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It works! But why do we need the type annotation on &lt;code&gt;1&lt;/code&gt;? If we leave it out, we get a rather hairy type error:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;error:
    • Couldn't match type ‘ElementOf [a0]’ with ‘ElementOf [a]’
      Expected type: [ElementOf [a]]
        Actual type: [ElementOf [a0]]
      NB: ‘ElementOf’ is a non-injective type family
      The type variable ‘a0’ is ambiguous
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The issue here stems from the polymorphic nature of Haskell number literals. Theoretically, someone could define a &lt;code&gt;Num [a]&lt;/code&gt; instance, in which case &lt;code&gt;1&lt;/code&gt; could actually have a list type, and either case of &lt;code&gt;ElementOf&lt;/code&gt; could match depending on the choice of &lt;code&gt;Num&lt;/code&gt; instance. Of course, no such &lt;code&gt;Num&lt;/code&gt; instance exists, nor should it, but the possibility of it being defined means GHC can’t be certain of the depth of the argument list.&lt;/p&gt;&lt;p&gt;This issue happens to come up a lot in simple examples of TMP, since polymorphic number literals introduce a level of ambiguity. In real programs, this is much less of an issue, since there’s no reason to call &lt;code&gt;flatten&lt;/code&gt; on a completely hardcoded list! However, it’s still important to understand what these type errors mean and why they occur.&lt;/p&gt;&lt;p&gt;That wrinkle aside, &lt;code&gt;flatten&lt;/code&gt; is a functioning example of what useful TMP can look like. We’ve written a single, generic definition that flattens lists of any depth, taking advantage of static type information to choose what to do at runtime.&lt;/p&gt;&lt;h4&gt;&lt;a name="typeclasses-as-compile-time-code-generation"&gt;&lt;/a&gt;Typeclasses as compile-time code generation&lt;/h4&gt;&lt;p&gt;Presented with the above definition of &lt;code&gt;Flatten&lt;/code&gt;, it might not be immediately obvious how to think about &lt;code&gt;Flatten&lt;/code&gt; as a function from types to terms. After all, it looks a lot more like an “ordinary” typeclass (like, say, &lt;code&gt;Eq&lt;/code&gt; or &lt;code&gt;Show&lt;/code&gt;) than the &lt;code&gt;TypeOf&lt;/code&gt; and &lt;code&gt;ReifyNat&lt;/code&gt; classes we defined above.&lt;/p&gt;&lt;p&gt;One useful way to shift our perspective is to consider equivalent &lt;code&gt;Flatten&lt;/code&gt; instances written using point-free style:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ElementOf&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Flatten&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;concat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These definitions of &lt;code&gt;flatten&lt;/code&gt; no longer (syntactically) depend on term-level arguments, just like our definitions of &lt;code&gt;typeOf&lt;/code&gt; and &lt;code&gt;reifyNat&lt;/code&gt; didn’t accept any term-level arguments above. This allows us to consider what &lt;code&gt;flatten&lt;/code&gt; might “expand to” given a type argument alone:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;flatten @[Int]&lt;/code&gt; is just &lt;code&gt;id&lt;/code&gt;, since the &lt;code&gt;Flatten [a]&lt;/code&gt; instance is selected.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;flatten @[[Int]]&lt;/code&gt; is &lt;code&gt;flatten @[Int] . concat&lt;/code&gt;, since the &lt;code&gt;Flatten [[a]]&lt;/code&gt; instance is selected. That then becomes &lt;code&gt;id . concat&lt;/code&gt;, which can be further simplified to just &lt;code&gt;concat&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;flatten @[[[Int]]]&lt;/code&gt; is &lt;code&gt;flatten @[[Int]] . concat&lt;/code&gt;, which simplifies to &lt;code&gt;concat . concat&lt;/code&gt; by the same reasoning above.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;flatten @[[[[Int]]]]&lt;/code&gt; is then &lt;code&gt;concat . concat . concat&lt;/code&gt;, and so on.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This meshes quite naturally with our intuition of typeclasses as functions from types to terms. Each application of &lt;code&gt;flatten&lt;/code&gt; takes a type as an argument and produces some number of composed &lt;code&gt;concat&lt;/code&gt;s as a result. From this perspective, &lt;code&gt;Flatten&lt;/code&gt; is performing a kind of compile-time code generation, synthesizing an expression to do the concatenation on the fly by inspecting the type information.&lt;/p&gt;&lt;p&gt;This framing is one of the key ideas that makes TMP so powerful, and indeed, it explains how it’s worthy of the name &lt;em&gt;metaprogramming&lt;/em&gt;. As we continue to more sophisticated examples of TMP, try to keep this perspective in mind.&lt;/p&gt;&lt;h2&gt;&lt;a name="part-2-generic-programming"&gt;&lt;/a&gt;Part 2: Generic programming&lt;/h2&gt;&lt;p&gt;Part 1 of this blog post established the foundational techniques used in TMP, all of which are useful on their own. If you’ve read up to this point, you now know enough to start applying TMP yourself, and the remainder of this blog post will simply continue to build upon what you already know.&lt;/p&gt;&lt;p&gt;In the previous section, we discussed how to use TMP to write a generic &lt;code&gt;flatten&lt;/code&gt; operation. In this section, we’ll aim a bit higher: totally generic functions that operate on &lt;em&gt;arbitrary&lt;/em&gt; datatypes.&lt;/p&gt;&lt;h3&gt;&lt;a name="open-type-families-and-associated-types"&gt;&lt;/a&gt;Open type families and associated types&lt;/h3&gt;&lt;p&gt;Before we can dive into examples, we need to revisit type families. In the previous sections, we discussed closed type families, but we did not cover their counterpart, &lt;em&gt;open type families&lt;/em&gt;. Like closed type families, open type families are effectively functions from types to types, but unlike closed type families, they are not defined with a predefined set of equations. Instead, new equations are added separately using &lt;code&gt;type instance&lt;/code&gt; declarations. For example, we could define our &lt;code&gt;Sum&lt;/code&gt; family from above like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Sum&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the case of &lt;code&gt;Sum&lt;/code&gt;, this would not be very useful, and indeed, &lt;code&gt;Sum&lt;/code&gt; is much better expressed as a closed type family than an open one. But the advantage of open type families is similar to the advantage of typeclasses: new equations can be added at any time, even in modules other than the one that declares the open type family.&lt;/p&gt;&lt;p&gt;This extensibility means open type families are used less for type-level computation and more for type-level maps that associate types with other types. For example, one might define a &lt;code&gt;Key&lt;/code&gt; open type family that relates types to the types used to index them:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ByteString&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This can be combined with a typeclass to provide a generic way to see if a data structure contains a given key:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, anyone could define their own data structure, define instances of &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;HasKey&lt;/code&gt; for their data structure, and use &lt;code&gt;hasKey&lt;/code&gt; to see if it contains a given key, regardless of the structure of those keys. In fact, it’s so common for open type families and typeclasses to cooperate in this way that GHC provides the option to make the connection explicit by defining them together:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Vector&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;HasKey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Key&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ByteString&lt;/span&gt;
  &lt;span class="n"&gt;hasKey&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Trie&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An open family declared inside a typeclass like this is called an &lt;em&gt;associated type&lt;/em&gt;. It works exactly the same way as the separate definitions of &lt;code&gt;Key&lt;/code&gt; and &lt;code&gt;HasKey&lt;/code&gt;, it just uses a different syntax. Note that although the &lt;code&gt;family&lt;/code&gt; and &lt;code&gt;instance&lt;/code&gt; keywords have disappeared from the declarations, that is only an abbreviation; the keywords are simply implicitly added (and explicitly writing them is still allowed, though most people do not).&lt;/p&gt;&lt;p&gt;Open type families and associated types are extremely useful for abstracting over similar types with slightly different structure, and libraries like &lt;a href="https://hackage.haskell.org/package/mono-traversable"&gt;&lt;code&gt;mono-traversable&lt;/code&gt;&lt;/a&gt; are examples of how they can be used to that end for their full effect. However, those use cases can’t really be classified as TMP, just using typeclasses for their traditional purpose of operation overloading.&lt;/p&gt;&lt;p&gt;However, that doesn’t mean open type families aren’t useful for TMP. In fact, one use case of TMP makes &lt;em&gt;heavy&lt;/em&gt; use of open type families: datatype-generic programming.&lt;/p&gt;&lt;h3&gt;&lt;a name="example-2-datatype-generic-programming"&gt;&lt;/a&gt;Example 2: Datatype-generic programming&lt;/h3&gt;&lt;p&gt;&lt;em&gt;Datatype-generic programming&lt;/em&gt; refers to a class of techniques for writing generic functions that operate on arbitrary data structures. Some useful applications of datatype-generic programming include&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;equality, comparison, and hashing,&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;recursive traversal of self-similar data structures, and&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;serialization and deserialization,&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;among other things. The idea is that by exploiting the structure of datatype definitions themselves, it’s possible for a datatype-generic function to provide implementations of functionality like the above on &lt;em&gt;any&lt;/em&gt; datatype.&lt;/p&gt;&lt;p&gt;In Haskell, the most popular approach to datatype-generic programming leverages GHC generics, which is quite sophisticated. The &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Generics.html"&gt;module documentation for &lt;code&gt;GHC.Generics&lt;/code&gt;&lt;/a&gt; already includes a fairly lengthy explanation of how it works, so I will not regurgitate it here (that could fill a blog post of its own!), but I will show how to construct a simplified version of the system that highlights the key role of TMP.&lt;/p&gt;&lt;h4&gt;&lt;a name="generic-datatype-representations"&gt;&lt;/a&gt;Generic datatype representations&lt;/h4&gt;&lt;p&gt;At the heart of the &lt;code&gt;Generic&lt;/code&gt; class is a simple concept: all non-GADT Haskell datatypes can be represented as sums of products. For example, if we have&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt;
  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;AuthBasic&lt;/span&gt; &lt;span class="kt"&gt;Username&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;AuthSSH&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;then we have a type that is essentially equivalent to this one:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we know how to define a function on a nested tree built out of &lt;code&gt;Either&lt;/code&gt;s and pairs, then we know how to define it on &lt;em&gt;any&lt;/em&gt; such datatype! This is where TMP comes in: recall the way we viewed &lt;code&gt;Flatten&lt;/code&gt; as a mechanism for compile-time code generation based on type information. Could we use the same technique to generate implementations of equality, comparison, hashing, etc. from statically-known information about the structure of a datatype?&lt;/p&gt;&lt;p&gt;The answer to that question is &lt;em&gt;yes&lt;/em&gt;. To start, let’s consider a particularly simple example: suppose we want to write a generic function that counts the number of fields stored in an arbitrary constructor. For example, &lt;code&gt;numFields (AuthBasic "alyssa" "pass1234")&lt;/code&gt; would return &lt;code&gt;2&lt;/code&gt;, while &lt;code&gt;numFields (AuthSSH "&amp;lt;key&amp;gt;")&lt;/code&gt; would return &lt;code&gt;1&lt;/code&gt;. Not a very useful function, admittedly, but it’s a simple example of what generic programming can do.&lt;/p&gt;&lt;p&gt;We’ll start by using TMP to implement a “generic” version of &lt;code&gt;numFields&lt;/code&gt; that operates on trees of &lt;code&gt;Either&lt;/code&gt;s and pairs as described above:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;

&lt;span class="c1"&gt;-- base case: leaf value&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="cm"&gt;{-# OVERLAPPING #-}&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just like our &lt;code&gt;Flatten&lt;/code&gt; class from earlier, &lt;code&gt;GNumFields&lt;/code&gt; uses the type-level structure of its argument to choose what to do:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;If we find a pair, that corresponds to a product, so we recur into both sides and sum the results.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If we find &lt;code&gt;Left&lt;/code&gt; or &lt;code&gt;Right&lt;/code&gt;, that corresponds to the “spine” differentiating different constructors, so we simply recur into the contained value.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;In the case of any other value, we’re at a “leaf” in the tree of &lt;code&gt;Either&lt;/code&gt;s and pairs, which corresponds to a single field, so we just return &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Now if we call &lt;code&gt;gnumFields (Left ("alyssa", "pass1234"))&lt;/code&gt;, we’ll get &lt;code&gt;2&lt;/code&gt;, and if we call &lt;code&gt;gnumFields (Right "&amp;lt;key&amp;gt;")&lt;/code&gt;, we’ll get &lt;code&gt;1&lt;/code&gt;. All that’s left to do is write a bit of code that converts our &lt;code&gt;Authentication&lt;/code&gt; type to a tree of &lt;code&gt;Either&lt;/code&gt;s and pairs:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;genericizeAuthentication&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;
&lt;span class="nf"&gt;genericizeAuthentication&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthBasic&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;genericizeAuthentication&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthSSH&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;

&lt;span class="nf"&gt;numFieldsAuthentication&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;
&lt;span class="nf"&gt;numFieldsAuthentication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;genericizeAuthentication&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we get the results we want on our &lt;code&gt;Authentication&lt;/code&gt; type using &lt;code&gt;numFieldsAuthentication&lt;/code&gt;, but we’re not done yet, since it only works on &lt;code&gt;Authentication&lt;/code&gt; values. Is there a way to define a generic &lt;code&gt;numFields&lt;/code&gt; function that works on arbitrary datatypes that implement this conversion to sums-of-products? Yes, with another typeclass:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthBasic&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthSSH&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;

&lt;span class="nf"&gt;numFields&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;
&lt;span class="nf"&gt;numFields&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;genericize&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now &lt;code&gt;numFields (AuthBasic "alyssa" "pass1234")&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;, as desired, and it will &lt;em&gt;also&lt;/em&gt; work with any datatype that provides a &lt;code&gt;Generic&lt;/code&gt; instance. If the above code makes your head spin, don’t worry: this is by far the most complicated piece of code in this blog post up to this point. Let’s break down how it works piece by piece:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;First, we define the &lt;code&gt;Generic&lt;/code&gt; class, comprised of two parts:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;The &lt;code&gt;Rep a&lt;/code&gt; associated type maps a type &lt;code&gt;a&lt;/code&gt; onto its generic, sums-of-products representation, i.e. one built out of combinations of &lt;code&gt;Either&lt;/code&gt; and pairs.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The &lt;code&gt;genericize&lt;/code&gt; method converts an actual &lt;em&gt;value&lt;/em&gt; of type &lt;code&gt;a&lt;/code&gt; to the equivalent value using the sums-of-products representation.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Next, we define a &lt;code&gt;Generic&lt;/code&gt; instance for &lt;code&gt;Authentication&lt;/code&gt;. &lt;code&gt;Rep Authentication&lt;/code&gt; is the sums-of-products representation we described above, and &lt;code&gt;genericize&lt;/code&gt; is likewise &lt;code&gt;genericizeAuthentication&lt;/code&gt; from above.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, we define &lt;code&gt;numFields&lt;/code&gt; as a function with a &lt;code&gt;GNumFields (Rep a)&lt;/code&gt; constraint. This is where all the magic happens:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;When we apply &lt;code&gt;numFields&lt;/code&gt; to a datatype, &lt;code&gt;Rep&lt;/code&gt; retrieves its generic, sums-of-products representation type.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The &lt;code&gt;GNumFields&lt;/code&gt; class then uses various TMP techniques we’ve already described so far in this blog post to generate a &lt;code&gt;numFields&lt;/code&gt; implementation on the fly from the structure of &lt;code&gt;Rep a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, that generated &lt;code&gt;numFields&lt;/code&gt; implementation is applied to the genericized term-level value, and the result is produced.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;After all that, I suspect you might think this seems like a very convoluted way to define the (rather unhelpful) &lt;code&gt;numFields&lt;/code&gt; operation. Surely just defining &lt;code&gt;numFields&lt;/code&gt; on each type directly would be far easier? Indeed, if we were just considering &lt;code&gt;numFields&lt;/code&gt;, you’d be right, but in fact we get much more than that. Using the same machinery, we can continue to define other generic operations—equality, comparison, etc.—the same way we defined &lt;code&gt;numFields&lt;/code&gt;, and all of them would automatically work on &lt;code&gt;Authentication&lt;/code&gt; because they all leverage the same &lt;code&gt;Generic&lt;/code&gt; instance!&lt;/p&gt;&lt;p&gt;This is the basic value proposition of generic programming: we can do a little work up front to normalize our datatype to a generic representation &lt;em&gt;once&lt;/em&gt;, then get a whole buffet of generic operations on it for free. In Haskell, the code generation capabilities of TMP is a key piece of that puzzle.&lt;/p&gt;&lt;h4&gt;&lt;a name="improving-our-definition-of-generic"&gt;&lt;/a&gt;Improving our definition of &lt;code&gt;Generic&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;You may note that the definition of &lt;code&gt;Generic&lt;/code&gt; provided above does not match the one in &lt;code&gt;GHC.Generic&lt;/code&gt;. Indeed, our naïve approach suffers from several flaws that the real version does not. This is not a &lt;code&gt;GHC.Generics&lt;/code&gt; tutorial, so I will not discuss every detail of the full implementation, but I will highlight a few improvements relevant to the broader theme of TMP.&lt;/p&gt;&lt;h5&gt;&lt;a name="distinguishing-leaves-from-the-spine"&gt;&lt;/a&gt;Distinguishing leaves from the spine&lt;/h5&gt;&lt;p&gt;One problem with our version of &lt;code&gt;Generic&lt;/code&gt; is that it provides no way to distinguish an &lt;code&gt;Either&lt;/code&gt; or pair that should be considered a “leaf”, as in a type like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;A&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;B&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Given this type, &lt;code&gt;Rep Foo&lt;/code&gt; should be &lt;code&gt;Either (Either Int String) (Char, Bool)&lt;/code&gt;, and &lt;code&gt;numFields (Right ('a', True))&lt;/code&gt; will erroneously return &lt;code&gt;2&lt;/code&gt; rather than &lt;code&gt;1&lt;/code&gt;. To fix this, we can introduce a simple wrapper newtype that distinguishes leaves specifically:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;getLeaf&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now our &lt;code&gt;Generic&lt;/code&gt; instances look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="kt"&gt;Authentication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="kt"&gt;Username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="kt"&gt;Password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="kt"&gt;PublicKey&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthBasic&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;AuthSSH&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;A&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;B&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since the &lt;code&gt;Leaf&lt;/code&gt; constructor now distinguishes a leaf, rather than the absence of an &lt;code&gt;Either&lt;/code&gt; or &lt;code&gt;(,)&lt;/code&gt; constructor, we’ll have to update our &lt;code&gt;GNumFields&lt;/code&gt; instances as well. However, this has the additional pleasant effect of eliminating the need for overlapping instances:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;  
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a good example of why overlapping instances can be so seductive, but they often have unintended consequences. Even when doing TMP, explicit tags are almost always preferable.&lt;/p&gt;&lt;h5&gt;&lt;a name="handling-empty-constructors"&gt;&lt;/a&gt;Handling empty constructors&lt;/h5&gt;&lt;p&gt;Suppose we have a type with nullary data constructors, like the standard &lt;code&gt;Bool&lt;/code&gt; type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;How do we write a &lt;code&gt;Generic&lt;/code&gt; instance for &lt;code&gt;Bool&lt;/code&gt;? Using just &lt;code&gt;Either&lt;/code&gt;, &lt;code&gt;(,)&lt;/code&gt;, and &lt;code&gt;Leaf&lt;/code&gt;, we can’t, but if we are willing to add a case for &lt;code&gt;()&lt;/code&gt;, we can use it to denote nullary constructors:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;GNumFields&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;gnumFields&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Rep&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;genericize&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In a similar vein, we could use &lt;code&gt;Void&lt;/code&gt; to represent datatypes that don’t have any constructors at all.&lt;/p&gt;&lt;h4&gt;&lt;a name="continuing-from-here"&gt;&lt;/a&gt;Continuing from here&lt;/h4&gt;&lt;p&gt;The full version of &lt;code&gt;Generic&lt;/code&gt; has a variety of further improvements useful for generic programming, including:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Support for converting from &lt;code&gt;Rep a&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Special indication of self-recursive datatypes, making generic tree traversals possible.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Type-level information about datatype constructor and record accessor names, allowing them to be used in serialization.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Fully automatic generation of &lt;code&gt;Generic&lt;/code&gt; instances via &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/generics.html#extension-DeriveGeneric"&gt;the &lt;code&gt;DeriveGeneric&lt;/code&gt; extension&lt;/a&gt;, which reduces the per-type boilerplate to essentially nothing.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Generics.html"&gt;module documentation for &lt;code&gt;GHC.Generics&lt;/code&gt;&lt;/a&gt; discusses the full system in detail, and it provides an additional example that uses the same essential TMP techniques discussed here.&lt;/p&gt;&lt;h2&gt;&lt;a name="part-3-dependent-typing"&gt;&lt;/a&gt;Part 3: Dependent typing&lt;/h2&gt;&lt;p&gt;It’s time for the third and final part of this blog post: an introduction to dependently typed programming in Haskell. A full treatment of dependently typed programming is far, far too vast to be contained in a single blog post, so I will not attempt to do so here. Rather, I will cover some basic idioms for doing dependent programming and highlight how TMP can be valuable when doing so.&lt;/p&gt;&lt;h3&gt;&lt;a name="datatype-promotion"&gt;&lt;/a&gt;Datatype promotion&lt;/h3&gt;&lt;p&gt;In part 1, we used uninhabited datatypes like &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;S a&lt;/code&gt; to define new type-level constants. This works, but it is awkward. Imagine for a moment that we wanted to work with type-level booleans. Using our previous approach, we could define two empty datatypes, &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we could define type families to provide operations on these types, such as &lt;code&gt;Not&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
  &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, this has some frustrating downsides:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;First, it’s simply inconvenient that we have to define these new &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; “dummy” types, which are completely distinct from the &lt;code&gt;Bool&lt;/code&gt; type provided by the prelude.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;More significantly, it means &lt;code&gt;Not&lt;/code&gt; has a very unhelpful kind:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kind&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt;
&lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Even though &lt;code&gt;Not&lt;/code&gt; is only &lt;em&gt;supposed&lt;/em&gt; to be applied to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;, its kind allows it to be applied to any type at all. You can see this in practice if you try to evaluate something like &lt;code&gt;Not Char&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kind&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;
&lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Rather than getting an error, GHC simply spits &lt;code&gt;Not Char&lt;/code&gt; back at us. This is a somewhat unintuitive property of closed type families: if none of the clauses match, the type family just gets “stuck,” not reducing any further. This can lead to very confusing type errors later in the typechecking process.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;One way to think about &lt;code&gt;Not&lt;/code&gt; is that it is largely &lt;em&gt;dynamically kinded&lt;/em&gt; in the same way some languages are dynamically typed. That isn’t entirely true, as we technically &lt;em&gt;will&lt;/em&gt; get a kind error if we try to apply &lt;code&gt;Not&lt;/code&gt; to a type constructor rather than a type, such as &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ghci&amp;gt; :kind! Not Maybe

&amp;lt;interactive&amp;gt;:1:5: error:
    • Expecting one more argument to ‘Maybe’
      Expected a type, but ‘Maybe’ has kind ‘* -&amp;gt; *’
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;…but &lt;code&gt;*&lt;/code&gt; is still a very big kind, much bigger than we would like to permit for &lt;code&gt;Not&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;To help with both these problems, GHC provides &lt;em&gt;datatype promotion&lt;/em&gt; via &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/data_kinds.html"&gt;the &lt;code&gt;DataKinds&lt;/code&gt; language extension&lt;/a&gt;. The idea is that for each normal, non-GADT type definition like&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;then in addition to the normal type constructor and value constructors, GHC also defines several &lt;em&gt;promoted&lt;/em&gt; constructors:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Bool&lt;/code&gt; is allowed as both a type and a kind.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;'True&lt;/code&gt; and &lt;code&gt;'False&lt;/code&gt; are defined as new types of kind &lt;code&gt;Bool&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We can see this in action if we remove our &lt;code&gt;data True&lt;/code&gt; and &lt;code&gt;data False&lt;/code&gt; declarations and adjust our definition of &lt;code&gt;Not&lt;/code&gt; to use promoted constructors:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="cm"&gt;{-# LANGUAGE DataKinds #-}&lt;/span&gt;

&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;True&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;False&lt;/span&gt;
  &lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;False&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the inferred kind of &lt;code&gt;Not&lt;/code&gt; is no longer &lt;code&gt;* -&amp;gt; *&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;kind&lt;/span&gt; &lt;span class="kt"&gt;Not&lt;/span&gt;
&lt;span class="kt"&gt;Not&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Consequently, we will now get a kind error if we attempt to apply &lt;code&gt;Not&lt;/code&gt; to anything other than &lt;code&gt;'True&lt;/code&gt; or &lt;code&gt;'False&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ghci&amp;gt; :kind! Not Char

&amp;lt;interactive&amp;gt;:1:5: error:
    • Expected kind ‘Bool’, but ‘Char’ has kind ‘*’
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a nice improvement. We can make a similar change to our definitions involving type-level natural numbers:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;S&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Nat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Z&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ReifyNat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;&amp;#39;S&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;reifyNat&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that we need to add an explicit kind signature on the definition of the &lt;code&gt;ReifyNat&lt;/code&gt; typeclass, since otherwise GHC will assume &lt;code&gt;a&lt;/code&gt; has kind &lt;code&gt;*&lt;/code&gt;, since nothing in the types of the typeclass methods suggests otherwise. In addition to making it clearer that &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt; are related, this prevents someone from coming along and defining a nonsensical instance like &lt;code&gt;ReifyNat Char&lt;/code&gt;, which previously would have been allowed but will now be rejected with a kind error.&lt;/p&gt;&lt;p&gt;Datatype promotion is not strictly required to do TMP, but makes the process significantly less painful. It makes Haskell’s kind language extensible in the same way its type language is, which allows type-level programming to enjoy static typechecking (or more accurately, static kindchecking) in the same way term-level programming does.&lt;/p&gt;&lt;h3&gt;&lt;a name="gadts-and-proof-terms"&gt;&lt;/a&gt;GADTs and proof terms&lt;/h3&gt;&lt;p&gt;So far in this blog post, we have discussed several different function-like things:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Ordinary Haskell functions are functions from terms to terms.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Type families are functions from types to types.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Typeclasses are functions from types to terms.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;A curious reader may wonder about the existence of a fourth class of function:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;???&lt;/em&gt; are functions from terms to types.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;To reason about what could go in the &lt;em&gt;???&lt;/em&gt; above, we must consider what “a function from terms to types” would even mean. Functions from terms to terms and types to types are straightforward enough. Functions from types to terms are a little trickier, but they make intuitive sense: we use information known at compile-time to generate runtime behavior. But how could information possibly flow in the other direction? How could we possibly turn runtime information into compile-time information without being able to predict the future?&lt;/p&gt;&lt;p&gt;In general, we cannot. However, one feature of Haskell allows a restricted form of seemingly doing the impossible—turning runtime information into compile-time information—and that’s GADTs.&lt;/p&gt;&lt;p&gt;GADTs&lt;sup&gt;&lt;a href="#footnote-4" id="footnote-ref-4-1"&gt;4&lt;/a&gt;&lt;/sup&gt; are &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/gadt.html"&gt;described in detail in the GHC User’s Guide&lt;/a&gt;, but the key idea for our purposes is that &lt;em&gt;pattern-matching on a GADT constructor can refine type information&lt;/em&gt;. Here’s a simple, silly example:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;ABool&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
  &lt;span class="kt"&gt;AnInt&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;

&lt;span class="nf"&gt;doSomething&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;doSomething&lt;/span&gt; &lt;span class="kt"&gt;ABool&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;doSomething&lt;/span&gt; &lt;span class="kt"&gt;AnInt&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, &lt;code&gt;WhatIsIt&lt;/code&gt; is a datatype with two nullary constructors, &lt;code&gt;ABool&lt;/code&gt; and &lt;code&gt;AnInt&lt;/code&gt;, similar to a normal, non-GADT datatype like this one:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;WhatIsIt&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ABool&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;AnInt&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What’s special about GADTs is that each constructor is given an explicit type signature. With the plain ADT definition above, &lt;code&gt;ABool&lt;/code&gt; and &lt;code&gt;AnInt&lt;/code&gt; would both have the type &lt;code&gt;forall a. WhatIsIt a&lt;/code&gt;, but in the GADT definition, we explicitly fix &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;Bool&lt;/code&gt; in the type of &lt;code&gt;ABool&lt;/code&gt; and to &lt;code&gt;Int&lt;/code&gt; in the type of &lt;code&gt;AnInt&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;This simple feature allows us to do very interesting things. The &lt;code&gt;doSomething&lt;/code&gt; function is polymorphic in &lt;code&gt;a&lt;/code&gt;, but on the right-hand side of the first equation, &lt;code&gt;x&lt;/code&gt; has type &lt;code&gt;Bool&lt;/code&gt;, while on the right-hand side of the second equation, &lt;code&gt;x&lt;/code&gt; has type &lt;code&gt;Int&lt;/code&gt;. This is because the &lt;code&gt;WhatIsIt a&lt;/code&gt; argument effectively constrains the type of &lt;code&gt;a&lt;/code&gt;, as we can see by experimenting with &lt;code&gt;doSomething&lt;/code&gt; in GHCi:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ghci&amp;gt; doSomething ABool True
False
ghci&amp;gt; doSomething AnInt 10
11
ghci&amp;gt; doSomething AnInt True

error:
    • Couldn't match expected type ‘Int’ with actual type ‘Bool’
    • In the second argument of ‘doSomething’, namely ‘True’
      In the expression: doSomething AnInt True
      In an equation for ‘it’: it = doSomething AnInt True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One way to think about GADTs is as “proofs” or “witnesses” of type equalities. The &lt;code&gt;ABool&lt;/code&gt; constructor is a proof of &lt;code&gt;a ~ Bool&lt;/code&gt;, while the &lt;code&gt;AnInt&lt;/code&gt; constructor is a proof of &lt;code&gt;a ~ Int&lt;/code&gt;. When you construct &lt;code&gt;ABool&lt;/code&gt; or &lt;code&gt;AnInt&lt;/code&gt;, you must be able to satisfy the equality, and it is in a sense “packed into” the constructor value. When code pattern-matches on the constructor, the equality is “unpacked from” the value, and the equality becomes available on the right-hand side of the pattern match.&lt;/p&gt;&lt;p&gt;GADTs can be much more sophisticated than our simple &lt;code&gt;WhatIsIt&lt;/code&gt; type above. Just like normal ADTs, GADT constructors can have parameters, which makes it possible to write inductive datatypes that carry type equality proofs with them:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;infixr&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt;

&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;HNil&lt;/span&gt;  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;
  &lt;span class="kt"&gt;HCons&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This type is a &lt;em&gt;heterogenous list&lt;/em&gt;, a list that can contain elements of different types:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
&lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Num&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[Bool, [Char]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An &lt;code&gt;HList&lt;/code&gt; is parameterized by a type-level list that keeps track of the types of its elements, which allows us to highlight another interesting property of GADTs: if we restrict that type information, the GHC pattern exhaustiveness checker will take the restriction into account. For example, we can write a completely total &lt;code&gt;head&lt;/code&gt; function on &lt;code&gt;HList&lt;/code&gt;s like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) -&amp;gt; a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Remarkably, GHC does not complain that this definition of &lt;code&gt;head&lt;/code&gt; is non-exhaustive. Since we specified that the argument must be of type &lt;code&gt;HList (a ': as)&lt;/code&gt; in the type signature for &lt;code&gt;head&lt;/code&gt;, GHC knows that the argument &lt;em&gt;cannot&lt;/em&gt; be &lt;code&gt;HNil&lt;/code&gt; (which would have the type &lt;code&gt;HList '[]&lt;/code&gt;), so it doesn’t ask us to handle that case.&lt;/p&gt;&lt;p&gt;These examples illustrate the way GADTs serve as a general-purpose construct for relating type- and term-level information. Information flows bidirectionally: type information refines the set of type constructors that can be matched on, and matching on type constructors exposes new type equalities.&lt;/p&gt;&lt;h4&gt;&lt;a name="proofs-that-work-together"&gt;&lt;/a&gt;Proofs that work together&lt;/h4&gt;&lt;p&gt;This interplay is wonderfully compositional. Suppose we wanted to write a function that accepts an &lt;code&gt;HList&lt;/code&gt; of exactly 1, 2, or 3 elements. There’s no easy way to express that in the type signature the way we did with &lt;code&gt;head&lt;/code&gt;, so it might seem like all we can do is write an entirely new container datatype that has three constructors, one for each case.&lt;/p&gt;&lt;p&gt;However, a more interesting solution exists that takes advantage of the bidirectional nature of GADTs. We can start by writing a &lt;em&gt;proof term&lt;/em&gt; that contains no values, it just encapsulates type equalities on a type-level list:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;One&lt;/span&gt;   &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[a]&lt;/span&gt;
  &lt;span class="kt"&gt;Two&lt;/span&gt;   &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[a, b]&lt;/span&gt;
  &lt;span class="kt"&gt;Three&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[a, b, c]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We call it a proof term because a value of type &lt;code&gt;OneToThree a b c as&lt;/code&gt; constitutes a &lt;em&gt;proof&lt;/em&gt; that &lt;code&gt;as&lt;/code&gt; has exactly 1, 2, or 3 elements. Using &lt;code&gt;OneToThree&lt;/code&gt;, we can write a function that accepts an &lt;code&gt;HList&lt;/code&gt; accompanied by a proof term:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;sumUpToThree&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToThree&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="nf"&gt;sumUpToThree&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;sumUpToThree&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;           &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="nf"&gt;sumUpToThree&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As with &lt;code&gt;head&lt;/code&gt;, this function is completely exhaustive, in this case because we take full advantage of the bidirectional nature of GADTs:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;When we match on the &lt;code&gt;OneToThree&lt;/code&gt; proof term, information flows from the term level to the type level, refining the type of &lt;code&gt;as&lt;/code&gt; in that branch.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The refined type of &lt;code&gt;as&lt;/code&gt; then flows back down to the term level, restricting the shape the &lt;code&gt;HList&lt;/code&gt; can take and refinine the set of patterns we have to match.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Of course, this example is not especially useful, but in general proof terms can encode any number of useful properties. For example, we can write a proof term that ensures an &lt;code&gt;HList&lt;/code&gt; has an even number of elements:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;EvenNil&lt;/span&gt;  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;
  &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a proof which itself has inductive structure: &lt;code&gt;EvenCons&lt;/code&gt; takes a proof that &lt;code&gt;as&lt;/code&gt; has an even number of elements and produces a proof that adding two more elements preserves the evenness. We can combine this with a type family to write a function that “pairs up” elements in an &lt;code&gt;HList&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;            &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;
  &lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: PairUp as&lt;/span&gt;

&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;         &lt;span class="kt"&gt;HNil&lt;/span&gt;                     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;pairUp&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Once again, this definition is completely exhaustive, and we can show that it works in GHCi:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This ability to capture properties of a type using auxiliary proof terms, rather than having to define an entirely new type, is one of the things that makes dependently typed programming so powerful.&lt;/p&gt;&lt;h4&gt;&lt;a name="proof-inference"&gt;&lt;/a&gt;Proof inference&lt;/h4&gt;&lt;p&gt;While our definition of &lt;code&gt;pairUp&lt;/code&gt; is interesting, you may be skeptical of its practical utility. It’s fiddly and inconvenient to have to pass the &lt;code&gt;Even&lt;/code&gt; proof term explicitly, since it must be updated every time the length of the list changes. Fortunately, this is where TMP comes in.&lt;/p&gt;&lt;p&gt;Remember that typeclasses are functions from types to terms. As its happens, a value of type &lt;code&gt;Even as&lt;/code&gt; can be mechanically produced from the structure of the type &lt;code&gt;as&lt;/code&gt;. This suggests that we could use TMP to automatically generate &lt;code&gt;Even&lt;/code&gt; proofs, and indeed, we can. In fact, it’s not at all complicated:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;evenProof&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now adjust our &lt;code&gt;pairUp&lt;/code&gt; function to use &lt;code&gt;IsEven&lt;/code&gt; instead of an explicit &lt;code&gt;Even&lt;/code&gt; argument:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;         &lt;span class="kt"&gt;HNil&lt;/span&gt;                     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
  &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="n"&gt;even&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is essentially identical to its old definition, but by acquiring the proof via &lt;code&gt;IsEven&lt;/code&gt; rather than passing it explicitly, we can call &lt;code&gt;pairUp&lt;/code&gt; without having to construct a proof manually:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is rather remarkable. Using TMP, we are able to get GHC to &lt;em&gt;automatically construct a proof that a list is even&lt;/em&gt;, with no programmer guidance beyond writing the &lt;code&gt;IsEven&lt;/code&gt; typeclass. This relies once more on the perspective that typeclasses are functions that accept types and generate term-level code: &lt;code&gt;IsEven&lt;/code&gt; is a function that accepts a type-level list and generates an &lt;code&gt;Even&lt;/code&gt; proof term.&lt;/p&gt;&lt;p&gt;From this perspective, &lt;strong&gt;typeclasses are a way of specifying a proof search algorithm&lt;/strong&gt; to the compiler. In the case of &lt;code&gt;IsEven&lt;/code&gt;, the proofs being generated are rather simple, so the proof search algorithm is quite mechanical. But in general, typeclasses can be used to perform proof search of significant complexity, given a sufficiently clever encoding into the type system.&lt;/p&gt;&lt;h3&gt;&lt;a name="aside-gadts-versus-type-families"&gt;&lt;/a&gt;Aside: GADTs versus type families&lt;/h3&gt;&lt;p&gt;Before moving on, I want to explicitly call attention to the relationship between GADTs and type families. Though at first glance they may seem markedly different, there are some similarities between the two, and sometimes they may be used to accomplish similar things.&lt;/p&gt;&lt;p&gt;Consider again the type of the &lt;code&gt;pairUp&lt;/code&gt; function above (without the typeclass for simplicity):&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We used both a GADT, &lt;code&gt;Even&lt;/code&gt;, and a type family, &lt;code&gt;PairUp&lt;/code&gt;. But we could have, in theory, used &lt;em&gt;only&lt;/em&gt; a GADT and eliminated the type family altogether. Consider this variation on the &lt;code&gt;Even&lt;/code&gt; proof term:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;EvenNil&lt;/span&gt;  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;
  &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: bs)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This type has two type parameters rather than one, and though there’s no distinction between the two from GHC’s point of view, it can be useful to think of &lt;code&gt;as&lt;/code&gt; as an “input” parameter and &lt;code&gt;bs&lt;/code&gt; as an “output” parameter. The idea is that any &lt;code&gt;EvenPairs&lt;/code&gt; proof relates both an even-length list type and its paired up equivalent:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;EvenNil&lt;/code&gt; has type &lt;code&gt;EvenPairs '[] '[]&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;EvenCons EvenNil&lt;/code&gt; has type &lt;code&gt;EvenPairs '[a, b] '[(a, b)]&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;EvenCons (EvenCons EvenNil)&lt;/code&gt; has type &lt;code&gt;EvenPairs '[a, b, c, d] '[(a, b), (c, d)]&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;…and so on.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This allows us to reformulate our &lt;code&gt;pairUp&lt;/code&gt; type signature this way:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;EvenPairs&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The definition is otherwise unchanged. The &lt;code&gt;PairUp&lt;/code&gt; type family is completely gone, because now &lt;code&gt;EvenPairs&lt;/code&gt; itself defines the relation. In this way, GADTs can be used like type-level functions!&lt;/p&gt;&lt;p&gt;The inverse, however, is not true, at least not directly: we cannot eliminate the GADT altogether and exclusively use type families. One way to attempt doing so would be to define a type family that returns a constraint rather than a type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Data.Kind&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Constraint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Constraint&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;            &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: _&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The idea here is that &lt;code&gt;IsEvenTF as&lt;/code&gt; produces a constraint can only be satisfied if &lt;code&gt;as&lt;/code&gt; has an even number of elements, since that’s the only way it will eventually reduce to &lt;code&gt;()&lt;/code&gt;, which in this case means the empty set of constraints, not the unit type (yes, the syntax for that is confusing). And in fact, it’s true that putting &lt;code&gt;IsEvenTF as =&amp;gt;&lt;/code&gt; in a type signature successfully restricts &lt;code&gt;as&lt;/code&gt; to be an even-length list, but it doesn’t allow us to write &lt;code&gt;pairUp&lt;/code&gt;. To see why, we can try the following definition:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PairUp&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;                     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;
&lt;span class="nf"&gt;pairUp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;pairUp&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unlike the version using the GADT, this version of &lt;code&gt;pairUp&lt;/code&gt; is not considered exhaustive:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for ‘pairUp’: Patterns not matched: HCons _ HNil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is because type families don’t provide the same bidirectional flow of information that GADTs do, they’re only type-level functions. The constraint generated by &lt;code&gt;IsEvenTF&lt;/code&gt; provides no term-level evidence about the shape of &lt;code&gt;as&lt;/code&gt;, so we can’t branch on it the way we can branch on the &lt;code&gt;Even&lt;/code&gt; GADT.&lt;sup&gt;&lt;a href="#footnote-5" id="footnote-ref-5-1"&gt;5&lt;/a&gt;&lt;/sup&gt; (In a sense, &lt;code&gt;IsEvenTF&lt;/code&gt; is doing &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;validation, not parsing&lt;/a&gt;.)&lt;/p&gt;&lt;p&gt;For this reason, I caution against overuse of type families. Their simplicity is seductive, but all too often you pay for that simplicity with inflexibility. GADTs combined with TMP for proof inference can provide the best of both worlds: complete control over the term-level proof that gets generated while still letting the compiler do most of the work for you.&lt;/p&gt;&lt;h3&gt;&lt;a name="guiding-type-inference"&gt;&lt;/a&gt;Guiding type inference&lt;/h3&gt;&lt;p&gt;So far, this blog post has given relatively little attention to type inference. That is in some part a testament to the robustness of GHC’s type inference algorithm: even when fairly sophisticated TMP is involved, GHC often manages to propagate enough type information that type annotations are rarely needed.&lt;/p&gt;&lt;p&gt;However, when doing TMP, it would be irresponsible to not at least consider the type inference properties of programs. Type inference is what drives the whole typeclass resolution process to begin with, so poor type inference can easily make your fancy TMP construction next to useless. To take advantage of GHC to the fullest extent, programs should proactively guide the typechecker to help it infer as much as possible as often as possible.&lt;/p&gt;&lt;p&gt;To illustrate what that can look like, suppose we want to use TMP to generate an &lt;code&gt;HList&lt;/code&gt; full of &lt;code&gt;()&lt;/code&gt; values of an arbitrary length:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Testing in GHCi, we can see it behaves as desired:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[(), (), ()]&lt;/span&gt;
&lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now suppose we write a function that accepts a list containing exactly one element and returns it:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;unsingleton&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;HList&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[a]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;unsingleton&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="kt"&gt;HNil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Naturally, we would expect these to compose without a hitch. If we write &lt;code&gt;unsingleton unitList&lt;/code&gt;, our TMP should generate a list of length 1, and we should get back &lt;code&gt;()&lt;/code&gt;. However, it may surprise you to learn that &lt;em&gt;isn’t&lt;/em&gt;, in fact, what happens:&lt;sup&gt;&lt;a href="#footnote-6" id="footnote-ref-6-1"&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ghci&amp;gt; unsingleton unitList

error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘unitList’
      prevents the constraint ‘(UnitList '[a0])’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance UnitList as =&amp;gt; UnitList (() : as)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What went wrong? The type error says that &lt;code&gt;a0&lt;/code&gt; is ambiguous, but it only lists a single matching &lt;code&gt;UnitList&lt;/code&gt; instance—the one we want—so how can it be ambiguous which one to select?&lt;/p&gt;&lt;p&gt;The problem stems from the way we defined &lt;code&gt;UnitList&lt;/code&gt;. When we wrote the instance&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) where&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;we said the first element of the type-level list must be &lt;code&gt;()&lt;/code&gt;, so there’s nothing stopping someone from coming along and defining another instance:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In that case, GHC would have no way to know which instance to pick. Nothing in the type of &lt;code&gt;unsingleton&lt;/code&gt; forces the element in the list to have type &lt;code&gt;()&lt;/code&gt;, so both instances are equally valid. To hedge against this future possibility, GHC rejects the program as ambiguous from the start.&lt;/p&gt;&lt;p&gt;Of course, this isn’t what we want. The &lt;code&gt;UnitList&lt;/code&gt; class is supposed to &lt;em&gt;always&lt;/em&gt; return a list of &lt;code&gt;()&lt;/code&gt; values, so how can we force GHC to pick our instance anyway? The answer is to play a trick:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;UnitList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) where&lt;/span&gt;
  &lt;span class="n"&gt;unitList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="kt"&gt;HCons&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we’ve changed the instance so that it has the shape &lt;code&gt;UnitList (a ': as)&lt;/code&gt;, with a type variable in place of the &lt;code&gt;()&lt;/code&gt;, but we also added an equality constraint that forces &lt;code&gt;a&lt;/code&gt; to be &lt;code&gt;()&lt;/code&gt;. Intuitively, you might think these two instances are completely identical, but in fact they are not! As proof, our example now typechecks:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;unsingleton&lt;/span&gt; &lt;span class="n"&gt;unitList&lt;/span&gt;
&lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To understand why, it’s important to understand how GHC’s typeclass resolution algorithm works. Let’s start by establishing some terminology. Note that every instance declaration has the following shape:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;constraints&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;C&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The part to the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; is known as the &lt;em&gt;instance context&lt;/em&gt;, while the part to the right is known as the &lt;em&gt;instance head&lt;/em&gt;. Now for the important bit: when GHC attempts to pick which typeclass instance to use to solve a typeclass constraint, &lt;strong&gt;only the instance head matters, and the instance context is completely ignored&lt;/strong&gt;. Once GHC picks an instance, it commits to its choice, and only then does it consider the instance context.&lt;/p&gt;&lt;p&gt;This explains why our two &lt;code&gt;UnitList&lt;/code&gt; instances behave differently:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Given the instance head &lt;code&gt;UnitList (() ': as)&lt;/code&gt;, GHC won’t select the instance unless it knows the first element of the list is &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;But given the instance head &lt;code&gt;UnitList (a ': as)&lt;/code&gt;, GHC will pick the instance regardless of the type of the first element. All that matters is that the list is at least one element long.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;After the &lt;code&gt;UnitList (a ': as)&lt;/code&gt; instance is selected, GHC attempts to solve the constraints in the instance context, including the &lt;code&gt;a ~ ()&lt;/code&gt; constraint. This &lt;em&gt;forces&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; to be &lt;code&gt;()&lt;/code&gt;, resolving the ambiguity and allowing type inference to proceed.&lt;/p&gt;&lt;p&gt;This distinction might seem excessively subtle, but in practice it is enormously useful. It means you, the programmer, have direct control over the type inference process:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;If you put a type in the instance head, you’re asking GHC to figure out how to make the types match up by some other means. Sometimes that’s very useful, since perhaps you want that type to inform which instance to pick.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;But if you put an equality constraint in the instance context, the roles are reversed: you’re saying to the compiler “you don’t tell me, I’ll tell &lt;em&gt;you&lt;/em&gt; what type this is,” effectively giving you a role in type inference itself.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;From this perspective, typeclass instances with equality constraints make GHC’s type inference algorithm extensible. You get to pick which decisions are made and when, and crucially, you can use knowledge of your own program structure to expose more information to the typechecker.&lt;/p&gt;&lt;p&gt;Given all of the above, consider again the definition of &lt;code&gt;IsEven&lt;/code&gt; from earlier:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Even&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsEven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: b&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;evenProof&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Though it didn’t cause any problems in the examples we tried, this definition isn’t optimized for type inference. If GHC needed to solve an &lt;code&gt;IsEven (a ': b0)&lt;/code&gt; constraint, where &lt;code&gt;b0&lt;/code&gt; is an ambiguous type variable, it would get stuck, since it doesn’t know that someone won’t come along and define an &lt;code&gt;IsEven '[a]&lt;/code&gt; instance in the future.&lt;/p&gt;&lt;p&gt;To fix this, we can apply the same trick we used for &lt;code&gt;UnitList&lt;/code&gt;, just in a slightly different way:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: bs), IsEven bs) =&amp;gt; IsEven (a&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;evenProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;evenProof&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, the idea is to move the type information we &lt;em&gt;learn&lt;/em&gt; from picking this instance into the instance context, allowing it to guide type inference rather than making type inference figure it out from some other source. Consistently applying this transformation can &lt;strong&gt;dramatically&lt;/strong&gt; improve type inference in programs that make heavy use of TMP.&lt;/p&gt;&lt;h3&gt;&lt;a name="example-3-subtyping-constraints"&gt;&lt;/a&gt;Example 3: Subtyping constraints&lt;/h3&gt;&lt;p&gt;At last, we have reached the final example of this blog post. For this one, I have the pleasure of providing a real-world example from a production Haskell codebase: while I was working at &lt;a href="https://hasura.io/"&gt;Hasura&lt;/a&gt;, I had the opportunity to design an internal parser combinator library that captures aspects of the &lt;a href="https://graphql.org/"&gt;GraphQL&lt;/a&gt; type system. One such aspect of that type system is a form of subtyping; GraphQL essentially has two “kinds” of types—input types and output types—but some types can be used as both.&lt;/p&gt;&lt;p&gt;Haskell has no built-in support for subtyping, so most Haskell programs do their best to get away with parametric polymorphism instead. However, in our case, we actually need to distinguish (at runtime) types in the “both” category from those that are exclusively input or exclusively output types. Consequently, our &lt;code&gt;GQLKind&lt;/code&gt; datatype has three cases:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;GQLKind&lt;/span&gt;
  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Both&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Input&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Output&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We use &lt;code&gt;DataKind&lt;/code&gt;-promoted versions of this &lt;code&gt;GQLKind&lt;/code&gt; type as a parameter to a &lt;code&gt;GQLType&lt;/code&gt; GADT:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;GQLType&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;TScalar&lt;/span&gt;      &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;GQLType&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Both&lt;/span&gt;
  &lt;span class="kt"&gt;TInputObject&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;InputObjectInfo&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLType&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt;
  &lt;span class="kt"&gt;TIObject&lt;/span&gt;     &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ObjectInfo&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLType&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Output&lt;/span&gt;
  &lt;span class="c1"&gt;-- ...and so on...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This allows us to write functions that only accept input types or only accept output types, which is a wonderful property to be able to guarantee at compile-time! But there’s a problem: if we write a function that only accepts values of type &lt;code&gt;GQLType 'Input&lt;/code&gt;, we can’t pass a &lt;code&gt;GQLType 'Both&lt;/code&gt;, even though we really ought to be able to.&lt;/p&gt;&lt;p&gt;To fix this, we can use a little dependently typed programming. First, we’ll define a type to represent proof terms that witness a subkinding relationship:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;SubKind&lt;/span&gt; &lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="n"&gt;k2&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;KRefl&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;SubKind&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;
  &lt;span class="kt"&gt;KBoth&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;SubKind&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Both&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first case, &lt;code&gt;KRefl&lt;/code&gt;, states that every kind is trivially a subkind of itself. The second case, &lt;code&gt;KBoth&lt;/code&gt;, states that &lt;code&gt;Both&lt;/code&gt; is a subkind of any kind at all. (This is a particularly literal example of &lt;a href="/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/"&gt;using a type to define axioms&lt;/a&gt;.) The next step is to use TMP to implement proof inference:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="n"&gt;k2&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;SubKind&lt;/span&gt; &lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="n"&gt;k2&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Both&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;KBoth&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;KRefl&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Output&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Output&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;KRefl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These instances use the type equality trick described in the previous section to guide type inference, ensuring that if we ever need to prove that &lt;code&gt;k&lt;/code&gt; is a superkind of &lt;code&gt;'Input&lt;/code&gt; or &lt;code&gt;'Output&lt;/code&gt;, type inference will force them to be equal.&lt;/p&gt;&lt;p&gt;Using &lt;code&gt;IsSubKind&lt;/code&gt;, we can easily resolve the problem described above. Rather than write a function with a type like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;nullable&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;…we simply use an &lt;code&gt;IsSubKind&lt;/code&gt; constraint, instead:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;nullable&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now both &lt;code&gt;'Input&lt;/code&gt; and &lt;code&gt;'Both&lt;/code&gt; kinds are accepted. In my experience, this caused no trouble at all for callers of these functions; everything worked completely automatically. &lt;em&gt;Consuming&lt;/em&gt; the &lt;code&gt;SubKind&lt;/code&gt; proofs was slightly more involved, but only ever so slightly. For example, we have a type family that looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Both&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;InputValue&lt;/span&gt;
  &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;InputValue&lt;/span&gt;
  &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Output&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;SelectionSet&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This type family is used to determine what a &lt;code&gt;GQLParser k a&lt;/code&gt; actually consumes as input, based on the kind of the GraphQL type it corresponds to. In some functions, we need to prove to GHC that &lt;code&gt;IsSubKind k 'Input&lt;/code&gt; implies &lt;code&gt;ParserInput k ~ InputValue&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Fortunately, that is very easy to do using &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Type-Equality.html"&gt;the &lt;code&gt;(:~:)&lt;/code&gt; type from &lt;code&gt;Data.Type.Equality&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt;&lt;/a&gt; to capture a term-level witness of a type equality. It’s an ordinary Haskell GADT that happens to have an infix type constructor, and this is its definition:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:~:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;Refl&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:~:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just as with any other GADT, &lt;code&gt;(:~:)&lt;/code&gt; can be used to pack up type equalities and unpack them later; &lt;code&gt;a :~: b&lt;/code&gt; just happens to be the GADT that corresponds precisely to the equality &lt;code&gt;a ~ b&lt;/code&gt;. Using &lt;code&gt;(:~:)&lt;/code&gt;, we can write a reusable proof that &lt;code&gt;IsSubKind k 'Input&lt;/code&gt; implies &lt;code&gt;ParserInput k ~ InputValue&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;inputParserInput&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ParserInput&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kt"&gt;:~:&lt;/span&gt; &lt;span class="kt"&gt;InputValue&lt;/span&gt;
&lt;span class="nf"&gt;inputParserInput&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;subKindProof&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;KRefl&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Refl&lt;/span&gt;
  &lt;span class="kt"&gt;KBoth&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Refl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function is a very simple proof by cases, where &lt;code&gt;Refl&lt;/code&gt; can be read as “Q.E.D.”:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;In the first case, matching on &lt;code&gt;KRefl&lt;/code&gt; refines &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;'Input&lt;/code&gt;, and &lt;code&gt;ParserInput 'Input&lt;/code&gt; is &lt;code&gt;InputValue&lt;/code&gt; by definition of &lt;code&gt;ParserInput&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Likewise, in the second case, matching on &lt;code&gt;KBoth&lt;/code&gt; refines &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;'Both&lt;/code&gt;, and &lt;code&gt;ParserInput 'Both&lt;/code&gt; is also &lt;code&gt;InputValue&lt;/code&gt; by definition of &lt;code&gt;ParserInput&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This &lt;code&gt;inputParserInput&lt;/code&gt; helper allows functions like &lt;code&gt;nullable&lt;/code&gt;, which internally need &lt;code&gt;ParserInput k ~ InputValue&lt;/code&gt;, to take the form&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;nullable&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;IsSubKind&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;Input&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GQLParser&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;nullable&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;inputParserInput&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Refl&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="cm"&gt;{- ...implementation goes here... -}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Overall, this burden is quite minimal, so the additional type safety is more than worth the effort. The same could not be said without &lt;code&gt;IsSubKind&lt;/code&gt; doing work to infer the proofs at each use site, so in this case, TMP has certainly paid its weight!&lt;/p&gt;&lt;h2&gt;&lt;a name="wrapping-up-and-closing-thoughts"&gt;&lt;/a&gt;Wrapping up and closing thoughts&lt;/h2&gt;&lt;p&gt;So concludes my introduction to Haskell TMP. As seems to happen all too often with my blog posts, this one has grown rather long, so allow me to provide a summary of the most important points:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Typeclass metaprogramming is a powerful technique for performing type-directed code generation, making it a form of “value inference” that infers values from types.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Unlike most other metaprogramming mechanisms, TMP has a wonderful synergy with type inference, which allows it to take advantage of information the programmer may not have even written explicitly.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Though I’ve called the technique “&lt;em&gt;typeclass&lt;/em&gt; metaprogramming,” TMP really leverages the entirety of the modern GHC type system. Type families, GADTs, promoted types, and more all have their place in usefully applying type-level programming.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, since TMP relies so heavily on type inference to do its job, it’s crucial to be thoughtful about how you design type-level code to give the typechecker as many opportunities to succeed as you possibly can.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The individual applications of TMP covered in this blog post—type-level computation, generic programming, and dependent typing—are all useful in their own right, and this post does not linger on any of them long enough to do any of them justice. That is, perhaps, the cost one pays when trying to discuss such an abstract, general technique. However, I hope that readers can see the forest for the trees and understand how TMP can be a set of techniques in their own right, applicable to the topics described above and more.&lt;/p&gt;&lt;p&gt;Readers may note that this blog post targets a slightly different audience than my other recent writing has been. That is a conscious choice: there is an unfortunate dearth of resources to help intermediate Haskell programmers become advanced Haskell programmers, in part because it’s hard to write them. The lack of resources makes tackling topics like this rather difficult, as too often it feels as though an entire web of concepts must be explained all at once, with no obvious incremental path that provides sufficient motivation every step of the way.&lt;/p&gt;&lt;p&gt;It remains to be seen whether my stab at the problem will be successful. But on the chance that it is, I suspect some readers will be curious about where to go next. Here are some ideas:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;As mentioned earlier in this blog post, &lt;a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Generics.html"&gt;the &lt;code&gt;GHC.Generics&lt;/code&gt; module documentation&lt;/a&gt; is a great resource if you want to explore generic programming further, and generic programming is a great way to put TMP to practical use.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I have long believed that &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/"&gt;the GHC User’s Guide&lt;/a&gt; is a criminally under-read and underappreciated piece of documentation. It is a treasure trove of knowledge, and I highly recommend reading through the sections on type-related language extensions if you want to get a better grasp of the mechanics of the Haskell type system.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, if dependently typed programming in Haskell intrigues you, and you don’t mind staring into the sun, the &lt;a href="https://hackage.haskell.org/package/singletons"&gt;singletons&lt;/a&gt; library provides abstractions and design patterns that can considerably cut down on the boilerplate. (Also, &lt;a href="https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf"&gt;the accompanying paper&lt;/a&gt; is definitely worth a read if you’d like to go down that route.)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Even if you don’t decide to pursue type-level programming in Haskell, I hope this blog post helps make some of the concepts involved less mystical and intimidating. I, for one, think this stuff is worth the effort involved in understanding. After all, you never know when it might come in handy.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;Not to be confused with C++’s &lt;a href="https://en.wikipedia.org/wiki/Template_metaprogramming"&gt;&lt;em&gt;template&lt;/em&gt; metaprogramming&lt;/a&gt;, though there are significant similarities between the two techniques. &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-2"&gt;&lt;p&gt;There have been proposals to introduce ordered instances, known in the literature as &lt;a href="https://homepage.cs.uiowa.edu/~jgmorrs/pubs/morris-icfp2010-instances.pdf"&gt;&lt;em&gt;instance chains&lt;/em&gt;&lt;/a&gt;, but as of this writing, GHC does not implement them. &lt;a href="#footnote-ref-2-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-3"&gt;&lt;p&gt;Note that this also preserves an important property of the Haskell type system, parametricity. A function like &lt;code&gt;id :: a -&amp;gt; a&lt;/code&gt; shouldn’t be allowed to do different things depending on which type is chosen for &lt;code&gt;a&lt;/code&gt;, which our first version of &lt;code&gt;guardUnit&lt;/code&gt; tried to violate. Typeclasses, being functions on types, can naturally do different things given different types, so a typeclass constraint is precisely what gives us the power to violate parametricity. &lt;a href="#footnote-ref-3-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-4"&gt;&lt;p&gt;Short for &lt;em&gt;generalized algebraic datatypes&lt;/em&gt;, which is a rather unhelpful name for actually understanding what they are or what they’re for. &lt;a href="#footnote-ref-4-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-5"&gt;&lt;p&gt;If GHC allowed lightweight existential quantification, we could make that term-level evidence available with a sufficiently clever definition for &lt;code&gt;IsEvenTF&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;family&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Constraint&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;[]&lt;/span&gt;       &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: as) = exists b a&lt;/span&gt;&lt;span class="sc"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: a&lt;/span&gt;&lt;span class="sc"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="kt"&gt;IsEvenTF&lt;/span&gt; &lt;span class="n"&gt;as&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The type refinement provided by matching on &lt;code&gt;HCons&lt;/code&gt; would be enough for the second case of &lt;code&gt;IsEvenTF&lt;/code&gt; to be selected, which would provide an equality proof that &lt;code&gt;as&lt;/code&gt; has at least two elements. Sadly, GHC does not support anything of this sort, and it’s unclear if it would be tractable to implement at all. &lt;a href="#footnote-ref-5-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-6"&gt;&lt;p&gt;Actually, I’ve cheated a little bit here, because &lt;code&gt;unsingleton unitList&lt;/code&gt; really does typecheck in GHCi under normal circumstances. That’s because &lt;a href="https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/ghci.html#extension-ExtendedDefaultRules"&gt;the &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; extension&lt;/a&gt; is enabled in GHCi by default, which defaults ambiguous type variables to &lt;code&gt;()&lt;/code&gt;, which happens to be exactly what’s needed to make this contrived example typecheck. However, that doesn’t say anything very useful, since the same expression really would fail to typecheck inside a Haskell module, so I’ve turned &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; off to illustrate the problem. &lt;a href="#footnote-ref-6-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Names are not type safety</title><link>https://lexi-lambda.github.io/blog/2020/11/01/names-are-not-type-safety/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2020/11/01/names-are-not-type-safety/</guid><pubDate>01 Nov 2020</pubDate><description>&lt;article&gt;&lt;p&gt;Haskell programmers spend a lot of time talking about &lt;em&gt;type safety&lt;/em&gt;. The Haskell school of program construction advocates “capturing invariants in the type system” and “making illegal states unrepresentable,” both of which sound like compelling goals, but are rather vague on the techniques used to achieve them. Almost exactly one year ago, I published &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;Parse, Don’t Validate&lt;/a&gt; as an initial stab towards bridging that gap.&lt;/p&gt;&lt;p&gt;The ensuing discussions were largely productive and right-minded, but one particular source of confusion quickly became clear: Haskell’s &lt;code&gt;newtype&lt;/code&gt; construct. The idea is simple enough—the &lt;code&gt;newtype&lt;/code&gt; keyword declares a wrapper type, nominally distinct from but representationally equivalent to the type it wraps—and on the surface this &lt;em&gt;sounds&lt;/em&gt; like a simple and straightforward path to type safety. For example, one might consider using a &lt;code&gt;newtype&lt;/code&gt; declaration to define a type for an email address:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;EmailAddress&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EmailAddress&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This technique can provide &lt;em&gt;some&lt;/em&gt; value, and when coupled with a smart constructor and an encapsulation boundary, it can even provide some safety. But it is a meaningfully distinct &lt;em&gt;kind&lt;/em&gt; of type safety from the one I highlighted a year ago, one that is far weaker. On its own, a newtype is just a name.&lt;/p&gt;&lt;p&gt;And names are not type safety.&lt;/p&gt;&lt;h2&gt;&lt;a name="intrinsic-and-extrinsic-safety"&gt;&lt;/a&gt;Intrinsic and extrinsic safety&lt;/h2&gt;&lt;p&gt;To illustrate the difference between constructive data modeling (discussed at length in my &lt;a href="/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/"&gt;previous blog post&lt;/a&gt;) and newtype wrappers, let’s consider an example. Suppose we want a type for “an integer between 1 and 5, inclusive.” The natural constructive modeling would be an enumeration with five cases:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt;
  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Four&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Five&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We could then write some functions to convert between &lt;code&gt;Int&lt;/code&gt; and our &lt;code&gt;OneToFive&lt;/code&gt; type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Four&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Five&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;

&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;Four&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="kt"&gt;Five&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This would be perfectly sufficient for achieving our stated goal, but you’d be forgiven for finding it odd: it would be rather awkward to work with in practice. Because we’ve invented an entirely new type, we can’t reuse any of the usual numeric functions Haskell provides. Consequently, many programmers would gravitate towards a newtype wrapper, instead:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just as before, we can provide &lt;code&gt;toOneToFive&lt;/code&gt; and &lt;code&gt;fromOneToFive&lt;/code&gt; functions, with identical types:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt;
&lt;span class="nf"&gt;toOneToFive&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;otherwise&lt;/span&gt;        &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;

&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="nf"&gt;fromOneToFive&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we put these declarations in their own module and choose not to export the &lt;code&gt;OneToFive&lt;/code&gt; constructor, these APIs might appear entirely interchangeable. Naïvely, it seems that the newtype version is both simpler and equally type-safe. However—perhaps surprisingly—this is not actually true.&lt;/p&gt;&lt;p&gt;To see why, suppose we write a function that consumes a &lt;code&gt;OneToFive&lt;/code&gt; value as an argument. Under the constructive modeling, such a function need only pattern-match against each of the five constructors, and GHC will accept the definition as exhaustive:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;One&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"first"&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;Two&lt;/span&gt;   &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"second"&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;Three&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"third"&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;Four&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"fourth"&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="kt"&gt;Five&lt;/span&gt;  &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"fifth"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The same is not true given the newtype encoding. The newtype is opaque, so the only way to observe it is to convert it back to an &lt;code&gt;Int&lt;/code&gt;—after all, it &lt;em&gt;is&lt;/em&gt; an &lt;code&gt;Int&lt;/code&gt;. An &lt;code&gt;Int&lt;/code&gt; can of course contain many other values besides &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;5&lt;/code&gt;, so we are forced to add an error case to satisfy the exhaustiveness checker:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OneToFive&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;span class="nf"&gt;ordinal&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromOneToFive&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"first"&lt;/span&gt;
  &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"second"&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"third"&lt;/span&gt;
  &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"fourth"&lt;/span&gt;
  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"fifth"&lt;/span&gt;
  &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"impossible: bad OneToFive value"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this highly contrived example, this may not seem like much of a problem to you. But it nonetheless illustrates a key difference in the guarantees afforded by the two approaches:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The constructive datatype captures its invariants in such a way that they are &lt;em&gt;accessible&lt;/em&gt; to downstream consumers. This frees our &lt;code&gt;ordinal&lt;/code&gt; function from worrying about handling illegal values, as they have been made unutterable.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The newtype wrapper provides a smart constructor that &lt;em&gt;validates&lt;/em&gt; the value, but the boolean result of that check is used only for control flow; it is not preserved in the function’s result. Accordingly, downstream consumers cannot take advantage of the restricted domain; they are functionally accepting &lt;code&gt;Int&lt;/code&gt;s.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Losing exhaustiveness checking might seem like small potatoes, but it absolutely is not: our use of &lt;code&gt;error&lt;/code&gt; has punched a hole right through our type system. If we were to add another constructor to our &lt;code&gt;OneToFive&lt;/code&gt; datatype,&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;1&lt;/a&gt;&lt;/sup&gt; the version of &lt;code&gt;ordinal&lt;/code&gt; that consumes a constructive datatype would be immediately detected non-exhaustive at compile-time, while the version that consumes a newtype wrapper would continue to compile yet fail at runtime, dropping through to the “impossible” case.&lt;/p&gt;&lt;p&gt;All of this is a consequence of the fact that the constructive modeling is &lt;em&gt;intrinsically&lt;/em&gt; type-safe; that is, the safety properties are enforced by the type declaration itself. Illegal values truly are unrepresentable: there is simply no way to represent &lt;code&gt;6&lt;/code&gt; using any of the five constructors. The same is not true of the newtype declaration, which has no intrinsic semantic distinction from that of an &lt;code&gt;Int&lt;/code&gt;; its meaning is specified extrinsically via the &lt;code&gt;toOneToFive&lt;/code&gt; smart constructor. Any semantic distinction intended by a newtype is thoroughly invisible to the type system; it exists only in the programmer’s mind.&lt;/p&gt;&lt;h3&gt;&lt;a name="revisiting-non-empty-lists"&gt;&lt;/a&gt;Revisiting non-empty lists&lt;/h3&gt;&lt;p&gt;Our &lt;code&gt;OneToFive&lt;/code&gt; datatype is rather artificial, but identical reasoning applies to other datatypes that are significantly more practical. Consider the &lt;code&gt;NonEmpty&lt;/code&gt; datatype I’ve repeatedly highlighted in recent blog posts:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It may be illustrative to imagine a version of &lt;code&gt;NonEmpty&lt;/code&gt; represented as a newtype over ordinary lists. We can use the usual smart constructor strategy to enforce the desired non-emptiness property:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Foldable&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;toList&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just as with &lt;code&gt;OneToFive&lt;/code&gt;, we quickly discover the consequences of failing to preserve this information in the type system. Our motivating use case for &lt;code&gt;NonEmpty&lt;/code&gt; was the ability to write a safe version of &lt;code&gt;head&lt;/code&gt;, but the newtype version requires another assertion:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;toList&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="kt"&gt;[]&lt;/span&gt;  &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"impossible: empty NonEmpty value"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This might not seem like a big deal, since it seems unlikely such a case would ever happen. But that reasoning hinges entirely on trusting the correctness of the module that defines &lt;code&gt;NonEmpty&lt;/code&gt;, while the constructive definition only requires trusting the GHC typechecker. As we generally trust that the typechecker works correctly, the latter is a much more compelling proof.&lt;/p&gt;&lt;h2&gt;&lt;a name="newtypes-as-tokens"&gt;&lt;/a&gt;Newtypes as tokens&lt;/h2&gt;&lt;p&gt;If you are fond of newtypes, this whole argument may seem a bit troubling. It may seem like I’m implying newtypes are scarcely better than comments, albeit comments that happen to be meaningful to the typechecker. Fortunately, the situation is not quite that grim—newtypes &lt;em&gt;can&lt;/em&gt; provide a sort of safety, just a weaker one.&lt;/p&gt;&lt;p&gt;The primary safety benefit of newtypes is derived from abstraction boundaries. If a newtype’s constructor is not exported, it becomes opaque to other modules. The module that defines the newtype—its “home module”—can take advantage of this to create a &lt;em&gt;trust boundary&lt;/em&gt; where internal invariants are enforced by restricting clients to a safe API.&lt;/p&gt;&lt;p&gt;We can use the &lt;code&gt;NonEmpty&lt;/code&gt; example from above to illustrate how this works. We refrain from exporting the &lt;code&gt;NonEmpty&lt;/code&gt; constructor, and we provide &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; operations that we trust to never actually fail:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Data.List.NonEmpty.Newtype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;cons&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;nonEmpty&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;head&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;tail&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;

&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;

&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"impossible: empty NonEmpty value"&lt;/span&gt;

&lt;span class="nf"&gt;tail&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;tail&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
&lt;span class="nf"&gt;tail&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"impossible: empty NonEmpty value"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since the only way to construct or consume &lt;code&gt;NonEmpty&lt;/code&gt; values is to use the functions in &lt;code&gt;Data.List.NonEmpty.Newtype&lt;/code&gt;’s exported API, the above implementation makes it impossible for clients to violate the non-emptiness invariant. In a sense, values of opaque newtypes are like &lt;em&gt;tokens&lt;/em&gt;: the implementing module issues tokens via its constructor functions, and those tokens have no intrinsic value. The only way to do anything useful with them is to “redeem” them to the issuing module’s accessor functions, in this case &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;, to obtain the values contained within.&lt;/p&gt;&lt;p&gt;This approach is significantly weaker than using a constructive datatype, since it is theoretically possible to screw up and accidentally provide a means to construct an invalid &lt;code&gt;NonEmpty []&lt;/code&gt; value. For this reason, the newtype approach to type safety does not on its own constitute a &lt;em&gt;proof&lt;/em&gt; that a desired invariant holds. However, it restricts the “surface area” where an invariant violation can occur to the defining module, so reasonable confidence the invariant really does hold can be achieved by thoroughly testing the module’s API using fuzzing or property-based testing techniques.&lt;sup&gt;&lt;a href="#footnote-2" id="footnote-ref-2-1"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;This tradeoff may not seem all that bad, and indeed, it is often a very good one! Guaranteeing invariants using constructive data modeling can, in general, be quite difficult, which often makes it impractical. However, it is easy to dramatically underestimate the care needed to avoid accidentally providing a mechanism that permits violating the invariant. For example, the programmer may choose to take advantage of GHC’s convenient typeclass deriving to derive a &lt;code&gt;Generic&lt;/code&gt; instance for &lt;code&gt;NonEmpty&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="cm"&gt;{-# LANGUAGE DeriveGeneric #-}&lt;/span&gt;

&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;GHC.Generics&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Generic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Generic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, this innocuous line provides a trivial mechanism to circumvent the abstraction boundary:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;GHC&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Generics&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;M1&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;M1&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;M1&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;K1&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a particularly extreme example, since derived &lt;code&gt;Generic&lt;/code&gt; instances are fundamentally abstraction-breaking, but this problem can crop up in less obvious ways, too. The same problem occurs with a derived &lt;code&gt;Read&lt;/code&gt; instance:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;read&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"NonEmpty []"&lt;/span&gt;
&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To some readers, these pitfalls may seem obvious, but safety holes of this sort are remarkably common in practice. This is especially true for datatypes with more sophisticated invariants, as it may not be easy to determine whether the invariants are actually upheld by the module’s implementation. Proper use of this technique demands caution and care:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;All invariants must be made clear to maintainers of the trusted module. For simple types, such as &lt;code&gt;NonEmpty&lt;/code&gt;, the invariant is self-evident, but for more sophisticated types, comments are not optional.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Every change to the trusted module must be carefully audited to ensure it does not somehow weaken the desired invariants.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Discipline is needed to resist the temptation to add unsafe trapdoors that allow compromising the invariants if used incorrectly.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Periodic refactoring may be needed to ensure the trusted surface area remains small. It is all too easy for the responsibility of the trusted module to accumulate over time, dramatically increasing the likelihood of some subtle interaction causing an invariant violation.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In contrast, datatypes that are correct by construction suffer none of these problems. The invariant cannot be violated without changing the datatype definition itself, which has rippling effects throughout the rest of the program to make the consequences immediately clear. Discipline on the part of the programmer is unnecessary, as the typechecker enforces the invariants automatically. There is no “trusted code” for such datatypes, since all parts of the program are equally beholden to the datatype-mandated constraints.&lt;/p&gt;&lt;p&gt;In libraries, the newtype-afforded notion of safety via encapsulation is useful, as libraries often provide the building blocks used to construct more complicated data structures. Such libraries generally receive more scrutiny and care than application code does, especially given they change far less frequently. In application code, these techniques are still useful, but the churn of a production codebase tends to weaken encapsulation boundaries over time, so correctness by construction should be preferred whenever practical.&lt;/p&gt;&lt;h2&gt;&lt;a name="other-newtype-use-abuse-and-misuse"&gt;&lt;/a&gt;Other newtype use, abuse, and misuse&lt;/h2&gt;&lt;p&gt;The previous section covers the primary means by which newtypes are useful. However, in practice, newtypes are routinely used in ways that do not fit the above pattern. Some such uses are reasonable:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Haskell’s notion of typeclass coherency limits each type to a single instance of any given class. For types that permit more than one useful instance, newtypes are the traditional solution, and this can be used to good effect. For example, the &lt;code&gt;Sum&lt;/code&gt; and &lt;code&gt;Product&lt;/code&gt; newtypes from &lt;code&gt;Data.Monoid&lt;/code&gt; provide useful &lt;code&gt;Monoid&lt;/code&gt; instances for numeric types.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;In a similar vein, newtypes can be useful for introducing or rearranging type parameters. The &lt;code&gt;Flip&lt;/code&gt; newtype from &lt;code&gt;Data.Bifunctor.Flip&lt;/code&gt; is a simple example, flipping the arguments of a &lt;code&gt;Bifunctor&lt;/code&gt; so the &lt;code&gt;Functor&lt;/code&gt; instance may operate on the other side:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Flip&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Flip&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;runFlip&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Newtypes are needed to do this sort of juggling, as Haskell does not (yet) support type-level lambdas.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;More simply, transparent newtypes can be useful to discourage misuse when the value needs to be passed between distant parts of the program and the intermediate code has no reason to inspect the value. For example, a &lt;code&gt;ByteString&lt;/code&gt; containing a secret key may be wrapped in a newtype (with a &lt;code&gt;Show&lt;/code&gt; instance omitted) to discourage code from accidentally logging or otherwise exposing it.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;All of these applications are good ones, but they have little to do with &lt;em&gt;type safety.&lt;/em&gt; The last bullet in particular is often confused for safety, and to be fair, it does in fact take advantage of the type system to help avoid logical mistakes. However, it would be a mischaracterization to claim such usage actually &lt;em&gt;prevents&lt;/em&gt; misuse; any part of the program may inspect the value at any time.&lt;/p&gt;&lt;p&gt;Too often, this illusion of safety leads to outright newtype abuse. For example, here’s a definition from the very codebase I work on for a living:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;ArgumentName&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ArgumentName&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;unArgumentName&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;GraphQL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FromJSONKey&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSONKey&lt;/span&gt;
           &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Hashable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToTxt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Lift&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Generic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;NFData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Cacheable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This newtype is useless noise. Functionally, it is completely interchangeable with its underlying &lt;code&gt;Name&lt;/code&gt; type, so much so that it derives a dozen typeclasses! In every location it’s used, it’s immediately unwrapped the instant it’s extracted from its enclosing record, so there is no type safety benefit whatsoever. Worse, there isn’t even any clarity added by labeling it an &lt;code&gt;ArgumentName&lt;/code&gt;, since the enclosing field name already makes its role clear.&lt;/p&gt;&lt;p&gt;Newtypes like these seem to arise from a desire to use the type system as a taxonomy of the external world. An “argument name” is a more specific concept than a generic “name,” so surely it ought to have its own type. This makes some intuitive sense, but it’s rather misguided: taxonomies are useful for documenting a domain of interest, but not necessarily helpful for modeling it. When programming, we use types for a different end:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Primarily, types distinguish &lt;em&gt;functional&lt;/em&gt; differences between values. A value of type &lt;code&gt;NonEmpty a&lt;/code&gt; is &lt;em&gt;functionally&lt;/em&gt; distinct from a value of type &lt;code&gt;[a]&lt;/code&gt;, since it is fundamentally structurally different and permits additional operations. In this sense, types are &lt;em&gt;structural&lt;/em&gt;; they describe what values &lt;em&gt;are&lt;/em&gt; in the internal world of the programming language.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Secondarily, we sometimes use types to help ourselves avoid making logical mistakes. We might use separate &lt;code&gt;Distance&lt;/code&gt; and &lt;code&gt;Duration&lt;/code&gt; types to avoid accidentally doing something nonsensical like adding them together, even though they’re both representationally real numbers.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Note that both these uses are &lt;em&gt;pragmatic&lt;/em&gt;; they look at the type system as a tool. This is a rather natural perspective to take, seeing as a static type system &lt;em&gt;is&lt;/em&gt; a tool in a literal sense. Nevertheless, that perspective seems surprisingly unusual, even though the use of types to classify the world routinely yields unhelpful noise like &lt;code&gt;ArgumentName&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;If a newtype is completely transparent, and it is routinely wrapped and unwrapped at will, it is likely not very helpful. In this particular case, I would eliminate the distinction altogether and use &lt;code&gt;Name&lt;/code&gt;, but in situations where the different label adds genuine clarity, one can always use a type alias:&lt;sup&gt;&lt;a href="#footnote-3" id="footnote-ref-3-1"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;ArgumentName&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;GraphQL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Newtypes like these are security blankets. Forcing programmers to jump through a few hoops is not type safety—trust me when I say they will happily jump through them without a second thought.&lt;/p&gt;&lt;h2&gt;&lt;a name="final-thoughts-and-related-reading"&gt;&lt;/a&gt;Final thoughts and related reading&lt;/h2&gt;&lt;p&gt;I’ve been wanting to write this blog post for a long time. Ostensibly, it’s a very specific critique of Haskell newtypes, and I’ve chosen to frame things this way because I write Haskell for a living and this is the way I encounter this problem in practice. Really, though, the core idea is much bigger than that.&lt;/p&gt;&lt;p&gt;Newtypes are one particular mechanism of defining &lt;em&gt;wrapper types&lt;/em&gt;, a concept that exists in almost any language, even those that are dynamically typed. Even if you don’t write Haskell, much of the reasoning in this blog post is likely still relevant in your language of choice. More broadly, this is a continuation of a theme I’ve been trying to convey from different angles over the past year: type systems are tools, and we should be more conscious and intentional about what they actually do and how to use them effectively.&lt;/p&gt;&lt;p&gt;The catalyst that got me to finally sit down and write this was the recently-published &lt;a href="https://tech.freckle.com/2020/10/26/tagged-is-not-a-newtype/"&gt;Tagged is not a Newtype&lt;/a&gt;. It’s a good blog post, and I wholeheartedly agree with its general thrust, but I thought it was a missed opportunity to make a larger point. Indeed, &lt;code&gt;Tagged&lt;/code&gt; &lt;em&gt;is&lt;/em&gt; a newtype, definitionally, so the title of the blog post is something of a misdirection. The real problem is a little deeper.&lt;/p&gt;&lt;p&gt;Newtypes are useful when carefully applied, but their safety is not intrinsic, no more than the safety of a traffic cone is somehow contained within the plastic it’s made of. What matters is being placed in the right context—without that, newtypes are just a labeling scheme, a way of giving something a name.&lt;/p&gt;&lt;p&gt;And a name is not type safety.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;Admittedly rather unlikely given its name, but bear with me through the contrived example. &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-2"&gt;&lt;p&gt;In theory, it is still possible to thoroughly prove the invariant holds using external verification techniques, such as by writing a pen-and-paper proof or by using program extraction in combination with a proof assistant/theorem prover. However, these techniques are extremely uncommon in general programming practice. &lt;a href="#footnote-ref-2-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-3"&gt;&lt;p&gt;As it happens, I think type aliases are often also more harmful than helpful, so I would caution against overusing them, too, but that is outside the scope of this blog post. &lt;a href="#footnote-ref-3-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Types as axioms, or: playing god with static types</title><link>https://lexi-lambda.github.io/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/</guid><pubDate>13 Aug 2020</pubDate><description>&lt;article&gt;&lt;p&gt;Just what exactly &lt;em&gt;is&lt;/em&gt; a type?&lt;/p&gt;&lt;p&gt;A common perspective is that types are &lt;em&gt;restrictions&lt;/em&gt;. Static types restrict the set of values a variable may contain, capturing some subset of the space of “all possible values.” Under this worldview, a typechecker is sort of like an oracle, predicting which values will end up where when the program runs and making sure they satisfy the constraints the programmer wrote down in the type annotations. Of course, the typechecker can’t &lt;em&gt;really&lt;/em&gt; predict the future, so when the typechecker gets it wrong—it can’t “figure out” what a value will be—static types can feel like self-inflicted shackles.&lt;/p&gt;&lt;p&gt;But that is not the &lt;em&gt;only&lt;/em&gt; perspective. There is another way—a way that puts you, the programmer, back in the driver’s seat. You make the rules, you call the shots, you set the objectives. You need not be limited any longer by what the designers of your programming language decided the typechecker can and cannot prove. You do not serve the typechecker; the typechecker serves &lt;em&gt;you.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;…no, I’m not trying to sell you a dubious self-help book for programmers who feel like they’ve lost control of their lives. If the above sounds too good to be true, well… I won’t pretend it’s all actually as easy as I make it sound. Nevertheless, it’s well within the reach of the working programmer, and most remarkably, all it takes is a change in perspective.&lt;/p&gt;&lt;h2&gt;&lt;a name="seeing-the-types-half-empty"&gt;&lt;/a&gt;Seeing the types half-empty&lt;/h2&gt;&lt;p&gt;Let’s talk a little about TypeScript.&lt;/p&gt;&lt;p&gt;TypeScript is a &lt;em&gt;gradually-typed&lt;/em&gt; language, which means it’s possible to mix statically- and dynamically-typed code. The original intended use case of gradual typing was to &lt;em&gt;gradually&lt;/em&gt; add static types to an existing dynamically-typed codebase, which imposes some interesting design constraints. For one, a valid JavaScript program must also be a valid TypeScript program; for another, TypeScript must be accommodating of traditional JavaScript idioms.&lt;/p&gt;&lt;p&gt;Gradually typed languages like TypeScript are particularly good illustrations of the way type annotations can be viewed as constraints. A function with no explicit type declarations&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;1&lt;/a&gt;&lt;/sup&gt; can accept &lt;em&gt;any&lt;/em&gt; JavaScript value, so adding a type annotation fundamentally restricts the set of legal values.&lt;/p&gt;&lt;p&gt;Furthermore, languages like TypeScript tend to have subtyping. This makes it easy to classify certain types as “more restrictive” than others. For example, a type like &lt;code&gt;string | number&lt;/code&gt; clearly includes more values than just &lt;code&gt;number&lt;/code&gt;, so &lt;code&gt;number&lt;/code&gt; is a more restrictive type—a &lt;em&gt;subtype&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;An exceptionally concrete way to illustrate this “types are restrictions” mentality is to write a function with an unnecessarily specific type. Here’s a TypeScript function that returns the first element in an array of numbers:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;getFirst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arr&lt;/span&gt;: &lt;span class="kt"&gt;number&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;number&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kc"&gt;undefined&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we ignore the type annotations and consider only the dynamic semantics of JavaScript, this function would work perfectly well given a list of strings. However, if we write &lt;code&gt;getFirst(["hello", "world"])&lt;/code&gt;, the typechecker will complain. In this example, the restriction is thoroughly self-imposed—it would be easy to give this function a more generic type—but it’s not always that easy. For example, suppose we wrote a function where the return type depends upon the type of the argument:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;emptyLike&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;val&lt;/span&gt;: &lt;span class="kt"&gt;number&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;number&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="s2"&gt;"number"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now if we write &lt;code&gt;emptyLike(42) * 10&lt;/code&gt;, the typechecker will once again complain, claiming the result might be a string—it can’t “figure out” that when we pass a number, we always get a number back.&lt;/p&gt;&lt;p&gt;When type systems are approached from this perspective, the result is often frustration. The programmer knows that the equivalent untyped JavaScript is perfectly well-behaved, so the typechecker comes off as being the highly unfortunate combination of stubborn yet dim-witted. What’s more, the programmer likely has little mental model of the typechecker’s internal operation, so when types like the above are inferred (not explicitly written), it can be unclear what solutions exist to make the error go away.&lt;/p&gt;&lt;p&gt;At this point, the programmer may give up. “Stupid typechecker,” they grumble, changing the return type of &lt;code&gt;emptyLike&lt;/code&gt; to &lt;code&gt;any&lt;/code&gt;. “If it can’t even figure this out, can it &lt;em&gt;really&lt;/em&gt; be all that useful?”&lt;/p&gt;&lt;p&gt;Sadly, this relationship with the typechecker is all too common, and gradually-typed languages in particular tend to create a vicious cycle of frustration:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Gradual type systems are intentionally designed to “just work” on idiomatic code as much as possible, so programmers may not think much about the types except when they get type errors.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Furthermore, many programmers using gradually-typed languages are already adept at programming in the underlying dynamically-typed language, so they have working mental models of program operation in terms of the dynamic semantics alone. They are much less likely to develop a rich mental model of the static semantics of the type system because they are used to reasoning without one.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Gradually typed languages must support idioms from their dynamically-typed heritage, so they often include ad-hoc special cases (such as, for example, special treatment of &lt;code&gt;typeof&lt;/code&gt; checks) that obscure the rules the typechecker follows and make them seem semi-magical.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Builtin types are deeply blessed in the type system, strongly encouraging programmers to embrace their full flexibility, but leaving little recourse when they run up against their limits.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;All this frustration breeds a readiness to override the typechecker using casts or &lt;code&gt;any&lt;/code&gt;, which ultimately creates a self-fulfilling prophecy in which the typechecker rarely catches any interesting mistakes because it has been so routinely disabled.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The end result of all of this is a defeatist attitude that views the typechecker as a minor tooling convenience at best (i.e. a fancy autocomplete provider) or an active impediment at worst. Who can really blame them? The type system has (unintentionally of course) been designed in such a way so as to lead them into this dead end. The public perception of type systems settles into that of a strikingly literal nitpicker we endure rather than as a tool we actively leverage.&lt;/p&gt;&lt;h2&gt;&lt;a name="taking-back-types"&gt;&lt;/a&gt;Taking back types&lt;/h2&gt;&lt;p&gt;After everything I said above, it may be hard to imagine seeing types any other way. Indeed, through the lens of TypeScript, the “types are restrictions” mentality is incredibly natural, so much so that it seems self-evident. But let’s move away from TypeScript for a moment and focus on a different language, Haskell, which encourages a somewhat different perspective. If you aren’t familiar with Haskell, that’s alright—I’m going to try to keep the examples in this blog post as accessible as possible whether you’ve written any Haskell or not.&lt;/p&gt;&lt;p&gt;Though Haskell and TypeScript are both statically-typed—and both of their type systems are fairly sophisticated—Haskell’s type system is almost completely different philosophically:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Haskell does not have subtyping,&lt;sup&gt;&lt;a href="#footnote-2" id="footnote-ref-2-1"&gt;2&lt;/a&gt;&lt;/sup&gt; which means that every value belongs to exactly one type.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;While JavaScript is built around a small handful of flexible builtin datatypes (booleans, numbers, strings, arrays, and objects), Haskell has essentially no blessed, built-in datatypes other than numbers. Key types such as booleans, lists, and tuples are ordinary datatypes defined in the standard library, no different from types users could define.&lt;sup&gt;&lt;a href="#footnote-3" id="footnote-ref-3-1"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;In particular, Haskell is built around the idea that datatypes can be defined with multiple &lt;em&gt;cases&lt;/em&gt;, and branching is done via pattern-matching (more on this shortly).&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Let’s look at a basic Haskell datatype declaration. Suppose we want to define a type that represents a season:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Spring&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Summer&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Fall&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Winter&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you are familiar with TypeScript, this may look rather similar to a union type; if you’re familiar with a C-family language, this may remind you more of an enum. Both are on the right track: this defines a new type named &lt;code&gt;Season&lt;/code&gt; with four possible values, &lt;code&gt;Spring&lt;/code&gt;, &lt;code&gt;Summer&lt;/code&gt;, &lt;code&gt;Fall&lt;/code&gt;, and &lt;code&gt;Winter&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;But what exactly &lt;em&gt;are&lt;/em&gt; those values?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;In TypeScript, we’d represent this type with a union of strings, like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"spring"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"summer"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"fall"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"winter"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, &lt;code&gt;Season&lt;/code&gt; is a type that can be one of those four strings, but nothing else.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;In C, we’d represent this type with an enum, like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;SPRING&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SUMMER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FALL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;WINTER&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, &lt;code&gt;SPRING&lt;/code&gt;, &lt;code&gt;SUMMER&lt;/code&gt;, &lt;code&gt;FALL&lt;/code&gt;, and &lt;code&gt;WINTER&lt;/code&gt; are essentially defined to be global aliases for the integers &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;, and the type &lt;code&gt;enum season&lt;/code&gt; is essentially an alias for &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So in TypeScript, the values are strings, and in C, the values are numbers. What are they in Haskell? Well… they simply &lt;em&gt;are&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;The Haskell declaration invents four completely new constants out of thin air, &lt;code&gt;Spring&lt;/code&gt;, &lt;code&gt;Summer&lt;/code&gt;, &lt;code&gt;Fall&lt;/code&gt;, and &lt;code&gt;Winter&lt;/code&gt;. They aren’t aliases for numbers, nor are they symbols or strings. The compiler doesn’t expose anything about how it chooses to represent these values at runtime; that’s an implementation detail. In Haskell, &lt;code&gt;Spring&lt;/code&gt; is now a value &lt;em&gt;distinct from all other values&lt;/em&gt;, even if someone in a different module were to also use the name &lt;code&gt;Spring&lt;/code&gt;. Haskell type declarations let us play god, creating something from nothing.&lt;/p&gt;&lt;p&gt;Since these values are totally unique, abstract constants, what can we actually do with them? The answer is one thing and &lt;em&gt;exactly&lt;/em&gt; one thing: we can branch on them. For example, we can write a function that takes a &lt;code&gt;Season&lt;/code&gt; as an argument and returns whether or not Christmas occurs during it:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;containsChristmas&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="nf"&gt;containsChristmas&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Spring&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
  &lt;span class="kt"&gt;Summer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="c1"&gt;-- southern hemisphere&lt;/span&gt;
  &lt;span class="kt"&gt;Fall&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
  &lt;span class="kt"&gt;Winter&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="c1"&gt;-- northern hemisphere&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;case&lt;/code&gt; expressions are, to a first approximation, a lot like C-style &lt;code&gt;switch&lt;/code&gt; statements (though they can do a lot more than this simple example suggests). Using &lt;code&gt;case&lt;/code&gt;, we can also define conversions from our totally unique &lt;code&gt;Season&lt;/code&gt; constants to other types, if we want:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;seasonToString&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;span class="nf"&gt;seasonToString&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Spring&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"spring"&lt;/span&gt;
  &lt;span class="kt"&gt;Summer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"summer"&lt;/span&gt;
  &lt;span class="kt"&gt;Fall&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"fall"&lt;/span&gt;
  &lt;span class="kt"&gt;Winter&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"winter"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also go the other way around, converting a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Season&lt;/code&gt;, but if we try, we run into a problem: what do we return for a string like, say, &lt;code&gt;"cheesecake"&lt;/code&gt;? In other languages, we might throw an error or return &lt;code&gt;null&lt;/code&gt;, but Haskell does not have &lt;code&gt;null&lt;/code&gt;, and errors are generally reserved for truly catastrophic failures. What can we do instead?&lt;/p&gt;&lt;p&gt;A particularly naïve solution would be to create a type called &lt;code&gt;MaybeASeason&lt;/code&gt; that has two cases—it can be a valid &lt;code&gt;Season&lt;/code&gt;, or it can be &lt;code&gt;NotASeason&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;MaybeASeason&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;NotASeason&lt;/span&gt;

&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MaybeASeason&lt;/span&gt;
&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="s"&gt;"spring"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Spring&lt;/span&gt;
  &lt;span class="s"&gt;"summer"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Summer&lt;/span&gt;
  &lt;span class="s"&gt;"fall"&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Fall&lt;/span&gt;
  &lt;span class="s"&gt;"winter"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Winter&lt;/span&gt;
  &lt;span class="kr"&gt;_&lt;/span&gt;        &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;NotASeason&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This shows a feature of Haskell datatypes that C-style enums do &lt;em&gt;not&lt;/em&gt; have: they aren’t just constants, they can contain other values. A &lt;code&gt;MaybeASeason&lt;/code&gt; can be one of five different values: &lt;code&gt;IsASeason Spring&lt;/code&gt;, &lt;code&gt;IsASeason Summer&lt;/code&gt;, &lt;code&gt;IsASeason Fall&lt;/code&gt;, &lt;code&gt;IsASeason Winter&lt;/code&gt;, or &lt;code&gt;NotASeason&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;In TypeScript, we’d write &lt;code&gt;MaybeASeason&lt;/code&gt; more like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;MaybeASeason&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"not-a-season"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is kind of nice, because we don’t have to wrap all our &lt;code&gt;Season&lt;/code&gt; values with &lt;code&gt;IsASeason&lt;/code&gt; like we have to do in Haskell. But remember that Haskell doesn’t have subtyping—every value must belong to exactly one type—so the Haskell code needs the &lt;code&gt;IsASeason&lt;/code&gt; wrapper to distinguish the value as a &lt;code&gt;MaybeASeason&lt;/code&gt; rather than a &lt;code&gt;Season&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Now, you may rightly point out that having to invent a type like &lt;code&gt;MaybeASeason&lt;/code&gt; every time we need to create a variant of a type with a failure case is absurd, so fortunately we can define a type like &lt;code&gt;MaybeASeason&lt;/code&gt; that works for &lt;em&gt;any&lt;/em&gt; underlying type. In Haskell, it looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This defines a generic type, where the &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;Maybe a&lt;/code&gt; is a stand-in for some other type, much like the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; in other languages. We can change our &lt;code&gt;stringToSeason&lt;/code&gt; function to use &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt;
&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="s"&gt;"spring"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Spring&lt;/span&gt;
  &lt;span class="s"&gt;"summer"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Summer&lt;/span&gt;
  &lt;span class="s"&gt;"fall"&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Fall&lt;/span&gt;
  &lt;span class="s"&gt;"winter"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Winter&lt;/span&gt;
  &lt;span class="kr"&gt;_&lt;/span&gt;        &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; gets us something a lot like nullable types, but it isn’t built into the type system, it’s just an ordinary type defined in the standard library.&lt;/p&gt;&lt;h3&gt;&lt;a name="positive-versus-negative-space"&gt;&lt;/a&gt;Positive versus negative space&lt;/h3&gt;&lt;p&gt;At this point, you may be wondering to yourself why I am talking about all of this, seeing as everything in the previous section is information you could find in a basic Haskell tutorial. But the point of this blog post is not to teach you Haskell, it’s to focus on a particular philosophical approach to modeling data.&lt;/p&gt;&lt;p&gt;In TypeScript, when we write a type declaration like&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"summer"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"spring"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"fall"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"winter"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;we are defining a type that can be one of those four strings &lt;em&gt;and nothing else&lt;/em&gt;. All the other strings that &lt;em&gt;aren’t&lt;/em&gt; one of those four make up &lt;code&gt;Season&lt;/code&gt;’s “negative space”—values that exist, but that we have intentionally excluded. In contrast, the Haskell type does not really have any “negative space” because we pulled four new values out of thin air.&lt;/p&gt;&lt;p&gt;Of course, I suspect you don’t really buy this argument. What makes a string like &lt;code&gt;"cheesecake"&lt;/code&gt; “negative space” in TypeScript but not in Haskell? Well… nothing, really. The distinction I’m drawing here doesn’t really exist, it’s just a different perspective, and arguably a totally contrived and arbitrary one. But now that I’ve explained the premise and set up some context, let me provide a more compelling example.&lt;/p&gt;&lt;p&gt;Suppose you are writing a TypeScript program, and you want a function that only accepts &lt;em&gt;non-empty&lt;/em&gt; arrays. What can you do? Your first instinct is that you need a way to somehow further restrict the function’s input type to exclude empty arrays. And indeed, there &lt;em&gt;is&lt;/em&gt; a trick for doing that:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;NonEmptyArray&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;[]];&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Great! But what if the constraint was more complicated: what if you needed an array containing an even number of elements? Unfortunately, there isn’t really a trick for that one. At this point, you might start wishing the type system had support for something really fancy, like refinement types, so you could write something like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;EvenArray&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="nx"&gt;satisfies&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But TypeScript doesn’t support anything like that, so for now you’re stuck. You need a way to restrict the function’s domain in a way the type system does not have any special support for, so your conclusion might be “I guess the type system just can’t do this.” People tend to call this “running up against the limits of the type system.”&lt;/p&gt;&lt;p&gt;But what if we took a different perspective? Recall that in Haskell, lists aren’t built-in datatypes, they’re just ordinary datatypes defined in the standard library:&lt;sup&gt;&lt;a href="#footnote-4" id="footnote-ref-4-1"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Cons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This type might be a bit confusing at first if you have not written any Haskell, since it’s &lt;em&gt;recursive&lt;/em&gt;. All of these are valid values of type &lt;code&gt;List Int&lt;/code&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Nil&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Cons 1 Nil&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Cons 1 (Cons 2 Nil)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Cons 1 (Cons 2 (Cons 3 Nil))&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The recursive nature of &lt;code&gt;Cons&lt;/code&gt; is what gives our user-defined datatype the ability to hold any number of values: we can have any number of nested &lt;code&gt;Cons&lt;/code&gt;es we want before we terminate the list with a final &lt;code&gt;Nil&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;If we wanted to define an &lt;code&gt;EvenList&lt;/code&gt; type in Haskell, we might end up thinking along the same lines we did before, that we need some fancy type system extension so we can restrict &lt;code&gt;List&lt;/code&gt; to exclude lists with odd numbers of elements. But that’s focusing on the negative space of things we want to exclude… what if instead, we focused on the &lt;em&gt;positive&lt;/em&gt; space of things we want to &lt;em&gt;include?&lt;/em&gt;&lt;/p&gt;&lt;p&gt;What do I mean by that? Well, we could define an entirely new type that’s just like &lt;code&gt;List&lt;/code&gt;, but we make it &lt;em&gt;impossible&lt;/em&gt; to ever include an odd number of elements:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here are some valid values of type &lt;code&gt;EvenList Int&lt;/code&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;EvenNil&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;EvenCons 1 2 EvenNil&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;EvenCons 1 2 (EvenCons 3 4 EvenNil)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Lo and behold, a datatype that can only ever include even numbers of elements!&lt;/p&gt;&lt;p&gt;Now, at this point you might realize that this is kind of silly. We don’t need to invent an entirely new datatype for this! We could just create a list of pairs:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now values like &lt;code&gt;Cons (1, 2) (Cons (3, 4) Nil)&lt;/code&gt; would be valid values of type &lt;code&gt;EvenList Int&lt;/code&gt;, and we wouldn’t have to reinvent lists. But again, this is an approach based on thinking not on which values we want to exclude, but rather how to structure our data such that those illegal values aren’t even &lt;em&gt;constructible.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;This is the essence of the Haskeller’s mantra, “Make illegal states unrepresentable,”&lt;/strong&gt; and sadly it is often misinterpreted. It’s much easier to think “hm, I want to make these states illegal, how can I add some post-hoc restrictions to rule them out?” And indeed, this is why refinement types really &lt;em&gt;are&lt;/em&gt; awesome, and when they’re available, by all means use them! But checking totally arbitrary properties at the type level is not tractable in general, and sometimes you need to think a little more outside the box.&lt;/p&gt;&lt;h3&gt;&lt;a name="types-as-axiom-schemas"&gt;&lt;/a&gt;Types as axiom schemas&lt;/h3&gt;&lt;p&gt;So far in this blog post, I’ve repeatedly touched upon a handful of different ideas in a few different ways:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Instead of thinking about how to &lt;em&gt;restrict&lt;/em&gt;, it can be useful to think about how to &lt;em&gt;correctly construct&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;In Haskell, datatype declarations invent new values out of thin air.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;We can represent a &lt;em&gt;lot&lt;/em&gt; of different data structures using the incredibly simple framework of “datatypes with several possibilities.”&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Independently, those ideas might not seem deeply related, but in fact, they’re all essential to the Haskell school of data modeling. I want to now explore how we can unify them into a single framework that makes this seem less magical and more like an iterative design process.&lt;/p&gt;&lt;p&gt;In Haskell, when you define a datatype, you’re really defining a new, self-contained set of &lt;em&gt;axioms&lt;/em&gt; and &lt;em&gt;inference rules.&lt;/em&gt; That is rather abstract, so let’s make it more concrete. Consider the &lt;code&gt;List&lt;/code&gt; type again:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Cons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Viewed as an axiom schema, this type has one axiom and one inference rule:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The empty list is a list.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If you have a list, and you add an element to the beginning, the result is also a list.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The axiom is &lt;code&gt;Nil&lt;/code&gt;, and the inference rule is &lt;code&gt;Cons&lt;/code&gt;. Every list&lt;sup&gt;&lt;a href="#footnote-5" id="footnote-ref-5-1"&gt;5&lt;/a&gt;&lt;/sup&gt; is constructed by starting with the axiom, &lt;code&gt;Nil&lt;/code&gt;, followed by some number of applications of the inference rule, &lt;code&gt;Cons&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;We can take a similar approach when designing the &lt;code&gt;EvenList&lt;/code&gt; type. The axiom is the same:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The empty list is a list with an even number of elements.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;But our inference rule must preserve the invariant that the list always contains an even number of elements. We can do this by always adding two elements at a time:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;If you have a list with an even number of elements, and you add two elements to the beginning, the result is also a list with an even number of elements.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This corresponds precisely to our &lt;code&gt;EvenList&lt;/code&gt; declaration:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also go through this same reasoning process to come up with a type that represents non-empty lists. That type has just one inference rule:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;If you have a list, and you add an element to the beginning, the result is a non-empty list.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;That inference rule corresponds to the following datatype:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;NonEmptyList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmptyCons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course, it’s possible to do this with much more than just lists. A particularly classic example is the constructive definition of natural numbers:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Zero is a natural number.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If you have a natural number, its successor (i.e. that number plus one) is also a natural number.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;These are two of the &lt;a href="https://en.wikipedia.org/wiki/Peano_axioms"&gt;Peano axioms&lt;/a&gt;, which can be represented in Haskell as the following datatype:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Zero&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Succ&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using this type, &lt;code&gt;Zero&lt;/code&gt; represents 0, &lt;code&gt;Succ Zero&lt;/code&gt; represents 1, &lt;code&gt;Succ (Succ Zero)&lt;/code&gt; represents 2, and so on. Just as &lt;code&gt;EvenList&lt;/code&gt; allowed us to represent any list with an even number of elements but made other values impossible to even express, this &lt;code&gt;Natural&lt;/code&gt; type allows us to represent all natural numbers, while other numbers (such as, for example, negative integers) are impossible to express.&lt;/p&gt;&lt;p&gt;Now, of course, all this hinges on our interpretation of the values we’ve invented! We have chosen to interpret &lt;code&gt;Zero&lt;/code&gt; as &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;Succ n&lt;/code&gt; as &lt;code&gt;n + 1&lt;/code&gt;, but that interpretation is not inherent to &lt;code&gt;Natural&lt;/code&gt;’s definition—it’s all in our heads! We could choose to interpret &lt;code&gt;Succ n&lt;/code&gt; as &lt;code&gt;n - 1&lt;/code&gt; instead, in which case we would only be able to represent non-positive integers, or we could interpret &lt;code&gt;Zero&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;Succ n&lt;/code&gt; as &lt;code&gt;n * 2&lt;/code&gt;, in which case we could only represent powers of two.&lt;/p&gt;&lt;p&gt;I find that people sometimes find this approach troubling, or at least counterintuitive. Is &lt;code&gt;Succ (Succ Zero)&lt;/code&gt; &lt;em&gt;really&lt;/em&gt; 2? It certainly doesn’t look like a number we’re used to writing. When someone thinks “I need a datatype for a number greater than or equal to zero,” they’re going to reach for the type in their programming language called &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;, not think to invent a recursive datatype. And admittedly, the &lt;code&gt;Natural&lt;/code&gt; type defined here is not very practical: it’s an incredibly inefficient representation of natural numbers.&lt;/p&gt;&lt;p&gt;But in less contrived situations, this approach &lt;em&gt;is&lt;/em&gt; practical, and in fact it’s highly useful! The quibble that an &lt;code&gt;EvenList Int&lt;/code&gt; isn’t “really” a &lt;code&gt;List Int&lt;/code&gt; is rather meaningless, seeing as our definition of &lt;code&gt;List&lt;/code&gt; was just as arbitrary. A great deal of our jobs as programmers is imbuing arbitrary symbols with meaning; at some point someone decided that the number 65 would correspond to the capital letter A, and it was no less arbitrary then.&lt;/p&gt;&lt;p&gt;So when you have a property you want to capture in your types, take a step back and think about it for a little bit. Is there a way you can structure your data so that, no matter how you build it, the result is always a valid value? In other words, don’t try to add post-hoc restrictions to exclude bad values, &lt;strong&gt;make your datatypes correct by construction&lt;/strong&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name="but-what-if-i-don-t-write-haskell-and-other-closing-thoughts"&gt;&lt;/a&gt;“But what if I don’t write Haskell?” And other closing thoughts&lt;/h2&gt;&lt;p&gt;I write Haskell for a living, and I wrote this blog post with both my coworkers and the broader Haskell community in mind, but if I had &lt;em&gt;only&lt;/em&gt; written it with those people in mind, it wouldn’t make sense to have spent so much time explaining basic Haskell. These techniques can be used in almost any statically typed programming language, though it’s certainly easier in some than others.&lt;/p&gt;&lt;p&gt;I don’t want people to come away from this blog post with an impression that I think TypeScript is a bad language, or that I’m claiming Haskell can do things TypeScript can’t. In fact, TypeScript &lt;em&gt;can&lt;/em&gt; do all the things I’ve talked about in this blog post! As proof, here are TypeScript definitions of both &lt;code&gt;EvenList&lt;/code&gt; and &lt;code&gt;Natural&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;EvenList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;EvenList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Natural&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"zero"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;succ&lt;/span&gt;: &lt;span class="kt"&gt;Natural&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If anything, &lt;strong&gt;the real point of this blog post is that a type system does not have a well-defined list of things it “can prove” and “can’t prove.”&lt;/strong&gt; Languages like TypeScript don’t really encourage this approach to data modeling, where you restructure your values in a certain way so as to guarantee certain properties. Rather, they prefer to add increasingly sophisticated constraints and type system features that can capture the properties people want to capture without having to change their data representation.&lt;/p&gt;&lt;p&gt;And in general, &lt;em&gt;that’s great!&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Being able to reuse the same data representation is &lt;em&gt;hugely&lt;/em&gt; beneficial. Functions like &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; already exist for ordinary lists/arrays, but a home-grown &lt;code&gt;EvenList&lt;/code&gt; type needs its own versions. Passing an &lt;code&gt;EvenList&lt;/code&gt; to a function that expects a list requires explicitly converting between the two. All these things have both code complexity and performance costs, and type system features that make these issues just invisibly disappear are &lt;em&gt;obviously&lt;/em&gt; a good thing.&lt;/p&gt;&lt;p&gt;But the danger of treating the type system this way is that it means you may find yourself unsure what to do when suddenly you have a new requirement that the type system doesn’t provide built-in support for. What then? Do you start punching holes through your type system? The more you do that, the less useful the type system becomes: type systems are great at detecting how changes in one part of a codebase can impact seemingly-unrelated areas in surprising ways, but every unsafe cast or use of &lt;code&gt;any&lt;/code&gt; is a hard stop, a point past which the typechecker cannot propagate information. Do that once or twice in a leaf function, it’s okay, but do that even just a half dozen times in your application’s connective tissue, and your type system might not be able to catch those things anymore.&lt;/p&gt;&lt;p&gt;Even if it isn’t a technique you use every day, it’s worth getting comfortable tweaking your data representation to preserve those guarantees. It’s a magical experience having the typechecker teach you things about your domain you hadn’t even considered simply because you got a type error and started thinking through why. Yes, it’s extra work, but trust me: it’s a lot more pleasant to work for your typechecker when you know exactly how much your typechecker is working for you.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;Sort of. TypeScript will try to infer type annotations based on how variables and functions are used, but by default, it falls back on the dynamic, unchecked &lt;code&gt;any&lt;/code&gt; type if it can’t find a solution that makes the program typecheck. That behavior can be changed via a configuration option, but that isn’t relevant here: I’m just trying to illustrate a perspective, not make any kind of value judgment about TypeScript specifically. &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-2"&gt;&lt;p&gt;Sort of. Haskell does have a limited notion of subtyping when polymorphism is involved; for example, the type &lt;code&gt;forall a. a -&amp;gt; a&lt;/code&gt; is a subtype of the type &lt;code&gt;Int -&amp;gt; Int&lt;/code&gt;. But Haskell does not have anything resembling inheritance (e.g. there is no common &lt;code&gt;Number&lt;/code&gt; supertype that includes both &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt;) nor does it have untagged unions (e.g. the argument to a function cannot be something like &lt;code&gt;Int | String&lt;/code&gt;, you must define a wrapper type like &lt;code&gt;data IntOrString = AnInt Int | AString String&lt;/code&gt;). &lt;a href="#footnote-ref-2-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-3"&gt;&lt;p&gt;Lists, tuples, and strings do technically have special &lt;em&gt;syntax&lt;/em&gt;, which is built into the compiler, but there is truly nothing special about their semantics. They would work exactly the same way without the syntax, the code would just look less pretty. &lt;a href="#footnote-ref-3-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-4"&gt;&lt;p&gt;Haskell programmers will notice that this is not actually the definition of the list type, since the real list type uses special syntax, but I wanted to keep things as simple as possible for this blog post. &lt;a href="#footnote-ref-4-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-5"&gt;&lt;p&gt;Ignoring infinite lists, but the fact that infinite lists are representable in Haskell is outside the scope of this blog post. &lt;a href="#footnote-ref-5-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>No, dynamic type systems are not inherently more open</title><link>https://lexi-lambda.github.io/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/</guid><pubDate>19 Jan 2020</pubDate><description>&lt;article&gt;&lt;p&gt;Internet debates about typing disciplines continue to be plagued by a pervasive myth that dynamic type systems are inherently better at modeling “open world” domains. The argument usually goes like this: the goal of static typing is to pin everything down as much as possible, but in the real world, that just isn’t practical. Real systems should be loosely coupled and worry about data representation as little as possible, so dynamic types lead to a more robust system in the large.&lt;/p&gt;&lt;p&gt;This story sounds compelling, but it isn’t true. The flaw is in the premise: static types are &lt;em&gt;not&lt;/em&gt; about “classifying the world” or pinning down the structure of every value in a system. The reality is that static type systems allow specifying exactly how much a component needs to know about the structure of its inputs, and conversely, how much it doesn’t. Indeed, in practice static type systems excel at processing data with only a partially-known structure, as they can be used to ensure application logic doesn’t accidentally assume too much.&lt;/p&gt;&lt;h2&gt;&lt;a name="two-typing-fallacies"&gt;&lt;/a&gt;Two typing fallacies&lt;/h2&gt;&lt;p&gt;I’ve wanted to write this blog post for a while, but what finally made me decide to do it were misinformed comments responding to &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;my previous blog post&lt;/a&gt;. Two comments in particular caught my eye, &lt;a href="https://www.reddit.com/r/programming/comments/dt0w63/parse_dont_validate/f6ulpsy/"&gt;the first of which was posted on /r/programming&lt;/a&gt;:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Strongly disagree with the post […] it promotes a fundamentally entangled and static view of the world. It assumes that we can or should theorize about what is "valid" input at the edge between the program and the world, thus introducing a strong sense of coupling through the entire software, where failure to conform to some schema will automatically crash the program.&lt;/p&gt;&lt;p&gt;This is touted as a feature here but imagine if the internet worked like this. A server changes their JSON output, and we need to recompile and reprogram the entire internet. This is the static view that is promoted as a feature here. […] The "parser mentality" is fundamentally rigid and global, whereas robust system design should be decentralised and leave interpretation of data to the receiver.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Given the argument being made in the blog post—that you should use precise types whenever possible—one can see where this misinterpretation comes from. How could a proxy server possibly be written in such a style, since it cannot anticipate the structure of its payloads? The commenter’s conclusion is that strict static typing is at odds with programs that don’t know the structure of their inputs ahead of time.&lt;/p&gt;&lt;p&gt;&lt;a href="https://news.ycombinator.com/item?id=21479933"&gt;The second comment was left on Hacker News&lt;/a&gt;, and it is significantly shorter than the first one:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;What would be the type signature of, say, Python's &lt;code&gt;pickle.load()&lt;/code&gt;?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;This is a different kind of argument, one that relies on the fact that the types of reflective operations may depend on runtime values, which makes them challenging to capture with static types. This argument suggests that static types limit expressiveness because they forbid such operations outright.&lt;/p&gt;&lt;p&gt;Both these arguments are fallacious, but in order to show why, we have to make explicit an implicit claim. The two comments focus primarily on illustrating how static type systems can’t process data of an unknown shape, but they simultaneously advance an implicit belief: that dynamically typed languages &lt;em&gt;can&lt;/em&gt; process data of an unknown shape. As we’ll see, this belief is misguided; programs are not capable of processing data of a truly unknown shape regardless of typing discipline, and static type systems only make already-present assumptions explicit.&lt;/p&gt;&lt;h2&gt;&lt;a name="you-can-t-process-what-you-don-t-know"&gt;&lt;/a&gt;You can’t process what you don’t know&lt;/h2&gt;&lt;p&gt;The claim is simple: in a static type system, you must declare the shape of data ahead of time, but in a dynamic type system, the type can be, well, dynamic! It sounds self-evident, so much so that Rich Hickey has practically built a speaking career upon its emotional appeal. The only problem is it isn’t true.&lt;/p&gt;&lt;p&gt;The hypothetical scenario usually goes like this. Say you have a distributed system, and services in the system emit events that can be consumed by any other service that might need them. Each event is accompanied by a payload, which listening services can use to inform further action. The payload itself is minimally-structured, schemaless data encoded using a generic interchange format such as JSON or &lt;a href="https://github.com/edn-format/edn"&gt;EDN&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;As a simple example, a login service might emit an event like this one whenever a new user signs up:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;"event_type"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"signup"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;"timestamp"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"2020-01-19T05:37:09Z"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;"data"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;"user"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;"id"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;"name"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Alyssa"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;"email"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"alyssa@example.com"&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Some downstream services might listen for these &lt;code&gt;signup&lt;/code&gt; events and take further action whenever they are emitted. For example, a transactional email service might send a welcome email whenever a new user signs up. If the service were written in JavaScript, the handler might look something like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;login&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="cm"&gt;/* ... */&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;signup&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="nx"&gt;sendEmail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;email&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sb"&gt;`Welcome to Blockchain Emporium, &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;!`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if this service were written in Haskell instead? Being good, reality-fearing Haskell programmers who &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;parse, not validate&lt;/a&gt;, the Haskell code might look something like this, instead:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Event&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;Event&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;parseJSON&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;withObject&lt;/span&gt; &lt;span class="s"&gt;"Event"&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;eventType&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"event_type"&lt;/span&gt;
    &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;eventType&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
      &lt;span class="s"&gt;"login"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"data"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="s"&gt;"signup"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"signup"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"unknown event_type: "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;eventType&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromJSON&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Success&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="cm"&gt;{- ... -}&lt;/span&gt;
  &lt;span class="kt"&gt;Success&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;sendEmail&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"Welcome to Blockchain Emporium, "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"!"&lt;/span&gt;
  &lt;span class="kt"&gt;Error&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"could not parse event: "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It’s definitely more boilerplate, but some extra overhead for type definitions is to be expected (and is greatly exaggerated in such tiny examples), and the arguments we’re discussing aren’t about boilerplate, anyway. The &lt;em&gt;real&lt;/em&gt; problem with this version of the code, according to the Reddit comment from earlier, is that the Haskell code has to be updated whenever a service adds a new event type! A new case has to be added to the &lt;code&gt;Event&lt;/code&gt; datatype, and it must be given new parsing logic. And what about when new fields get added to the payload? What a maintenance nightmare.&lt;/p&gt;&lt;p&gt;In comparison, the JavaScript code is much more permissive. If a new event type is added, it will just fall through the &lt;code&gt;switch&lt;/code&gt; and do nothing. If extra fields are added to the payload, the JavaScript code will just ignore them. Seems like a win for dynamic typing.&lt;/p&gt;&lt;p&gt;Except that no, it isn’t. The only reason the statically typed program fails if we don’t update the &lt;code&gt;Event&lt;/code&gt; type is that we wrote &lt;code&gt;handleEvent&lt;/code&gt; that way. We could just have easily done the same thing in the JavaScript code, adding a default case that rejects unknown event types:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* ... */&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sb"&gt;`unknown event_type: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We didn’t do that, since in this case it would clearly be silly. If a service receives an event it doesn’t know about, it should just ignore it. This is a case where being permissive is clearly the correct behavior, and we can easily implement that in the Haskell code too:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromJSON&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="cm"&gt;{- ... -}&lt;/span&gt;
  &lt;span class="kt"&gt;Error&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is still in the spirit of “parse, don’t validate” because we’re still parsing the values we &lt;em&gt;do&lt;/em&gt; care about as early as possible, so we don’t fall into the double-validation trap. At no point do we take a code path that depends on a value being well-formed without first ensuring (with the help of the type system) that it is, in fact, actually well-formed. We don’t have to respond to an ill-formed value by raising an error! We just have to be explicit about ignoring it.&lt;/p&gt;&lt;p&gt;This illustrates an important point: the &lt;code&gt;Event&lt;/code&gt; type in this Haskell code doesn’t describe “all possible events,” it describes all the events that the application cares about. Likewise, the code that parses those events’ payloads only worries about the fields the application needs, and it ignores extraneous ones. A static type system doesn’t require you eagerly write a schema for the whole universe, it simply requires you to be up front about the things you need.&lt;/p&gt;&lt;p&gt;This turns out to have a lot of pleasant benefits even though knowledge about inputs is limited:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;It’s easy to discover the assumptions of the Haskell program just by looking at the type definitions. We know, for example, that this application doesn’t care about the &lt;code&gt;timestamp&lt;/code&gt; field, since it never appears in any of the payload types. In the dynamically-typed program, we’d have to audit every code path to see whether or not it inspects that field, which would be a lot of error-prone work!&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;What’s more, it turns out the Haskell code doesn’t actually &lt;em&gt;use&lt;/em&gt; the &lt;code&gt;userId&lt;/code&gt; field inside the &lt;code&gt;SignupPayload&lt;/code&gt; type, so that type is overly conservative. If we want to ensure it isn’t actually needed (since, for example, maybe we’re phasing out providing the user ID in that payload entirely), we need only delete that record field; if the code typechecks, we can be confident it really doesn’t depend on that field.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, we neatly avoid all the gotchas related to shotgun parsing &lt;a href="/blog/2019/11/05/parse-don-t-validate/#the-danger-of-validation"&gt;mentioned in the previous blog post&lt;/a&gt;, since we still haven’t compromised on any of those principles.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We’ve already invalidated the first half of the claim: that statically typed languages can’t deal with data where the structure isn’t completely known. Let’s now look at the other half, which states that dynamically typed languages can process data where the structure isn’t known at all. Maybe that still sounds right, but if you slow down and think about it more carefully, you’ll find it can’t be.&lt;/p&gt;&lt;p&gt;The above JavaScript code makes all the same assumptions our Haskell code does: it assumes event payloads are JSON objects with an &lt;code&gt;event_type&lt;/code&gt; field, and it assumes &lt;code&gt;signup&lt;/code&gt; payloads include &lt;code&gt;data.user.name&lt;/code&gt; and &lt;code&gt;data.user.email&lt;/code&gt; fields. It certainly can’t do anything useful with truly unknown input! If a new event payload is added, our JavaScript code can’t magically adapt to handle it simply because it is dynamically typed. Dynamic typing just means the types of values are carried alongside them at runtime and checked as the program executes; the types are still there, and this program still implicitly relies on them being particular things.&lt;/p&gt;&lt;h2&gt;&lt;a name="keeping-opaque-data-opaque"&gt;&lt;/a&gt;Keeping opaque data opaque&lt;/h2&gt;&lt;p&gt;In the previous section, we debunked the idea that statically typed systems can’t process partially-known data, but if you have been paying close attention, you may have noticed it did not fully refute the original claim.&lt;/p&gt;&lt;p&gt;Although we were able to handle unknown data, we always simply discarded it, which would not fly if we were trying to implement some sort of proxying. For example, suppose we have a forwarding service that broadcasts events over a public network, attaching a signature to each payload to ensure it can’t be spoofed. We might implement this in JavaScript this way:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;signedPayload&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="nx"&gt;retransmitEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;signedPayload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, we don’t care about the structure of the payload at all (the &lt;code&gt;signature&lt;/code&gt; function just works on any valid JSON object), but we still have to preserve all the information. How could we do that in a statically typed language, since a statically-typed language would have to assign the payload a precise type?&lt;/p&gt;&lt;p&gt;Once again, the answer involves rejecting the premise: there’s no need to give data a type that’s any more precise than the application needs. The same logic could be written in a straightforward way in Haskell:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;signedPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"signature"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;
  &lt;span class="n"&gt;retransmitEvent&lt;/span&gt; &lt;span class="n"&gt;signedPayload&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"event payload was not an object "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, since we don’t care about the structure of the payload, we manipulate a value of type &lt;code&gt;JSON.Value&lt;/code&gt; directly. This type is extremely imprecise compared to our &lt;code&gt;Event&lt;/code&gt; type from earlier—it can hold any legal JSON value, of any shape—but in this case, we &lt;em&gt;want&lt;/em&gt; it to be imprecise.&lt;/p&gt;&lt;p&gt;Thanks to that imprecision, the type system helped us here: it caught the fact that we’re assuming the payload is a JSON object, not some other JSON value, and it made us handle the non-object cases explicitly. In this case we chose to raise an error, but of course, as before, you could choose some other form of recovery if you wanted to. You just have to be explicit about it.&lt;/p&gt;&lt;p&gt;Once more, note that the assumption we were forced to make explicit in Haskell is &lt;em&gt;also&lt;/em&gt; made by the JavaScript code! If our JavaScript &lt;code&gt;handleEvent&lt;/code&gt; function were called with a string rather than an object, it’s unlikely the behavior would be desirable, since an object spread on a string results in the following surprise:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="s2"&gt;"payload"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"sig"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"y"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"l"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"o"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"d"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"sig"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Oops. Once again, the parsing style of programming has helped us out, since if we didn’t “parse” the JSON value into an object by matching on the &lt;code&gt;Object&lt;/code&gt; case explicitly, our code would not compile, and if we left off the fallthrough case, we’d get a warning about inexhaustive patterns.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;Let’s look at one more example of this phenomenon before moving on. Suppose we’re consuming an API that returns user IDs, and suppose those IDs happen to be UUIDs. A straightforward interpretation of “parse, don’t validate” might suggest we represent user IDs in our Haskell API client using a &lt;code&gt;UUID&lt;/code&gt; type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UUID&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, our Reddit commenter would likely take umbrage with this! Unless the API contract explicitly states that all user IDs will be UUIDs, this representation is overstepping our bounds. Although user IDs might be UUIDs today, perhaps they won’t be tomorrow, and then our code would break for no reason! Is this the fault of static type systems?&lt;/p&gt;&lt;p&gt;Again, the answer is no. This is a case of improper data modeling, but the static type system is not at fault—it has simply been misused. The appropriate way to represent a &lt;code&gt;UserId&lt;/code&gt; is to define a new, opaque type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unlike the type alias defined above which simply creates a new name for the existing &lt;code&gt;UUID&lt;/code&gt; type, this declaration creates a totally new &lt;code&gt;UserId&lt;/code&gt; type that is distinct from all other types, including &lt;code&gt;Text&lt;/code&gt;. If we keep the datatype’s constructor private (that is, we don’t export it from the module that defines this type), then the &lt;em&gt;only&lt;/em&gt; way to produce a &lt;code&gt;UserId&lt;/code&gt; will be to go through its &lt;code&gt;FromJSON&lt;/code&gt; parser. Dually, the only things you can do with a &lt;code&gt;UserId&lt;/code&gt; are compare it with other &lt;code&gt;UserId&lt;/code&gt;s for equality or serialize it using the &lt;code&gt;ToJSON&lt;/code&gt; instance. Nothing else is permitted: the type system will prevent you from depending on the remote service’s internal representation of user IDs.&lt;/p&gt;&lt;p&gt;This illustrates another way that static type systems can provide strong, useful guarantees when manipulating completely opaque data. The runtime representation of a &lt;code&gt;UserId&lt;/code&gt; is really just a string, but the type system does not allow you to accidentally use it like it’s a string, nor does it allow you to forge a new &lt;code&gt;UserId&lt;/code&gt; out of thin air from an arbitrary string.&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;The type system is not a ball and chain forcing you to describe the representation of every value that enters and leaves your program in exquisite detail. Rather, it’s a tool that you can use in whatever way best suits your needs.&lt;/p&gt;&lt;h2&gt;&lt;a name="reflection-is-not-special"&gt;&lt;/a&gt;Reflection is not special&lt;/h2&gt;&lt;p&gt;We’ve now thoroughly debunked the claims made by the first commenter, but the question posed by the second commenter may still seem like a loophole in our logic. What &lt;em&gt;is&lt;/em&gt; the type of Python’s &lt;code&gt;pickle.load()&lt;/code&gt;? For those unfamiliar, &lt;a href="https://docs.python.org/3/library/pickle.html"&gt;Python’s cutely-named &lt;code&gt;pickle&lt;/code&gt; library&lt;/a&gt; allows serializing and deserializing entire Python object graphs. Any object can be serialized and stored in a file using &lt;code&gt;pickle.dump()&lt;/code&gt;, and it can be deserialized at a later point in time using &lt;code&gt;pickle.load()&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;What makes this appear challenging to our static type system is that the type of value produced by &lt;code&gt;pickle.load()&lt;/code&gt; is difficult to predict—it depends entirely on whatever happened to be written to that file using &lt;code&gt;pickle.dump()&lt;/code&gt;. This seems inherently dynamic, since we cannot possibly know what type of value it will produce at compile-time. At first blush, this is something a dynamically typed system can pull off, but a statically-typed one just can’t.&lt;/p&gt;&lt;p&gt;However, it turns out this situation is actually identical to the previous examples using JSON, and the fact that Python’s pickling serializes native Python objects directly does not change things. Why? Well, consider what happens &lt;em&gt;after&lt;/em&gt; a program calls &lt;code&gt;pickle.load()&lt;/code&gt;. Say you write the following function:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;load_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="c1"&gt;# do something with `val`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The trouble is that &lt;code&gt;val&lt;/code&gt; can now be of &lt;em&gt;any&lt;/em&gt; type, and just as you can’t do anything useful with truly unknown, unstructured input, you can’t do anything with a value unless you know at least something about it. If you call any method or access any field on the result, then you’ve already made an assumption about what sort of thing &lt;code&gt;pickle.load(f)&lt;/code&gt; returned—and it turns out those assumptions &lt;em&gt;are&lt;/em&gt; &lt;code&gt;val&lt;/code&gt;’s type!&lt;/p&gt;&lt;p&gt;For example, imagine the only thing you do with &lt;code&gt;val&lt;/code&gt; is call the &lt;code&gt;val.foo()&lt;/code&gt; method and return its result, which is expected to be a string. If we were writing Java, then the expected type of &lt;code&gt;val&lt;/code&gt; would be quite straightforward—we’d expect it to be an instance of the following interface:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Serializable&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And indeed, it turns out a &lt;code&gt;pickle.load()&lt;/code&gt;-like function can be given a perfectly reasonable type in Java:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;load&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nitpickers will complain that this isn’t the same as &lt;code&gt;pickle.load()&lt;/code&gt;, since you have to pass a &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; token to choose what type of thing you want ahead of time. However, nothing is stopping you from passing &lt;code&gt;Serializable.class&lt;/code&gt; and branching on the type later, after the object has been loaded. And that’s the key point: the instant you do &lt;em&gt;anything&lt;/em&gt; with the object, you must know something about its type, even in a dynamically typed language! The statically-typed language just forces you to be more explicit about it, just as it did when we were talking about JSON payloads.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;Can we do this in Haskell, too? Absolutely—we can use &lt;a href="https://hackage.haskell.org/package/serialise"&gt;the &lt;code&gt;serialise&lt;/code&gt; library&lt;/a&gt;, which has a similar API to the Java one mentioned above. It also happens to have a very similar interface to &lt;a href="https://hackage.haskell.org/package/aeson"&gt;the Haskell JSON library, aeson&lt;/a&gt;, as it turns out the problem of dealing with unknown JSON data is not terribly different from dealing with an unknown Haskell value—at some point, you have to do a little bit of parsing to do anything with the value.&lt;/p&gt;&lt;p&gt;That said, while you &lt;em&gt;can&lt;/em&gt; emulate the dynamic typing of &lt;code&gt;pickle.load()&lt;/code&gt; if you really want to by deferring the type check until the last possible moment, the reality is that doing so is almost never actually useful. At some point, you have to make assumptions about the structure of the value in order to use it, and you know what those assumptions are because &lt;em&gt;you wrote the code&lt;/em&gt;. While there are extremely rare exceptions to this that require true dynamic code loading (such as, say, implementing a REPL for your programming language), they do not occur in day-to-day programming, and programmers in statically-typed languages are perfectly happy to supply their assumptions up front.&lt;/p&gt;&lt;p&gt;This is one of the fundamental disconnects between the static typing camp and the dynamic typing camp. Programmers working in statically-typed languages are perplexed when a programmer suggests they can do something in a dynamically typed language that a statically-typed language “fundamentally” prevents, since a programmer in a statically-typed language may reply the value has simply not been given a sufficiently precise type. From the perspective of a programmer working in a dynamically-typed language, the type system restricts the space of legal behaviors, but from the perspective of a programmer working in a statically-typed language, the set of legal behaviors &lt;em&gt;is&lt;/em&gt; a value’s type.&lt;/p&gt;&lt;p&gt;Neither of these perspectives are actually inaccurate, from the appropriate point of view. Static type systems &lt;em&gt;do&lt;/em&gt; impose restrictions on program structure, as it is provably impossible to reject &lt;em&gt;all&lt;/em&gt; bad programs in a Turing-complete language without also rejecting some good ones (this is &lt;a href="https://en.wikipedia.org/wiki/Rice's_theorem"&gt;Rice’s theorem&lt;/a&gt;). But it is simultaneously true that the impossibility of solving the general problem does not preclude solving a slightly more restricted version of the problem in a useful way, and a lot of the so-called “fundamental” inabilities of static type systems are not fundamental at all.&lt;/p&gt;&lt;h2&gt;&lt;a name="appendix-the-reality-behind-the-myths"&gt;&lt;/a&gt;Appendix: the reality behind the myths&lt;/h2&gt;&lt;p&gt;The key thesis of this blog post has now been delivered: static type systems are not fundamentally worse than dynamic type systems at processing data with an open or partially-known structure. The sorts of claims made in the comments cited at the beginning of this blog post are not accurate depictions of what statically-typed program construction is like, and they misunderstand the limitations of static typing disciplines while exaggerating the capabilities of dynamically typed disciplines.&lt;/p&gt;&lt;p&gt;However, although greatly exaggerated, these myths do have some basis in reality. They appear to have developed at least in part from a misunderstanding about the differences between structural and nominal typing. This difference is unfortunately too big to address in this blog post, as it could likely fill several blog posts of its own. About six months ago I attempted to write a blog post on the subject, but I didn’t think it came out very compelling, so I scrapped it. Maybe someday I’ll find a better way to communicate the ideas.&lt;/p&gt;&lt;p&gt;Although I can’t give it the full treatment it deserves right now, I’d still like to touch on the idea briefly so that interested readers may be able to find other resources on the subject should they wish to do so. The key idea is that many dynamically typed languages idiomatically reuse simple data structures like hashmaps to represent what in statically-typed languages are often represented by bespoke datatypes (usually defined as classes or structs).&lt;/p&gt;&lt;p&gt;These two styles facilitate very different flavors of programming. A JavaScript or Clojure program may represent a record as a hashmap from string or symbol keys to values, written using object or hash literals and manipulated using ordinary functions from the standard library that manipulate keys and values in a generic way. This makes it straightforward to take two records and union their fields or to take an arbitrary (or even dynamic) subselection of fields from an existing record.&lt;/p&gt;&lt;p&gt;In contrast, most static type systems do not allow such free-form manipulation of records because records are not maps at all but unique types distinct from all other types. These types are uniquely identified by their (fully-qualified) name, hence the term &lt;em&gt;nominal typing&lt;/em&gt;. If you wish to take a subselection of a struct’s fields, you must define an entirely new struct; doing this often creates an explosion of awkward boilerplate.&lt;/p&gt;&lt;p&gt;This is one of the main ideas that Rich Hickey has discussed in many of his talks that criticize static typing. He has advanced the idea that this ability to fluidly merge, separate, and transform records makes dynamic typing particularly suited to the domain of distributed, open systems. Unfortunately, this rhetoric has two significant flaws:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;It skirts too close to calling this a fundamental limitation of type systems, suggesting that it is not simply inconvenient but &lt;em&gt;impossible&lt;/em&gt; to model such systems in a nominal, static type system. Not only is this not true (as this blog post has demonstrated), it misdirects people away from the point of his that actually has value: the practical, pragmatic advantage of a more structural approach to data modeling.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;It confuses the structural/nominal distinction with the dynamic/static distinction, incorrectly creating the impression that the fluid merging and splitting of records represented as key-value maps is only possible in a dynamically typed language. In fact, not only can statically-typed languages support structural typing, many dynamically-typed languages also support nominal typing. These axes have historically loosely correlated, but they are theoretically orthogonal.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;For counterexamples to these claims, consider Python classes, which are quite nominal despite being dynamic, and TypeScript interfaces, which are structural despite being static. Indeed, modern statically-typed languages are increasingly acquiring native support for structurally-typed records. In these systems, record types work much like hashes in Clojure—they are not distinct, named types but rather anonymous collections of key-value pairs—and they support many of the same expressive manipulation operations that Clojure’s hashes do, all within a statically-typed framework.&lt;/p&gt;&lt;p&gt;If you are interested in exploring static type systems with strong support for structural typing, I would recommend taking a look at any of TypeScript, Flow, PureScript, Elm, OCaml, or Reason, all of which have some sort of support for structurally typed records. What I would &lt;em&gt;not&lt;/em&gt; recommend for this purpose is Haskell, which has abysmal support for structural typing; Haskell is (for various reasons outside the scope of this blog post) aggressively nominal.&lt;sup&gt;&lt;a href="#footnote-2" id="footnote-ref-2-1"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;Does this mean Haskell is bad, or that it cannot be practically used to solve these kinds of problems? No, certainly not; there are many ways to model these problems in Haskell that work well enough, though some of them suffer from significant boilerplate. The core thesis of this blog post applies just as much to Haskell as it does to any of the other languages I mentioned above. However, I would be remiss not to mention this distinction, as it may give programmers from a dynamically-typed background who have historically found statically-typed languages much more frustrating to work with a better understanding of the &lt;em&gt;real&lt;/em&gt; reason they feel that way. (Essentially all mainstream, statically-typed OOP languages are even more nominal than Haskell!)&lt;/p&gt;&lt;p&gt;As closing thoughts: this blog post is not intended to start a flame war, nor is it intended to be an assault on dynamically typed programming. There are many patterns in dynamically-typed languages that are genuinely difficult to translate into a statically-typed context, and I think discussions of those patterns can be productive. The purpose of this blog post is to clarify why one particular discussion is &lt;em&gt;not&lt;/em&gt; productive, so please: stop making these arguments. There are much more productive conversations to have about typing than this.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;Technically, you could abuse the &lt;code&gt;FromJSON&lt;/code&gt; instance to convert an arbitrary string to a &lt;code&gt;UserId&lt;/code&gt;, but this would not be as easy as it sounds, since &lt;code&gt;fromJSON&lt;/code&gt; can fail. This means you’d somehow have to handle that failure case, so this trick would be unlikely to get you very far unless you’re already in a context where you’re doing input parsing… at which point it would be easier to just do the right thing. So yes, the type system doesn’t prevent you from going out of your way to shoot yourself in the foot, but it guides you towards the right solution (and there is no safeguard in existence that can completely protect a programmer from making their own life miserable if they are determined to do so). &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-2"&gt;&lt;p&gt;I consider this to be Haskell’s most significant flaw at the time of this writing. &lt;a href="#footnote-ref-2-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Parse, don’t validate</title><link>https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/</guid><pubDate>05 Nov 2019</pubDate><description>&lt;article&gt;&lt;p&gt;Historically, I’ve struggled to find a concise, simple way to explain what it means to practice type-driven design. Too often, when someone asks me “How did you come up with this approach?” I find I can’t give them a satisfying answer. I know it didn’t just come to me in a vision—I have an iterative design process that doesn’t require plucking the “right” approach out of thin air—yet I haven’t been very successful in communicating that process to others.&lt;/p&gt;&lt;p&gt;However, about a month ago, &lt;a href="https://twitter.com/lexi_lambda/status/1182242561655746560"&gt;I was reflecting on Twitter&lt;/a&gt; about the differences I experienced parsing JSON in statically- and dynamically-typed languages, and finally, I realized what I was looking for. Now I have a single, snappy slogan that encapsulates what type-driven design means to me, and better yet, it’s only three words long:&lt;/p&gt;&lt;div style="text-align: center; font-size: larger"&gt;&lt;strong&gt;Parse, don’t validate.&lt;/strong&gt;&lt;/div&gt;&lt;h2&gt;&lt;a name="the-essence-of-type-driven-design"&gt;&lt;/a&gt;The essence of type-driven design&lt;/h2&gt;&lt;p&gt;Alright, I’ll confess: unless you already know what type-driven design is, my catchy slogan probably doesn’t mean all that much to you. Fortunately, that’s what the remainder of this blog post is for. I’m going to explain precisely what I mean in gory detail—but first, we need to practice a little wishful thinking.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-realm-of-possibility"&gt;&lt;/a&gt;The realm of possibility&lt;/h3&gt;&lt;p&gt;One of the wonderful things about static type systems is that they can make it possible, and sometimes even easy, to answer questions like “is it possible to write this function?” For an extreme example, consider the following Haskell type signature:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;foo&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Is it possible to implement &lt;code&gt;foo&lt;/code&gt;? Trivially, the answer is &lt;em&gt;no&lt;/em&gt;, as &lt;code&gt;Void&lt;/code&gt; is a type that contains no values, so it’s impossible for &lt;em&gt;any&lt;/em&gt; function to produce a value of type &lt;code&gt;Void&lt;/code&gt;.&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;1&lt;/a&gt;&lt;/sup&gt; That example is pretty boring, but the question gets much more interesting if we choose a more realistic example:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function returns the first element from a list. Is it possible to implement? It certainly doesn’t sound like it does anything very complicated, but if we attempt to implement it, the compiler won’t be satisfied:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for ‘head’: Patterns not matched: []
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This message is helpfully pointing out that our function is &lt;em&gt;partial&lt;/em&gt;, which is to say it is not defined for all possible inputs. Specifically, it is not defined when the input is &lt;code&gt;[]&lt;/code&gt;, the empty list. This makes sense, as it isn’t possible to return the first element of a list if the list is empty—there’s no element to return! So, remarkably, we learn this function isn’t possible to implement, either.&lt;/p&gt;&lt;h3&gt;&lt;a name="turning-partial-functions-total"&gt;&lt;/a&gt;Turning partial functions total&lt;/h3&gt;&lt;p&gt;To someone coming from a dynamically-typed background, this might seem perplexing. If we have a list, we might very well want to get the first element in it. And indeed, the operation of “getting the first element of a list” isn’t impossible in Haskell, it just requires a little extra ceremony. There are two different ways to fix the &lt;code&gt;head&lt;/code&gt; function, and we’ll start with the simplest one.&lt;/p&gt;&lt;h4&gt;&lt;a name="managing-expectations"&gt;&lt;/a&gt;Managing expectations&lt;/h4&gt;&lt;p&gt;As established, &lt;code&gt;head&lt;/code&gt; is partial because there is no element to return if the list is empty: we’ve made a promise we cannot possibly fulfill. Fortunately, there’s an easy solution to that dilemma: we can weaken our promise. Since we cannot guarantee the caller an element of the list, we’ll have to practice a little expectation management: we’ll do our best return an element if we can, but we reserve the right to return nothing at all. In Haskell, we express this possibility using the &lt;code&gt;Maybe&lt;/code&gt; type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This buys us the freedom we need to implement &lt;code&gt;head&lt;/code&gt;—it allows us to return &lt;code&gt;Nothing&lt;/code&gt; when we discover we can’t produce a value of type &lt;code&gt;a&lt;/code&gt; after all:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;    &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Problem solved, right? For the moment, yes… but this solution has a hidden cost.&lt;/p&gt;&lt;p&gt;Returning &lt;code&gt;Maybe&lt;/code&gt; is undoubtably convenient when we’re &lt;em&gt;implementing&lt;/em&gt;  &lt;code&gt;head&lt;/code&gt;. However, it becomes significantly less convenient when we want to actually use it! Since &lt;code&gt;head&lt;/code&gt; always has the potential to return &lt;code&gt;Nothing&lt;/code&gt;, the burden falls upon its callers to handle that possibility, and sometimes that passing of the buck can be incredibly frustrating. To see why, consider the following code:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirsString&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getEnv&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS"&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;configDirsString&lt;/span&gt;
  &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
    &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS cannot be empty"&lt;/span&gt;
  &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt;

&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirs&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getConfigurationDirectories&lt;/span&gt;
  &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;configDirs&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;cacheDir&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;initializeCache&lt;/span&gt; &lt;span class="n"&gt;cacheDir&lt;/span&gt;
    &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"should never happen; already checked configDirs is non-empty"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When &lt;code&gt;getConfigurationDirectories&lt;/code&gt; retrieves a list of file paths from the environment, it proactively checks that the list is non-empty. However, when we use &lt;code&gt;head&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt; to get the first element of the list, the &lt;code&gt;Maybe FilePath&lt;/code&gt; result still requires us to handle a &lt;code&gt;Nothing&lt;/code&gt; case that we know will never happen! This is terribly bad for several reasons:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;First, it’s just annoying. We already checked that the list is non-empty, why do we have to clutter our code with another redundant check?&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Second, it has a potential performance cost. Although the cost of the redundant check is trivial in this particular example, one could imagine a more complex scenario where the redundant checks could add up, such as if they were happening in a tight loop.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, and worst of all, this code is a bug waiting to happen! What if &lt;code&gt;getConfigurationDirectories&lt;/code&gt; were modified to stop checking that the list is empty, intentionally or unintentionally? The programmer might not remember to update &lt;code&gt;main&lt;/code&gt;, and suddenly the “impossible” error becomes not only possible, but probable.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The need for this redundant check has essentially forced us to punch a hole in our type system. If we could statically &lt;em&gt;prove&lt;/em&gt; the &lt;code&gt;Nothing&lt;/code&gt; case impossible, then a modification to &lt;code&gt;getConfigurationDirectories&lt;/code&gt; that stopped checking if the list was empty would invalidate the proof and trigger a compile-time failure. However, as-written, we’re forced to rely on a test suite or manual inspection to catch the bug.&lt;/p&gt;&lt;h4&gt;&lt;a name="paying-it-forward"&gt;&lt;/a&gt;Paying it forward&lt;/h4&gt;&lt;p&gt;Clearly, our modified version of &lt;code&gt;head&lt;/code&gt; leaves some things to be desired. Somehow, we’d like it to be smarter: if we already checked that the list was non-empty, &lt;code&gt;head&lt;/code&gt; should unconditionally return the first element without forcing us to handle the case we know is impossible. How can we do that?&lt;/p&gt;&lt;p&gt;Let’s look at the original (partial) type signature for &lt;code&gt;head&lt;/code&gt; again:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The previous section illustrated that we can turn that partial type signature into a total one by weakening the promise made in the return type. However, since we don’t want to do that, there’s only one thing left that can be changed: the argument type (in this case, &lt;code&gt;[a]&lt;/code&gt;). Instead of weakening the return type, we can &lt;em&gt;strengthen&lt;/em&gt; the argument type, eliminating the possibility of &lt;code&gt;head&lt;/code&gt; ever being called on an empty list in the first place.&lt;/p&gt;&lt;p&gt;To do this, we need a type that represents non-empty lists. Fortunately, the existing &lt;code&gt;NonEmpty&lt;/code&gt; type from &lt;code&gt;Data.List.NonEmpty&lt;/code&gt; is exactly that. It has the following definition:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that &lt;code&gt;NonEmpty a&lt;/code&gt; is really just a tuple of an &lt;code&gt;a&lt;/code&gt; and an ordinary, possibly-empty &lt;code&gt;[a]&lt;/code&gt;. This conveniently models a non-empty list by storing the first element of the list separately from the list’s tail: even if the &lt;code&gt;[a]&lt;/code&gt; component is &lt;code&gt;[]&lt;/code&gt;, the &lt;code&gt;a&lt;/code&gt; component must always be present. This makes &lt;code&gt;head&lt;/code&gt; completely trivial to implement:&lt;sup&gt;&lt;a href="#footnote-2" id="footnote-ref-2-1"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:|&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unlike before, GHC accepts this definition without complaint—this definition is &lt;em&gt;total&lt;/em&gt;, not partial. We can update our program to use the new implementation:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirsString&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getEnv&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS"&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;configDirsString&lt;/span&gt;
  &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;nonEmpty&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;nonEmptyConfigDirsList&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;nonEmptyConfigDirsList&lt;/span&gt;
    &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS cannot be empty"&lt;/span&gt;

&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirs&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getConfigurationDirectories&lt;/span&gt;
  &lt;span class="n"&gt;initializeCache&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;configDirs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the redundant check in &lt;code&gt;main&lt;/code&gt; is now completely gone! Instead, we perform the check exactly once, in &lt;code&gt;getConfigurationDirectories&lt;/code&gt;. It constructs a &lt;code&gt;NonEmpty a&lt;/code&gt; from a &lt;code&gt;[a]&lt;/code&gt; using the &lt;code&gt;nonEmpty&lt;/code&gt; function from &lt;code&gt;Data.List.NonEmpty&lt;/code&gt;, which has the following type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;Maybe&lt;/code&gt; is still there, but this time, we handle the &lt;code&gt;Nothing&lt;/code&gt; case very early in our program: right in the same place we were already doing the input validation. Once that check has passed, we now have a &lt;code&gt;NonEmpty FilePath&lt;/code&gt; value, which preserves (in the type system!) the knowledge that the list really is non-empty. Put another way, you can think of a value of type &lt;code&gt;NonEmpty a&lt;/code&gt; as being like a value of type &lt;code&gt;[a]&lt;/code&gt;, plus a &lt;em&gt;proof&lt;/em&gt; that the list is non-empty.&lt;/p&gt;&lt;p&gt;By strengthening the type of the argument to &lt;code&gt;head&lt;/code&gt; instead of weakening the type of its result, we’ve completely eliminated all the problems from the previous section:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The code has no redundant checks, so there can’t be any performance overhead.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Furthermore, if &lt;code&gt;getConfigurationDirectories&lt;/code&gt; changes to stop checking that the list is non-empty, its return type must change, too. Consequently, &lt;code&gt;main&lt;/code&gt; will fail to typecheck, alerting us to the problem before we even run the program!&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;What’s more, it’s trivial to recover the old behavior of &lt;code&gt;head&lt;/code&gt; from the new one by composing &lt;code&gt;head&lt;/code&gt; with &lt;code&gt;nonEmpty&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;head&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fmap&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;nonEmpty&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the inverse is &lt;em&gt;not&lt;/em&gt; true: there is no way to obtain the new version of &lt;code&gt;head&lt;/code&gt; from the old one. All in all, the second approach is superior on all axes.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-power-of-parsing"&gt;&lt;/a&gt;The power of parsing&lt;/h3&gt;&lt;p&gt;You may be wondering what the above example has to do with the title of this blog post. After all, we only examined two different ways to validate that a list was non-empty—no parsing in sight. That interpretation isn’t wrong, but I’d like to propose another perspective: in my mind, the difference between validation and parsing lies almost entirely in how information is preserved. Consider the following pair of functions:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;validateNonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;validateNonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;validateNonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"list cannot be empty"&lt;/span&gt;

&lt;span class="nf"&gt;parseNonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;parseNonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:|&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;parseNonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"list cannot be empty"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These two functions are nearly identical: they check if the provided list is empty, and if it is, they abort the program with an error message. The difference lies entirely in the return type: &lt;code&gt;validateNonEmpty&lt;/code&gt; always returns &lt;code&gt;()&lt;/code&gt;, the type that contains no information, but &lt;code&gt;parseNonEmpty&lt;/code&gt; returns &lt;code&gt;NonEmpty a&lt;/code&gt;, a refinement of the input type that preserves the knowledge gained in the type system. Both of these functions check the same thing, but &lt;code&gt;parseNonEmpty&lt;/code&gt; gives the caller access to the information it learned, while &lt;code&gt;validateNonEmpty&lt;/code&gt; just throws it away.&lt;/p&gt;&lt;p&gt;These two functions elegantly illustrate two different perspectives on the role of a static type system: &lt;code&gt;validateNonEmpty&lt;/code&gt; obeys the typechecker well enough, but only &lt;code&gt;parseNonEmpty&lt;/code&gt; takes full advantage of it. If you see why &lt;code&gt;parseNonEmpty&lt;/code&gt; is preferable, you understand what I mean by the mantra “parse, don’t validate.” Still, perhaps you are skeptical of &lt;code&gt;parseNonEmpty&lt;/code&gt;’s name. Is it really &lt;em&gt;parsing&lt;/em&gt; anything, or is it merely validating its input and returning a result? While the precise definition of what it means to parse or validate something is debatable, I believe &lt;code&gt;parseNonEmpty&lt;/code&gt; is a bona-fide parser (albeit a particularly simple one).&lt;/p&gt;&lt;p&gt;Consider: what is a parser? Really, a parser is just a function that consumes less-structured input and produces more-structured output. By its very nature, a parser is a partial function—some values in the domain do not correspond to any value in the range—so all parsers must have some notion of failure. Often, the input to a parser is text, but this is by no means a requirement, and &lt;code&gt;parseNonEmpty&lt;/code&gt; is a perfectly cromulent parser: it parses lists into non-empty lists, signaling failure by terminating the program with an error message.&lt;/p&gt;&lt;p&gt;Under this flexible definition, parsers are an incredibly powerful tool: they allow discharging checks on input up-front, right on the boundary between a program and the outside world, and once those checks have been performed, they never need to be checked again! Haskellers are well-aware of this power, and they use many different types of parsers on a regular basis:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The &lt;a href="https://hackage.haskell.org/package/aeson"&gt;aeson&lt;/a&gt; library provides a &lt;code&gt;Parser&lt;/code&gt; type that can be used to parse JSON data into domain types.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Likewise, &lt;a href="https://hackage.haskell.org/package/optparse-applicative"&gt;optparse-applicative&lt;/a&gt; provides a set of parser combinators for parsing command-line arguments.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Database libraries like &lt;a href="https://hackage.haskell.org/package/persistent"&gt;persistent&lt;/a&gt; and &lt;a href="https://hackage.haskell.org/package/postgresql-simple"&gt;postgresql-simple&lt;/a&gt; have a mechanism for parsing values held in an external data store.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The &lt;a href="https://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; ecosystem is built around parsing Haskell datatypes from path components, query parameters, HTTP headers, and more.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The common theme between all these libraries is that they sit on the boundary between your Haskell application and the external world. That world doesn’t speak in product and sum types, but in streams of bytes, so there’s no getting around a need to do some parsing. Doing that parsing up front, before acting on the data, can go a long way toward avoiding many classes of bugs, some of which might even be security vulnerabilities.&lt;/p&gt;&lt;p&gt;One drawback to this approach of parsing everything up front is that it sometimes requires values be parsed long before they are actually used. In a dynamically-typed language, this can make keeping the parsing and processing logic in sync a little tricky without extensive test coverage, much of which can be laborious to maintain. However, with a static type system, the problem becomes marvelously simple, as demonstrated by the &lt;code&gt;NonEmpty&lt;/code&gt; example above: if the parsing and processing logic go out of sync, the program will fail to even compile.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-danger-of-validation"&gt;&lt;/a&gt;The danger of validation&lt;/h3&gt;&lt;p&gt;Hopefully, by this point, you are at least somewhat sold on the idea that parsing is preferable to validation, but you may have lingering doubts. Is validation really so bad if the type system is going to force you to do the necessary checks eventually anyway? Maybe the error reporting will be a little bit worse, but a bit of redundant checking can’t hurt, right?&lt;/p&gt;&lt;p&gt;Unfortunately, it isn’t so simple. Ad-hoc validation leads to a phenomenon that the &lt;a href="http://langsec.org"&gt;language-theoretic security&lt;/a&gt; field calls &lt;em&gt;shotgun parsing&lt;/em&gt;. In the 2016 paper, &lt;a href="http://langsec.org/papers/langsec-cwes-secdev2016.pdf"&gt;The Seven Turrets of Babel: A Taxonomy of LangSec Errors and How to Expunge Them&lt;/a&gt;, its authors provide the following definition:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Shotgun parsing is a programming antipattern whereby parsing and input-validating code is mixed with and spread across processing code—throwing a cloud of checks at the input, and hoping, without any systematic justification, that one or another would catch all the “bad” cases.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;They go on to explain the problems inherent to such validation techniques:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Shotgun parsing necessarily deprives the program of the ability to reject invalid input instead of processing it. Late-discovered errors in an input stream will result in some portion of invalid input having been processed, with the consequence that program state is difficult to accurately predict.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;In other words, a program that does not parse all of its input up front runs the risk of acting upon a valid portion of the input, discovering a different portion is invalid, and suddenly needing to roll back whatever modifications it already executed in order to maintain consistency. Sometimes this is possible—such as rolling back a transaction in an RDBMS—but in general it may not be.&lt;/p&gt;&lt;p&gt;It may not be immediately apparent what shotgun parsing has to do with validation—after all, if you do all your validation up front, you mitigate the risk of shotgun parsing. The problem is that validation-based approaches make it extremely difficult or impossible to determine if everything was actually validated up front or if some of those so-called “impossible” cases might actually happen. The entire program must assume that raising an exception anywhere is not only possible, it’s regularly necessary.&lt;/p&gt;&lt;p&gt;Parsing avoids this problem by stratifying the program into two phases—parsing and execution—where failure due to invalid input can only happen in the first phase. The set of remaining failure modes during execution is minimal by comparison, and they can be handled with the tender care they require.&lt;/p&gt;&lt;h2&gt;&lt;a name="parsing-not-validating-in-practice"&gt;&lt;/a&gt;Parsing, not validating, in practice&lt;/h2&gt;&lt;p&gt;So far, this blog post has been something of a sales pitch. “You, dear reader, ought to be parsing!” it says, and if I’ve done my job properly, at least some of you are sold. However, even if you understand the “what” and the “why,” you might not feel especially confident about the “how.”&lt;/p&gt;&lt;p&gt;My advice: focus on the datatypes.&lt;/p&gt;&lt;p&gt;Suppose you are writing a function that accepts a list of tuples representing key-value pairs, and you suddenly realize you aren’t sure what to do if the list has duplicate keys. One solution would be to write a function that asserts there aren’t any duplicates in the list:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;checkNoDuplicateKeys&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="kt"&gt;AppError&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Eq&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, this check is fragile: it’s extremely easy to forget. Because its return value is unused, it can always be omitted, and the code that needs it would still typecheck. A better solution is to choose a data structure that disallows duplicate keys by construction, such as a &lt;code&gt;Map&lt;/code&gt;. Adjust your function’s type signature to accept a &lt;code&gt;Map&lt;/code&gt; instead of a list of tuples, and implement it as you normally would.&lt;/p&gt;&lt;p&gt;Once you’ve done that, the call site of your new function will likely fail to typecheck, since it is still being passed a list of tuples. If the caller was given the value via one of its arguments, or if it received it from the result of some other function, you can continue updating the type from list to &lt;code&gt;Map&lt;/code&gt;, all the way up the call chain. Eventually, you will either reach the location the value is created, or you’ll find a place where duplicates actually ought to be allowed. At that point, you can insert a call to a modified version of &lt;code&gt;checkNoDuplicateKeys&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;checkNoDuplicateKeys&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="kt"&gt;AppError&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Eq&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the check &lt;em&gt;cannot&lt;/em&gt; be omitted, since its result is actually necessary for the program to proceed!&lt;/p&gt;&lt;p&gt;This hypothetical scenario highlights two simple ideas:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use a data structure that makes illegal states unrepresentable.&lt;/strong&gt; Model your data using the most precise data structure you reasonably can. If ruling out a particular possibility is too hard using the encoding you are currently using, consider alternate encodings that can express the property you care about more easily. Don’t be afraid to refactor.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Push the burden of proof upward as far as possible, but no further.&lt;/strong&gt; Get your data into the most precise representation you need as quickly as you can. Ideally, this should happen at the boundary of your system, before &lt;em&gt;any&lt;/em&gt; of the data is acted upon.&lt;sup&gt;&lt;a href="#footnote-3" id="footnote-ref-3-1"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;If one particular code branch eventually requires a more precise representation of a piece of data, parse the data into the more precise representation as soon as the branch is selected. Use sum types judiciously to allow your datatypes to reflect and adapt to control flow.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;In other words, write functions on the data representation you &lt;em&gt;wish&lt;/em&gt; you had, not the data representation you are given. The design process then becomes an exercise in bridging the gap, often by working from both ends until they meet somewhere in the middle. Don’t be afraid to iteratively adjust parts of the design as you go, since you may learn something new during the refactoring process!&lt;/p&gt;&lt;p&gt;Here are a handful of additional points of advice, arranged in no particular order:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Let your datatypes inform your code, don’t let your code control your datatypes.&lt;/strong&gt; Avoid the temptation to just stick a &lt;code&gt;Bool&lt;/code&gt; in a record somewhere because it’s needed by the function you’re currently writing. Don’t be afraid to refactor code to use the right data representation—the type system will ensure you’ve covered all the places that need changing, and it will likely save you a headache later.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Treat functions that return &lt;code&gt;m ()&lt;/code&gt; with deep suspicion.&lt;/strong&gt; Sometimes these are genuinely necessary, as they may perform an imperative effect with no meaningful result, but if the primary purpose of that effect is raising an error, it’s likely there’s a better way.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Don’t be afraid to parse data in multiple passes.&lt;/strong&gt; Avoiding shotgun parsing just means you shouldn’t act on the input data before it’s fully parsed, not that you can’t use some of the input data to decide how to parse other input data. Plenty of useful parsers are context-sensitive.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Avoid denormalized representations of data, &lt;em&gt;especially&lt;/em&gt; if it’s mutable.&lt;/strong&gt; Duplicating the same data in multiple places introduces a trivially representable illegal state: the places getting out of sync. Strive for a single source of truth.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Keep denormalized representations of data behind abstraction boundaries.&lt;/strong&gt; If denormalization is absolutely necessary, use encapsulation to ensure a small, trusted module holds sole responsibility for keeping the representations in sync.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use abstract datatypes to make validators “look like” parsers.&lt;/strong&gt; Sometimes, making an illegal state truly unrepresentable is just plain impractical given the tools Haskell provides, such as ensuring an integer is in a particular range. In that case, use an abstract &lt;code&gt;newtype&lt;/code&gt; with a smart constructor to “fake” a parser from a validator.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;As always, use your best judgement. It probably isn’t worth breaking out &lt;a href="https://hackage.haskell.org/package/singletons"&gt;singletons&lt;/a&gt; and refactoring your entire application just to get rid of a single &lt;code&gt;error "impossible"&lt;/code&gt; call somewhere—just make sure to treat those situations like the radioactive substance they are, and handle them with the appropriate care. If all else fails, at least leave a comment to document the invariant for whoever needs to modify the code next.&lt;/p&gt;&lt;h2&gt;&lt;a name="recap-reflection-and-related-reading"&gt;&lt;/a&gt;Recap, reflection, and related reading&lt;/h2&gt;&lt;p&gt;That’s all, really. Hopefully this blog post proves that taking advantage of the Haskell type system doesn’t require a PhD, and it doesn’t even require using the latest and greatest of GHC’s shiny new language extensions—though they can certainly sometimes help! Sometimes the biggest obstacle to using Haskell to its fullest is simply being aware what options are available, and unfortunately, one downside of Haskell’s small community is a relative dearth of resources that document design patterns and techniques that have become tribal knowledge.&lt;/p&gt;&lt;p&gt;None of the ideas in this blog post are new. In fact, the core idea—“write total functions”—is conceptually quite simple. Despite that, I find it remarkably challenging to communicate actionable, practicable details about the way I write Haskell code. It’s easy to spend lots of time talking about abstract concepts—many of which are quite valuable!—without communicating anything useful about &lt;em&gt;process&lt;/em&gt;. My hope is that this is a small step in that direction.&lt;/p&gt;&lt;p&gt;Sadly, I don’t know very many other resources on this particular topic, but I do know of one: I never hesitate to recommend Matt Parson’s fantastic blog post &lt;a href="https://www.parsonsmatt.org/2017/10/11/type_safety_back_and_forth.html"&gt;Type Safety Back and Forth&lt;/a&gt;. If you want another accessible perspective on these ideas, including another worked example, I’d highly encourage giving it a read. For a significantly more advanced take on many of these ideas, I can also recommend Matt Noonan’s 2018 paper &lt;a href="https://kataskeue.com/gdp.pdf"&gt;Ghosts of Departed Proofs&lt;/a&gt;, which outlines a handful of techniques for capturing more complex invariants in the type system than I have described here.&lt;/p&gt;&lt;p&gt;As a closing note, I want to say that doing the kind of refactoring described in this blog post is not always easy. The examples I’ve given are simple, but real life is often much less straightforward. Even for those experienced in type-driven design, it can be genuinely difficult to capture certain invariants in the type system, so do not consider it a personal failing if you cannot solve something the way you’d like! Consider the principles in this blog post ideals to strive for, not strict requirements to meet. All that matters is to try.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;Technically, in Haskell, this ignores “bottoms,” constructions that can inhabit &lt;em&gt;any&lt;/em&gt; value. These aren’t “real” values (unlike &lt;code&gt;null&lt;/code&gt; in some other languages)—they’re things like infinite loops or computations that raise exceptions—and in idiomatic Haskell, we usually try to avoid them, so reasoning that pretends they don’t exist still has value. But don’t take my word for it—I’ll let Danielsson et al. convince you that &lt;a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf"&gt;Fast and Loose Reasoning is Morally Correct&lt;/a&gt;. &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-2"&gt;&lt;p&gt;In fact, &lt;code&gt;Data.List.NonEmpty&lt;/code&gt; already provides a &lt;code&gt;head&lt;/code&gt; function with this type, but just for the sake of illustration, we’ll reimplement it ourselves. &lt;a href="#footnote-ref-2-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-3"&gt;&lt;p&gt;Sometimes it is necessary to perform some kind of authorization before parsing user input to avoid denial of service attacks, but that’s okay: authorization should have a relatively small surface area, and it shouldn’t cause any significant modifications to the state of your system. &lt;a href="#footnote-ref-3-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Empathy and subjective experience in programming languages</title><link>https://lexi-lambda.github.io/blog/2019/10/19/empathy-and-subjective-experience-in-programming-languages/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2019/10/19/empathy-and-subjective-experience-in-programming-languages/</guid><pubDate>19 Oct 2019</pubDate><description>&lt;article&gt;&lt;p&gt;A stereotype about programmers is that they like to think in black and white. Programmers like things to be good or bad, moral or immoral, responsible or irresponsible. Perhaps there is something romantic in the idea that programmers like to be as binary as the computers they program. Reductionist? Almost certainly, but hey, laugh at yourself a bit: we probably deserve to be made fun of from time to time.&lt;/p&gt;&lt;p&gt;Personally, I have no idea if the trope of the nuance-challenged programmer is accurate, but whether it’s a property of programmers or just humans behind a keyboard, the intensity with which we disagree with one another never ceases to amaze. Ask any group of working programmers what their least favorite programming language is, and there’s a pretty good chance things are going to get heated real fast. Why? What is it about programming that makes us feel so strongly that we are right and others are wrong, even when our experiences contradict those of tens or hundreds of thousands of others?&lt;/p&gt;&lt;p&gt;I think about that question a lot.&lt;/p&gt;&lt;h2&gt;&lt;a name="2015-called-and-they-want-their-dress-back"&gt;&lt;/a&gt;2015 called, and they want their dress back&lt;/h2&gt;&lt;p&gt;Humans have a knack for caring intensely about the most trivial of things. Name almost anything—cats versus dogs, the appropriate way to fasten a necktie, or even which day of the week comes first—and someone somewhere has probably written an essay about it on an internet forum. It would be easy to throw up our hands and give up trying to understand our peers, as sometimes they seem like aliens from another planet.&lt;/p&gt;&lt;p&gt;However, what interests me is how the littlest things seem to get people the most upset. Few people have shouting matches over the best interpretation of quantum mechanics, but friendships will be tested when someone says they just aren’t that into &lt;em&gt;Star Wars&lt;/em&gt;. One explanation for this phenomenon is simple accessibility: most people aren’t equipped to understand quantum mechanics well enough to argue about it, but almost anyone can have an opinion on which direction the toilet paper is supposed to go.&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;There is truth in that explanation, but personally, I don’t think it’s the whole story. Rather, I think we grow so used to the idea that our experiences are universal that discovering someone else experienced the exact same thing we did yet came to a different conclusion is not just frustrating: it’s incomprehensible.&lt;/p&gt;&lt;p&gt;Take 2015’s phenomenon of “&lt;a href="https://en.wikipedia.org/wiki/The_dress"&gt;the dress&lt;/a&gt;” as an example. Some people see black and blue, others white and gold, and frankly, whether you see one or the other has no impact on anything remotely meaningful. How did &lt;em&gt;this&lt;/em&gt;—something so completely irrelevant—become a cross-cultural phenomenon reported on by major news outlets? My guess: people just aren’t used to the idea that vision—the primary way we sense the world—does not provide us with an objective, universal understanding of reality.&lt;/p&gt;&lt;h3&gt;&lt;a name="when-something-objective-isn-t"&gt;&lt;/a&gt;When something objective isn’t&lt;/h3&gt;&lt;p&gt;Our culture and society works because, in spite of our differences, we’re still all humans. We eat food, we sleep, we like spending time with each other, and we like feeling connected to those around us. So when we watch a movie, and it tickles us in a way that makes us feel good, we can have an awfully hard time understanding how our best friend—who we largely agree with about everything—didn’t like it at all.&lt;/p&gt;&lt;p&gt;The truth, of course, is that very little of what we experience is in any way objective. Yes, we can be pretty confident that basic arithmetic is true anywhere in the universe, and that if we all agree a table is brown it probably is. There are even things we accept as subjective without a second thought, such as the kinds of food people like or the fashions they find attractive. It’s all the in-betweens that are so pernicious! “The dress” was so unbelievable to most people because, nine hundred and ninety nine times out of of a thousand, when two humans look at a picture, they at least mostly agree on the colors contained within. We do not consider that we are seeing different lenses into the same objective reality, we simply think we are perceiving objective truths directly.&lt;/p&gt;&lt;p&gt;In the case of the dress, whether you &lt;a href="https://en.wikipedia.org/wiki/Yanny_or_Laurel"&gt;heard “yanny” or “laurel,”&lt;/a&gt; or whether you believe the &lt;em&gt;Sonic&lt;/em&gt; games were ever any good, subjective disagreement is essentially harmless. But what about when it isn’t? Might incorrect beliefs that our experiences are universal cause genuine harm?&lt;/p&gt;&lt;p&gt;I think the answer is absolutely, unequivocally &lt;em&gt;yes&lt;/em&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name="subjectivity-in-programming-and-in-programming-languages-specifically"&gt;&lt;/a&gt;Subjectivity in programming, and in programming languages specifically&lt;/h2&gt;&lt;p&gt;Quick question: which is better, functional or imperative programming?&lt;/p&gt;&lt;p&gt;My guess, given the usual subject of my blog, most of my readers would pick the former. However, the actual answer you chose doesn’t matter: my guess is you feel like you have a pretty rational argument to back it up. It certainly isn’t simply a matter of taste… right?&lt;/p&gt;&lt;p&gt;Well, no, I hope not. I don’t think the world is so subjective that we cannot ever advocate for one thing over another—we tried that whole “everything is XML” thing for a while, and I think we agreed it really wasn’t a good idea. But if you truly believe your answer to the above question can be completely objectively justified (as many do), how does one explain the average Hacker News comment thread on just about any post about Haskell?&lt;/p&gt;&lt;p&gt;I generally try not to read Hacker News if I can help it, as I find doing it mostly just makes me angry,&lt;sup&gt;&lt;a href="#footnote-2" id="footnote-ref-2-1"&gt;2&lt;/a&gt;&lt;/sup&gt; but I did happen to find a link to &lt;a href="https://news.ycombinator.com/item?id=21282647"&gt;a recent discussion&lt;/a&gt; on a blog post about using Haskell in production. Let’s take a look at a few comments, shall we?&lt;/p&gt;&lt;p&gt;In a &lt;a href="https://news.ycombinator.com/item?id=21284383"&gt;branch of the discussion&lt;/a&gt;, one user writes:&lt;/p&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Haskell is great for business and great in production&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I disagree. It's a beautiful language but it lacks a lot of features to make it useable at scale. And in my experience Haskell engineers are extremely smart but the environment/culture they create makes it difficult to foster team spirit.&lt;/p&gt;&lt;p&gt;I've been in 2 companies in the last 4 years who initially used Haskell in production. One has transitioned to Go and the other is rewriting the codebase in Rust.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The first paragraph is an assertion without many specifics, but it does sound like it could be reasonable. And although the last two sentences are entirely anecdotal, anecdotes are still better than hunches. Let’s see what someone else has to say in response:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;I’ve met some pretty damn solid engineers who started on Haskell and, even at a junior level in other languages, produce an elegant solution far more easily than a senior engineer in that language. You probably wouldn’t put the code in production verbatim but you can very easily see what’s going on and it isn’t haunted by spectre of early abstraction, which IMO is the biggest flaw of OOP at scale.&lt;/p&gt;&lt;p&gt;[…]&lt;/p&gt;&lt;p&gt;From my naive perspective it’s easy to make classes out of everything, and to hold state and put side-effects everywhere, but you don’t want to deal with the trouble of a monad until you need it. So you have an automatic inclination towards cleaner code when you start functional and move on.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Also pretty vague and high-level, but also sounds reasonable. If you read either of these comments, and your first inclination was to grow frustrated and start crafting counter-arguments in your head, I encourage you to step outside your feelings momentarily (rational as they may be!) and try your very hardest to interpret them charitably. The discussion continues:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Haskell gives one plenty of rope to hang himself on complexity.&lt;/p&gt;&lt;p&gt;So much that developers develop an aversion to it as deep as fear. It's unavoidable, the ones that didn't develop it are still buried at the working of their first Rube Goldberg machine and unavailable.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Whether you think it’s accurate or not, there is definitely a perception held by a great many people that Haskell is a very complicated language. Surely at least some of them must have given it an honest shot, so have they just not “seen the light” yet? What do you think they’re missing? Perhaps a followup commenter can help elucidate things:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Hi, I find that everything people here are complaining about (and they're valid complaints) has also been true of C++. C++ developed a lot of its complexity (particularly 15-20 yrs ago in the template space) after it got popular, so people were already wed to it.&lt;/p&gt;&lt;p&gt;[…]&lt;/p&gt;&lt;p&gt;The C++ community's really gotten good in the last 5 years or so about reigning in the bad impulses and getting people to write clean, clear, efficient code that has reasonable expressiveness.&lt;/p&gt;&lt;p&gt;Coming into Haskell from C++, I have the same instincts. Haskell's been a pure pleasure. The benefits are really there, and they're easy to get. You just have to think of the trade-offs.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;That argument seems reasonable, too. Everything in moderation, right? If you disagree, and you think Haskell is just not worth it, what does this person value that you don’t? What are they missing that you see?&lt;/p&gt;&lt;h3&gt;&lt;a name="the-unsatisfying-subjective-reality-of-programming-languages"&gt;&lt;/a&gt;The unsatisfying subjective reality of programming languages&lt;/h3&gt;&lt;p&gt;You can probably see where I’m going with all this. These arguments are not built on hard, refutable facts or rigorous real-world evidence, they’re based in gut feelings and personal preferences. Does that mean they’re wrong, invalid, and worthless, and we should do studies to determine which language allows programmers to ship features the fastest and with the fewest bugs, then all agree to use that?&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;No!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;These conversations are subjective because, for better or for worse, humans think in different ways and value different things, and programming languages are the medium in which we express ourselves. To many people who write Haskell (myself included), there is an effervescent joy in modeling a problem with the type system—like capturing something in amber—that others just don’t care about. What’s more, some people clearly loathe Haskell’s significant whitespace and plethora of infix operators, but I’ve never really minded. Is one of us wrong? If so, &lt;em&gt;why?&lt;/em&gt; Talk about reliability all you want, but the few rigorous numbers we have don’t provide much evidence one way or the other.&lt;/p&gt;&lt;p&gt;While &lt;a href="https://news.ycombinator.com/item?id=21284317"&gt;one commenter&lt;/a&gt; in the aforementioned Hacker News thread described Haskell as nothing less than “pain and torture,” &lt;a href="https://news.ycombinator.com/item?id=21284540"&gt;another&lt;/a&gt; says they “did some Haskell in production and it was delightful.” People push excuses and rationalizations for these differences constantly—they point out that most people are exposed to imperative programming first, while others retort that Haskell is clearly not very widely used despite being around for an awfully long time—but none of their arguments ever seem to change people’s minds.&lt;/p&gt;&lt;p&gt;Often, people walk away from these conversations confused and incensed. To them, their point of view is so obviously apparent that it is hard to fathom anyone else seeing things differently. They rack their brains trying to figure out why their opponents just don’t &lt;em&gt;get it.&lt;/em&gt; There must be some key point they’ve misunderstood, some joy they haven’t experienced, some sharp edge they haven’t yet been cut by. But no matter how much time they spend trying to reach these people, somehow, it’s never enough.&lt;/p&gt;&lt;h3&gt;&lt;a name="empathy-and-how-bad-results-come-from-good-intentions"&gt;&lt;/a&gt;Empathy, and how bad results come from good intentions&lt;/h3&gt;&lt;p&gt;I’ll admit that these kinds of discussions aren’t &lt;em&gt;always&lt;/em&gt; fruitless; sometimes they really do manage to change people’s minds or help them see some new idea they had not been able to grasp. When people manage to keep their cool and acknowledge the differences in their mindsets while still helping people learn, everyone benefits.&lt;/p&gt;&lt;p&gt;Sadly, in my experience, this rarely happens. We have a natural tendency to become angry if people don’t see things the way we do; it’s confusing and disorienting, and it can even disgust us. None of those emotions are conducive to empathy. When we fail to account for the ways in which others might think differently, we voluntarily reject any insights we might have otherwise gained from the conversation because we did not allow ourselves to embrace, even just temporarily, someone else’s strange and perhaps uncomfortable set of values and experiences. We refuse to accept that our perception of color might not be as universal as we thought, and we miss out on the amazing insights we could learn about the nature of light, color, and human vision.&lt;/p&gt;&lt;p&gt;Although failing to empathize with those we are arguing with is bad enough, in my mind, this failure to accept the potential subjectivity of one’s own views has even worse, indirect effects. Take this comment for example, again from the same thread:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Sounds like you've barely programmed in Haskell and don't know what you're talking about. Haskell was the first language I learned. I didn't think this at all and I still don't. It doesn't strike me as any more difficult than learning Java or something.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I have no doubts that this commenter meant what they said: they didn’t find Haskell difficult to learn. The comment they were replying to was vitriolic and combative, so one could almost feel they had a smackdown coming to them… but this isn’t a private conversation. How do you think someone feels when they are learning Haskell, scroll through this thread, and find a comment that tells them they ought to find it easy? If they’ve been struggling, even a little bit, what do you think they might think?&lt;/p&gt;&lt;p&gt;If I were in their place, I might feel a little stupid. I might wonder if I’m really cut out for Haskell or if I should just give up. I definitely wouldn’t feel encouraged and excited to keep trying.&lt;/p&gt;&lt;p&gt;Who knows why this commenter found Haskell straightforward. Maybe they were exposed to certain concepts already, maybe it just fit their style of thinking, perhaps they’re even exceptionally smart. I don’t know. But no matter what the answer is, insulting the intelligence of others, even indirectly in this way, belies a lack of empathy in the face of frustration, and although the intent may not have been to hurt, it can still be seriously harmful.&lt;/p&gt;&lt;p&gt;To be clear, I’m not saying the commenter should have pretended their experiences were different or even kept them to themselves. I don’t believe in being “fake nice”—in my experience, I am best equipped to reach people when speaking genuinely, from the heart. What I would have done is tell my story in a different way, perhaps by writing something like this:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;It’s true that a lot of people find Haskell challenging, and I totally accept that some people just don’t think it’s worth it. It’s fine if you don’t want to write Haskell. But personally, I really enjoy writing it, as do the people I work with, and I think we ship great software with it because it aligns naturally—even joyfully!—with the way we like to think about program construction.&lt;/p&gt;&lt;p&gt;Personally, I didn’t find Haskell as challenging to learn as I think some people have, but it was still work, and in some ways I was just exposed to it at the right time. Other people I know have struggled quite a lot at first, and reasonably so, but they’ve still managed to become great Haskell programmers, and they found it worthwhile. Our team dynamic just wouldn’t be the same in any other language.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;When I respond to comments I disagree with, I try to tell a personal story that provides a different perspective &lt;strong&gt;without&lt;/strong&gt; invalidating their experiences. Sometimes the result is ungrateful snark anyway (or just no response at all), but you might be surprised how often talking from an emotional place about &lt;em&gt;your own&lt;/em&gt; experiences—while being neither aggressive nor especially defensive—can go a long way. Perhaps you can even learn something if they return the favor and explain what they find frustrating, beyond the fundamental, subjective disagreements.&lt;/p&gt;&lt;p&gt;It’s okay to have opinions. It’s okay to like and dislike things. It’s okay to be frustrated that others don’t see things the way you do, and to advocate for the technologies and values you believe in. It’s just not okay to tell someone else their reality is wrong.&lt;/p&gt;&lt;p&gt;Learn to embrace the subjective differences between us all, and you won’t just be kinder. You’ll be &lt;em&gt;happier.&lt;/em&gt;&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;This is where I’m supposed to put a snarky footnote saying something like “obviously, the correct way is &lt;em&gt;blah&lt;/em&gt;,” but you deserve better. So you, uh, get a &lt;em&gt;meta&lt;/em&gt; snarky footnote instead. &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-2"&gt;&lt;p&gt;Which, to be entirely fair, may well be as subjective as anything else in this blog post. &lt;a href="#footnote-ref-2-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Demystifying MonadBaseControl</title><link>https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/</guid><pubDate>07 Sep 2019</pubDate><description>&lt;article&gt;&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl"&gt;&lt;code&gt;MonadBaseControl&lt;/code&gt; from the &lt;code&gt;monad-control&lt;/code&gt; package&lt;/a&gt; is a confusing typeclass, and its methods have complicated types. For many people, it’s nothing more than scary, impossible-to-understand magic that is, for some reason, needed when lifting certain kinds of operations. Few resources exist that adequately explain how, why, and when it works, which sadly seems to have resulted in some &lt;a href="https://en.wikipedia.org/wiki/Fear,_uncertainty,_and_doubt"&gt;FUD&lt;/a&gt; about its use.&lt;/p&gt;&lt;p&gt;There’s no doubt that the machinery of &lt;code&gt;MonadBaseControl&lt;/code&gt; is complex, and the role it plays in practice is often subtle. However, its essence is actually much simpler than it appears, and I promise it can be understood by mere mortals. In this blog post, I hope to provide a complete survey of &lt;code&gt;MonadBaseControl&lt;/code&gt;—how it works, how it’s designed, and how it can go wrong—in a way that is accessible to anyone with a firm grasp of monads and monad transformers. To start, we’ll motivate &lt;code&gt;MonadBaseControl&lt;/code&gt; by reinventing it ourselves.&lt;/p&gt;&lt;h2&gt;&lt;a name="the-higher-order-action-problem"&gt;&lt;/a&gt;The higher-order action problem&lt;/h2&gt;&lt;p&gt;Say we have a function with the following type:&lt;sup&gt;&lt;a href="#footnote-0" id="footnote-ref-0-1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;foo&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we have an action built from a transformer stack like&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;bar&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="kt"&gt;X&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;Y&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;then we might wish to apply &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;, but that is ill-typed, since &lt;code&gt;IO&lt;/code&gt; is not the same as &lt;code&gt;StateT X IO&lt;/code&gt;. In cases like these, we often use &lt;code&gt;lift&lt;/code&gt;, but it’s not good enough here: &lt;code&gt;lift&lt;/code&gt; &lt;em&gt;adds&lt;/em&gt; a new monad transformer to an action, but here we need to &lt;em&gt;remove&lt;/em&gt; a transformer. So we need a function with a type like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;unliftState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="kt"&gt;X&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;Y&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;Y&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, if you think about that type just a little bit, it’s clear something’s wrong: it throws away information, namely the state. You may remember that a &lt;code&gt;StateT X IO Y&lt;/code&gt; action is equivalent to a function of type &lt;code&gt;X -&amp;gt; IO (Y, X)&lt;/code&gt;, so our hypothetical &lt;code&gt;unliftState&lt;/code&gt; function has two problems:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;We have no &lt;code&gt;X&lt;/code&gt; to use as the initial state.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;We’ll lose any modifications &lt;code&gt;bar&lt;/code&gt; made to the state, since the result type is just &lt;code&gt;Y&lt;/code&gt;, not &lt;code&gt;(Y, X)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Clearly, we’ll need something more sophisticated, but what?&lt;/p&gt;&lt;h2&gt;&lt;a name="a-na-ve-solution"&gt;&lt;/a&gt;A naïve solution&lt;/h2&gt;&lt;p&gt;Given that &lt;code&gt;foo&lt;/code&gt; doesn’t know anything about the state, we can’t easily thread it through &lt;code&gt;foo&lt;/code&gt; itself. However, by using &lt;code&gt;runStateT&lt;/code&gt; explicitly, we could do some of the state management ourselves:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runStateT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;
  &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Do you see what’s going on there? It’s not actually very complicated: we get the current state, then pass it as the initial state to &lt;code&gt;runStateT&lt;/code&gt;. This produces an action &lt;code&gt;IO (a, s)&lt;/code&gt; that has &lt;em&gt;closed over&lt;/em&gt; the current state. We can pass that action to &lt;code&gt;foo&lt;/code&gt; without issue, since &lt;code&gt;foo&lt;/code&gt; is polymorphic in the action’s return type. Finally, all we have to do is &lt;code&gt;put&lt;/code&gt; the modified state back into the enclosing &lt;code&gt;StateT&lt;/code&gt; computation, and we can get on with our business.&lt;/p&gt;&lt;p&gt;That strategy works okay when we only have one monad transformer, but it gets hairy quickly as soon as we have two or more. For example, if we had &lt;code&gt;baz :: ExceptT X (StateT Y IO) Z&lt;/code&gt;, then we &lt;em&gt;could&lt;/em&gt; do the same trick by getting the underlying&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kt"&gt;Y&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;X&lt;/span&gt; &lt;span class="kt"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;function, closing over the state, restoring it, and doing the appropriate case analysis to re-raise any &lt;code&gt;ExceptT&lt;/code&gt; errors, but that’s a lot of work to do for every single function! What we’d like to do instead is somehow abstract over the pattern we used to write &lt;code&gt;foo'&lt;/code&gt; in a way that scales to arbitrary monad transformers.&lt;/p&gt;&lt;h2&gt;&lt;a name="the-essence-of-monadbasecontrol"&gt;&lt;/a&gt;The essence of &lt;code&gt;MonadBaseControl&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;To build a more general solution for “unlifting” arbitrary monad transformers, we need to start thinking about monad transformer state. The technique we used to implement &lt;code&gt;foo'&lt;/code&gt; operated on the following process:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Capture the action’s input state and close over it.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Package up the action’s output state with its result and run it.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Restore the action’s output state into the enclosing transformer.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Return the action’s result.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;For &lt;code&gt;StateT s&lt;/code&gt;, it turns out that the input state and output state are both &lt;code&gt;s&lt;/code&gt;, but other monad transformers have state, too. Consider the input and output state for the following common monad transformers:&lt;/p&gt;&lt;div class="table-wrapper"&gt;
  &lt;table class="no-line-wrapping"&gt;
    &lt;thead&gt;&lt;tr&gt;
      &lt;th&gt;transformer&lt;/th&gt;
      &lt;th&gt;representation&lt;/th&gt;
      &lt;th&gt;input state&lt;/th&gt;
      &lt;th&gt;output state&lt;/th&gt;
    &lt;/tr&gt;&lt;/thead&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;StateT s m a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;s -&amp;gt; m (a, s)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;ReaderT r m a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;r -&amp;gt; m a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;r&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;WriterT w m a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;m (a, w)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;&lt;p&gt;Notice how the input state is whatever is to the left of the &lt;code&gt;-&amp;gt;&lt;/code&gt;, while the output state is whatever extra information gets produced alongside the result. Using the same reasoning, we can also deduce the input and output state for compositions of multiple monad transformers, such as the following:&lt;/p&gt;&lt;div class="table-wrapper"&gt;
  &lt;table class="no-line-wrapping"&gt;
    &lt;thead&gt;&lt;tr&gt;
      &lt;th&gt;transformer&lt;/th&gt;
      &lt;th&gt;representation&lt;/th&gt;
      &lt;th&gt;input state&lt;/th&gt;
      &lt;th&gt;output state&lt;/th&gt;
    &lt;/tr&gt;&lt;/thead&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;ReaderT r (WriterT w m) a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;r -&amp;gt; m (a, w)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;r&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;StateT s (ReaderT r m) a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;r -&amp;gt; s -&amp;gt; m (a, s)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;(r, s)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;WriterT w (StateT s m) a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;s -&amp;gt; m ((a, w), s)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;(w, s)&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;&lt;p&gt;Notice that when monad transformers are composed, their states are composed, too. This is useful to keep in mind, since our goal is to capture the four steps above in a typeclass, polymorphic in the state of the monad transformers we need to lift through. At minimum, we need two new operations: one to capture the input state and close over it (step 1) and one to restore the output state (step 3). One class we might come up with could look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;MonadBase&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="n"&gt;captureInputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we can write instances of that typeclass for various transformers, we can use the class’s operations to implement &lt;code&gt;foo'&lt;/code&gt; in a generic way that works with any combination of them:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;captureInputState&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftBase&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;
  &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So how do we implement those instances? Let’s start with &lt;code&gt;IO&lt;/code&gt;, since that’s the base case:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;captureInputState&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;amp;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(,&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Not very exciting. The &lt;code&gt;StateT s&lt;/code&gt; instance, on the other hand, is significantly more interesting:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;captureInputState&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(,)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="n"&gt;captureInputState&lt;/span&gt;
  &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runStateT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;
    &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;This instance alone includes most of the key ideas behind &lt;code&gt;MonadBaseControl&lt;/code&gt;.&lt;/strong&gt; There’s a lot going on, so let’s break it down, step by step:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Start by examining the definitions of &lt;code&gt;InputState&lt;/code&gt; and &lt;code&gt;OutputState&lt;/code&gt;. Are they what you expected? You’d be forgiven for expecting the following:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After all, that’s what we wrote in the table, isn’t it?&lt;/p&gt;&lt;p&gt;However, if you give it a try, you’ll find it doesn’t work. &lt;code&gt;InputState&lt;/code&gt; and &lt;code&gt;OutputState&lt;/code&gt; must capture the state of the &lt;em&gt;entire&lt;/em&gt; monad, not just a single transformer layer, so we have to combine the &lt;code&gt;StateT s&lt;/code&gt; state with the state of the underlying monad. In the simplest case we get&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which is boring, but in a more complex case, we need to get something like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Therefore, &lt;code&gt;InputState (StateT s m)&lt;/code&gt; combines &lt;code&gt;s&lt;/code&gt; with &lt;code&gt;InputState m&lt;/code&gt; in a tuple, and &lt;code&gt;OutputState&lt;/code&gt; does the same.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Moving on, take a look at &lt;code&gt;captureInputState&lt;/code&gt; and &lt;code&gt;closeOverInputState&lt;/code&gt;. Just as &lt;code&gt;InputState&lt;/code&gt; and &lt;code&gt;OutputState&lt;/code&gt; capture the state of the entire monad, these functions need to be inductive in the same way.&lt;/p&gt;&lt;p&gt;&lt;code&gt;captureInputState&lt;/code&gt; acquires the current state using &lt;code&gt;get&lt;/code&gt;, and it combines it with the remaining monadic state using &lt;code&gt;lift captureInputState&lt;/code&gt;. &lt;code&gt;closeOverInputState&lt;/code&gt; uses the captured state to peel off the outermost &lt;code&gt;StateT&lt;/code&gt; layer, then calls &lt;code&gt;closeOverInputState&lt;/code&gt; recursively to peel off the rest of them.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, &lt;code&gt;restoreOutputState&lt;/code&gt; restores the state of the underlying monad stack, then restores the &lt;code&gt;StateT&lt;/code&gt; state, ensuring everything ends up back the way it’s supposed to be.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Take the time to digest all that—work through it yourself if you need to—as it’s a dense piece of code. Once you feel comfortable with it, take a look at the instances for &lt;code&gt;ReaderT&lt;/code&gt; and &lt;code&gt;WriterT&lt;/code&gt; as well:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="n"&gt;captureInputState&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(,)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="n"&gt;captureInputState&lt;/span&gt;
  &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runReaderT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;InputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;captureInputState&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="n"&gt;captureInputState&lt;/span&gt;
  &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runWriterT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;
    &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Make sure you understand these instances, too. It should be easier this time, since they share most of their structure with the &lt;code&gt;StateT&lt;/code&gt; instance, but note the asymmetry that arises from the differing input and output states. (It may even help to try and write these instances yourself, focusing on the types whenever you get stuck.)&lt;/p&gt;&lt;p&gt;If you feel alright with them, then congratulations: you’re already well on your way to grokking &lt;code&gt;MonadBaseControl&lt;/code&gt;!&lt;/p&gt;&lt;h3&gt;&lt;a name="hiding-the-input-state"&gt;&lt;/a&gt;Hiding the input state&lt;/h3&gt;&lt;p&gt;So far, our implementation of &lt;code&gt;MonadBaseControl&lt;/code&gt; works, but it’s actually slightly more complicated than it needs to be. As it happens, all valid uses of &lt;code&gt;MonadBaseControl&lt;/code&gt; will always end up performing the following pattern:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;captureInputState&lt;/span&gt;
&lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is, we close over the input state as soon as we capture it. We can therefore combine &lt;code&gt;captureInputState&lt;/code&gt; and &lt;code&gt;closeOverInputState&lt;/code&gt; into a single function:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What’s more, we no longer need the &lt;code&gt;InputState&lt;/code&gt; associated type at all! This is an improvement, since it simplifies the API and removes the possibility for any misuse of the input state, since it’s never directly exposed. On the other hand, it has a more complicated type: it produces a monadic action &lt;em&gt;that returns another monadic action&lt;/em&gt;. This can be a little more difficult to grok, which is why I presented the original version first, but it may help to consider how the above type arises naturally from the following definition:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;closeOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;captureInputState&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let’s update the &lt;code&gt;MonadBaseControl&lt;/code&gt; class to incorporate this simplification:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;MonadBase&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can then update all the instances to use the simpler API by simply fusing the definitions of &lt;code&gt;captureInputState&lt;/code&gt; and &lt;code&gt;closeOverInputState&lt;/code&gt; together:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;amp;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(,&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;
    &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runStateT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
      &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;
      &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt;
    &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runReaderT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runWriterT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
      &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;
      &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is already very close to a full &lt;code&gt;MonadBaseControl&lt;/code&gt; implementation. The &lt;code&gt;captureAndCloseOverInputState&lt;/code&gt; implementations are getting a little out of hand, but bear with me—they’ll get simpler before this blog post is over.&lt;/p&gt;&lt;h3&gt;&lt;a name="coping-with-partiality"&gt;&lt;/a&gt;Coping with partiality&lt;/h3&gt;&lt;p&gt;Our &lt;code&gt;MonadBaseControl&lt;/code&gt; class now works with &lt;code&gt;StateT&lt;/code&gt;, &lt;code&gt;ReaderT&lt;/code&gt;, and &lt;code&gt;WriterT&lt;/code&gt;, but one transformer we haven’t considered is &lt;code&gt;ExceptT&lt;/code&gt;. Let’s try to extend our table from before with a row for &lt;code&gt;ExceptT&lt;/code&gt;:&lt;/p&gt;&lt;div class="table-wrapper"&gt;
  &lt;table class="no-line-wrapping"&gt;
    &lt;thead&gt;&lt;tr&gt;
      &lt;th&gt;transformer&lt;/th&gt;
      &lt;th&gt;representation&lt;/th&gt;
      &lt;th&gt;input state&lt;/th&gt;
      &lt;th&gt;output state&lt;/th&gt;
    &lt;/tr&gt;&lt;/thead&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;ExceptT e m a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;m (Either e a)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;???&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;&lt;p&gt;Hmm… what &lt;em&gt;is&lt;/em&gt; the output state for &lt;code&gt;ExceptT&lt;/code&gt;?&lt;/p&gt;&lt;p&gt;The answer can’t be &lt;code&gt;e&lt;/code&gt;, since we might not end up with an &lt;code&gt;e&lt;/code&gt;—the computation might not fail. &lt;code&gt;Maybe e&lt;/code&gt; would be closer… could that work?&lt;/p&gt;&lt;p&gt;Well, let’s try it. Let’s write a &lt;code&gt;MonadBaseControl&lt;/code&gt; instance for &lt;code&gt;ExceptT&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;OutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runExceptT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
      &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;
      &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;throwError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
    &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, the above implementation doesn’t typecheck; it is rejected with the following type error:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;• Couldn't match type ‘Either e a’ with ‘(a, Maybe e)’
  Expected type: m (b ((a, Maybe e), OutputState m))
    Actual type: m (b (Either e a, OutputState m))
• In the second argument of ‘($)’, namely
    ‘captureAndCloseOverInputState (runExceptT m)’
  In a stmt of a 'do' block:
    m' &amp;lt;- lift $ captureAndCloseOverInputState (runExceptT m)
  In the expression:
    do m' &amp;lt;- lift $ captureAndCloseOverInputState (runExceptT m)
       return do ((v, s'), ss') &amp;lt;- m'
                 pure (v, (s', ss'))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We promised a &lt;code&gt;(a, Maybe e)&lt;/code&gt;, but we have an &lt;code&gt;Either e a&lt;/code&gt;, and there’s certainly no way to get the former from the latter. Are we stuck? (If you’d like, take a moment to think about how you’d solve this type error before moving on, as it may be helpful for understanding the following solution.)&lt;/p&gt;&lt;p&gt;The fundamental problem here is &lt;em&gt;partiality&lt;/em&gt;. The type of the &lt;code&gt;captureAndCloseOverInputState&lt;/code&gt; method always produces an action in the base monad that includes an &lt;code&gt;a&lt;/code&gt; &lt;em&gt;in addition&lt;/em&gt; to some other output state. But &lt;code&gt;ExceptT&lt;/code&gt; is different: when it an error is raised, it doesn’t produce an &lt;code&gt;a&lt;/code&gt; at all—it only produces an &lt;code&gt;e&lt;/code&gt;. Therefore, as written, it’s impossible to give &lt;code&gt;ExceptT&lt;/code&gt; a &lt;code&gt;MonadBaseControl&lt;/code&gt; instance.&lt;/p&gt;&lt;p&gt;Of course, we’d very much &lt;em&gt;like&lt;/em&gt; to give &lt;code&gt;ExceptT&lt;/code&gt; a &lt;code&gt;MonadBaseControl&lt;/code&gt; instance, so that isn’t very satisfying. Somehow, we need to change &lt;code&gt;captureAndCloseOverInputState&lt;/code&gt; so that it doesn’t always need to produce an &lt;code&gt;a&lt;/code&gt;. There are a few ways we could accomplish that, but an elegant way to do it is this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;MonadBase&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We’ve replaced the old &lt;code&gt;OutputState&lt;/code&gt; associated type with a new &lt;code&gt;WithOutputState&lt;/code&gt; type, and the key difference between them is that &lt;code&gt;WithOutputState&lt;/code&gt; describes the type of a &lt;em&gt;combination&lt;/em&gt; of the result (of type &lt;code&gt;a&lt;/code&gt;) and the output state, rather than describing the type of the output state alone. For total monad transformers like &lt;code&gt;StateT&lt;/code&gt;, &lt;code&gt;ReaderT&lt;/code&gt;, and &lt;code&gt;WriterT&lt;/code&gt;, &lt;code&gt;WithOutputState m a&lt;/code&gt; will just be a tuple of the result value and the output state, the same as before. For example, here’s an updated &lt;code&gt;MonadBaseControl&lt;/code&gt; instance for &lt;code&gt;StateT&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;
    &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runStateT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;
    &lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
    &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Before we consider how this helps us with &lt;code&gt;ExceptT&lt;/code&gt;, let’s pause for a moment and examine the revised &lt;code&gt;StateT&lt;/code&gt; instance in detail, as there are some new things going on here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Take a close look at the definition of &lt;code&gt;WithOutputState (StateT s m) a&lt;/code&gt;. Note that we’ve defined it to be &lt;code&gt;WithOutputState m (a, s)&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt; &lt;code&gt;(WithOutputState m a, s)&lt;/code&gt;. Consider, for a moment, the difference between these types. Can you see why we used the former, not the latter?&lt;/p&gt;&lt;p&gt;If it’s unclear to you, that’s okay—let’s illustrate the difference with an example. Consider two similar monad transformer stacks:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;m1&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;m2&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both these stacks contain &lt;code&gt;StateT&lt;/code&gt; and &lt;code&gt;ExceptT&lt;/code&gt;, but they are layered in a different order. What’s the difference? Well, consider what &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; return once fully unwrapped:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;runExceptT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runStateT&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nf"&gt;runStateT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runExceptT&lt;/span&gt; &lt;span class="n"&gt;m2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These results are meaningfully different: in &lt;code&gt;m1&lt;/code&gt;, the state is discarded if an error is raised, but in &lt;code&gt;m2&lt;/code&gt;, the final state is always returned, even if the computation is aborted. What does this mean for &lt;code&gt;WithOutputState&lt;/code&gt;?&lt;/p&gt;&lt;p&gt;Here’s the important detail: &lt;strong&gt;the state is discarded when &lt;code&gt;ExceptT&lt;/code&gt; is “inside” &lt;code&gt;StateT&lt;/code&gt;, not the other way around.&lt;/strong&gt; This can be counterintuitive, since the &lt;code&gt;s&lt;/code&gt; ends up &lt;em&gt;inside&lt;/em&gt; the &lt;code&gt;Either&lt;/code&gt; when the &lt;code&gt;StateT&lt;/code&gt; constructor is on the &lt;em&gt;outside&lt;/em&gt; and vice versa. This is really just a property of how monad transformers compose, not anything specific to &lt;code&gt;MonadBaseControl&lt;/code&gt;, so an explanation of why this happens is outside the scope of this blog post, but the relevant insight is that the &lt;code&gt;m&lt;/code&gt; in &lt;code&gt;StateT s m a&lt;/code&gt; controls the eventual action’s output state.&lt;/p&gt;&lt;p&gt;If we had defined &lt;code&gt;WithOutputState (StateT s m) a&lt;/code&gt; to be &lt;code&gt;(WithOutputState m a, s)&lt;/code&gt;, we’d be in a pickle, since &lt;code&gt;m&lt;/code&gt; would be unable to influence the presence of &lt;code&gt;s&lt;/code&gt; in the output state. Therefore, we have no choice but to use &lt;code&gt;WithOutputState m (a, s)&lt;/code&gt;. (If you are still confused by this, try it yourself; you’ll find that there’s no way to make the other definition typecheck.)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Now that we’ve developed an intuitive understanding of why &lt;code&gt;WithOutputState&lt;/code&gt; must be defined the way it is, let’s look at things from another perspective. Consider the type of &lt;code&gt;runStateT&lt;/code&gt; once more:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;runStateT&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the result type is &lt;code&gt;m (a, s)&lt;/code&gt;, with the &lt;code&gt;m&lt;/code&gt; on the outside. As it happens, this correspondence simplifies the definition of &lt;code&gt;captureAndCloseOverInputState&lt;/code&gt;, since we no longer have to do any fiddling with its result—it’s already in the proper shape, so we can just return it directly.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, this instance illustrates an interesting change to &lt;code&gt;restoreOutputState&lt;/code&gt;. Since the &lt;code&gt;a&lt;/code&gt; is now packed inside the &lt;code&gt;WithOutputState m a&lt;/code&gt; value, the caller of &lt;code&gt;captureAndCloseOverInputState&lt;/code&gt; needs some way to get the &lt;code&gt;a&lt;/code&gt; back out! Conveniently, &lt;code&gt;restoreOutputState&lt;/code&gt; can play that role, both restoring the output state and unpacking the result.&lt;/p&gt;&lt;p&gt;Even ignoring partial transformers like &lt;code&gt;ExceptT&lt;/code&gt;, this is an improvement over the old API, as it conveniently prevents the programmer from forgetting to call &lt;code&gt;restoreOutputState&lt;/code&gt;. However, as we’ll see shortly, it is much more than a convenience: once &lt;code&gt;ExceptT&lt;/code&gt; comes into play, it is essential!&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;With those details addressed, let’s return to &lt;code&gt;ExceptT&lt;/code&gt;. Using the new interface, writing an instance for &lt;code&gt;ExceptT&lt;/code&gt; is not only possible, it’s actually rather easy:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runExceptT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;either&lt;/span&gt; &lt;span class="n"&gt;throwError&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This instance illustrates why it’s so crucial that &lt;code&gt;restoreOutputState&lt;/code&gt; have the aforementioned dual role: it must handle the case where no &lt;code&gt;a&lt;/code&gt; exists at all! In the case of &lt;code&gt;ExceptT&lt;/code&gt;, it restores the state in the enclosing monad by re-raising an error.&lt;/p&gt;&lt;p&gt;Now all that’s left to do is update the other instances:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt;
    &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runReaderT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runWriterT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;
    &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
    &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, we can update our lifted variant of &lt;code&gt;foo&lt;/code&gt; to use the new interface so it will work with transformer stacks that include &lt;code&gt;ExceptT&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="o"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;liftBase&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point, it’s worth considering something: although getting the &lt;code&gt;MonadBaseControl&lt;/code&gt; class and instances right was a lot of work, the resulting &lt;code&gt;foo'&lt;/code&gt; implementation is actually incredibly simple. That’s a good sign, since we only have to write the &lt;code&gt;MonadBaseControl&lt;/code&gt; instances once (in a library), but we have to write functions like &lt;code&gt;foo'&lt;/code&gt; quite often.&lt;/p&gt;&lt;h2&gt;&lt;a name="scaling-to-the-real-monadbasecontrol"&gt;&lt;/a&gt;Scaling to the real &lt;code&gt;MonadBaseControl&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;The &lt;code&gt;MonadBaseControl&lt;/code&gt; class we implemented in the previous section is complete. It is a working, useful class that is equivalent in power to &lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl"&gt;the “real” &lt;code&gt;MonadBaseControl&lt;/code&gt; class in the &lt;code&gt;monad-control&lt;/code&gt; library&lt;/a&gt;. However, if you compare the two, you’ll notice that the version in &lt;code&gt;monad-control&lt;/code&gt; looks a little bit different. What gives?&lt;/p&gt;&lt;p&gt;Let’s compare the two classes side by side:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;-- ours&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;MonadBase&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;restoreOutputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;WithOutputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="c1"&gt;-- theirs&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;MonadBase&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;StM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;RunInBase&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;StM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let’s start with the similarities, since those are easy:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Our &lt;code&gt;WithOutputState&lt;/code&gt; associated type is precisely equivalent to their &lt;code&gt;StM&lt;/code&gt; associated type, they just use a (considerably) shorter name.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Likewise, our &lt;code&gt;restoreOutputState&lt;/code&gt; method is precisely equivalent to their &lt;code&gt;restoreM&lt;/code&gt; method, simply under a different name.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;That leaves &lt;code&gt;captureAndCloseOverInputState&lt;/code&gt; and &lt;code&gt;liftBaseWith&lt;/code&gt;. Those two methods both do similar things, but they aren’t identical, and that’s where all the differences lie. To understand &lt;code&gt;liftBaseWith&lt;/code&gt;, let’s start by inlining the definition of the &lt;code&gt;RunInBase&lt;/code&gt; type alias so we can see the fully-expanded type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;liftBaseWith&lt;/span&gt;
  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That type is complicated! However, if we break it down, hopefully you’ll find it’s not as scary as it first appears. Let’s reimplement the &lt;code&gt;foo'&lt;/code&gt; example from before using &lt;code&gt;liftBaseWith&lt;/code&gt; to show how this version of &lt;code&gt;MonadBaseControl&lt;/code&gt; works:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is, in some ways, superficially similar to the version we wrote using our version of &lt;code&gt;MonadBaseControl&lt;/code&gt;. Just like in our version, we capture the input state, apply &lt;code&gt;foo&lt;/code&gt; in the &lt;code&gt;IO&lt;/code&gt; monad, then restore the state. But what exactly is doing the state capturing, and what is &lt;code&gt;runInBase&lt;/code&gt;?&lt;/p&gt;&lt;p&gt;Let’s start by adding a type annotation to &lt;code&gt;runInBase&lt;/code&gt; to help make it a little clearer what’s going on:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That type should look sort of recognizable. If we replace &lt;code&gt;StM&lt;/code&gt; with &lt;code&gt;WithOutputState&lt;/code&gt;, then we get a type that looks very similar to that of our original &lt;code&gt;closeOverInputState&lt;/code&gt; function, except it doesn’t need to take the input state as an argument. How does that work?&lt;/p&gt;&lt;p&gt;Here’s the trick: &lt;code&gt;liftBaseWith&lt;/code&gt; starts by capturing the input state, just as before. However, it then builds a function, &lt;code&gt;runInBase&lt;/code&gt;, which is like &lt;code&gt;closeOverInputState&lt;/code&gt; partially-applied to the input state it captured. It hands that function to us, and we’re free to apply it to &lt;code&gt;m&lt;/code&gt;, which produces the &lt;code&gt;IO (StM m a)&lt;/code&gt; action we need, and we can now pass that action to &lt;code&gt;foo&lt;/code&gt;. The result is returned in the outer monad, and we restore the state using &lt;code&gt;restoreM&lt;/code&gt;.&lt;/p&gt;&lt;h3&gt;&lt;a name="sharing-the-input-state"&gt;&lt;/a&gt;Sharing the input state&lt;/h3&gt;&lt;p&gt;At first, this might seem needlessly complicated. When we first started, we separated capturing the input state and closing over it into two separate operations (&lt;code&gt;captureInputState&lt;/code&gt; and &lt;code&gt;closeOverInputState&lt;/code&gt;), but we eventually combined them so that we could keep the input state hidden. Why does &lt;code&gt;monad-control&lt;/code&gt; split them back into two operations again?&lt;/p&gt;&lt;p&gt;As it turns out, when lifting &lt;code&gt;foo&lt;/code&gt;, there’s no advantage to the more complicated API of &lt;code&gt;monad-control&lt;/code&gt;. In fact, we could implement our &lt;code&gt;captureAndCloseOverInputState&lt;/code&gt; operation in terms of &lt;code&gt;liftBaseWith&lt;/code&gt;, and we could use that to implement &lt;code&gt;foo'&lt;/code&gt; the same way we did before:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nf"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;foo&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="o"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;liftBase&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, that approach has a downside once we need to lift more complicated functions. &lt;code&gt;foo&lt;/code&gt; is exceptionally simple, as it only accepts a single input argument, but what if we wanted to lift a more complicated function that took &lt;em&gt;two&lt;/em&gt; monadic arguments, such as this one:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;bar&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We could implement that by calling &lt;code&gt;captureAndCloseOverInputState&lt;/code&gt; twice, like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;bar&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;bar&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;ma&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt;
  &lt;span class="n"&gt;mb&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;captureAndCloseOverInputState&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt;
  &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="o"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;liftBase&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="n"&gt;ma&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;mb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, that would capture the monadic state twice, which is rather inefficient. By using &lt;code&gt;liftBaseWith&lt;/code&gt;, the state capturing is done just once, and it’s shared between all calls to &lt;code&gt;runInBase&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;bar&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;bar&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By providing a “running” function (&lt;code&gt;runInBase&lt;/code&gt;) instead of direct access to the input state, &lt;code&gt;liftBaseWith&lt;/code&gt; allows sharing the captured input state between multiple actions without exposing it directly.&lt;/p&gt;&lt;h3&gt;&lt;a name="sidebar-continuation-passing-and-impredicativity"&gt;&lt;/a&gt;Sidebar: continuation-passing and impredicativity&lt;/h3&gt;&lt;p&gt;One last point before we move on: although the above explains why &lt;code&gt;captureAndCloseOverInputState&lt;/code&gt; is insufficient, you may be left wondering why &lt;code&gt;liftBaseWith&lt;/code&gt; can’t just &lt;em&gt;return&lt;/em&gt; &lt;code&gt;runInBase&lt;/code&gt;. Why does it need to be given a continuation? After all, it would be nicer if we could just write this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;bar&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;bar&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;askRunInBase&lt;/span&gt;
  &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="o"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;liftBase&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To understand the problem with a hypothetical &lt;code&gt;askRunInBase&lt;/code&gt; function, remember that the type of &lt;code&gt;runInBase&lt;/code&gt; is polymorphic:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is important, since if you need to lift a function with a type like&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;baz&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;then you’ll want to instantiate that &lt;code&gt;a&lt;/code&gt; variable with two different types. We’d need to retain that power in &lt;code&gt;askRunInBase&lt;/code&gt;, so it would need to have the following type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;askRunInBase&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, that type is illegal in Haskell. Type constructors must be applied to monomorphic types, but in the above type signature, &lt;code&gt;m&lt;/code&gt; is applied to a polymorphic type.&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;2&lt;/a&gt;&lt;/sup&gt; The &lt;code&gt;RankNTypes&lt;/code&gt; GHC extension introduces a single exception: the &lt;code&gt;(-&amp;gt;)&lt;/code&gt; type constructor is special and may be applied to polymorphic types. That’s why &lt;code&gt;liftBaseWith&lt;/code&gt; is legal, but &lt;code&gt;askRunInBase&lt;/code&gt; is not: since &lt;code&gt;liftBaseWith&lt;/code&gt; is passed a higher-order function that receives &lt;code&gt;runInBase&lt;/code&gt; as an argument, the polymorphic type appears immediately under an application of &lt;code&gt;(-&amp;gt;)&lt;/code&gt;, which is allowed.&lt;/p&gt;&lt;p&gt;The aforementioned restriction means we’re basically out of luck, but if you &lt;em&gt;really&lt;/em&gt; want &lt;code&gt;askRunInBase&lt;/code&gt;, there is a workaround. GHC is perfectly alright with a field of a datatype being polymorphic, so we can define a newtype that wraps a suitably-polymorphic function:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;RunInBase&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;RunInBase&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now alter &lt;code&gt;askRunInBase&lt;/code&gt; to return our newtype, and we can implement it in terms of &lt;code&gt;liftBaseWith&lt;/code&gt;:&lt;sup&gt;&lt;a href="#footnote-2" id="footnote-ref-2-1"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;askRunInBase&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;RunInBase&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;askRunInBase&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;RunInBase&lt;/span&gt; &lt;span class="n"&gt;runInBase&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To use &lt;code&gt;askRunInBase&lt;/code&gt;, we have to pattern match on the &lt;code&gt;RunInBase&lt;/code&gt; constructor, but it isn’t very noisy, since we can do it directly in a &lt;code&gt;do&lt;/code&gt; binding. For example, we could implement a lifted version of &lt;code&gt;baz&lt;/code&gt; this way:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;baz&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;baz&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="kt"&gt;RunInBase&lt;/span&gt; &lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;askRunInBase&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftBase&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;bitraverse&lt;/span&gt; &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As of version 1.0.2.3, &lt;code&gt;monad-control&lt;/code&gt; does not provide a newtype like &lt;code&gt;RunInBase&lt;/code&gt;, so it also doesn’t provide a function like &lt;code&gt;askRunInBase&lt;/code&gt;. For now, you’ll have to use &lt;code&gt;liftBaseWith&lt;/code&gt;, but it might be a useful future addition to the library.&lt;/p&gt;&lt;h2&gt;&lt;a name="pitfalls"&gt;&lt;/a&gt;Pitfalls&lt;/h2&gt;&lt;p&gt;At this point in the blog post, we’ve covered the essentials of &lt;code&gt;MonadBaseControl&lt;/code&gt;: how it works, how it’s designed, and how you might go about using it. However, so far, we’ve only considered situations where &lt;code&gt;MonadBaseControl&lt;/code&gt; works well, and I’ve intentionally avoided examples where the technique breaks down. In this section, we’re going to take a look at the pitfalls and drawbacks of &lt;code&gt;MonadBaseControl&lt;/code&gt;, plus some ways they can be mitigated.&lt;/p&gt;&lt;h3&gt;&lt;a name="no-polymorphism-no-lifting"&gt;&lt;/a&gt;No polymorphism, no lifting&lt;/h3&gt;&lt;p&gt;All of the pitfalls of &lt;code&gt;MonadBaseControl&lt;/code&gt; stem from the same root problem, and that’s the particular technique it uses to save and restore monadic state. We’ll start by considering one of the simplest ways that technique is thwarted, and that’s monomorphism. Consider the following two functions:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;poly&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;mono&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;X&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;X&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Even after all we’ve covered, it may surprise you to learn that although &lt;code&gt;poly&lt;/code&gt; can be easily lifted to &lt;code&gt;MonadBaseControl IO m =&amp;gt; m a -&amp;gt; m a&lt;/code&gt;, it’s &lt;em&gt;impossible&lt;/em&gt; to lift &lt;code&gt;mono&lt;/code&gt; to &lt;code&gt;MonadBaseControl IO m =&amp;gt; m X -&amp;gt; m X&lt;/code&gt;. It’s a little unintuitive, as we often think of polymorphic types as being more complicated (so surely lifting polymorphic functions ought to be harder), but in fact, it’s the flexibility of polymorphism that allows &lt;code&gt;MonadBaseControl&lt;/code&gt; to work in the first place.&lt;/p&gt;&lt;p&gt;To understand the problem, remember that when we lift a function of type &lt;code&gt;forall a. b a -&amp;gt; b a&lt;/code&gt; using &lt;code&gt;MonadBaseControl&lt;/code&gt;, we actually instantiate &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;(StM m c)&lt;/code&gt;. That produces a function of type &lt;code&gt;b (StM m c) -&amp;gt; b (StM m c)&lt;/code&gt;, which is isomorphic to the &lt;code&gt;m c -&amp;gt; m c&lt;/code&gt; type we want. The instantiation step is easily overlooked, but it’s crucial, since otherwise we have no way to thread the state through the otherwise opaque function we’re trying to lift!&lt;/p&gt;&lt;p&gt;In the case of &lt;code&gt;mono&lt;/code&gt;, that’s exactly the problem we’re faced with. &lt;code&gt;mono&lt;/code&gt; will not accept an &lt;code&gt;IO (StM m X)&lt;/code&gt; as an argument, only precisely an &lt;code&gt;IO X&lt;/code&gt;, so we can’t pass along the monadic state. For all its machinery, &lt;code&gt;MonadBaseControl&lt;/code&gt; is no help at all if no polymorphism is involved. Trying to generalize &lt;code&gt;mono&lt;/code&gt; without modifying its implementation is a lost cause.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-dangers-of-discarded-state"&gt;&lt;/a&gt;The dangers of discarded state&lt;/h3&gt;&lt;p&gt;Our inability to lift &lt;code&gt;mono&lt;/code&gt; is frustrating, but at least it’s conclusively impossible. In practice, however, many functions lie in an insidious in-between: polymorphic enough to be lifted, but not without compromises. The simplest of these functions have types such as the following:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;sideEffect&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unlike &lt;code&gt;mono&lt;/code&gt;, it’s entirely possible to lift &lt;code&gt;sideEffect&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;sideEffect&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;sideEffect&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sideEffect&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This definition typechecks, but you may very well prefer it didn’t, since it has a serious problem: any changes made by &lt;code&gt;m&lt;/code&gt; to the monadic state are completely discarded once &lt;code&gt;sideEffect'&lt;/code&gt; returns! Since &lt;code&gt;sideEffect'&lt;/code&gt; never calls &lt;code&gt;restoreM&lt;/code&gt;, there’s no way the state of &lt;code&gt;m&lt;/code&gt; can be any different from the original state, but it’s impossible to call &lt;code&gt;restoreM&lt;/code&gt; since we don’t actually get an &lt;code&gt;StM m ()&lt;/code&gt; result from &lt;code&gt;sideEffect&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Sometimes this may be acceptable, since some monad transformers don’t actually have any output state anyway, such as &lt;code&gt;ReaderT r&lt;/code&gt;. In other cases, however, &lt;code&gt;sideEffect'&lt;/code&gt; could be a bug waiting to happen. One way to make &lt;code&gt;sideEffect'&lt;/code&gt; safe would be to add a &lt;code&gt;StM m a ~ a&lt;/code&gt; constraint to its context, since that guarantees the monad transformers being lifted through are stateless, and nothing is actually being discarded. Of course, that significantly restricts the set of monad transformers that can be lifted through.&lt;/p&gt;&lt;h4&gt;&lt;a name="rewindable-state"&gt;&lt;/a&gt;Rewindable state&lt;/h4&gt;&lt;p&gt;One scenario where state discarding can actually be useful is operations with so-called rewindable or transactional state. The most common example of such an operation is &lt;code&gt;catch&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;catch&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When lifted, state changes from the action &lt;em&gt;or&lt;/em&gt; from the exception handler will be “committed,” but never both. If an exception is raised during the computation, those state changes are discarded (“rewound”), giving &lt;code&gt;catch&lt;/code&gt; a kind of backtracking semantics. This behavior arises naturally from the way a lifted version of &lt;code&gt;catch&lt;/code&gt; must be implemented:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;catch&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;catch&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If &lt;code&gt;m&lt;/code&gt; raises an exception, it will never return an &lt;code&gt;StM m a&lt;/code&gt; value, so there’s no way to get ahold of any of the state changes that happened before the exception. Therefore, the only option is to discard that state.&lt;/p&gt;&lt;p&gt;This behavior is actually quite useful, and it’s definitely not unreasonable. However, useful or not, it’s inconsistent with state changes to mutable values like &lt;code&gt;IORef&lt;/code&gt;s or &lt;code&gt;MVar&lt;/code&gt;s (they stay modified whether an exception is raised or not), so it can still be a gotcha. Either way, it’s worth being aware of.&lt;/p&gt;&lt;h4&gt;&lt;a name="partially-discarded-state"&gt;&lt;/a&gt;Partially discarded state&lt;/h4&gt;&lt;p&gt;The next function we’re going to examine is &lt;code&gt;finally&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;finally&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function has a similar type to &lt;code&gt;catch&lt;/code&gt;, and it even has similar semantics. Like &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt; can be lifted, but unlike &lt;code&gt;catch&lt;/code&gt;, its state &lt;em&gt;can’t&lt;/em&gt; be given any satisfying treatment. The only way to implement a lifted version is&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;finally&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;finally&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which always discards all state changes made by the second argument. This is clear just from looking at &lt;code&gt;finally&lt;/code&gt;’s type: since &lt;code&gt;b&lt;/code&gt; doesn’t appear anywhere in the return type, there’s simply no way to access that action’s result, and therefore no way to access its modified state.&lt;/p&gt;&lt;p&gt;However, don’t despair: there actually &lt;em&gt;is&lt;/em&gt; a way to produce a lifted version of &lt;code&gt;finally&lt;/code&gt; that preserves all state changes. It can’t be done by lifting &lt;code&gt;finally&lt;/code&gt; directly, but if we reimplement &lt;code&gt;finally&lt;/code&gt; in terms of simpler lifted functions that are more amenable to lifting, we can produce a lifted version of &lt;code&gt;finally&lt;/code&gt; that preserves all the state:&lt;sup&gt;&lt;a href="#footnote-3" id="footnote-ref-3-1"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;finally&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;finally&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mask&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;restore&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restore&lt;/span&gt; &lt;span class="n"&gt;ma&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;liftBase&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;SomeException&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;restoreM&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;*&lt;/span&gt; &lt;span class="n"&gt;mb&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This illustrates an important (and interesting) point about &lt;code&gt;MonadBaseControl&lt;/code&gt;: whether or not an operation can be made state-preserving is not a fundamental property of the operation’s type, but rather a property of the types of the exposed primitives. There is sometimes a way to implement a state-preserving variant of operations that might otherwise seem unliftable given the right primitives and a bit of cleverness.&lt;/p&gt;&lt;h4&gt;&lt;a name="forking-state"&gt;&lt;/a&gt;Forking state&lt;/h4&gt;&lt;p&gt;As a final example, I want to provide an example where the state may not actually be discarded &lt;em&gt;per se&lt;/em&gt;, just inaccessible. Consider the type of &lt;code&gt;forkIO&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;forkIO&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;ThreadId&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Although &lt;code&gt;forkIO&lt;/code&gt; isn’t actually polymorphic in its argument, we can convert &lt;em&gt;any&lt;/em&gt; &lt;code&gt;IO&lt;/code&gt; action to one that produces &lt;code&gt;()&lt;/code&gt; via &lt;code&gt;void&lt;/code&gt;, so it might as well be. Therefore, we can lift &lt;code&gt;forkIO&lt;/code&gt; in much the same way we did with &lt;code&gt;sideEffect&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;forkIO&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;ThreadId&lt;/span&gt;
&lt;span class="nf"&gt;forkIO&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftBaseWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;forkIO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;runInBase&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As with &lt;code&gt;sideEffect&lt;/code&gt;, we can’t recover the output state, but in this case, there’s a fundamental reason that goes deeper than the types: we’ve forked off a concurrent computation! We’ve therefore split the state in two, which might be what we want… but it also might not. &lt;code&gt;forkIO&lt;/code&gt; is yet another illustration that it’s important to think about the state-preservation semantics when using &lt;code&gt;MonadBaseControl&lt;/code&gt;, or you may end up with a bug!&lt;/p&gt;&lt;h2&gt;&lt;a name="monadbasecontrol-in-context"&gt;&lt;/a&gt;&lt;code&gt;MonadBaseControl&lt;/code&gt; in context&lt;/h2&gt;&lt;p&gt;Congratulations: you’ve made it through most of this blog post. If you’ve followed everything so far, you now understand &lt;code&gt;MonadBaseControl&lt;/code&gt;. All the tricky parts are over. However, before wrapping up, I’d like to add a little extra information about how &lt;code&gt;MonadBaseControl&lt;/code&gt; relates to various other parts of the Haskell ecosystem. In practice, that information can be as important as understanding &lt;code&gt;MonadBaseControl&lt;/code&gt; itself.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-remainder-of-monad-control"&gt;&lt;/a&gt;The remainder of &lt;code&gt;monad-control&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;If you look at &lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html"&gt;the documentation for &lt;code&gt;monad-control&lt;/code&gt;&lt;/a&gt;, you’ll find that it provides more than just the &lt;code&gt;MonadBaseControl&lt;/code&gt; typeclass. I’m not going to cover everything else in detail in this blog post, but I do want to touch upon it briefly.&lt;/p&gt;&lt;p&gt;First off, you should definitely take a look at the handful of helper functions provided by &lt;code&gt;monad-control&lt;/code&gt;, such as &lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#v:control"&gt;&lt;code&gt;control&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#v:liftBaseOp_"&gt;&lt;code&gt;liftBaseOp_&lt;/code&gt;&lt;/a&gt;. These functions provide support for lifting common function types without having to use &lt;code&gt;liftBaseWith&lt;/code&gt; directly. It’s useful to understand &lt;code&gt;liftBaseWith&lt;/code&gt;, since it’s the most general way to use &lt;code&gt;MonadBaseControl&lt;/code&gt;, but in practice, it is simpler and more readable to use the more specialized functions wherever possible. Many of the examples in this very blog post could be simplified using them, and I only stuck to &lt;code&gt;liftBaseWith&lt;/code&gt; to introduce as few new concepts at a time as possible.&lt;/p&gt;&lt;p&gt;Second, I’d like to mention the related &lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadTransControl"&gt;&lt;code&gt;MonadTransControl&lt;/code&gt;&lt;/a&gt; typeclass. You hopefully remember from earlier in the blog post how we defined &lt;code&gt;MonadBaseControl&lt;/code&gt; instances inductively so that we could lift all the way down to the base monad. &lt;code&gt;MonadTransControl&lt;/code&gt; is like &lt;code&gt;MonadBaseControl&lt;/code&gt; if it intentionally did &lt;em&gt;not&lt;/em&gt; do that—it allows lifting through a single transformer at a time, rather than through all of them at once.&lt;/p&gt;&lt;p&gt;Usually, &lt;code&gt;MonadTransControl&lt;/code&gt; is not terribly useful to use directly (though I did use it once &lt;a href="/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/#making-mtls-classes-derivable"&gt;in a previous blog post of mine&lt;/a&gt; to help derive instances of mtl-style classes), but it &lt;em&gt;is&lt;/em&gt; useful for implementing &lt;code&gt;MonadBaseControl&lt;/code&gt; instances for your own transformers. If you define a &lt;code&gt;MonadTransControl&lt;/code&gt; instance for your monad transformer, you can get a &lt;code&gt;MonadBaseControl&lt;/code&gt; implementation for free using the provided &lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:ComposeSt"&gt;&lt;code&gt;ComposeSt&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#v:defaultLiftBaseWith"&gt;&lt;code&gt;defaultLiftBaseWith&lt;/code&gt;&lt;/a&gt;, and &lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#v:defaultRestoreM"&gt;&lt;code&gt;defaultRestoreM&lt;/code&gt;&lt;/a&gt; bindings; see the documentation for more details.&lt;/p&gt;&lt;h3&gt;&lt;a name="lifted-base-and-lifted-async"&gt;&lt;/a&gt;&lt;code&gt;lifted-base&lt;/code&gt; and &lt;code&gt;lifted-async&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;If you’re going to use &lt;code&gt;MonadBaseControl&lt;/code&gt;, the &lt;a href="http://hackage.haskell.org/package/lifted-base"&gt;&lt;code&gt;lifted-base&lt;/code&gt;&lt;/a&gt; and &lt;a href="http://hackage.haskell.org/package/lifted-async"&gt;&lt;code&gt;lifted-async&lt;/code&gt;&lt;/a&gt; packages are good to know about. As their names imply, they provide lifted versions of bindings in the &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt; packages, so you can use them directly without needing to lift them yourself. For example, if you needed a lifted version of &lt;code&gt;mask&lt;/code&gt; from &lt;code&gt;Control.Exception&lt;/code&gt;, you could swap it for the &lt;code&gt;mask&lt;/code&gt; export from &lt;code&gt;Control.Exception.Lifted&lt;/code&gt;, and everything would mostly just work (though always be sure to check the documentation for any caveats on state discarding).&lt;/p&gt;&lt;h3&gt;&lt;a name="relationship-to-monadunliftio"&gt;&lt;/a&gt;Relationship to &lt;code&gt;MonadUnliftIO&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Recently, FP Complete has developed the &lt;a href="https://hackage.haskell.org/package/unliftio"&gt;&lt;code&gt;unliftio&lt;/code&gt;&lt;/a&gt; package as an alternative to &lt;code&gt;monad-control&lt;/code&gt;. It provides the &lt;a href="https://hackage.haskell.org/package/unliftio-core-0.1.2.0/docs/Control-Monad-IO-Unlift.html#t:MonadUnliftIO"&gt;&lt;code&gt;MonadUnliftIO&lt;/code&gt;&lt;/a&gt; typeclass, which is similar in spirit to &lt;code&gt;MonadBaseControl&lt;/code&gt;, but heavily restricted: it is specialized to &lt;code&gt;IO&lt;/code&gt; as the base monad, and it &lt;em&gt;only&lt;/em&gt; allows instances for stateless monads, such as &lt;code&gt;ReaderT&lt;/code&gt;. This is designed to encourage the so-called &lt;a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern"&gt;&lt;code&gt;ReaderT&lt;/code&gt; design pattern&lt;/a&gt;, which avoids ever using stateful monads like &lt;code&gt;ExceptT&lt;/code&gt; or &lt;code&gt;StateT&lt;/code&gt; over &lt;code&gt;IO&lt;/code&gt;, encouraging the use of &lt;code&gt;IO&lt;/code&gt; exceptions and mutable variables (e.g. &lt;code&gt;MVar&lt;/code&gt;s or &lt;code&gt;TVar&lt;/code&gt;s) instead.&lt;/p&gt;&lt;p&gt;I should be clear: I really like most of what FP Complete has done—to this day, I still use &lt;code&gt;stack&lt;/code&gt; as my Haskell build tool of choice—and I think the suggestions given in the aforementioned “&lt;code&gt;ReaderT&lt;/code&gt; design pattern” blog post have real weight to them. I have a deep respect for Michael Snoyman’s commitment to opinionated, user-friendly tools and libraries. But truthfully, I can’t stand &lt;code&gt;MonadUnliftIO&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;code&gt;MonadUnliftIO&lt;/code&gt; is designed to avoid all the complexity around state discarding that &lt;code&gt;MonadBaseControl&lt;/code&gt; introduces, and on its own, that’s a noble goal. Safety first, after all. The problem is that &lt;code&gt;MonadUnliftIO&lt;/code&gt; really is extremely limiting, and what’s more, it can actually be trivially encoded in terms of &lt;code&gt;MonadBaseControl&lt;/code&gt; as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;MonadUnliftIO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;StM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This alias can be used to define safe, lifted functions that never discard state while still allowing functions that &lt;em&gt;can&lt;/em&gt; be safely lifted through stateful transformers to do so. Indeed, the &lt;a href="https://hackage.haskell.org/package/lifted-async-0.10.0.4/docs/Control-Concurrent-Async-Lifted-Safe.html"&gt;&lt;code&gt;Control.Concurrent.Async.Lifted.Safe&lt;/code&gt;&lt;/a&gt; module from &lt;code&gt;lifted-async&lt;/code&gt; does exactly that (albeit with a slightly different formulation than the above alias).&lt;/p&gt;&lt;p&gt;To be fair, the &lt;code&gt;unliftio&lt;/code&gt; README does address this in its &lt;a href="https://github.com/fpco/unliftio/tree/bb2e26e7fbbaebb15555f417ba9753a76b3218b2/unliftio#monad-control"&gt;comparison section&lt;/a&gt;:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;monad-control&lt;/code&gt; allows us to unlift both styles. In theory, we could write a variant of &lt;code&gt;lifted-base&lt;/code&gt; that never does state discards […] In other words, this is an advantage of &lt;code&gt;monad-control&lt;/code&gt; over &lt;code&gt;MonadUnliftIO&lt;/code&gt;. We've avoided providing any such extra typeclass in this package though, for two reasons:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;MonadUnliftIO&lt;/code&gt; is a simple typeclass, easy to explain. We don't want to complicated [sic] matters […]&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Having this kind of split would be confusing in user code, when suddenly [certain operations are] not available to us.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;In other words, the authors of &lt;code&gt;unliftio&lt;/code&gt; felt that &lt;code&gt;MonadBaseControl&lt;/code&gt; was simply not worth the complexity, and they could get away with &lt;code&gt;MonadUnliftIO&lt;/code&gt;. Frankly, if you feel the same way, by all means, use &lt;code&gt;unliftio&lt;/code&gt;. I just found it too limiting given the way I write Haskell, plain and simple.&lt;/p&gt;&lt;h2&gt;&lt;a name="recap"&gt;&lt;/a&gt;Recap&lt;/h2&gt;&lt;p&gt;So ends another long blog post. As often seems the case, I set out to write something short, but I ended up writing well over 5,000 words. I suppose that means I learned something from this experience, too: &lt;code&gt;MonadBaseControl&lt;/code&gt; is more complicated than I had anticipated! Maybe there’s something to take away from that.&lt;/p&gt;&lt;p&gt;In any case, it’s over now, so I’d like to briefly summarize what we’ve covered:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl"&gt;&lt;code&gt;MonadBaseControl&lt;/code&gt;&lt;/a&gt; allows us to lift higher-order monadic operations.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;It operates by capturing the current monadic state and explicitly threading it through the action in the base monad before restoring it.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;That technique works well for polymorphic operations for the type &lt;code&gt;forall a. b a -&amp;gt; b a&lt;/code&gt;, but it can be tricky or even impossible for more complex operations, sometimes leading to discarded state.&lt;/p&gt;&lt;p&gt;This can sometimes be mitigated by restricting certain operations to stateless monads using a &lt;code&gt;StM m a ~ a&lt;/code&gt; constraint, or by reimplementing the operation in terms of simpler primitives.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The &lt;a href="http://hackage.haskell.org/package/lifted-base"&gt;&lt;code&gt;lifted-base&lt;/code&gt;&lt;/a&gt; and &lt;a href="http://hackage.haskell.org/package/lifted-async"&gt;&lt;code&gt;lifted-async&lt;/code&gt;&lt;/a&gt; packages provide lifted versions of existing operations, avoiding the need to lift them yourself.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;As with many abstractions in Haskell, don’t worry too much if you don’t have a completely firm grasp of &lt;code&gt;MonadBaseControl&lt;/code&gt; at first. Insight often comes with repeated experience, and &lt;code&gt;monad-control&lt;/code&gt; can still be used in useful ways even without a perfect understanding. My hope is that this blog post has helped you build intuitions about &lt;code&gt;MonadBaseControl&lt;/code&gt; even if some of the underlying machinery remains a little fuzzy, and I hope it can also serve as a reference for those who want or need to understand (or just be reminded of) all the little details.&lt;/p&gt;&lt;p&gt;Finally, I’ll admit &lt;code&gt;MonadBaseControl&lt;/code&gt; isn’t especially elegant or beautiful as Haskell abstractions go. In fact, in many ways, it’s a bit of a kludge! Perhaps, in time, effect systems will evolve and mature so that it and its ilk are no longer necessary, and they may become distant relics of an inferior past. But in the meantime, it’s here, it’s useful, and I think it’s worth embracing. If you’ve shied away from it in the past, I hope I’ve illuminated it enough to make you consider giving it another try.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-0"&gt;&lt;p&gt;One example of a function with that type is &lt;code&gt;mask_&lt;/code&gt;. &lt;a href="#footnote-ref-0-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;Types with polymorphic types under type constructors are called &lt;em&gt;impredicative&lt;/em&gt;. GHC technically has limited support for impredicativity via the &lt;code&gt;ImpredicativeTypes&lt;/code&gt; language extension, but as of GHC 8.8, it has been fairly broken for some time. A fix is apparently being worked on, but even if that effort is successful, I don’t know what impact it will have on type inference. &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-2"&gt;&lt;p&gt;Note that &lt;code&gt;askRunInBase = liftBaseWith (pure . RunInBase)&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; typecheck, as it would require impredicative polymorphism: it would require instantiating the type of &lt;code&gt;(.)&lt;/code&gt; with polymorphic types. The version using &lt;code&gt;($)&lt;/code&gt; works because GHC actually has special typechecking rules for &lt;code&gt;($)&lt;/code&gt;! Effectively, &lt;code&gt;f $ x&lt;/code&gt; is really syntax in GHC. &lt;a href="#footnote-ref-2-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-3"&gt;&lt;p&gt;Assume that &lt;code&gt;mask'&lt;/code&gt; is a suitably lifted version of &lt;code&gt;mask&lt;/code&gt; (which can in fact be made state-preserving). &lt;a href="#footnote-ref-3-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Defeating Racket’s separate compilation guarantee</title><link>https://lexi-lambda.github.io/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/</guid><pubDate>21 Apr 2019</pubDate><description>&lt;article&gt;&lt;p&gt;Being a self-described &lt;a href="https://felleisen.org/matthias/manifesto/sec_pl-pl.html"&gt;programming-language programming language&lt;/a&gt; is an ambitious goal. To preserve predictability while permitting linguistic extension, Racket comes equipped with a module system carefully designed to accommodate &lt;a href="https://www.cs.utah.edu/plt/publications/macromod.pdf"&gt;composable and compilable macros&lt;/a&gt;. One of the module system’s foundational properties is its &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._separate-compilation%29"&gt;&lt;em&gt;separate compilation guarantee&lt;/em&gt;&lt;/a&gt;, which imposes strong, unbreakable limits on the extent of compile-time side-effects. It is &lt;em&gt;essential&lt;/em&gt; for preserving static guarantees in a world where compiling a module can execute arbitrary code, and despite numerous unsafe trapdoors that have crept into Racket since its birth as PLT Scheme, none have ever given the programmer the ability to cheat it.&lt;/p&gt;&lt;p&gt;Yet today, in this blog post, we’re going to do exactly that.&lt;/p&gt;&lt;h2&gt;&lt;a name="what-is-the-separate-compilation-guarantee"&gt;&lt;/a&gt;What is the separate compilation guarantee?&lt;/h2&gt;&lt;p&gt;Before we get to the fun part (i.e. breaking things), let’s go over some fundamentals so we understand what we’re breaking. The authoritative source for the separate compilation guarantee is &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._separate-compilation%29"&gt;the Racket reference&lt;/a&gt;, but it is dense, as authoritative sources tend to be. Although I enjoy reading technical manuals for sport, it is my understanding that not all the people who read this blog are as strange as I am, so let’s start with a quick primer, instead. (If you’re already an expert, feel free to &lt;a href="#section:main-start"&gt;skip to the next section&lt;/a&gt;.)&lt;/p&gt;&lt;p&gt;Racket is a macro-enabled programming language. In Racket, a macro is a user-defined, code-to-code transformation that occurs at compile-time. These transformations cannot make arbitrary changes to the program—in Racket, they are usually required to be &lt;em&gt;local&lt;/em&gt;, affecting a single expression or definition at a time—but they may be implemented using arbitrary code. This means that a macro can, if it so desires, read the SSH keys off your filesystem and issue an HTTP request to send them someplace.&lt;/p&gt;&lt;p&gt;That kind of attack is bad, admittedly, but it’s also &lt;em&gt;uninteresting&lt;/em&gt;: Racket allows you do all that and then some, making no attempt to prevent it.&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;1&lt;/a&gt;&lt;/sup&gt; Racket calls these “external effects,” things that affect state outside of the programming language. They sound scary, but in practice, &lt;em&gt;internal effects&lt;/em&gt;—effects that mutate state inside the programming language—are a much bigger obstacle to practical programming. Let’s take a look at why.&lt;/p&gt;&lt;p&gt;Let’s say we have a module with some global, mutable state. Perhaps it is used to keep track of a set of delicious foods:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;;; foods.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;add-delicious-food!&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mutable-set&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set-member?&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set-add!&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using this interface, let’s write a program that checks if a particular food, given as a command-line argument, is delicious:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;;; check-food.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"foods.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="s2"&gt;"pineapple"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="s2"&gt;"sushi"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="s2"&gt;"cheesecake"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;command-line&lt;/span&gt;
  &lt;span class="kd"&gt;#:args&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;food-to-check&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;food-to-check&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"~a is a delicious food.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;food-to-check&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"~a is not delicious.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;food-to-check&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ racket check-food.rkt cheesecake
cheesecake is a delicious food.
$ racket check-food.rkt licorice
licorice is not delicious.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Exhilarating. (Sorry, licorice fans.) But what if a &lt;em&gt;macro&lt;/em&gt; were to call &lt;code&gt;add-delicious-food!&lt;/code&gt;? What would happen? For example, what if we wrote a macro to add a lot of foods at once?&lt;sup&gt;&lt;a href="#footnote-2" id="footnote-ref-2-1"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-food-combinations!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fst:string&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snd:string&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;for*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;fst-str&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;datum&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fst&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]))]&lt;/span&gt;
               &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snd-str&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;datum&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;snd&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]))])&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;string-append&lt;/span&gt; &lt;span class="n"&gt;fst-str&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="n"&gt;snd-str&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;void&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; should add “fried chicken,” “roasted chicken”, “fried potato,” and “roasted potato”&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-food-combinations!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"fried"&lt;/span&gt; &lt;span class="s2"&gt;"roasted"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"chicken"&lt;/span&gt; &lt;span class="s2"&gt;"potato"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, what do you think executing &lt;code&gt;racket check-food.rkt 'fried chicken'&lt;/code&gt; will do?&lt;/p&gt;&lt;p&gt;Clearly, the program should print &lt;code&gt;fried chicken is a delicious food&lt;/code&gt;, and indeed, many traditional Lisp systems would happily produce such a result. After all, running &lt;code&gt;racket check-food.rkt 'fried chicken'&lt;/code&gt; must load the source code inside &lt;code&gt;check-food.rkt&lt;/code&gt;, expand and compile it, then run the result. While the program is being expanded, the compile-time calls to &lt;code&gt;add-delicious-food!&lt;/code&gt; should add new elements to the &lt;code&gt;delicious-food&lt;/code&gt; set, so when the program is executed, the string &lt;code&gt;"fried chicken"&lt;/code&gt; ought to be in it.&lt;/p&gt;&lt;p&gt;But if you actually try this yourself, you will find that &lt;em&gt;isn’t&lt;/em&gt; what happens. Instead, Racket rejects the program:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
check-food.rkt:12:11: add-delicious-food!: reference to an unbound identifier
  at phase: &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; the transformer environment
  in: add-delicious-food!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Why does Racket reject this program? Well, consider that Racket allows programs to be pre-compiled using &lt;code&gt;raco make&lt;/code&gt;, doing all the work of macroexpansion and compilation to bytecode ahead of time. Subsequent runs of the program will use the pre-compiled version, without having to run all the macros again. This is a problem, since expanding the &lt;code&gt;add-food-combinations!&lt;/code&gt; macro had side-effects that our program depended on!&lt;/p&gt;&lt;p&gt;If Racket allowed the above program, it might do different things depending on whether it was pre-compiled. Running directly from source code might treat &lt;code&gt;'fried chicken'&lt;/code&gt; as a delicious food, while running from pre-compiled bytecode might not. Racket considers this unacceptable, so it disallows the program entirely.&lt;/p&gt;&lt;h3&gt;&lt;a name="preserving-separate-compilation-via-phases"&gt;&lt;/a&gt;Preserving separate compilation via phases&lt;/h3&gt;&lt;p&gt;Hopefully, you are now mostly convinced that the above program is a bad one, but you might have some lingering doubts. You might, for example, wonder if Racket disallows mutable compile-time state entirely. That is not the case—Racket really does allow everything that happens at runtime to happen at compile-time—but it does prevent compile-time and run-time state from ever &lt;em&gt;interacting&lt;/em&gt;. Racket stratifies every program into a compile-time part and a run-time part, and it restricts communication between them to limited, well-defined channels (mainly via expanding to code that does something at run-time).&lt;/p&gt;&lt;p&gt;Racket calls this system of stratification &lt;em&gt;phases&lt;/em&gt;. Code that executes at run-time belongs to the &lt;em&gt;run-time phase&lt;/em&gt;, while code that executes at compile-time (i.e. macros) belongs to the &lt;em&gt;compile-time phase&lt;/em&gt;. When a variable is defined, it is always defined in a particular phase, so bindings declared with &lt;code&gt;define&lt;/code&gt; can only be used at run-time, while bindings declared with &lt;code&gt;define-for-syntax&lt;/code&gt; can only be used at compile-time. Since &lt;code&gt;add-delicious-food!&lt;/code&gt; was declared using &lt;code&gt;define&lt;/code&gt;, it was not allowed (and in fact was not even visible) in the body of the &lt;code&gt;add-food-combinations!&lt;/code&gt; macro.&lt;/p&gt;&lt;p&gt;While the whole macro system could work precisely as just described, such a strict stratification would be incredibly rigid. Since every definition would belong to either run-time or compile-time, but never both, reusing run-time code to implement macros would be impossible. While the example in the previous section might make it seem like that’s a good thing, it very often isn’t: imagine if general-purpose functions like &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; all needed to be written twice!&lt;/p&gt;&lt;p&gt;To avoid this problem, Racket allows modules to be imported at both run-time and compile-time, so long as it’s done explicitly. Writing &lt;code&gt;(require "some-library.rkt")&lt;/code&gt; requires &lt;code&gt;some-library.rkt&lt;/code&gt; for run-time code, but writing &lt;code&gt;(require (for-syntax "some-library.rkt"))&lt;/code&gt; requires it for compile-time code. Requiring a module &lt;code&gt;for-syntax&lt;/code&gt; is sort of like implicitly adjusting all of its uses of &lt;code&gt;define&lt;/code&gt; to be &lt;code&gt;define-for-syntax&lt;/code&gt;, instead, effectively shifting all the code from run-time to compile-time. This kind of operation is therefore known as &lt;em&gt;phase shifting&lt;/em&gt; in Racket terminology.&lt;/p&gt;&lt;p&gt;We can use phase shifting to make the program we wrote compile. If we adjust the &lt;code&gt;require&lt;/code&gt; at the beginning of our program, then we can ensure &lt;code&gt;add-delicious-food!&lt;/code&gt; is visible to both the run-time and compile-time parts of &lt;code&gt;check-food.rkt&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"foods.rkt"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="s2"&gt;"foods.rkt"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now our program compiles. However, if you’ve been following everything carefully, you should be wondering why! According to the last section, sharing state between run-time and compile-time fundamentally can’t work without introducing inconsistencies between uncompiled and pre-compiled code. And that’s true—such a thing would cause all sorts of problems, and Racket doesn’t allow it. If you run the program, whether pre-compiled or not, you’ll find it always does the same thing:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
fried chicken is not delicious.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This seems rather confusing. What happened to the calls to &lt;code&gt;add-delicious-food!&lt;/code&gt; inside our &lt;code&gt;add-food-combinations!&lt;/code&gt; macro? If we stick a &lt;code&gt;printf&lt;/code&gt; inside &lt;code&gt;add-delicious-food!&lt;/code&gt;, we’ll find that it really does get called:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"Registering ~a as a delicious food.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set-add!&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
Registering fried chicken as a delicious food.
Registering fried potato as a delicious food.
Registering roasted chicken as a delicious food.
Registering roasted potato as a delicious food.
Registering pineapple as a delicious food.
Registering sushi as a delicious food.
Registering cheesecake as a delicious food.
fried chicken is not delicious.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And in fact, if we pre-compile &lt;code&gt;check-food.rkt&lt;/code&gt;, we’ll see that the first four registrations appear at compile-time, exactly as we expect:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ raco make check-food.rkt
Registering fried chicken as a delicious food.
Registering fried potato as a delicious food.
Registering roasted chicken as a delicious food.
Registering roasted potato as a delicious food.
$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
Registering pineapple as a delicious food.
Registering sushi as a delicious food.
Registering cheesecake as a delicious food.
fried chicken is not delicious.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The compile-time registrations really are happening, but Racket is automatically restricting the compile-time side-effects so they only apply at compile-time. After compilation has finished, Racket ensures that compile-time side effects are thrown away, and the run-time code starts over with fresh, untouched state. This guarantees consistent behavior, since it becomes impossible to distinguish at run-time whether a module was just compiled on the fly, or if it was pre-compiled long ago (possibly even on someone else’s computer).&lt;/p&gt;&lt;p&gt;This is the essence of the separate compilation guarantee. To summarize:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Run-time and compile-time are distinct &lt;em&gt;phases&lt;/em&gt; of execution, which cannot interact.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Modules can be required at multiple phases via &lt;em&gt;phase shifting&lt;/em&gt;, but their state is kept separate. Each phase gets its own copy of the state.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Ensuring that the state is kept separate ensures predictable program behavior, no matter when the program is compiled.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This summary is a simplification of phases in Racket. The full Racket module system does not have only two phases, since macros can also be &lt;em&gt;used&lt;/em&gt; at compile-time to implement other macros, effectively creating a separate “compile-time” for the compile-time code. Each compile-time pass is isolated to its own phase, creating a finite but arbitrarily large number of distinct program phases (all but one of which occur at compile-time).&lt;/p&gt;&lt;p&gt;Furthermore, the separate compilation guarantee does not just isolate the state of each phase from the state of other phases but also isolates all compile-time state from the compile-time state of other modules. This ensures that compilation is still deterministic even if modules are compiled in a different &lt;em&gt;order&lt;/em&gt;, or if several modules are sometimes compiled individually while other times compiled together all at once.&lt;/p&gt;&lt;p&gt;If you want to learn more, the full details of the module system are described at length in the &lt;a href="https://docs.racket-lang.org/guide/phases.html"&gt;General Phase Levels&lt;/a&gt; section of the Racket Guide, but the abridged summary I’ve described is enough for the purposes of this blog post. If the bulleted list above mostly made sense to you, you’re ready to move on.&lt;/p&gt;&lt;h2 id="section:main-start"&gt;How we’re going to break it&lt;/h2&gt;&lt;p&gt;The separate compilation guarantee is a sturdy opponent, but it is not without weaknesses. Although no API in Racket, safe or unsafe, allows arbitrarily disabling phase separation, a couple features of Racket are already known to allow limited forms of cross-phase communication.&lt;/p&gt;&lt;p&gt;The most significant of these, and the one we’ll be using as our vector of attack, is the logger. Unlike many logging systems, which are exclusively string-oriented, Racket’s logging interface allows structured logging by associating an arbitrary Racket value with each and every log message. Since it is possible to set up listeners within Racket that receive log messages sent to a particular “topic,” the logger can be used as a communication channel to send values between different parts of a program.&lt;/p&gt;&lt;p&gt;The following program illustrates how this works. One thread creates a listener for all log messages on the topic &lt;code&gt;'send-me-a-value&lt;/code&gt; using &lt;code&gt;make-log-receiver&lt;/code&gt;, then uses &lt;code&gt;sync&lt;/code&gt; to block until a value is received. Meanwhile, a second thread sends values through the logger using &lt;code&gt;log-message&lt;/code&gt;. Together, this creates a makeshift buffered, asynchronous channel:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;;; log-comm.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-log-receiver&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;send-me-a-value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;log-message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;send-me-a-value&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sleep&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; wait forever&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;$ racket log-comm.rkt
'#(debug "" 1 send-me-a-value)
'#(debug "" 2 send-me-a-value)
'#(debug "" 3 send-me-a-value)
'#(debug "" 4 send-me-a-value)
^Cuser break
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this program, the value being sent through the logger is just a number, which isn’t very interesting. But the value really can be &lt;em&gt;any&lt;/em&gt; value, even arbitrary closures or mutable data structures. It’s even possible to send a &lt;a href="https://docs.racket-lang.org/guide/concurrency.html#%28part._.Channels%29"&gt;channel&lt;/a&gt; through a logger, which can subsequently be used to communicate directly, without having to abuse the logger.&lt;/p&gt;&lt;p&gt;Generally, this feature of loggers isn’t very useful, since Racket has plenty of features for cross-thread communication. What’s special about the logger, however, is that it is global, and it is cross-phase.&lt;/p&gt;&lt;p&gt;The cross-phase nature of the logger makes some sense. If a Racket program creates a namespace (that is, a fresh environment for dynamic evaluation), then uses it to expand and compile a Racket module, the process of compilation might produce some log messages, and the calling thread might wish to receive them. It wouldn’t be a very useful logging system if log messages during compile-time were always lost. However, this convenience is a loophole in the phase separation system, since it allows values to flow—bidirectionally—between phases.&lt;/p&gt;&lt;p&gt;This concept forms the foundation of our exploit, but it alone is not a new technique, and I did not discover it. However, all existing uses I know of that use the logger for cross-phase communication require control of the parent namespace in which modules are being compiled, which means some code must exist “outside” the actual program. That technique does not work for ordinary programs run directly with &lt;code&gt;racket&lt;/code&gt; or compiled directly with &lt;code&gt;raco make&lt;/code&gt;, so to get there, we’ll need something more clever.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-challenge"&gt;&lt;/a&gt;The challenge&lt;/h3&gt;&lt;p&gt;Our goal, therefore, is to share state between phases &lt;em&gt;without&lt;/em&gt; controlling the compilation namespace. More precisely, we want to be able to create an arbitrary module-level definition that is &lt;em&gt;cross-phase persistent&lt;/em&gt;, which means it will be evaluated once and only once no matter how many times its enclosing module is re-instantiated (i.e. given a fresh, untouched state) at various phases. A phase-shifted &lt;code&gt;require&lt;/code&gt; of the module that contains the definition should share state with an unshifted version of the module, breaking the separate compilation guarantee wide open.&lt;/p&gt;&lt;p&gt;To use the example from the previous section, we should be able to adjust &lt;code&gt;foods.rkt&lt;/code&gt; very slightly…&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;;; foods.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"define-cross-phase.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;add-delicious-food!&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;; share across phases&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mutable-set&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="cm"&gt;#| ... |#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;…and the &lt;code&gt;delicious-foods&lt;/code&gt; mutable state should magically become cross-phase persistent. When running &lt;code&gt;check-food.rkt&lt;/code&gt; from source, we should see the side-effects persisted from the module’s compilation, while running from pre-compiled bytecode should give us the result with compile-time effects discarded.&lt;/p&gt;&lt;p&gt;We already know the logger is going to be part of our exploit, but implementing &lt;code&gt;define/cross-phase&lt;/code&gt; on top of it is more subtle than it might seem. In our previous example that used &lt;code&gt;make-log-receiver&lt;/code&gt;, we had well-defined sender and receiver threads, but who is the “sender” in our multi-phased world? And what exactly is the sender sending?&lt;/p&gt;&lt;p&gt;To answer those questions, allow me to outline the general idea of our approach:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;The first time our &lt;code&gt;foods.rkt&lt;/code&gt; module is instantiated, at any phase, it evaluates the &lt;code&gt;(mutable-set)&lt;/code&gt; expression to produce a new mutable set. It spawns a sender thread that sends this value via the logger to anyone who will listen, and that thread lingers in the background for the remaining duration of the program.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;All subsequent instantiations of &lt;code&gt;foods.rkt&lt;/code&gt; do &lt;em&gt;not&lt;/em&gt; evaluate the &lt;code&gt;(mutable-set)&lt;/code&gt; expression. Instead, they obtain the existing set by creating a log receiver and obtaining the value the sender thread is broadcasting. This ensures that a single value is shared across all instantiations of the module.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;This sounds deceptively simple, but the crux of the problem is how to determine whether &lt;code&gt;foods.rkt&lt;/code&gt; has previously been instantiated or not. Since we can only communicate across phases via the logger, we cannot use any shared state to directly record the first time the module is instantiated. We can listen to a log receiver and wait to see if we get a response, but this introduces a race condition: how long do we wait until giving up and deciding we’re the first instantiation? Worse, what if two threads instantiate the module at the same time, and both threads end up spawning a new sender thread, duplicating the state?&lt;/p&gt;&lt;p&gt;The true challenge, therefore, is to develop a protocol by which we can be &lt;em&gt;certain&lt;/em&gt; we are the first instantiation of a module, without relying on any unspecified behavior, and without introducing any race conditions. This is possible, but it isn’t obvious, and it requires combining loggers with some extra tools available to the Racket programmer.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-key-idea"&gt;&lt;/a&gt;The key idea&lt;/h3&gt;&lt;p&gt;It’s finally time to tackle the key idea at the heart of our exploit: garbage collection. In Racket, garbage collection is an observable effect, since Racket allows attaching finalizers to values via &lt;a href="https://docs.racket-lang.org/reference/willexecutor.html"&gt;wills and executors&lt;/a&gt;. Since a single heap is necessarily shared by the entire VM, behavior happening on other threads (even in other phases) can be indirectly observed by creating a unique value—a “canary”—then sending it to another thread, and waiting to see if it will be garbage collected or not (that is, whether or not the canary “dies”).&lt;/p&gt;&lt;p&gt;Remember that logs and log receivers are effectively buffered, multicast, asynchronous FIFO channels. Since they are buffered, if any thread is already listening to a logger topic when a value is sent, it cannot possibly be garbage collected until that thread either reads it and discards it or the receiver itself is garbage collected. It’s possible to use this mechanism to observe whether or not another thread is already listening on a topic, as the following program demonstrates:&lt;sup&gt;&lt;a href="#footnote-3" id="footnote-ref-3-1"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;;; check-receivers.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-will-executor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;; limit scope of `canary` so we don’t retain a reference&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;canary&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;will-register&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;log-message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync/timeout&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"no receivers for ~v&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"receiver exists for ~v&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;; add a receiver on topic &amp;#39;foo&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-log-receiver&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;$ racket check-receivers.rkt
no receivers for 'bar
receiver exists for 'foo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, this program has some problems. For one, it needs to call &lt;code&gt;collect-garbage&lt;/code&gt; several times to be certain that the canary will be collected if there are no listeners, which can take a second or two, and it also assumes that three calls to &lt;code&gt;collect-garbage&lt;/code&gt; will be enough to collect the canary, though there is no guarantee that will be true.&lt;/p&gt;&lt;p&gt;A bulletproof solution should be both reasonably performant and guaranteed to work. To get there, we have to combine this idea with something more. Here’s the trick: instead of sending the canary alone, send a &lt;a href="https://docs.racket-lang.org/guide/concurrency.html#%28part._.Channels%29"&gt;channel&lt;/a&gt; alongside it. Synchronize on both the canary’s executor &lt;em&gt;and&lt;/em&gt; the channel so that the thread will unblock if either the canary is collected &lt;em&gt;or&lt;/em&gt; the channel is received and sent a value using &lt;code&gt;channel-put&lt;/code&gt;. Have the receiver listen for the channel on a separate thread, and when it receives it, send a value back to unblock the waiting thread as quickly as possible, without needing to rely on a timeout or a particular number of calls to &lt;code&gt;collect-garbage&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Using that idea, we can revise the program:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;;; check-receivers.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-will-executor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;; limit scope of `canary` so we don’t retain a reference&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;canary&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;will-register&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="nb"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;log-message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
                 &lt;span class="c1"&gt;; send the channel + the canary&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector-immutable&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; yield to try to let the receiver thread work&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync/timeout&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;wrap-evt&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;received&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;wrap-evt&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;collected&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;collected&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;received&lt;/span&gt;  &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="c1"&gt;; collect garbage and try again&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;minor&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;major&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"no receivers for ~v&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;printf&lt;/span&gt; &lt;span class="s2"&gt;"receiver exists for ~v&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;; add a receiver on topic &amp;#39;foo&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-log-receiver&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync&lt;/span&gt; &lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;channel-put&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)])))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-receivers&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread-wait&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the program completes almost instantly. For this simple program, the explicit &lt;code&gt;(sleep)&lt;/code&gt; call is effective enough at yielding that, on my machine, &lt;code&gt;(check-receivers 'foo)&lt;/code&gt; returns without ever calling &lt;code&gt;collect-garbage&lt;/code&gt;, and &lt;code&gt;(check-receivers 'bar)&lt;/code&gt; returns after performing a single minor collection.&lt;/p&gt;&lt;p&gt;This is extremely close to a bulletproof solution, but there are two remaining subtle issues:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;There is technically a race condition between the &lt;code&gt;(sync recv)&lt;/code&gt; in the receiver thread and the subsequent &lt;code&gt;channel-put&lt;/code&gt;, since it’s possible for the canary to be received, discarded, and garbage collected before reaching the call to &lt;code&gt;channel-put&lt;/code&gt;, which the sending thread would incorrectly interpret as indicating the topic has no receivers.&lt;/p&gt;&lt;p&gt;To fix that, the receiver thread can send the canary itself back through the channel, which fundamentally has to work, since the value cannot be collected until it has been received by the sending thread, at which point the &lt;code&gt;sync&lt;/code&gt; has already chosen the channel.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;It is possible for the receiver thread to receive the log message and call &lt;code&gt;channel-put&lt;/code&gt;, but for the sending thread to somehow die in the meantime (which cannot be protected against in general in Racket, since &lt;code&gt;thread-kill&lt;/code&gt; immediately and forcibly terminates a thread). If this were to happen, the sending thread would never obtain the value from the channel, blocking the receiving thread indefinitely.&lt;/p&gt;&lt;p&gt;A solution is to spawn a new thread for each &lt;code&gt;channel-put&lt;/code&gt; instead of calling it directly from the receiving thread. Conveniently, this both ensures the receiving thread never gets stuck and avoids resource leaks, since the Racket runtime is smart enough to GC a thread blocked on a channel that has no other references and therefore can never be unblocked.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;With those fixes in place, the program is, to the best of my knowledge, bulletproof. It will always correctly determine whether or not a logger has a listener, with no race conditions or reliance upon unspecified behavior of the Racket runtime. It does, however, make a couple of assumptions.&lt;/p&gt;&lt;p&gt;First, it assumes that the value of &lt;code&gt;(current-logger)&lt;/code&gt; is shared between the threads. It is true that &lt;code&gt;(current-logger)&lt;/code&gt; can be changed, and sometimes is, but it’s usually done via &lt;code&gt;parameterize&lt;/code&gt;, not mutation of the parameter directly. Therefore, this can largely be mitigated by storing the value of &lt;code&gt;(current-logger)&lt;/code&gt; at module instantiation time.&lt;/p&gt;&lt;p&gt;Second, it assumes that no other receivers are listening on the same topic. Technically, even using a unique, uninterned key for the topic is insufficient to ensure that no receivers are listening to it, since a receiver can choose to listen to all topics. However, in practice, it is highly unlikely that any receiver would willfully choose to listen to all topics at the &lt;code&gt;'debug&lt;/code&gt; level, since the receiver would be inundated with enormous amounts of useless information. Even if such a receiver were to be created, it is highly likely that it would dequeue the messages as quickly as possible and discard the accompanying payload, since doing otherwise would cause all messages to be retained in memory, leading to a significant memory leak.&lt;/p&gt;&lt;p&gt;Both these problems can be mitigated by using a logger other than the root logger, which is easy in this example. However, for the purpose of subverting the separate compilation guarantee, we would have no way to share the logger object itself across phases, defeating the whole purpose, so we are forced to use the root logger and hope the above two assumptions remain true (but they usually do).&lt;/p&gt;&lt;h3&gt;&lt;a name="preparing-the-exploit"&gt;&lt;/a&gt;Preparing the exploit&lt;/h3&gt;&lt;p&gt;If you’ve made it here, congratulations! The most difficult part of this blog post is over. All that’s left is the fun part: performing the exploit.&lt;/p&gt;&lt;p&gt;The bulk of our implementation is a slightly adapted version of &lt;code&gt;check-receivers&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;;; define-cross-phase.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;root-logger&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;current-logger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-cross-phase&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="k"&gt;thunk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-log-receiver&lt;/span&gt; &lt;span class="n"&gt;root-logger&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-will-executor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;canary&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;will-register&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;collected&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;log-message&lt;/span&gt; &lt;span class="n"&gt;root-logger&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;debug&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector-immutable&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;==&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="nb"&gt;eq?&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)])))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;execute-evt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;wrap-evt&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="nb"&gt;will-execute&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync/timeout&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="n"&gt;execute-evt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;collect-garbage&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;minor&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;major&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;collected&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;thunk&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sync&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;thread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;channel-put&lt;/span&gt; &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector-immutable&lt;/span&gt; &lt;span class="n"&gt;canary&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)]))))&lt;/span&gt;
     &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are a few minor differences, which I’ll list:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;The most obvious difference is that &lt;code&gt;make-cross-phase&lt;/code&gt; does the work of both checking if a receiver exists—which I’ll call the &lt;em&gt;manager thread&lt;/em&gt;—and spawning it if it doesn’t. If it does end up spawning a manager thread, it evaluates the given thunk to produce a value, which becomes the cross-phase value that will be sent through the channel alongside the canary.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Once the manager thread is created, subsequent calls to &lt;code&gt;make-cross-phase&lt;/code&gt; will receive the value through the channel and return it instead of re-invoking &lt;code&gt;thunk&lt;/code&gt;. This is what ensures the right-hand side of each use of &lt;code&gt;define/cross-phase&lt;/code&gt; is only ever evaluated once.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Since &lt;code&gt;make-cross-phase&lt;/code&gt; needs to create a log receiver if no manager thread exists, it does so immediately, before sending the canary through the logger. This avoids a race condition between multiple threads that are simultaneously competing to become the manager thread, where both threads could send a canary through the logger before either was listening, both canaries would get GC’d, and both threads would spawn a new manager.&lt;sup&gt;&lt;a href="#footnote-4" id="footnote-ref-4-1"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;Creating the receiver before sending the canary avoids this problem, but the thread now needs to receive its own canary and discard it before synchronizing on the channel and executor, since otherwise it will retain a reference to the canary. It’s possible that in between creating the receiver and sending the canary, another thread also sent a canary, so it needs to drop any log messages it finds that don’t include its own canary.&lt;/p&gt;&lt;p&gt;This ends up working out perfectly, since every thread drops all the messages received before the one containing its own canary, but retains all subsequent values. This means that only one thread can ever “win” and become the manager, since the first thread to send a canary is guaranteed to retain all subsequent canaries, yet also guaranteed its canary will be GC’d. Other threads racing to become the manager will remain blocked until the manager thread is created, since its canaries will be retained by the manager-to-be until it dequeues them.&lt;/p&gt;&lt;p&gt;(This is the most subtle part of the process to get right, but conveniently, it mostly just works out without very much code. If you didn’t understand any of the above three paragraphs, it isn’t a big deal.)&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The final piece to this puzzle is to define the &lt;code&gt;define/cross-phase&lt;/code&gt; macro that wraps &lt;code&gt;make-cross-phase&lt;/code&gt;. The macro is actually slightly more involved than just generating a call to &lt;code&gt;make-cross-phase&lt;/code&gt; directly, since we’d like to use an uninterned symbol for the topic instead of an interned one, just to ensure it is unique. Ordinarily, this might seem impossible, since an uninterned symbol is fundamentally a unique value that needs to be communicated across phases, and the whole problem we are solving is creating a communication channel that spans phases. However, Racket actually provides some built-in support for sharing uninterned symbols across phases (plus some other kinds of values, but they must always be immutable). To do this, we need to generate a &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._cross-phase._persistent-modules%29"&gt;cross-phase persistent submodule&lt;/a&gt; that exports an uninterned symbol, then pass that symbol as the topic to &lt;code&gt;make-cross-phase&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;racket/syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;define/cross-phase&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;topic-mod-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generate-temporary&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;cross-phase-topic-key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;topic-mod-name&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;#%kernel&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%declare&lt;/span&gt; &lt;span class="kd"&gt;#:cross-phase-persistent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%provide&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt; &lt;span class="s2"&gt;"cross-phase"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;topic-mod-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-cross-phase&lt;/span&gt; &lt;span class="n"&gt;topic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And that’s really it. We’re done.&lt;/p&gt;&lt;h3&gt;&lt;a name="executing-the-exploit"&gt;&lt;/a&gt;Executing the exploit&lt;/h3&gt;&lt;p&gt;With our implementation of &lt;code&gt;define/cross-phase&lt;/code&gt; in hand, all that’s left to do is run our original &lt;code&gt;check-foods.rkt&lt;/code&gt; program and see what happens:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
set-add!: contract violation:
expected: set?
given: &lt;span class="o"&gt;(&lt;/span&gt;mutable-set &lt;span class="s2"&gt;"fried chicken"&lt;/span&gt; &lt;span class="s2"&gt;"roasted chicken"&lt;/span&gt; &lt;span class="s2"&gt;"roasted potato"&lt;/span&gt; &lt;span class="s2"&gt;"fried potato"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
argument position: 1st
other arguments...:
  x: &lt;span class="s2"&gt;"pineapple"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Well, I don’t know what you expected. Play stupid games, win stupid prizes.&lt;/p&gt;&lt;p&gt;This error actually makes sense, but it belies one reason (of many) why this whole endeavor is probably a bad idea. Although we’ve managed to make our mutable set cross-phase persistent, our references to set operations like &lt;code&gt;set-add!&lt;/code&gt; and &lt;code&gt;set-member?&lt;/code&gt; are not, and every time &lt;code&gt;racket/set&lt;/code&gt; is instantiated in a fresh phase, it creates an entirely new instance of the &lt;code&gt;set&lt;/code&gt; structure type. This means that even though we have a bona fide mutable set, it isn’t actually the type of set that this phase’s &lt;code&gt;set-add!&lt;/code&gt; understands!&lt;/p&gt;&lt;p&gt;Of course, this isn’t a problem that some liberal application of &lt;code&gt;define/cross-phase&lt;/code&gt; can’t solve:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;;; foods.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;"define-cross-phase.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;add-delicious-food!&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;cross:set-member?&lt;/span&gt; &lt;span class="nb"&gt;set-member?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;cross:set-add!&lt;/span&gt; &lt;span class="nb"&gt;set-add!&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/cross-phase&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mutable-set&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delicious-food?&lt;/span&gt; &lt;span class="n"&gt;food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cross:set-member?&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-delicious-food!&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cross:set-add!&lt;/span&gt; &lt;span class="n"&gt;delicious-foods&lt;/span&gt; &lt;span class="n"&gt;new-food&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
fried chicken is a delicious food.
$ raco make check-food.rkt
$ racket check-food.rkt &lt;span class="s1"&gt;&amp;#39;fried chicken&amp;#39;&lt;/span&gt;
fried chicken is not delicious.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And thus we find that another so-called “guarantee” isn’t.&lt;/p&gt;&lt;h2&gt;&lt;a name="reflection"&gt;&lt;/a&gt;Reflection&lt;/h2&gt;&lt;p&gt;Now comes the time in the blog post when I have to step back and think about what I’ve done. Have mercy.&lt;/p&gt;&lt;p&gt;Everything in this blog post is a terrible idea. No, you should not use loggers for anything that isn’t logging, you shouldn’t use wills and executors for critical control flow, and obviously you should absolutely not intentionally break one of the most helpful guarantees the Racket module system affords you.&lt;/p&gt;&lt;p&gt;But I thought it was fun to do all that, anyway.&lt;/p&gt;&lt;p&gt;The meaningful takeaways from this blog post aren’t that the separate compilation guarantee can be broken, nor that any of the particular techniques I used hold, but that&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;ensuring non-trivial guarantees is really hard,&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;despite that, the separate compilation guarantee is really, really hard to break,&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;the separate compilation guarantee is good, and you should appreciate the luxury it affords you while writing Racket macros,&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;avoiding races in a concurrent environment can be extremely subtle,&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;and Racket is totally &lt;em&gt;awesome&lt;/em&gt; for giving me this much rope to hang myself with.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;If you want to hang yourself with Racket, too, &lt;a href="https://gist.github.com/lexi-lambda/f173a84fc9727977bcea657b3bb0cd4f"&gt;runnable code from this blog post is available here&lt;/a&gt;.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;This isn’t &lt;em&gt;strictly&lt;/em&gt; true, since Racket provides sandboxing mechanisms that can compile and execute untrusted code without file system or network access, but this is not the default compilation mode. Usually, it doesn’t matter nearly as much as it might sound: most of the time, if you’re compiling untrusted code, you’re also going to run it, and running untrusted code can do all those things, anyway. &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-2"&gt;&lt;p&gt;This is actually a &lt;em&gt;terrible&lt;/em&gt; use case for a macro, since an ordinary function would do just fine, but I’m simplifying a little to keep the example small. &lt;a href="#footnote-ref-2-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-3"&gt;&lt;p&gt;Racket actually provides this functionality directly via the &lt;code&gt;log-level?&lt;/code&gt; procedure. However, since &lt;code&gt;log-level?&lt;/code&gt; provides no way to determine how &lt;em&gt;many&lt;/em&gt; receivers are listening to a topic, using it to guard against creating a receiver is vulnerable to a race condition that the garbage collection-based approach can avoid, as is discussed later. Furthermore, the GC technique is more likely to be resilient to nosy log receivers listening on all topics at the &lt;code&gt;'debug&lt;/code&gt; level, since they will almost certainly dequeue and discard the value quickly (as otherwise they would leak large quantities of memory). &lt;a href="#footnote-ref-3-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-4"&gt;&lt;p&gt;This race is the one that makes using &lt;code&gt;log-level?&lt;/code&gt; untenable, since the receiver needs to be created before the topic is checked for listeners to avoid the race, which can’t be done with &lt;code&gt;log-level?&lt;/code&gt; (since it would always return &lt;code&gt;#t&lt;/code&gt;). &lt;a href="#footnote-ref-4-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Macroexpand anywhere with local-apply-transformer!</title><link>https://lexi-lambda.github.io/blog/2018/10/06/macroexpand-anywhere-with-local-apply-transformer/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2018/10/06/macroexpand-anywhere-with-local-apply-transformer/</guid><pubDate>06 Oct 2018</pubDate><description>&lt;article&gt;&lt;p&gt;Racket programmers are accustomed to the language’s incredible capacity for extension and customization. Writing useful macros that do complicated things is easy, and it’s simple to add new syntactic forms to meet domain-specific needs. However, it doesn’t take long before many budding macrologists bump into the realization that only &lt;em&gt;certain positions&lt;/em&gt; in Racket code are subject to macroexpansion.&lt;/p&gt;&lt;p&gt;To illustrate, consider a macro that provides a Clojure-style &lt;code&gt;let&lt;/code&gt; form:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-let&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;body:expr&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This can be used anywhere an expression is expected, and it does as one would expect:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-let&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, a novice macro programmer might realize that &lt;code&gt;clj-let&lt;/code&gt; really only modifies the syntax of &lt;em&gt;binding pairs&lt;/em&gt; for a &lt;code&gt;let&lt;/code&gt; form. Therefore, could one define a macro that only adjusts the binding pairs of some existing &lt;code&gt;let&lt;/code&gt; form instead of expanding to an entire &lt;code&gt;let&lt;/code&gt;? That is, could one write the above example like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
         &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The answer is &lt;em&gt;no&lt;/em&gt;: the binding pairs of a &lt;code&gt;let&lt;/code&gt; form are not subject to macroexpansion, so the above attempt fails with a syntax error. In this blog post, we will examine the reasons behind this limitation, then explain how to overcome it using a solution that allows macroexpansion &lt;em&gt;anywhere&lt;/em&gt; in a Racket program.&lt;/p&gt;&lt;h2&gt;&lt;a name="why-only-some-positions-are-subject-to-macroexpansion"&gt;&lt;/a&gt;Why only some positions are subject to macroexpansion&lt;/h2&gt;&lt;p&gt;To understand &lt;em&gt;why&lt;/em&gt; the macroexpander refuses to touch certain positions in a program, we must first understand how the macro system operates. In Racket, a macro is defined as a compile-time function associated with a particular binding, and macros are given complete control over the syntax trees they are surrounded with. If we define a macro &lt;em&gt;&lt;code&gt;mac&lt;/code&gt;&lt;/em&gt;, then we write the expression &lt;code&gt;(&lt;em&gt;mac&lt;/em&gt; &lt;em&gt;form&lt;/em&gt;)&lt;/code&gt;, &lt;em&gt;&lt;code&gt;form&lt;/code&gt;&lt;/em&gt; is provided as-is to &lt;em&gt;&lt;code&gt;mac&lt;/code&gt;&lt;/em&gt; as a syntax object. Its structure can be anything at all, since &lt;em&gt;&lt;code&gt;mac&lt;/code&gt;&lt;/em&gt; can be an arbitrary Racket function, and that function can use &lt;em&gt;&lt;code&gt;form&lt;/code&gt;&lt;/em&gt; however it pleases.&lt;/p&gt;&lt;p&gt;To give a concrete illustration, consider a macro that binds some identifiers to symbols in a local scope:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;let-symbols&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;let-symbols&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;goodbye&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;goodbye&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;hello&lt;/span&gt; &lt;span class="ss"&gt;goodbye&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It isn’t the most exciting macro in the world, but it illustrates a key point: the first subform to &lt;code&gt;let-symbols&lt;/code&gt; is a list of identifiers that are eventually put in &lt;em&gt;binding&lt;/em&gt; position. This means that &lt;code&gt;hello&lt;/code&gt; and &lt;code&gt;goodbye&lt;/code&gt; are bindings, not uses, and such bindings shadow any existing bindings that might have been in scope:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;let-symbols&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This might not seem very interesting, but it’s critical to understand, since it means that the expander &lt;em&gt;can’t know&lt;/em&gt; which sub-pieces of a use of &lt;code&gt;let-symbols&lt;/code&gt; will eventually be expressions themselves until it expands the macro and discovers it produces a &lt;code&gt;let&lt;/code&gt; form, so it can’t know where it’s safe to perform macroexpansion. To make this more explicit, imagine we define a macro under some name, then try and use that name with our &lt;code&gt;let-symbols&lt;/code&gt; macro:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;let-symbols&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;goodbye&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What should the above program do? If we treat the first use of &lt;code&gt;hello&lt;/code&gt; in the &lt;code&gt;let-symbols&lt;/code&gt; form as a macro application, then &lt;code&gt;(hello goodbye)&lt;/code&gt; should be transformed into &lt;code&gt;(goodbye)&lt;/code&gt;, and the use of &lt;code&gt;hello&lt;/code&gt; in the body should be a syntax error. But if the first use of &lt;code&gt;hello&lt;/code&gt; was instead intended to be a binder, then it should shadow the &lt;code&gt;hello&lt;/code&gt; definition above, and the output of the program should be &lt;code&gt;'hello&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;To avoid the chaos that would ensue if defining a macro could completely break local reasoning about other macros, Racket chooses the second option, and the program produces &lt;code&gt;'hello&lt;/code&gt;. The macroexpander has no way of knowing &lt;em&gt;how&lt;/em&gt; each macro will inspect its constituent pieces, so it avoids touching anything until the macro expands. After it discovers the &lt;code&gt;let&lt;/code&gt; form in the expansion of &lt;code&gt;let-symbols&lt;/code&gt;, it can safely determine that the body expressions are, indeed, expressions, and it can recursively expand any macros they contain. To put things another way, a macro’s sub-forms are never expanded before the macro itself is expanded, only after.&lt;/p&gt;&lt;h2&gt;&lt;a name="forcing-sub-form-expansion"&gt;&lt;/a&gt;Forcing sub-form expansion&lt;/h2&gt;&lt;p&gt;The above section explains why the expander must operate as it does, but it’s a little bit unsatisfying. What if we write a macro where we &lt;em&gt;want&lt;/em&gt; certain sub-forms to be expanded before they are passed to us? Fortunately, the Racket macro system provides an API to handle this use case, too.&lt;/p&gt;&lt;p&gt;It is true that the Racket macro system never &lt;em&gt;automatically&lt;/em&gt; expands sub-forms before outer forms are expanded, but macro transformers can explicitly op-in to recursive expansion via the &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._local-expand%29%29"&gt;&lt;code&gt;local-expand&lt;/code&gt;&lt;/a&gt; function. This function effectively yields control back to the expander to expand some arbitrary piece of syntax as an expression, and when it returns, the macro transformer can inspect the expanded expression however it wishes. In theory, this can be used to implement extensible macros that allow macroexpansion in locations other than expression position.&lt;/p&gt;&lt;p&gt;To give an example of such a macro, consider the Racket &lt;code&gt;match&lt;/code&gt; form, which implements an expressive pattern-matcher as a macro. One of the most interesting qualities of Racket’s &lt;code&gt;match&lt;/code&gt; macro is that its pattern language is user-extensible, essentially allowing pattern-level macros. For example, a user might find they frequently match against natural numbers, and they wish to be able to write &lt;code&gt;(nat n)&lt;/code&gt; as a shorthand for &lt;code&gt;(? exact-nonnegative-integer? n)&lt;/code&gt;. Fortunately, this is easy using &lt;code&gt;define-match-expander&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-match-expander&lt;/span&gt; &lt;span class="n"&gt;nat&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;pat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;?&lt;/span&gt; &lt;span class="nb"&gt;exact-nonnegative-integer?&lt;/span&gt; &lt;span class="n"&gt;pat&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;-5&lt;/span&gt; &lt;span class="mi"&gt;-2&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;-7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nat&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Clearly, &lt;code&gt;match&lt;/code&gt; is somehow expanding the &lt;code&gt;nat&lt;/code&gt; match expander as a part of its expansion. Is it using &lt;code&gt;local-expand&lt;/code&gt;?&lt;/p&gt;&lt;p&gt;Well, no. While &lt;a href="/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/"&gt;a previous blog post of mine&lt;/a&gt; has illustrated that it is possible to do such a thing with &lt;code&gt;local-expand&lt;/code&gt; via some clever trickery, &lt;code&gt;local-expand&lt;/code&gt; is really designed to expand &lt;em&gt;expressions&lt;/em&gt;. This is a problem, since &lt;code&gt;(nat n)&lt;/code&gt; is not an expression, it’s a pattern: it will expand into &lt;code&gt;(? exact-nonnegative-integer? n)&lt;/code&gt;, which will lead to a syntax error, since &lt;code&gt;?&lt;/code&gt; is not bound in the world of expressions. Instead, for a long while, &lt;code&gt;match&lt;/code&gt; and forms like it have emulated how the expander performs macroexpansion in ad-hoc ways. Fortunately, as of Racket v7.0, the new &lt;a href="http://docs.racket-lang.org/syntax/transformer-helpers.html#%28def._%28%28lib._syntax%2Fapply-transformer..rkt%29._local-apply-transformer%29%29"&gt;&lt;code&gt;local-apply-transformer&lt;/code&gt;&lt;/a&gt; API provides a way to invoke recursive macroexpansion in a consistent way, and it doesn’t assume that what’s being expanded is an expression.&lt;/p&gt;&lt;h3&gt;&lt;a name="a-closer-look-at-local-apply-transformer"&gt;&lt;/a&gt;A closer look at &lt;code&gt;local-apply-transformer&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;If &lt;code&gt;local-apply-transformer&lt;/code&gt; is the answer, what does it actually do? Well, &lt;code&gt;local-apply-transformer&lt;/code&gt; allows explicitly invoking a transformer function on some piece of syntax and retrieving the result. In other words, &lt;code&gt;local-apply-transformer&lt;/code&gt; allows expanding an arbitrary macro, but since it doesn’t make any assumptions about what the output will be, it only expands it &lt;em&gt;once&lt;/em&gt;: just a single step of macro transformation.&lt;/p&gt;&lt;p&gt;To illustrate, we can write a macro that uses &lt;code&gt;local-apply-transformer&lt;/code&gt; to invoke a transformer function and preserve the result using &lt;code&gt;quote-syntax&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/apply-transformer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-for-syntax&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-apply-transformer&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote-syntax&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When we use &lt;code&gt;mac&lt;/code&gt;, our &lt;code&gt;flip&lt;/code&gt; function will be applied, as a macro, to the syntax object we provide:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;#&amp;lt;syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Alright, so this works, but it raises some questions. Why is &lt;code&gt;flip&lt;/code&gt; defined as a function at phase 1 (using &lt;code&gt;define-for-syntax&lt;/code&gt;) instead of as a macro (using &lt;code&gt;define-syntax&lt;/code&gt;)? What’s the deal with the &lt;code&gt;'expression&lt;/code&gt; argument to &lt;code&gt;local-apply-transformer&lt;/code&gt; given that &lt;code&gt;local-apply-transformer&lt;/code&gt; is supposedly decoupled from expression expansion? And finally, how is this any different from just calling our &lt;code&gt;flip&lt;/code&gt; function on the syntax object directly by writing &lt;code&gt;(flip #'(([x 1]) let x))&lt;/code&gt;?&lt;/p&gt;&lt;p&gt;Let’s start with the first of those questions: why is &lt;code&gt;flip&lt;/code&gt; defined as a function rather than as a macro? Well, &lt;code&gt;local-apply-transformer&lt;/code&gt; is a fairly low-level operation: remember, it doesn’t assume &lt;em&gt;anything&lt;/em&gt; about the argument it’s given! Therefore, it doesn’t take an expression containing a macro and expand it based on its structure, it needs to be explicitly provided the macro transformer function to apply. In practice, this might not seem very useful, since presumably we want to write our macros as macros, not as phase 1 functions. Fortunately, it’s possible to look up the function associated with a macro binding using the &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-value%29%29"&gt;&lt;code&gt;syntax-local-value&lt;/code&gt;&lt;/a&gt; function, so if we use that, we can define &lt;code&gt;flip&lt;/code&gt; using &lt;code&gt;define-syntax&lt;/code&gt; as usual:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-apply-transformer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                         &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote-syntax&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now for the next question: what is the meaning of the &lt;code&gt;'expression&lt;/code&gt; argument? This one is more of a historical artifact than anything else: when the expander applies a macro transformer, it does it in a “context”, which is accessible using the &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-context%29%29"&gt;&lt;code&gt;syntax-local-context&lt;/code&gt;&lt;/a&gt; function. This context can be one of a predefined enumeration of cases, including &lt;code&gt;'expression&lt;/code&gt;, &lt;code&gt;'top-level&lt;/code&gt;, &lt;code&gt;'module&lt;/code&gt;, &lt;code&gt;'module-begin&lt;/code&gt;, or a list representing a definition context. Whether or not any of those actually apply to our use case, we still have to pick one, but aside from how they affect the value returned by &lt;code&gt;syntax-local-context&lt;/code&gt; (which some macros inspect), the value we choose is largely irrelevant. Using &lt;code&gt;'expression&lt;/code&gt; will do, even if it’s a bit of a lie.&lt;/p&gt;&lt;p&gt;Finally, how does any of this differ from just applying the function we get directly? Well, the critical answer is all about &lt;em&gt;hygiene&lt;/em&gt;. Racket’s macro system is hygienic, which, among other things, ensures bindings defined with the same name in different places do not unintentionally conflict. Racket’s hygiene mechanism is implemented in the macroexpander, when macro transformers are applied. If we just applied the &lt;code&gt;flip&lt;/code&gt; transformer procedure to a syntax object directly, we would circumvent this hygiene mechanism, potentially causing all sorts of problems. By using &lt;code&gt;local-apply-transformer&lt;/code&gt;, we ensure hygiene is preserved.&lt;/p&gt;&lt;p&gt;There is one small problem left with our program, however. Can you spot it? The key is to consider what would happen if we used &lt;code&gt;flip&lt;/code&gt; as an ordinary macro, without using &lt;code&gt;local-apply-transformer&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;let:&lt;/span&gt; &lt;span class="n"&gt;bad&lt;/span&gt; &lt;span class="k"&gt;syntax&lt;/span&gt;
  &lt;span class="n"&gt;in:&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What happened? Well, remember that when a macro in Racket is used, it receives the whole use site as a syntax object: in this case, &lt;code&gt;#'(flip (([x 1]) let x))&lt;/code&gt;. This means that &lt;code&gt;flip&lt;/code&gt; ought to be written to parse its argument slightly differently:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Indeed, now that we’ve properly restructured the macro, we can easily switch to using the convenient &lt;code&gt;define-simple-macro&lt;/code&gt; shorthand:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This means we also need to update our definition of &lt;code&gt;mac&lt;/code&gt; to provide the full syntax object the expander would:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-apply-transformer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                                         &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote-syntax&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This might seem redundant, but remember, &lt;code&gt;local-apply-transformer&lt;/code&gt; is very low-level! While the convention that &lt;code&gt;(&lt;em&gt;mac&lt;/em&gt; . _)&lt;/code&gt; is the syntax for a macro transformation might seem obvious, &lt;code&gt;local-apply-transformer&lt;/code&gt; makes no assumptions. It just does what we tell it to do.&lt;/p&gt;&lt;h3&gt;&lt;a name="applying-local-apply-transformer"&gt;&lt;/a&gt;Applying &lt;code&gt;local-apply-transformer&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;So what does &lt;code&gt;local-apply-transformer&lt;/code&gt; have to do with the problem at the beginning of this blog post? Well, as it happens, we can use &lt;code&gt;local-apply-transformer&lt;/code&gt; to implement a macro that allows expansion &lt;em&gt;anywhere&lt;/em&gt; using some simple tricks. While it’s true that we cannot magically divine which locations ought to be expanded, what we &lt;em&gt;can&lt;/em&gt; do is explicitly annotate which places to expand.&lt;/p&gt;&lt;p&gt;To do this, we will implement a macro, &lt;code&gt;expand-inside&lt;/code&gt;, that looks for subforms annotated with a special &lt;code&gt;$expand&lt;/code&gt; identifier and performs macro transformation on those locations before proceeding with ordinary macroexpansion. Using the &lt;code&gt;clj-binding-pairs&lt;/code&gt; example from the beginning of this blog post, our solution to that problem will look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-inside&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
           &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Put another way, &lt;code&gt;expand-inside&lt;/code&gt; will force eager expansion on any subform surrounded with an &lt;code&gt;$expand&lt;/code&gt; annotation.&lt;/p&gt;&lt;p&gt;We’ll start by defining the &lt;code&gt;$expand&lt;/code&gt; binding itself. This binding won’t mean anything at all outside of &lt;code&gt;expand-inside&lt;/code&gt;, but we’d like it to be a unique binding so that users can rename it (using, &lt;code&gt;rename-in&lt;/code&gt;, for example) if they wish. To do this, we’ll use the usual trick of defining it as a macro that always produces an error if it’s ever used:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="s2"&gt;"illegal outside an ‘expand-inside’ form"&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, we’ll implement a syntax class that will form the bulk of our implementation of &lt;code&gt;expand-inside&lt;/code&gt;. Since we need to find uses of &lt;code&gt;$expand&lt;/code&gt; that might be deeply-nested inside the syntax object provided to &lt;code&gt;expand-inside&lt;/code&gt;, we need to recursively look through the syntax object, find any instances of &lt;code&gt;$expand&lt;/code&gt;, and put it all back together once we’re done. This can be done relatively cleanly using a recursive syntax class:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;do-expand-inside&lt;/span&gt;
    &lt;span class="kd"&gt;#:literals&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="n"&gt;$expand&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;:do-expand-inside&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;do-$expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a:do-expand-inside&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;b:do-expand-inside&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;reassembled&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax?&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="n"&gt;reassembled&lt;/span&gt;
                                  &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="n"&gt;reassembled&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are some tricky details to get right in the reassembly of pairs, since syntax lists are actually composed of ordinary pairs rather than syntax pairs, but ultimately, the code for walking a syntax object is small. The key case of this syntax class is the call to &lt;code&gt;do-$expand&lt;/code&gt; in the first clause, which we have not yet defined. This function will actually handle performing the expansion by invoking &lt;code&gt;local-apply-transformer&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;do-$expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
      &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="n"&gt;trans&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trans&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)}})&lt;/span&gt;
       &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;trans&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;disjoin&lt;/span&gt; &lt;span class="nb"&gt;procedure?&lt;/span&gt; &lt;span class="nb"&gt;set!-transformer?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                               &lt;span class="s2"&gt;"syntax transformer"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-apply-transformer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;trans.value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;
                                &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)])))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This uses the handy &lt;code&gt;static&lt;/code&gt; syntax class that comes with &lt;code&gt;syntax/parse&lt;/code&gt;, which implicitly handles the call to &lt;code&gt;syntax-local-value&lt;/code&gt; and produces a nice error message if the value returned does not match a predicate. All we have to do is apply the transformer value bound to the &lt;code&gt;trans.value&lt;/code&gt; attribute using &lt;code&gt;local-apply-transformer&lt;/code&gt;, and now the &lt;code&gt;expand-macro&lt;/code&gt; can be written in just a couple lines of code:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;expand-inside&lt;/span&gt;
  &lt;span class="kd"&gt;#:track-literals&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;form:do-expand-inside&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;form.expansion&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(Using the &lt;code&gt;#:track-literals&lt;/code&gt; option, also new in Racket v7.0, ensures that Check Syntax will be able to recognize the uses of &lt;code&gt;$expand&lt;/code&gt; that disappear from after &lt;code&gt;expand-inside&lt;/code&gt; is expanded.)&lt;/p&gt;&lt;p&gt;Putting everything together, our example from above really works:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-inside&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;$expand&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clj-binding-pairs&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
           &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That’s it. All told, the entire implementation is only about 30 lines of code. For a full, compilable, working example, see &lt;a href="https://gist.github.com/lexi-lambda/65d69043023b519694f50dfca2dc7d33"&gt;this gist&lt;/a&gt;.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Custom core forms in Racket, part II: generalizing to arbitrary expressions and internal definitions</title><link>https://lexi-lambda.github.io/blog/2018/09/13/custom-core-forms-in-racket-part-ii-generalizing-to-arbitrary-expressions-and-internal-definitions/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2018/09/13/custom-core-forms-in-racket-part-ii-generalizing-to-arbitrary-expressions-and-internal-definitions/</guid><pubDate>13 Sep 2018</pubDate><description>&lt;article&gt;&lt;p&gt;In my &lt;a href="/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/"&gt;previous blog post&lt;/a&gt;, I covered the process involved in creating a small language with a custom set of core forms. Specifically, it discussed what was necessary to create Hackett’s type language, which involved expanding to custom expressions. While somewhat involved, Hackett’s type language was actually a relatively simple example to use, since it only made use of a subset of the linguistic features Racket supports. In this blog post, I’ll demonstrate how that same technique can be generalized to support runtime bindings and internal definitions, two key concepts useful if intending to develop a more featureful language than Hackett’s intentionally-restrictive type system.&lt;/p&gt;&lt;h2&gt;&lt;a name="what-are-internal-definitions"&gt;&lt;/a&gt;What are internal definitions?&lt;/h2&gt;&lt;p&gt;This blog post is going to be largely focused on how to properly implement a form that handles the expansion of &lt;em&gt;internal definitions&lt;/em&gt; in Racket. This is a tricky topic to get right, but before we can discuss internal definitions, we have to establish what definitions themselves are and how they relate to other binding forms.&lt;/p&gt;&lt;p&gt;In a traditional Lisp, there are two kinds of bindings: top-level bindings and local bindings. In Scheme and its descendants, this distinction is characterized by two different binding forms, &lt;code&gt;define&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;. To a first approximation, &lt;code&gt;define&lt;/code&gt; is used for defining top-level, global bindings, and it resembles variable definitions in many mainstream languages in the sense that definitions using &lt;code&gt;define&lt;/code&gt; are not really expressions. They don’t produce a value, they define a new binding. Definitions written with &lt;code&gt;define&lt;/code&gt; look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="s2"&gt;"hello"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Each definition is made up of two parts: the &lt;em&gt;binding identifier&lt;/em&gt;, in this case &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and the &lt;em&gt;right hand side&lt;/em&gt;, or RHS for short. Each RHS is a single expression that will be evaluated and used as the value for the introduced binding.&lt;/p&gt;&lt;p&gt;In Scheme and Racket, &lt;code&gt;define&lt;/code&gt; also supports a shorthand form for defining functions in a natural syntax without the explicit need to write &lt;code&gt;lambda&lt;/code&gt;, which looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, this is just syntactic sugar. The above form is really just a macro for the following equivalent, expanded version:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since we only care about fully-expanded programs, we’ll focus exclusively on the expanded version of &lt;code&gt;define&lt;/code&gt; in this blog post, since if we handle that, we’ll also handle the function shorthand’s expansion.&lt;/p&gt;&lt;p&gt;In contrast to &lt;code&gt;define&lt;/code&gt;, there is also &lt;code&gt;let&lt;/code&gt;, which has a rather different shape. A &lt;code&gt;let&lt;/code&gt; form &lt;em&gt;is&lt;/em&gt; an expression, and it creates local bindings in a delimited scope:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The binding clauses of a &lt;code&gt;let&lt;/code&gt; expression are known as the &lt;em&gt;binding pairs&lt;/em&gt;, and the sequence of expressions afterwards are known as the &lt;em&gt;body&lt;/em&gt; of the &lt;code&gt;let&lt;/code&gt;. Each binding pair consists of a binding identifier and a RHS, just like a top-level definition created with &lt;code&gt;define&lt;/code&gt;, but while &lt;code&gt;define&lt;/code&gt; is a standalone form, the binding pairs cannot meaningfully exist outside of a &lt;code&gt;let&lt;/code&gt;—they are recognized as part of the grammar of the &lt;code&gt;let&lt;/code&gt; form itself.&lt;/p&gt;&lt;p&gt;Like other Lisps, Racket distinguishes between top-level—or, more precisely, &lt;em&gt;module-level&lt;/em&gt;—bindings and local bindings. A module-level binding can be exported using &lt;code&gt;provide&lt;/code&gt;, which will allow other modules to access the binding by importing the module with &lt;code&gt;require&lt;/code&gt;. Such definitions are treated specially by the macroexpander, compiler, and runtime system alike. There is a pervasive, meaningful difference between module-level definitions and local definitions besides simply scope.&lt;/p&gt;&lt;p&gt;I am making an effort to make this as clear as possible before discussing internal definitions because without it, the following point can be rather confusing: internal definitions are written using &lt;code&gt;define&lt;/code&gt;, but they are local bindings, &lt;em&gt;not&lt;/em&gt; module-level ones! In Racket, &lt;code&gt;define&lt;/code&gt; is allowed to appear in the body of virtually all block forms like &lt;code&gt;let&lt;/code&gt;, so the following is a legal program:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This program is equivalent to the one expressed using &lt;code&gt;let&lt;/code&gt;. In fact, when the Racket macroexpander expands these local uses of &lt;code&gt;define&lt;/code&gt;, it actually translates them into uses of &lt;code&gt;letrec&lt;/code&gt;. After expanding the above expression, it would look closer to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
           &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this sense, &lt;code&gt;define&lt;/code&gt; is a form with a double life in Racket. When used at the module level, it creates module-level definitions, which remain in a fully-expanded program and can be imported by other modules. When used inside local blocks, it creates internal definitions, which do not remain in fully expanded programs, since they are translated into recursive local binding forms.&lt;/p&gt;&lt;p&gt;In this blog post, we will ignore module-level definitions. Like in the previous blog post, we will focus exclusively on expanding expressions, not whole modules. However, we will extend our language to allow internal definitions inside local binding forms, and we will translate them into &lt;code&gt;letrec&lt;/code&gt; forms in the same way as the Racket macroexpander.&lt;/p&gt;&lt;h2&gt;&lt;a name="revisiting-and-generalizing-the-expression-expander"&gt;&lt;/a&gt;Revisiting and generalizing the expression expander&lt;/h2&gt;&lt;p&gt;In the previous blog post, our expander expanded types, which were essentially expressions from the perspective of the Racket macroexpander. We wrote a syntax class that handled the parsing of a restricted type grammar that disallowed most Racket-level expression forms, like &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;#%plain-lambda&lt;/code&gt;, and &lt;code&gt;quote&lt;/code&gt;. After all, Hackett is not dependently-typed, and it disallows explicit type abstraction to preserve type inference, so it would be a very bad thing if we allowed &lt;code&gt;if&lt;/code&gt; or explicit lambda abstraction to appear in our types. For this blog post, however, we will restructure the type expander to handle the full grammar of expressions permitted by Racket.&lt;/p&gt;&lt;p&gt;While the syntax class approach used in the previous blog post was cute, this blog post will use ordinary functions defined at phase 1 instead of syntax classes. In practice, this provides superior error reporting, since it reports syntax errors in terms of the form that went wrong, not the form prior to expansion. Since we can still use &lt;code&gt;syntax-parse&lt;/code&gt; to parse the arguments to these functions, we don’t lose any expressive power in the expression of our pattern language.&lt;/p&gt;&lt;p&gt;To start, we’ll extract the call to &lt;code&gt;local-expand&lt;/code&gt; into its own function. This corresponds to the &lt;code&gt;type&lt;/code&gt; syntax class from the previous blog post, but we’ll use phase 1 parameters to avoid threading so many explicit function arguments around:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-parameter&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;current-stop-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-parameter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-parameter&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-stop-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Due to the way &lt;code&gt;local-expand&lt;/code&gt; implicitly extends the stop list, as discussed in the previous blog post, we can initialize the stop list to a list containing just &lt;code&gt;define-values&lt;/code&gt; and &lt;code&gt;define-syntaxes&lt;/code&gt;, and the other forms we care about will be included automatically.&lt;/p&gt;&lt;p&gt;Next, we’ll use this function to implement a &lt;code&gt;expand-expression&lt;/code&gt; function, which will emulate the way the expander expands a single expression, as the name implies. We’ll ignore any custom core forms for now, so we’ll just focus exclusively on the Racket core forms.&lt;/p&gt;&lt;p&gt;A few of Racket’s core forms are not actually subject to any expansion at all, and they expand to themselves. These forms are &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;quote-syntax&lt;/code&gt;, and &lt;code&gt;#%variable-reference&lt;/code&gt;. Additionally, &lt;code&gt;#%top&lt;/code&gt; is not something useful to handle ourselves, since it involves no recursive expansion, so we’ll treat it as if it expands to itself as well and allow the expander to raise any unbound identifier errors it produces. Here’s what the &lt;code&gt;expand-expression&lt;/code&gt; function looks like when exclusively handling these things:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="ss"&gt;quote-syntax&lt;/span&gt; &lt;span class="k"&gt;#%top&lt;/span&gt; &lt;span class="k"&gt;#%variable-reference&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another set of Racket core forms are simple expressions which contain subforms, all of which are themselves expressions. These forms include things like &lt;code&gt;#%expression&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, and &lt;code&gt;if&lt;/code&gt;, and they can be expanded recursively. We’ll add another clause to handle these, which can be written with a straightforward recursive call to &lt;code&gt;expand-expression&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="k"&gt;#%expression&lt;/span&gt; &lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="k"&gt;begin0&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;with-continuation-mark&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another easy form to handle is &lt;code&gt;set!&lt;/code&gt;, since it also requires simple recursive expansion, but it can’t be handled in the same way as the above forms since one of its subforms (the variable to mutate) should not be expanded. It needs another small clause:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:set!&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The other expressions are harder, since they’re all the binding forms. Fully-expanded Racket code has four local binding forms: &lt;code&gt;#%plain-lambda&lt;/code&gt;, &lt;code&gt;case-lambda&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, and &lt;code&gt;letrec-values&lt;/code&gt;. Additionally, as discussed in the previous blog post, &lt;code&gt;local-expand&lt;/code&gt; can also produce &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; forms produced by local syntax bindings. In the type expander, we completely disallowed runtime bindings from appearing in the resulting program, so we completely removed &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; in our expansion, but in the case of handling arbitrary Racket programs, we actually want to leave a &lt;code&gt;letrec-values&lt;/code&gt; form behind to hold any runtime bindings (i.e. the &lt;code&gt;values&lt;/code&gt; part of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;).&lt;/p&gt;&lt;p&gt;We’ll start with &lt;code&gt;#%plain-lambda&lt;/code&gt;, which is the simplest of all the five aforementioned binding forms. It binds a sequence of identifiers at runtime, and they are in scope within the body of the lambda expression. Just as we created and used an internal-definition context to hold the bindings of a &lt;code&gt;letrec-syntax+values&lt;/code&gt; form in the previous blog post, we’ll do the same for Racket’s other binding forms as well:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:#%plain-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, the above handling of &lt;code&gt;#%plain-lambda&lt;/code&gt; isn’t &lt;em&gt;quite&lt;/em&gt; right, since the argument list can also include a “rest argument” binding in addition to a sequence of positional arguments. To accommodate this, we can introduce a simple syntax class that handles the different permutations:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;plain-formals&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"formals"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id*:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;id**:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;id*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;id**&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use this to adjust &lt;code&gt;#%plain-lambda&lt;/code&gt; to handle rest arguments:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:#%plain-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;formals:plain-formals&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;formals.id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;formals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, we’ll handle &lt;code&gt;case-lambda&lt;/code&gt;. As it turns out, expanding &lt;code&gt;case-lambda&lt;/code&gt; is almost exactly the same as expanding &lt;code&gt;#%plain-lambda&lt;/code&gt;, except that it has multiple clauses. Since each clause is expanded identically to the body of a &lt;code&gt;#%plain-lambda&lt;/code&gt;, and it even has the same shape, the clauses can be extracted into a separate syntax class to share code between the two forms:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;lambda-clause&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;formals:plain-formals&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;formals.id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;formals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, both &lt;code&gt;#%plain-lambda&lt;/code&gt; and &lt;code&gt;case-lambda&lt;/code&gt; can be handled in a few lines of code each:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:#%plain-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;clause:lambda-clause&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;clause.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;

&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:case-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;clause:lambda-clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;clause.expansion&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, we need to tackle the three &lt;code&gt;let&lt;/code&gt; forms. None of these involve any fundamentally new ideas, but they are a little bit more involved than the variants of lambda due to the need to handle the RHSs. Each variant is slightly different, but not dramatically so: the bindings aren’t in scope when expanding the RHSs of &lt;code&gt;let-values&lt;/code&gt;, but they are for &lt;code&gt;letrec-values&lt;/code&gt; and &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, and &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; creates transformer bindings and must evaluate some RHSs in phase 1 while &lt;code&gt;let-values&lt;/code&gt; and &lt;code&gt;letrec-values&lt;/code&gt; exclusively bind runtime bindings. It would be possible to implement these three forms in separate clauses, but since we’d ideally like to duplicate as little code as possible, we can write a rather elaborate &lt;code&gt;syntax/parse&lt;/code&gt; pattern to handle all three binding forms all at once.&lt;/p&gt;&lt;p&gt;We’ll start by handling &lt;code&gt;let-values&lt;/code&gt; alone to keep things simple:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This isn’t dramatically different from the implementation of &lt;code&gt;#%plain-lambda&lt;/code&gt;. The only difference is that we have to recursively invoke &lt;code&gt;expand-expression&lt;/code&gt; on the RHSs in addition to expanding the body expressions. To handle &lt;code&gt;letrec-values&lt;/code&gt; in the same clause, however, we’ll have to get a little more creative.&lt;/p&gt;&lt;p&gt;So far, we haven’t actually tapped very far into &lt;code&gt;syntax/parse&lt;/code&gt;’s pattern language over the course of these two blog posts. The full language available to patterns is rather extensive, and we can take advantage of that to write a modification of the above clause that handles both &lt;code&gt;let-values&lt;/code&gt; and &lt;code&gt;letrec-values&lt;/code&gt; at once:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:letrec-values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]}}}&lt;/span&gt;
  &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rec?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;~bind&lt;/code&gt; pattern allows us to explicitly control how attributes are bound as part of the pattern-matching process, which allows us to track when we want to enable the recursive binding behavior of &lt;code&gt;letrec-values&lt;/code&gt; in our handler code. Since the vast majority of the logic is otherwise identical, this is a significant improvement over duplicating the clause.&lt;/p&gt;&lt;p&gt;Adding support for &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; is done in the same general way, but the pattern is even more involved. In addition to tracking whether or not the bindings are recursive, we have to track if any syntax bindings were present at all, and if they were, bind them with &lt;code&gt;syntax-local-bind-syntaxes&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:letrec-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
             &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x/s:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)}}&lt;/span&gt;
  &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x/s&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
               &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rec?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;syntax/loc&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This behemoth clause handles all three varieties of &lt;code&gt;let&lt;/code&gt; forms that can appear in the result of &lt;code&gt;local-expand&lt;/code&gt;. Notably, in the &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; case, we expand into &lt;code&gt;letrec-values&lt;/code&gt;, since the transformer bindings are effectively erased, and we use &lt;code&gt;syntax-track-origin&lt;/code&gt; to record that the result originally came from a use of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;With these five clauses, we’ve handled all the special forms that can appear in expression position in Racket’s kernel language. To tie things off, we just need to handle the cases of a variable reference, which is represented by a bare identifier not bound to syntax, or literal data, like numbers or strings. We can add one more clause at the end to handle those:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
 &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Putting them all together, our &lt;code&gt;expand-expression&lt;/code&gt; function looks as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="ss"&gt;quote-syntax&lt;/span&gt; &lt;span class="k"&gt;#%top&lt;/span&gt; &lt;span class="k"&gt;#%variable-reference&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

      &lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="k"&gt;#%expression&lt;/span&gt; &lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="k"&gt;begin0&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;with-continuation-mark&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;

      &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:#%plain-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;clause:lambda-clause&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;clause.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;

      &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:case-lambda&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;clause:lambda-clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;clause.expansion&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;

      &lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}&lt;/span&gt;
                  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:letrec-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}}&lt;/span&gt;
             &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
                   &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x/s:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)}}&lt;/span&gt;
        &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x/s&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
       &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
       &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rec?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;syntax/loc&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;

      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
       &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we try it out, we’ll see that it really does work! Even complicated local binding forms are handled properly by our expander:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-rename-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                       &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-rename-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="n"&gt;#&amp;lt;syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-values&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are now able to expand arbitrary Racket expressions in the same way that the expander does. While this might not seem immediately useful—after all, we haven’t actually gained anything here over just calling &lt;code&gt;local-expand&lt;/code&gt; with an empty stop list—we can use this as the basis of an expander that can extensibly handle custom core forms, which I may cover in a future blog post.&lt;/p&gt;&lt;h2&gt;&lt;a name="adding-support-for-internal-definitions"&gt;&lt;/a&gt;Adding support for internal definitions&lt;/h2&gt;&lt;p&gt;In the previous section, we defined an expander that could expand arbitrary Racket expressions, but our expander is still imperfect: we still do not support internal definitions. For all forms that have bodies, including &lt;code&gt;#%plain-lambda&lt;/code&gt;, &lt;code&gt;case-lambda&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, &lt;code&gt;letrec-values&lt;/code&gt;, and &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, Racket permits the use of internal definitions.&lt;/p&gt;&lt;p&gt;In practice, internal-definition contexts allow for an increased degree of modularity compared to traditional local binding forms, since they provide an &lt;em&gt;extensible&lt;/em&gt; binding language. Users may mix many different binding forms within a single definition context, such as &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;define-syntax&lt;/code&gt;, &lt;code&gt;match-define&lt;/code&gt;, and even &lt;code&gt;struct&lt;/code&gt;. However, this means the rewriting process described earlier in this blog post is not as simple as detecting the definitions and lifting them into a local binding form, since it’s not immediately apparent which forms are binding forms and which are expressions!&lt;/p&gt;&lt;p&gt;For this reason, expanding internal-definition contexts happens to be a nontrivial problem in itself. It involves a little more care than expanding expressions does, since it requires using partial expansion to discover which forms are definitions and which forms are expressions. We must take care to never expand too much, but also to expand enough that we reveal all uses of &lt;code&gt;define-values&lt;/code&gt; and &lt;code&gt;define-syntaxes&lt;/code&gt; (which all definition forms eventually expand into). We also must handle the splicing behavior of &lt;code&gt;begin&lt;/code&gt;, which is necessary to allow single forms to expand into multiple definitions.&lt;/p&gt;&lt;p&gt;We’ll start by writing an &lt;code&gt;expand-body&lt;/code&gt; function, which operates similarly to our previous &lt;code&gt;expand-expression&lt;/code&gt; function. Unlike &lt;code&gt;expand-expression&lt;/code&gt;, &lt;code&gt;expand-body&lt;/code&gt; will accept a &lt;em&gt;list&lt;/em&gt; of syntax objects, which represents the sequence of forms that make up the body. Logically, each body will create a first-class definition context with &lt;code&gt;syntax-local-make-definition-context&lt;/code&gt; to represent the sequence of definitions:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The bulk of our &lt;code&gt;expand-body&lt;/code&gt; function will be a loop that partially expands body forms, adds definitions to the definition context as it discovers them, and returns the expressions and runtime definitions to be rewritten into binding pairs for a &lt;code&gt;letrec-values&lt;/code&gt; form. Additionally, the loop will also track so-called &lt;em&gt;disappeared uses&lt;/em&gt; and &lt;em&gt;disappeared bindings&lt;/em&gt;, which are attached to the expansion using syntax properties to allow tools like DrRacket to learn about the binding structure of phase 1 definitions that are erased as part of macroexpansion.&lt;/p&gt;&lt;p&gt;The skeleton of this loop is relatively straightforward to write. We will iterate over the syntax objects that make up the body, expand them, and process the expansion using &lt;code&gt;syntax-parse&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stxs&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;disappeared-bindings&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()])&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;empty?&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="p"&gt;)))))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The hard part, of course, is actually handling the potential results of that expansion. We need to handle three forms specially: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;define-values&lt;/code&gt;, and &lt;code&gt;define-syntaxes&lt;/code&gt;. All other results of partial expansion will be treated as expressions. We’ll start by handling &lt;code&gt;begin&lt;/code&gt;, since it’s the simplest case; we only need to prepend the subforms to the list of body forms to be processed, then continue looping:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:begin&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, as is often the case, this isn’t quite perfect, since the information that these forms came from a surrounding &lt;code&gt;begin&lt;/code&gt; is lost, which tools like DrRacket want to know. To solve this problem, the expander adjusts the &lt;code&gt;origin&lt;/code&gt; property for all spliced forms, which we can mimic using &lt;code&gt;syntax-track-origin&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:begin&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is sufficient for &lt;code&gt;begin&lt;/code&gt;, so we can move onto the actual definitions themselves. This actually isn’t too hard, since we just need to add the bindings we discover to the first-class definition context and preserve &lt;code&gt;define-values&lt;/code&gt; bindings as binding pairs:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This solution is missing one thing, however, which is the use of &lt;code&gt;syntax-local-identifier-as-binding&lt;/code&gt; to any use-site scopes that were added to the binding identifier while expanding the binding form in the definition context. Explaining precisely why this is necessary is outside the scope of this blog post, and is best understood by reading &lt;a href="http://www.cs.utah.edu/plt/scope-sets/pattern-macros.html#%28part._use-site%29"&gt;the section on use-site scopes&lt;/a&gt; in the paper that describes the theory behind Racket’s current macro system, Bindings as Sets of Scopes. In any case, the impact on our implementation is small:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, as with &lt;code&gt;begin&lt;/code&gt;, we want to track that the binding pairs we generate actually came from a use of &lt;code&gt;define-values&lt;/code&gt; (which in turn likely came from a use of some other definition form). Therefore, we’ll add another use of &lt;code&gt;syntax-track-origin&lt;/code&gt; to copy and extend the necessary properties:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That’s it for &lt;code&gt;define-values&lt;/code&gt;. All that’s left is to handle &lt;code&gt;define-syntaxes&lt;/code&gt;, which is quite similar, but instead of storing the definition in a binding pair, its RHS is immediately evaluated and added to the definition context using &lt;code&gt;syntax-local-bind-syntaxes&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-syntaxes&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As the above snippet indicates, this is also where the disappeared uses and disappeared bindings come in. In previous cases, we’ve used &lt;code&gt;syntax-track-origin&lt;/code&gt; to indicate that a piece of syntax was the result of expanding a different piece of syntax, but in this case, &lt;code&gt;define-syntaxes&lt;/code&gt; doesn’t expand into anything at all; it’s simply removed from the expansion entirely. Therefore, we need to resort to tracking the information in syntax properties on the resulting &lt;code&gt;letrec-values&lt;/code&gt; form, so we’ll save them for later.&lt;/p&gt;&lt;p&gt;Finally, to finish things up, we can add a catchall clause that handles all other forms, which are now guaranteed to be expressions:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This completes our loop that processes definition forms, so all that’s left to do is handle the results. The only significant remaining work is to actually expand the RHSs of the binding pairs we collected and the body expressions, which can be done by calling our own &lt;code&gt;expand-expression&lt;/code&gt; function directly:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expanded-binding-clauses&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;binding-clause&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;binding-clause&lt;/span&gt;
      &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)])])))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expanded-exprs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, we can assemble all the pieces together into a single local binding form with the appropriate syntax properties:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;expanded-binding-clauses&lt;/span&gt; &lt;span class="o"&gt;#,@&lt;/span&gt;&lt;span class="n"&gt;expanded-exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;disappeared-bindings&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That’s it. We’ve now written an &lt;code&gt;expand-body&lt;/code&gt; function that can process internal definition contexts in the same way that the macroexpander does. Overall, the whole function is just under 45 lines of code:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;gensym&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stxs&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;disappeared-bindings&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()])&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;empty?&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:begin&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                               &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="n"&gt;exprs&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:define-syntaxes&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-identifier-as-binding&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rest&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="n"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)]))))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expanded-binding-clauses&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;binding-clause&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="n"&gt;binding-clauses&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;binding-clause&lt;/span&gt;
            &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
               &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)])])))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expanded-exprs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;exprs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;expanded-binding-clauses&lt;/span&gt; &lt;span class="o"&gt;#,@&lt;/span&gt;&lt;span class="n"&gt;expanded-exprs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;disappeared-uses&lt;/span&gt; &lt;span class="n"&gt;disappeared-uses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;disappeared-bindings&lt;/span&gt; &lt;span class="n"&gt;disappeared-bindings&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The next step is to actually use this function. We need to replace certain recursive calls to &lt;code&gt;expand-expression&lt;/code&gt; with calls to &lt;code&gt;expand-body&lt;/code&gt;, but if we do this naïvely, we’ll have some problems. Currently, when we expand body forms, they’re always immediately inside another definition context (i.e. the bindings introduced by lambda formals or by &lt;code&gt;let&lt;/code&gt; binding pairs), but they haven’t actually been expanded in that context yet. When we call &lt;code&gt;expand-body&lt;/code&gt;, we create a nested context, which will inherit the bindings, but won’t automatically add the parent context’s scope. Therefore, we need to manually call &lt;code&gt;internal-definition-context-introduce&lt;/code&gt; on the body syntax objects before calling &lt;code&gt;expand-body&lt;/code&gt;. We can write a small helper function to make this easier:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body/in-ctx&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-ctx-scope&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add-ctx-scope&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;add-ctx-scope&lt;/span&gt; &lt;span class="n"&gt;stxs&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we just need to replace the relevant calls to &lt;code&gt;expand-expression&lt;/code&gt; with calls to &lt;code&gt;expand-body/in-ctx&lt;/code&gt;, starting with a minor adjustment to our &lt;code&gt;lambda-clause&lt;/code&gt; syntax class from earlier:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;lambda-clause&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;formals:plain-formals&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;formals.id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;formals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body/in-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;formals*&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The only other change must occur in the handling of the various &lt;code&gt;let&lt;/code&gt; forms, which similarly replaces &lt;code&gt;expand-expression&lt;/code&gt; with &lt;code&gt;expand-body/in-ctx&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[({&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:let-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;head:letrec-values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;]}}}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~seq&lt;/span&gt; &lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~bind&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rec?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stxs?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
             &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x/s:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)}}&lt;/span&gt;
  &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;append*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;x/s&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
               &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;xs/s&lt;/span&gt; &lt;span class="n"&gt;rhs/s&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;internal-definition-context-introduce&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rhs*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rec?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-intdef-ctx&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-body/in-ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;stxs?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;syntax/loc&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;rhs*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body*&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With these changes, we’ve now extended our expression expander with the ability to expand internal definitions. We can see this in action on a simple example:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-rename-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-rename-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="n"&gt;#&amp;lt;syntax&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-values&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-values&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just as we’d like, the transformer bindings were expanded and subsequently eliminated, and the runtime binding was collected into a &lt;code&gt;letrec-values&lt;/code&gt; form. The outer &lt;code&gt;let-values&lt;/code&gt; is left over from the outer &lt;code&gt;let&lt;/code&gt;, which is needed only to create an internal-definition context to hold our internal definitions.&lt;/p&gt;&lt;h2&gt;&lt;a name="putting-the-expression-expander-to-work"&gt;&lt;/a&gt;Putting the expression expander to work&lt;/h2&gt;&lt;p&gt;So far, we’ve done a lot of work to emulate the behavior of Racket’s macroexpander, and as the above example demonstrates, we’ve been fairly successful in that goal. However, you might be wondering &lt;em&gt;why&lt;/em&gt; we did any of this, as replicating the behavior of &lt;code&gt;local-expand&lt;/code&gt; is not very useful on its own. As mentioned above, this can be used as the foundation of an expander for custom core forms that extends, rather than replaces, the built-in Racket core forms, It can also be used to “cheat” and expand through the behavior of the &lt;code&gt;local-expand&lt;/code&gt; stop list, which implicitly adds the Racket core forms to any non-empty stop list. Hopefully, I’ll have a chance to cover some of these things more deeply in the future, but for now, I’ll just give a small taste of the latter.&lt;/p&gt;&lt;p&gt;By using the power of our &lt;code&gt;expand-expression&lt;/code&gt; function, it’s actually possible to use this kind of expression expander to do genuinely nefarious things, such as hijack the behavior of arbitrary macros! For example, we could do something evil like make &lt;code&gt;for&lt;/code&gt; loops run in reverse order by adding &lt;code&gt;for&lt;/code&gt; to &lt;code&gt;current-stop-list&lt;/code&gt;, then adding an additional special case to &lt;code&gt;expand-expression&lt;/code&gt; for &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;current-stop-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-parameter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameterize&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;current-context&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current-expand&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="kd"&gt;#:literals&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="c1"&gt;; ...&lt;/span&gt;
      &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;head:for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;seq:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sequence-&amp;gt;list&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
      &lt;span class="c1"&gt;; ...&lt;/span&gt;
    &lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Amazingly, due to the fact that we’ve taken complete control of the expansion process, this will rewrite uses of &lt;code&gt;for&lt;/code&gt; &lt;em&gt;even if they are introduced by macroexpansion&lt;/em&gt;. For example, we could write a small macro that expands into a use of &lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-up-to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-range&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-up-to&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we write a wrapper macro that applies our evil version of &lt;code&gt;expand-expression&lt;/code&gt; to its body, then wrap a use of our &lt;code&gt;print-up-to&lt;/code&gt; macro with it, it will execute the loop in reverse order:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;hijack-for-loops&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;form:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-expression&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hijack-for-loops&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-up-to&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On its own, this is not that impressive, since we could have just used &lt;code&gt;local-expand&lt;/code&gt; on the body directly to achieve this. However, what’s remarkable about &lt;code&gt;hijack-for-loops&lt;/code&gt; is that it will work even if the &lt;code&gt;for&lt;/code&gt; loop is buried deep inside some arbitrary expression:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hijack-for-loops&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-up-to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course, this example is rather contrived—mucking with &lt;code&gt;for&lt;/code&gt; loops like this isn’t useful at all, and nobody would really write &lt;code&gt;print-up-to&lt;/code&gt; as a macro, anyway—but there is potential for using this technique to do more interesting things.&lt;/p&gt;&lt;h2&gt;&lt;a name="closing-thoughts"&gt;&lt;/a&gt;Closing thoughts&lt;/h2&gt;&lt;p&gt;The system outlined in this blog post is not something I would recommend using in any real macro. It is enormously complicated, requires knowledge well above that of your average working macrologist, and it involves doing rather horrible things to the macro system, things it was undoubtably never designed to do. Still, I believe this blog post is useful, for a few different reasons:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;The technology outlined in this post, while perhaps not directly applicable to existing real-world problems, provides a framework for implementing various new kinds of syntax transformations in Racket &lt;em&gt;without&lt;/em&gt; extending the macro system. It demonstrates the expressive power of the macro system, and it hopefully lays the foundation for a better, more high-level interface for users who wish to define their own languages with custom core forms.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;This system provides insight into the way the Racket macroexpander operates, &lt;em&gt;in terms of the userspace syntax API&lt;/em&gt;. The canonical existing model of hygienic macroexpansion, in the aforementioned &lt;a href="http://www.cs.utah.edu/plt/scope-sets/"&gt;Bindings as Sets of Scopes&lt;/a&gt; paper, does not explain the workings of internal definition contexts in detail, and it certainly doesn’t explain them in terms that a Racket programmer would already be familiar with. By reencoding those ideas within the macro system itself, an advanced macro writer may be able to more easily connect concepts in the macro system’s implementation to concepts they have already been exposed to.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The capability of the proof-of-concept outlined here demonstrates that the limitation imposed by the existing implementation of the stop list (namely, the way it is implicitly extended with additional identifiers) is essentially artificial, and it can be hacked around with sufficient (albeit significant) effort. This isn’t enormously important, but it is somewhat relevant to a recent debate in &lt;a href="https://github.com/racket/racket/issues/2154"&gt;a GitHub issue&lt;/a&gt; about the handling of the &lt;code&gt;local-expand&lt;/code&gt; stop list.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, for myself as much as anyone else, this implementation records in a concise way (perhaps overly concise at times) the collection of very subtle details I’ve learned over the past six months about how information is preserved and propagated during the expansion process.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;This blog post is not for everybody. If you made it to the end, give yourself a pat on the back. If you made it to the end &lt;em&gt;and&lt;/em&gt; understood everything you read: congratulations, you are a certified expert in Racket macro programming. If not, do not fear, and do not lose hope—I plan for something significantly more mellow next time.&lt;/p&gt;&lt;p&gt;As always, I’d like to give thanks to the people who contributed significantly, if indirectly, to the contents of this blog post, namely &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, &lt;a href="http://mballantyne.net"&gt;Michael Ballantyne&lt;/a&gt;, and &lt;a href="http://www.ccs.neu.edu/home/ryanc/"&gt;Ryan Culpepper&lt;/a&gt;. And finally, for those interested, all of the code in this blog post can be found in a runnable form &lt;a href="https://gist.github.com/lexi-lambda/c4f4b91ac9c0a555447d72d02e18be7b"&gt;in this GitHub gist&lt;/a&gt;.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Reimplementing Hackett’s type language: expanding to custom core forms in Racket</title><link>https://lexi-lambda.github.io/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/</guid><pubDate>15 Apr 2018</pubDate><description>&lt;article&gt;&lt;p&gt;In the past couple of weeks, I &lt;a href="https://github.com/lexi-lambda/hackett/commit/ba64193da38f63dab2523f42c1b7614cdfa8c935"&gt;completely rewrote the implementation of Hackett’s type language&lt;/a&gt; to improve the integration between the type representation and Racket’s macro system. The new type language effectively implements a way to reuse as much of the Racket macroexpanding infrastructure as possible while expanding a completely custom language, which uses a custom set of core forms. The fundamental technique used to do so is not novel, and it seems to be periodically rediscovered every so often, but it has never been published or documented anywhere, and getting it right involves understanding a great number of subtleties about the Racket macro system. While I cannot entirely eliminate the need to understand those subtleties, in this blog post, I hope to make the secret sauce considerably less secret.&lt;/p&gt;&lt;p&gt;This blog post is both a case study on how I implemented the expander for Hackett’s new type language and a discussion of how such a technique can apply more generally. Like &lt;a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/"&gt;my previous blog post on Hackett&lt;/a&gt;, which covered the implementation of its namespace system, the implementation section of this blog post is highly technical and probably requires significant experience with Racket’s macro system to completely comprehend. However, the surrounding material is written to be more accessible, so even if you are not a Racket programmer, you should hopefully be able to understand the big ideas behind this change.&lt;/p&gt;&lt;h2&gt;&lt;a name="what-are-core-forms"&gt;&lt;/a&gt;What are core forms?&lt;/h2&gt;&lt;p&gt;Before we can get started writing &lt;em&gt;custom core forms&lt;/em&gt;, we need to understand the meaning of Racket’s plain old &lt;em&gt;core forms&lt;/em&gt;. What is a core form? In order to answer that question, we need to think about how Racket’s expansion and compilation model works.&lt;/p&gt;&lt;p&gt;To start, let’s consider a simple Racket program. Racket programs are organized into modules, which are usually written with a &lt;code&gt;#lang&lt;/code&gt; line at the top. In this case, we’ll use &lt;code&gt;#lang racket&lt;/code&gt; to keep things simple:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;How does Racket see this program? Well, before it can do anything with it, it must parse the program text, which is known in Racket as &lt;em&gt;reading&lt;/em&gt; the program. The &lt;code&gt;#lang&lt;/code&gt; line controls how the program is read—some &lt;code&gt;#lang&lt;/code&gt;s provide parsers that allow syntax that is very different from the parser used for &lt;code&gt;#lang racket&lt;/code&gt;—but no matter which reader is used, the result is an s-expression (actually a syntax object, but essentially an s-expression) representing a module. In the case of the above program, the result looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;racket&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%module-begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note the introduction of &lt;code&gt;#%module-begin&lt;/code&gt;. Despite the fancy name, this is really just an ordinary macro provided by the &lt;code&gt;racket&lt;/code&gt; language. By convention, the reader and expander cooperate to ensure the body of every module is wrapped with &lt;code&gt;#%module-begin&lt;/code&gt;; as we’ll see shortly, this allows languages to add functionality that affects the entire contents of the module.&lt;/p&gt;&lt;p&gt;One the program has been read, it is subsequently &lt;em&gt;expanded&lt;/em&gt; by the macroexpander. As the name implies, this is the phase that expands all the macros in a module. What does the above module look like after expansion? Well, it doesn’t look unrecognizable, but it certainly does look different:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;racket&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-module-begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="nb"&gt;call-with-values&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%plain-app&lt;/span&gt; &lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="n"&gt;print-values&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let’s note the things that changed:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;#%module-begin&lt;/code&gt; was replaced with &lt;code&gt;#%plain-module-begin&lt;/code&gt;. &lt;code&gt;#%plain-module-begin&lt;/code&gt; is a binding that wraps the body of every expanded module, and all definitions of &lt;code&gt;#%module-begin&lt;/code&gt; in any language must eventually expand to &lt;code&gt;#%plain-module-begin&lt;/code&gt;. However, &lt;code&gt;#lang racket&lt;/code&gt;’s &lt;code&gt;#%module-begin&lt;/code&gt; doesn’t &lt;em&gt;just&lt;/em&gt; expand to &lt;code&gt;#%plain-module-begin&lt;/code&gt;, it also wraps bare expressions at the top level of a module so that their results are printed. This is why running the above program prints &lt;code&gt;5&lt;/code&gt; even though there is no code related to printing in the original program!&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The lambda shorthand used with &lt;code&gt;define&lt;/code&gt; was converted to an explicit use of &lt;code&gt;lambda&lt;/code&gt;, and it was expanded to &lt;code&gt;define-values&lt;/code&gt;. In Racket, &lt;code&gt;define&lt;/code&gt; and &lt;code&gt;define-syntax&lt;/code&gt; are really just macros for &lt;code&gt;define-values&lt;/code&gt; and &lt;code&gt;define-syntaxes&lt;/code&gt; that only bind a single identifier.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;All function applications were tagged explicitly with &lt;code&gt;#%plain-app&lt;/code&gt;. This syntactically distinguishes function applications from uses of forms like &lt;code&gt;define-values&lt;/code&gt; or &lt;code&gt;lambda&lt;/code&gt;. It also allows languages to customize function application by providing their own macros named &lt;code&gt;#%app&lt;/code&gt; (just like languages can provide their own macros named &lt;code&gt;#%module-begin&lt;/code&gt; that expand to &lt;code&gt;#%plain-module-begin&lt;/code&gt;), but that is outside the scope of this blog post.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;All literals have been wrapped with &lt;code&gt;quote&lt;/code&gt;, so &lt;code&gt;2&lt;/code&gt; became &lt;code&gt;'2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; became &lt;code&gt;'3&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Importantly, the resulting program contains &lt;strong&gt;no macros&lt;/strong&gt;. Such programs are called &lt;em&gt;fully expanded&lt;/em&gt;, since all macros have been eliminated and no further expansion can take place.&lt;/p&gt;&lt;p&gt;So what’s left behind? Well, some of the things in the program are literal data, like the numbers &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt;. There are also some variable references, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;add2&lt;/code&gt;. Most of the program, however, is built out of primitives like &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;#%plain-module-begin&lt;/code&gt;, &lt;code&gt;#%plain-app&lt;/code&gt;, &lt;code&gt;define-values&lt;/code&gt;, and &lt;code&gt;lambda&lt;/code&gt;. These primitives are &lt;em&gt;core forms&lt;/em&gt;—they are not variables, since they do not represent bindings that contain values at runtime, but they are also not macros, since they cannot be expanded any further.&lt;/p&gt;&lt;p&gt;In this sense, a fully-expanded program is just like a program in most languages that do not have macros. Core forms in Racket correspond to the syntax of other languages. We can imagine a JavaScript program similar to the above fully-expanded Racket program:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;add2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just as this JavaScript program is internally transformed into an AST containing a definition node, a function abstraction node, and some function application nodes, a fully-expanded Racket program represents an AST ready to be sent off to be &lt;em&gt;compiled&lt;/em&gt;. The Racket compiler has built-in rules for how to compile core forms like &lt;code&gt;define-values&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;, and &lt;code&gt;#%plain-app&lt;/code&gt;, and the result is optimized Racket bytecode.&lt;/p&gt;&lt;p&gt;In the remainder of this blog post, as most discussions of macros do, we’ll ignore the &lt;em&gt;read&lt;/em&gt; and &lt;em&gt;compile&lt;/em&gt; steps of the Racket program pipeline and focus exclusively on the &lt;em&gt;expand&lt;/em&gt; step. It’s useful, however, to keep the other steps in mind, since we’re going to be discussing what it means to implement custom core forms, and core forms really only make sense in the context of the subsequent compilation step that consumes them.&lt;/p&gt;&lt;h3&gt;&lt;a name="racket-s-default-core-forms"&gt;&lt;/a&gt;Racket’s default core forms&lt;/h3&gt;&lt;p&gt;So, now that we know what core forms are in an abstract sense, what are they in practice? We’ve already encountered &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;#%plain-module-begin&lt;/code&gt;, &lt;code&gt;#%plain-app&lt;/code&gt;, &lt;code&gt;define-values&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;, and &lt;code&gt;quote&lt;/code&gt;, but there are many more. The full list is available in the section of the Racket reference named &lt;a href="http://docs.racket-lang.org/reference/syntax-model.html#%28part._fully-expanded%29"&gt;Fully Expanded Programs&lt;/a&gt;, and I will not list all of them here. In general, they are more or less what you’d expect. The list of Racket’s core forms also includes things like &lt;code&gt;define-syntaxes&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, &lt;code&gt;letrec-values&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;quote-syntax&lt;/code&gt;, and &lt;code&gt;set!&lt;/code&gt;. Fundamentally, these correspond to the basic operations the Racket compiler understands, and it allows the remainder of Racket’s compilation pipeline to ignore the complexities of macroexpansion.&lt;/p&gt;&lt;p&gt;These forms are fairly versatile, and it’s easy to build high-level abstractions on top of them. For example, &lt;code&gt;#lang racket&lt;/code&gt; implements &lt;code&gt;cond&lt;/code&gt; as a macro that eventually expands into &lt;code&gt;if&lt;/code&gt;, and it implements &lt;code&gt;syntax&lt;/code&gt; as a macro that eventually expands into function calls and &lt;code&gt;quote-syntax&lt;/code&gt;. The real power comes in the way new macros can be built out of other macros, not just core forms, so Racket’s &lt;code&gt;match&lt;/code&gt; can expand into uses of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt;, and it doesn’t need to concern itself with using &lt;code&gt;let-values&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt;. For this reason, Racket’s core forms are quite capable of representing any language imaginable, since fully-expanded programs are essentially instructions for the Racket virtual machine, and macros are mini-compilers that can be mixed and matched.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-need-for-custom-core-forms"&gt;&lt;/a&gt;The need for custom core forms&lt;/h3&gt;&lt;p&gt;With that in mind, why might we wish to define &lt;em&gt;custom&lt;/em&gt; core forms? In fact, what would such a thing even mean? By their very nature, &lt;em&gt;all&lt;/em&gt; Racket programs eventually expand into Racket’s core forms; new core forms cannot be added because Racket’s underlying compiler infrastructure is not (currently) extensible. New forms can be added that are defined in terms of other forms, but adding new primitives doesn’t make any sense, since the compiler would not know what to do with them.&lt;/p&gt;&lt;p&gt;Despite this, there &lt;em&gt;are&lt;/em&gt; at least two use-cases in which a programmer might wish to customize the set of core forms produced by the macroexpander. Each situation is slightly different, but they both revolve around the same idea.&lt;/p&gt;&lt;h4&gt;&lt;a name="supporting-multiple-backends"&gt;&lt;/a&gt;Supporting multiple backends&lt;/h4&gt;&lt;p&gt;The most commonly discussed use case for customizing the set of core forms is for languages that wish to use the Racket macroexpander, but target backends that are not the Racket compiler. For example, a user might implement a Racket &lt;code&gt;#lang&lt;/code&gt; that describes electronic circuits, and they might even implement a way to execute such a program in Racket, but they might &lt;em&gt;also&lt;/em&gt; wish to compile the result to a more traditional hardware description language. Like other languages in the Racket ecosystem, such a language would be made up of a tower of macros built on top of core forms; unlike other languages, the core forms might need to be more abstract than the ones provided by Racket to efficiently compile to other targets.&lt;/p&gt;&lt;p&gt;In the case of a hardware description language, the custom core forms might include things like &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; for declaring circuit inputs and outputs, and expressions might be built out of hardware operations rather than high-level things like function calls. The Racket macroexpander would expand the input program into the custom set of core forms, at which point an external compiler program could compile the resutling AST in a more traditional way. If the language author wished, they could &lt;em&gt;additionally&lt;/em&gt; define implementations of these core forms as Racket macros that eventually expand into Racket, which would allow them to emulate their circuits in Racket at little cost, but this would be a wholly optional step.&lt;/p&gt;&lt;p&gt;Essentially, this use case stems from a desire to reuse Racket’s advanced language-development technology, such as the macroexpander, the module system, and editor tooling, without also committing to using Racket as a runtime, which is not always appropriate for all languages. This use case is not nearly as easy as it ought to be, but it is a common request, and it is possible that future improvements to the Racket toolchain will be designed specifically to address this problem.&lt;/p&gt;&lt;h4&gt;&lt;a name="compiling-an-extensible-embedded-language"&gt;&lt;/a&gt;Compiling an extensible embedded language&lt;/h4&gt;&lt;p&gt;A second use case for custom core forms is less frequently discussed, but I think it might actually be significantly more common in practice were it available in a form accessible to working macro programmers. In this scenario, users might wish to remain within Racket, but still want to define a custom language that other macros can consume.&lt;/p&gt;&lt;p&gt;This concept is a little more vague and fuzzily-defined than the case of developing a separate backend, so allow me to propose an example. Imagine a Racket programmer decides to build an embedded DSL for asynchronously producing and consuming events, similar to first-order functional reactive programming. In this case, the DSL is designed to be used in larger Racket programs, so it &lt;em&gt;will&lt;/em&gt; eventually expand to Racket’s core forms. However, it’s possible that such a language might wish to enforce static invariants about the network graph, and in doing so, it might be able to produce significantly more optimal Racket code via a compile-time analysis.&lt;/p&gt;&lt;p&gt;Performing such a compile-time analysis is essentially writing a custom optimizer as part of a macro, which has been done numerous times already within the Racket ecosystem. One of the most prominent examples of such a thing is the &lt;code&gt;match&lt;/code&gt; macro, which parses users’ patterns into compile-time data structures, performs a fairly traditional optimization pass designed to efficiently compile pattern matching, and it emits optimized Racket code as a result. This approach works well for fairly contained problems like pattern-matching, but it works less well for entirely new embedded languages that include everything from their own notion of evaluation to their own binding forms.&lt;/p&gt;&lt;p&gt;Existing DSLs of this type are rare, but they do exist. &lt;code&gt;syntax/parse&lt;/code&gt; provides an expressive, specialized pattern-matching language designed specifically for matching syntax objects, and it uses a different model from &lt;code&gt;racket/match&lt;/code&gt; to be more suitable for that task. It allows backtracking with cuts, an extensible pattern language, an abstraction language for defining reusable parsers that can accept inputs and produce outputs, and fine-grained control over both parsing and binding. While &lt;code&gt;match&lt;/code&gt; is essentially just a traditional pattern-matcher, albeit an extensible one, &lt;code&gt;syntax-parse&lt;/code&gt; is its own programming language, closer in some ways to Prolog than to Racket.&lt;/p&gt;&lt;p&gt;For this reason, &lt;code&gt;syntax/parse&lt;/code&gt; has an extensive language to do everything from creating new bindings to controlling when and how parsing fails. This language is represented in two ways: an inline pattern language, and an alternate syntax known as &lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#%28part._.Pattern_.Directives%29"&gt;&lt;em&gt;pattern directives&lt;/em&gt;&lt;/a&gt;. Here is an example of pattern directives in action, from my own &lt;code&gt;threading&lt;/code&gt; library:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;ex:expr&lt;/span&gt; &lt;span class="n"&gt;cl:clause&lt;/span&gt; &lt;span class="n"&gt;remaining:clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl.call&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;split-at&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;cl.insertion-point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Each directive is represented by a keyword, in this case &lt;code&gt;#:do&lt;/code&gt; and &lt;code&gt;#:with&lt;/code&gt;. Each directive has a corresponding keyword in the pattern language, in this case &lt;code&gt;~do&lt;/code&gt; and &lt;code&gt;~parse&lt;/code&gt;. Therefore, the above pattern could equivalently be written this way:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;ex:expr&lt;/span&gt; &lt;span class="n"&gt;cl:clause&lt;/span&gt; &lt;span class="n"&gt;remaining:clause&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~do&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl.call&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;split-at&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;cl.insertion-point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))))}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~parse&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~parse&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~parse&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)}}&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The transformation can go in the other direction, too—each syntax class annotation on each pattern variable can be extracted into the directive language using &lt;code&gt;#:declare&lt;/code&gt;, so this is also equivalent:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;
 &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt; &lt;span class="n"&gt;clause&lt;/span&gt;
 &lt;span class="kd"&gt;#:declare&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="n"&gt;clause&lt;/span&gt;
 &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-&amp;gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl.call&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;split-at&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;cl.insertion-point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))))]&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;
 &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;adjust-outer-context&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;app/ctx&lt;/span&gt; &lt;span class="n"&gt;remaining&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is very much a programming language, but it has very different semantics from programming in Racket! Failure to match against a &lt;code&gt;#:with&lt;/code&gt; or &lt;code&gt;~parse&lt;/code&gt; pattern causes pattern-matching to backtrack, and though it’s possible to escape to Racket using &lt;code&gt;#:do&lt;/code&gt; or &lt;code&gt;~do&lt;/code&gt;, practical uses of &lt;code&gt;syntax/parse&lt;/code&gt; really do involve quite a lot of programming in its pattern DSL.&lt;/p&gt;&lt;p&gt;But the Racket programmer might not find this DSL wholly satisfying. Why? Well, it isn’t extensible! The pattern directives—&lt;code&gt;#:declare&lt;/code&gt;, &lt;code&gt;#:do&lt;/code&gt;, and &lt;code&gt;#:with&lt;/code&gt;, among others—are essentially the core forms of &lt;code&gt;syntax/parse&lt;/code&gt;’s pattern-matching language, but new ones cannot be defined. The desire to make this language easy to analyze statically in order to emit optimal pattern-matching code meant its author opted to define the language in terms of a specific grammar rather than a tower of macros.&lt;/p&gt;&lt;p&gt;But what if &lt;code&gt;syntax/parse&lt;/code&gt; could define its own core forms? What if, instead of &lt;code&gt;#:do&lt;/code&gt;, &lt;code&gt;#:declare&lt;/code&gt;, and &lt;code&gt;#:with&lt;/code&gt; being implemented as keyword options specially recognized by the &lt;code&gt;syntax-parse&lt;/code&gt; grammar, it defined &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;declare&lt;/code&gt;, and &lt;code&gt;with&lt;/code&gt; as core forms for a new, macro-enabled language? A user of the language could then define a completely ordinary Racket macro and use it with this new language as long as it eventually expanded into the &lt;code&gt;syntax/parse&lt;/code&gt; core forms. The implementation of &lt;code&gt;syntax/parse&lt;/code&gt; could then invoke the macroexpander to request each clause be expanded into its core forms, perform its static analysis on the result, and finally emit optimized Racket code.&lt;/p&gt;&lt;p&gt;Now, to be fair, &lt;code&gt;syntax/parse&lt;/code&gt; is not actually entirely inextensible. While new directives cannot be defined, new patterns can be added through a pattern-expander API that was added to the library after its initial design. However, pattern expanders are still not ideal because they are not ordinary Racket macros—users must explicitly define each pattern expander differently from how they would a macro—and they cannot use existing Racket forms, even ones that would theoretically be compatible with an arbitrary set of core forms.&lt;/p&gt;&lt;p&gt;The technique described in this blog post avoids all those problems. In the following sections, I’ll show that it’s possible to define an embedded language with a custom set of core forms that works well with the rest of the Racket ecosystem and still permits arbitrary static analysis.&lt;/p&gt;&lt;h2&gt;&lt;a name="the-need-for-a-custom-type-language-in-hackett"&gt;&lt;/a&gt;The need for a custom type language in Hackett&lt;/h2&gt;&lt;p&gt;In the previous section, I described two use cases for custom core forms. Hackett, in fact, has uses for &lt;em&gt;both&lt;/em&gt; of them:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Hackett can definitely make use of custom core forms to compile to multiple backends. Eventually, it would be nice to compile Hackett to an intermediate language that can target both the Racket runtime and Haskell or GHC Core. This would allow Hackett to take advantage of GHC’s advanced optimizing compiler that already has decades of tuning for a pure, lazy, functional programming language, at the cost of not having access to the rest of Racket’s ecosystem of libraries at runtime.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hackett can &lt;em&gt;also&lt;/em&gt; make use of custom core forms for an embedded DSL. In this case, that embedded DSL is actually Hackett’s type language.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The second of those two use cases is simpler, and it’s what I ended up implementing first, so it’s what I will focus on in this blog post. Hackett’s type language is fundamentally quite simple, so its set of custom core forms is small as well. Everything in the type language eventually compiles into only seven core forms:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;(#%type:con &lt;em&gt;id&lt;/em&gt;)&lt;/code&gt; — Type constructors, like &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;. These are one of the fundamental building blocks of Hackett types.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;(#%type:app &lt;em&gt;type&lt;/em&gt; &lt;em&gt;type&lt;/em&gt;)&lt;/code&gt; — Type application, such as &lt;code&gt;(Maybe Integer)&lt;/code&gt;. Types are curried, so type constructors that accept multiple arguments are represented by nested uses of &lt;code&gt;#%type:app&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;(#%type:forall &lt;em&gt;id&lt;/em&gt; &lt;em&gt;type&lt;/em&gt;)&lt;/code&gt; — Universal quantification. This is essentially a binding form, which binds any uses of &lt;code&gt;(#%type:bound-var &lt;em&gt;id&lt;/em&gt;)&lt;/code&gt; in &lt;code&gt;&lt;em&gt;type&lt;/em&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;(#%type:qual &lt;em&gt;type&lt;/em&gt; &lt;em&gt;type&lt;/em&gt;)&lt;/code&gt; — Qualified types, aka types with typeclass constraints. Constraints in Hackett, like in GHC, are represented by types, so typeclass names like &lt;code&gt;Eq&lt;/code&gt; are bound as type constructors.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, Hackett types support three different varieties of type variables:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;(#%type:bound-var &lt;em&gt;id&lt;/em&gt;)&lt;/code&gt; — Bound type variables. These are only legal under a corresponding &lt;code&gt;#%type:forall&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;(#%type:wobbly-var &lt;em&gt;id&lt;/em&gt;)&lt;/code&gt; — Solver variables, which may unify with any other type as part of the typechecking process.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;(#%type:rigid-var &lt;em&gt;id&lt;/em&gt;)&lt;/code&gt; — Rigid variables, aka skolem variables, which only unify with themselves. They represent a unique, anonymous type used to ensure types are suitably polymorphic.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;To implement our custom core forms in Racket, we need to somehow define them, but how? Intentionally, these should never be expanded, since we want the expander to stop expanding whenever it encounters one of these identifiers. While we can’t encode this directly, we &lt;em&gt;can&lt;/em&gt; bind them to macros that do nothing but raise an exception if something attempts to expand them:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
                  &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="s2"&gt;"cannot be used as an expression"&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;
            &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will ensure our core forms are never accidentally expanded, and we’ll instruct the macroexpander to stop whenever it sees one of them via a separate mechanism.&lt;/p&gt;&lt;h3&gt;&lt;a name="expanding-types-in-our-type-language"&gt;&lt;/a&gt;Expanding types in our type language&lt;/h3&gt;&lt;p&gt;We’ve now defined our core forms, but we’ve intentionally left them meaningless. How do we actually inform the expander about how our types ought to be expanded? While it’s true that we don’t want the core forms themselves to be eliminated, we &lt;em&gt;do&lt;/em&gt; want to expand some of their subforms. For example, in the type &lt;code&gt;(#%type:app a b)&lt;/code&gt;, we want to recursively expand &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;In order to do this, we’ll use the API made available by the expander for manually invoking macroexpansion from within another macro. This API is called &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._local-expand%29%29"&gt;&lt;code&gt;local-expand&lt;/code&gt;&lt;/a&gt;, and it has an option relevant to our needs: the stop list.&lt;/p&gt;&lt;p&gt;Often, &lt;code&gt;local-expand&lt;/code&gt; is used to force the expander to completely, recursively expand a form. For example, by using &lt;code&gt;local-expand&lt;/code&gt;, we can produce a fragment of a fully-expanded program from a piece of syntax that still includes macros:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; (let-values ([(x) &amp;#39;1]) (#%plain-app + x &amp;#39;2))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The third argument to &lt;code&gt;local-expand&lt;/code&gt; is the &lt;em&gt;stop list&lt;/em&gt;, which controls how deep the expander ought to expand a given form. By providing an empty list, we ask for a complete, recursive expansion. In this case, however, we don’t want a complete expansion! We can inform the expander to stop whenever it sees any of our custom core forms by passing a list of our core form identifiers instead of an empty list:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt;
          &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;; =&amp;gt; (#%type:forall x t)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course, this isn’t very interesting, since it just gives us back exactly what we gave it. It spotted the &lt;code&gt;#%type:forall&lt;/code&gt; identifier, which is in our stop list, and immediately halted expansion. It didn’t attempt to continue expanding &lt;code&gt;t&lt;/code&gt; since the expander has no way of knowing which pieces of &lt;code&gt;(#%type:forall x t)&lt;/code&gt; it should expand! In this case, we want it to recur to expand &lt;code&gt;t&lt;/code&gt;, since it should be a type, but not &lt;code&gt;x&lt;/code&gt;, since &lt;code&gt;#%type:forall&lt;/code&gt; essentially puts &lt;code&gt;x&lt;/code&gt; in binding position.&lt;/p&gt;&lt;p&gt;Therefore, we have to get more clever. We need to call &lt;code&gt;local-expand&lt;/code&gt; to produce a type, then we have to pattern-match on it and subsequently call &lt;code&gt;local-expand&lt;/code&gt; &lt;em&gt;again&lt;/em&gt; on any of the pieces of syntax we want to keep expanding. Eventually, we’ll run out of things to expand, and our type will be fully-expanded.&lt;/p&gt;&lt;p&gt;One good way to do this is to use &lt;code&gt;syntax/parse&lt;/code&gt; syntax classes, since they provide a convenient way for other macros to invoke the type expander. To implement our type expander, we’ll use two mutually recursive syntax classes: one to perform the actual expansion using &lt;code&gt;local-expand&lt;/code&gt; and a second to pattern-match on the resulting expanded type. For example, here’s what these two classes would look like if they only handled &lt;code&gt;#%type:con&lt;/code&gt; and &lt;code&gt;#%type:app&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-literal-set&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
     &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"type"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;:expanded-type&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;expanded-type&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;a:type&lt;/span&gt; &lt;span class="n"&gt;b:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This blog post is definitely &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;syntax/parse&lt;/code&gt; tutorial, so I will not explain in detail everything that’s going on here, but the gist of it is that the above code defines two syntax classes, both of which produce a single output attribute named &lt;code&gt;expansion&lt;/code&gt;. This attribute contains the fully expanded version of the type currently being parsed. In the &lt;code&gt;#%type:con&lt;/code&gt; case, &lt;code&gt;expansion&lt;/code&gt; is just &lt;code&gt;this-syntax&lt;/code&gt;, which holds the current piece of syntax being parsed. This makes sense, since uses of &lt;code&gt;#%type:con&lt;/code&gt; just expand to themselves—expanding &lt;code&gt;(#%type:con Maybe)&lt;/code&gt; should not perform any additional expansion on &lt;code&gt;Maybe&lt;/code&gt;. This is one of Hackett’s atomic types.&lt;/p&gt;&lt;p&gt;In contrast, &lt;code&gt;#%type:app&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; recursively expand its arguments. By annotating its two subforms with &lt;code&gt;:type&lt;/code&gt;, the &lt;code&gt;type&lt;/code&gt; syntax class will invoke &lt;code&gt;local-expand&lt;/code&gt; on each subform, which will in turn use &lt;code&gt;expanded-type&lt;/code&gt; to parse the resulting type. This is what implements the expansion loop that will eventually expand each type completely. Once &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have been expanded, &lt;code&gt;#%type:app&lt;/code&gt; reassembles them into a new syntax object using &lt;code&gt;#'(#%type:app a.expansion b.expansion)&lt;/code&gt;, which replaces their unexpanded versions with their new, expanded versions.&lt;/p&gt;&lt;p&gt;We can see this behavior by writing a small &lt;code&gt;expand-type&lt;/code&gt; function that will expand its argument:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;t:type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use it to observe what happens when we try expanding a type using &lt;code&gt;#%type:app&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; #%type:app: expected type&lt;/span&gt;
&lt;span class="c1"&gt;;      at: Maybe&lt;/span&gt;
&lt;span class="c1"&gt;;      in: (#%type:app Maybe Integer)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Okay, it failed with an error, which is not ideal, but it makes sense. We haven’t actually defined &lt;code&gt;Maybe&lt;/code&gt; or &lt;code&gt;Integer&lt;/code&gt; anywhere. Let’s do so! We can define them as simple macros that expand into uses of &lt;code&gt;#%type:con&lt;/code&gt;, which can be done easily using &lt;a href="http://docs.racket-lang.org/syntax/transformer-helpers.html#%28def._%28%28lib._syntax%2Ftransformer..rkt%29._make-variable-like-transformer%29%29"&gt;&lt;code&gt;make-variable-like-transformer&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;syntax/transformer&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, if we try expanding that same type again:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; (#%type:app (#%type:con Maybe) (#%type:con Integer))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;…it works! Neat. Now we just need to add the cases for the remaining forms in our type language:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;expanded-type&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;a:type&lt;/span&gt; &lt;span class="n"&gt;b:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="n"&gt;t:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;a:type&lt;/span&gt; &lt;span class="n"&gt;b:type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is pretty good already, and to a first approximation, it’s done! However, it doesn’t actually work as well as we’d really like it to. One of the whole points of doing things this way is to allow other macros like &lt;code&gt;let-syntax&lt;/code&gt; to work in types. For example, we ought to be able to create a local type binding with &lt;code&gt;let-syntax&lt;/code&gt; and have it just work. Unfortunately, it doesn’t:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; let-syntax: expected one of these identifiers: `#%type:con&amp;#39;, `#%type:app&amp;#39;, `#%type:forall&amp;#39;, `#%type:qual&amp;#39;, `#%type:bound-var&amp;#39;, `#%type:wobbly-var&amp;#39;, or `#%type:rigid-var&amp;#39;&lt;/span&gt;
&lt;span class="c1"&gt;;     at: letrec-syntaxes+values&lt;/span&gt;
&lt;span class="c1"&gt;;     in: (let-syntax ((Bool (make-variable-like-transformer (syntax Bool)))) (#%type:app Maybe Bool))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What went wrong? And why is it complaining about &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;? Well, if you read the documentation for &lt;code&gt;local-expand&lt;/code&gt;, you’ll find that its behavior is a little more complicated than you might at first believe:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;If &lt;em&gt;&lt;code&gt;stop-ids&lt;/code&gt;&lt;/em&gt; is [a nonempty list containing more than just &lt;code&gt;module*&lt;/code&gt;], then &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;set!&lt;/code&gt;, &lt;code&gt;#%plain-lambda&lt;/code&gt;, &lt;code&gt;case-lambda&lt;/code&gt;, &lt;code&gt;let-values&lt;/code&gt;, &lt;code&gt;letrec-values&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;begin0&lt;/code&gt;, &lt;code&gt;with-continuation-mark&lt;/code&gt;, &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, &lt;code&gt;#%plain-app&lt;/code&gt;, &lt;code&gt;#%expression&lt;/code&gt;, &lt;code&gt;#%top&lt;/code&gt;, and &lt;code&gt;#%variable-reference&lt;/code&gt; are implicitly added to &lt;em&gt;&lt;code&gt;stop-ids&lt;/code&gt;&lt;/em&gt;. Expansion stops when the expander encounters any of the forms in &lt;em&gt;&lt;code&gt;stop-ids&lt;/code&gt;&lt;/em&gt;, and the result is the partially-expanded form.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;That’s a little strange, isn’t it? I am not completely sure why the behavior works quite this way, though I’m sure backwards compatibility plays a significant part, but while some of the behavior seems unnecessary, the issue with &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; (which &lt;code&gt;let-syntax&lt;/code&gt; expands to) is a reasonable one. If the expander naïvely expanded &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; in the presence of a nonempty stop list, it could cause some significant problems!&lt;/p&gt;&lt;p&gt;Allow me to illustrate with an example. Let’s imagine we are the expander, and we are instructed to expand the following program:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We see &lt;code&gt;let-syntax&lt;/code&gt;, so we start by evaluating the expression on the right hand side of the &lt;code&gt;Bool&lt;/code&gt; binding. This produces a transformer expression, so we bind &lt;code&gt;Bool&lt;/code&gt; to the transformer in the local environment, then move onto expanding the body. At this point, the expander is looking at this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;; local bindings:&lt;/span&gt;
&lt;span class="c1"&gt;;   Bool -&amp;gt; #&amp;lt;variable-like-transformer&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, the identifier in application position is &lt;code&gt;#%type:app&lt;/code&gt;, and &lt;code&gt;#%type:app&lt;/code&gt; is in the stop list. Therefore, expansion must stop, and it does not attempt to expand any further. But what should the result of expansion be? Well, the &lt;code&gt;let-syntax&lt;/code&gt; needs to go away when we expand it—local syntax bindings are erased as part of macroexpansion—so the logical thing to expand into is &lt;code&gt;(#%type:app Maybe Bool)&lt;/code&gt;. But this is a problem, because when we then go to expand &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt; isn’t in the local binding table anymore! The &lt;code&gt;let-syntax&lt;/code&gt; was already erased, and &lt;code&gt;Bool&lt;/code&gt; is unbound!&lt;/p&gt;&lt;p&gt;When expanding recursively, this isn’t a problem, since the entire expression is guaranteed to be expanded while the local binding is still in the expander’s environment. As soon as we introduce partial expansion, however, we run the risk of a binding getting erased too early. So we’re stuck: we can’t recursively expand, or we’ll expand too much, but we can’t partially expand, since we might expand too little.&lt;/p&gt;&lt;p&gt;Confronted with this problem, there is some good news and some bad news. The good news is that, while the macroexpander can’t help us, we can help the macroexpander by doing some of the necessary bookkeeping for it. We can do this using first-class definition contexts, which allow us to manually extend the local environment when we call &lt;code&gt;local-expand&lt;/code&gt;. The bad news is that first-class definition contexts are &lt;em&gt;complicated&lt;/em&gt;, and using them properly is a surprisingly subtle problem.&lt;/p&gt;&lt;p&gt;Fortunately, I’ve already spent a lot of time figuring out what needs to be done to properly manipulate the necessary definition contexts in this particular situation. The first step is to parameterize our &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;expanded-type&lt;/code&gt; syntax classes so that we may thread a definition context around as we recursively expand:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"type"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;||&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, we can add an additional case to &lt;code&gt;expanded-type&lt;/code&gt; to handle &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, which will explicitly create a new definition context, add bindings to it, and use it when parsing the body:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
         &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But even this isn’t quite right. The problem with this implementation is that it throws away the existing &lt;code&gt;intdef-ctx&lt;/code&gt; argument to &lt;code&gt;expanded-type&lt;/code&gt;, which means those bindings will be lost as soon as we introduce a new set. To fix this, we have to make the new definition context a &lt;em&gt;child&lt;/em&gt; of the previous definition context by passing the old context as an argument to &lt;code&gt;syntax-local-make-definition-context&lt;/code&gt;. This will ensure the parent bindings are brought into scope when expanding using the child context:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
         &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this in place, our example using &lt;code&gt;let-syntax&lt;/code&gt; actually works!&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; (#%type:app (#%type:con Maybe) (#%type:con Bool))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pretty cool, isn’t it?&lt;/p&gt;&lt;h3&gt;&lt;a name="preserving-syntax-properties-and-source-locations"&gt;&lt;/a&gt;Preserving syntax properties and source locations&lt;/h3&gt;&lt;p&gt;We’ve now managed to essentially implement an expander for our custom language by periodically yielding to the Racket macroexpander, and for the most part, it works. However, our implementation isn’t perfect. The real Racket macroexpander takes great care to preserve source locations and syntax properties on syntax objects wherever possible, which our implementation does not do. Normally we don’t have to worry so much about such things, since the macroexpander automatically copies properties when expanding macros, but since we’re circumventing the expander, we don’t get that luxury. In order to properly preserve this information, we’ll have to be a little more careful.&lt;/p&gt;&lt;p&gt;To start, we really ought to copy the identifier in application position into the output wherever we can. In addition to preserving source location information and syntax properties, it also preserves the even more visible renamings. For example, if a user imports &lt;code&gt;#%type:app&lt;/code&gt; under a different name, like &lt;code&gt;#%type:apply&lt;/code&gt;, we should expand to a piece of syntax that still has &lt;code&gt;#%type:apply&lt;/code&gt; in application position instead of replacing it with &lt;code&gt;#%type:app&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;To do this, we just need to bind each of the identifiers in application position, then use that binding when we produce output. For example, we would adjust the &lt;code&gt;#%type:app&lt;/code&gt; clause to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But even after doing this, some source locations and syntax properties are lost, since we’re still reconstructing the pair from scratch. To ensure we copy &lt;em&gt;everything&lt;/em&gt;, we can define two helper macros, &lt;code&gt;syntax/loc/props&lt;/code&gt; and &lt;code&gt;quasisyntax/loc/props&lt;/code&gt;, which are like &lt;code&gt;syntax/loc&lt;/code&gt; and &lt;code&gt;quasisyntax/loc&lt;/code&gt; but copy properties in addition to source location information:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;syntax-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
          &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr:expr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~describe&lt;/span&gt; &lt;span class="s2"&gt;"template"&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
           &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax?&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-argument-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;#,&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt; &lt;span class="s2"&gt;"syntax?"&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;syntax-id&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-disarm&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-rearm&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-e&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)))]))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;quasisyntax&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using &lt;code&gt;syntax/loc/props&lt;/code&gt;, we can be truly thorough about ensuring all properties are preserved:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Applying this to the other relevant clauses, we get an updated version of the &lt;code&gt;expanded-type&lt;/code&gt; syntax class:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                         &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we’re getting closer, but if you can believe it, even &lt;em&gt;this&lt;/em&gt; isn’t good enough. The real expander’s implementation of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt; does two things our implementation does not: it copies properties and updates the &lt;code&gt;'origin&lt;/code&gt; property to indicate the syntax came from a use of &lt;code&gt;letrec-syntaxes+values&lt;/code&gt;, and it adds a &lt;code&gt;'disappeared-use&lt;/code&gt; property to record the erased bindings for use by tools like DrRacket. We can apply &lt;code&gt;syntax-track-origin&lt;/code&gt; and &lt;code&gt;internal-definition-context-track&lt;/code&gt; to the resulting syntax to add the same properties the expander would:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
         &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
         &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;internal-definition-context-track&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we’ve &lt;em&gt;finally&lt;/em&gt; dotted all our i’s and crossed our t’s. While it does take a lot to properly emulate what the macroexpander is doing, the important thing is that it’s actually possible! The end result of all this definition context juggling and property copying is that we’ve effectively managed to move some of the macroexpander’s logic into userspace code, which allows us to manipulate it as we see fit.&lt;/p&gt;&lt;h3&gt;&lt;a name="connecting-our-custom-language-to-hackett"&gt;&lt;/a&gt;Connecting our custom language to Hackett&lt;/h3&gt;&lt;p&gt;It took a lot of work, but we finally managed to write a custom type language, and while the code is not exactly simple, it’s not actually very long. The entire implementation of our custom type language is less than 80 lines of code:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket/base&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-meta&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/intdef&lt;/span&gt;
                     &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;quasisyntax/loc/props&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;syntax-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
          &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr:expr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~describe&lt;/span&gt; &lt;span class="s2"&gt;"template"&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
           &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx-expr&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax?&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-argument-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;#,&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt; &lt;span class="s2"&gt;"syntax?"&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;syntax-id&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-disarm&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-rearm&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-e&lt;/span&gt; &lt;span class="n"&gt;stx*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt; &lt;span class="n"&gt;from-stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)))]))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;syntax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-syntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;quasisyntax/loc/props&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;quasisyntax&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntaxes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
                  &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="s2"&gt;"cannot be used as an expression"&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;
            &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt; &lt;span class="n"&gt;type-literal&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:qual&lt;/span&gt;
          &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-literal-set&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;#%type:app&lt;/span&gt; &lt;span class="n"&gt;#%type:forall&lt;/span&gt; &lt;span class="n"&gt;#%type:qual&lt;/span&gt;
     &lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;intdef-ctx&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"type"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;||&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;local-expand&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;type-literal-ids&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expanded-type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="kd"&gt;#:commit&lt;/span&gt;
    &lt;span class="kd"&gt;#:literal-sets&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kernel-literals&lt;/span&gt; &lt;span class="n"&gt;type-literals&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:letrec-syntaxes+values&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;id:id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;e:expr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;t:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-make-definition-context&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                         &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-bind-syntaxes&lt;/span&gt; &lt;span class="n"&gt;ids&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
             &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;internal-definition-context-track&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx*&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t*.expansion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-track-origin&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:con&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:app&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:forall&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;x:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head:#%type:qual&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;intdef-ctx&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax/loc/props&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;
                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;a.expansion&lt;/span&gt; &lt;span class="n"&gt;b.expansion&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:bound-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:wobbly-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%type:rigid-var&lt;/span&gt; &lt;span class="n"&gt;~!&lt;/span&gt; &lt;span class="n"&gt;_:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt; &lt;span class="n"&gt;this-syntax&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;expand-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;t:type&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;t.expansion&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what now? Just as Racket fully-expanded programs are useless without a compiler to turn them into something useful, our custom type language doesn’t do anything at all in isolation. As it happens, in the case of the type language, we don’t have a compiler at all—we have a &lt;em&gt;typechecker&lt;/em&gt;. The Hackett typechecker consumes fully-expanded types as input and uses them to perform its typechecking process. The actual implementation of Hackett’s typechecker is outside the scope of this blog post, since it’s really an entirely separate problem, but you can probably imagine what such a thing might look like, in an extremely vague, handwavy sense.&lt;/p&gt;&lt;p&gt;But we don’t &lt;em&gt;just&lt;/em&gt; need a typechecker. Just as the authors of Racket don’t expect users to write programs using the core forms directly, we also don’t expect users to write their types using the fully-expanded syntax. If we did, all this fancy expansion machinery would be pretty pointless! Hackett provides a custom &lt;code&gt;#%app&lt;/code&gt; binding that converts n-ary type applications to nested uses of &lt;code&gt;#%type:app&lt;/code&gt;, as well as a nicer &lt;code&gt;forall&lt;/code&gt; macro that supports specifying multiple type variables and multiple typeclass constraints all at once. The best part, though, is that these macros can be defined in a completely straightforward way, just as any ordinary Racket macro would be written, and the machinery will work precisely as intended. It’s also perfectly okay to have two different versions of &lt;code&gt;#%app&lt;/code&gt;—one for types and one for values—since &lt;a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/"&gt;Hackett supports multiple namespaces&lt;/a&gt;, and each can have its own &lt;code&gt;#%app&lt;/code&gt; binding.&lt;/p&gt;&lt;p&gt;The real implementation of Hackett’s type language is a little bit longer than the one in this blog post because it includes some extra definitions to provide custom &lt;code&gt;syntax/parse&lt;/code&gt; pattern expanders for matching types and some template metafunctions for producing them, which are used by the typechecker, but if you’d like to see the whole thing, &lt;a href="https://github.com/lexi-lambda/hackett/blob/ba64193da38f63dab2523f42c1b7614cdfa8c935/hackett-lib/hackett/private/type-language.rkt"&gt;it’s available on GitHub here&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name="evaluation-limitations-and-acknowledgements"&gt;&lt;/a&gt;Evaluation, limitations, and acknowledgements&lt;/h2&gt;&lt;p&gt;Reimplementing Hackett’s type language took about a week and a half, about half of which was supplemented by the extra time I had before I started &lt;a href="https://twitter.com/lexi_lambda/status/976533916596097024"&gt;my new job&lt;/a&gt; this past week. A portion of that time was spent deciding what I actually wanted to do, and a lot of it was spent hunting down fiddly bugs. All told, the rewrite resulted in a net addition of 250 lines of code to the Hackett codebase. However, 350 of the added lines reside in a new, self-contained module dedicated to Hackett’s type language, so the change actually resulted in a net &lt;em&gt;removal&lt;/em&gt; of 100 lines from the rest of the codebase, which I consider an organizational win.&lt;/p&gt;&lt;p&gt;As for whether or not the change will accomplish the goals I had in mind, I think signs currently point to a strong likelihood of the answer being yes. The very same night I finalized and merged the changes to the type language, I dusted off an old prototype of typeclass deriving I had not been able to get working due to insufficiencies of the old type representation. Not only was I &lt;a href="https://twitter.com/lexi_lambda/status/985051504867446786"&gt;able to get it working&lt;/a&gt; quickly and easily, I was able to do it in &lt;a href="https://twitter.com/lexi_lambda/status/985052476473856000"&gt;no more than 20 lines of code&lt;/a&gt;. While the implementation is not as robust as it should ideally be, nor is it safe or simple enough yet to be easy for Hackett users to write themselves, making the impossible possible is usually a sign of motion in the right direction.&lt;/p&gt;&lt;p&gt;Unfortunately, the technique outlined in this blog post is not completely flawless. Due to its reliance on the &lt;code&gt;local-expand&lt;/code&gt; stop list, this technique is incompatible with macros that force recursive expansion using an empty stop list. In the upcoming reimplementation of the Racket macroexpander to be released in Racket 7, this includes &lt;code&gt;syntax-parameterize&lt;/code&gt;, which unfortunately means syntax parameters don’t work in the type language. This is a problem, and while it’s not a dealbreaker, it is something that will almost certainly have to be fixed at some point. Fortunately, it isn’t intractable, and I’ve been discussing some potential approaches to fixing the problem, whether via changes to the macroexpander or by making macros like &lt;code&gt;syntax-parameterize&lt;/code&gt; cooperate better with things like Hackett’s type language.&lt;/p&gt;&lt;p&gt;Finally, as seems to be the case more and more with my blog posts, I cannot express enough thanks to &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, without whose help I would probably not have been able to get everything working (not to mention that the Racket macro system would not exist without Matthew inventing and implementing it nearly singlehandedly). Matthew does an almost unfathomable number of things for Racket already without me pestering him with questions, bug reports, and feature requests, but he’s always patient and helpful all the same. Also, once again, I’d like to thank &lt;a href="http://www.ccs.neu.edu/home/ryanc/"&gt;Ryan Culpepper&lt;/a&gt; for &lt;a href="https://www2.ccs.neu.edu/racket/pubs/dissertation-culpepper.pdf"&gt;his incredible work on constructing tools for the working macro developer&lt;/a&gt;, including writing the fantastic &lt;code&gt;syntax/parse&lt;/code&gt; library that powers essentially everything I do. Thank you both.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>An opinionated guide to Haskell in 2018</title><link>https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/</guid><pubDate>10 Feb 2018</pubDate><description>&lt;article&gt;&lt;p&gt;For me, this month marks the end of an era in my life: as of February 2018, I am no longer employed writing Haskell. It’s been a fascinating two years, and while I am excitedly looking forward to what I’ll be doing next, it’s likely I will continue to write Haskell in my spare time. I’ll probably even write it again professionally in the future.&lt;/p&gt;&lt;p&gt;In the meantime, in the interest of both sharing with others the small amount of wisdom I’ve gained and preserving it for my future self, I’ve decided to write a long, rather dry overview of a few select parts of the Haskell workflow I developed and the ecosystem I settled into. This guide is, as the title notes, &lt;em&gt;opinionated&lt;/em&gt;—it is what I used in my day-to-day work, nothing more—and I don’t claim that anything here is the only way to write Haskell, nor even the best way. It is merely what I found helpful and productive. Take from it as much or as little as you’d like.&lt;/p&gt;&lt;h2&gt;&lt;a name="build-tools-and-how-to-use-them"&gt;&lt;/a&gt;Build tools and how to use them&lt;/h2&gt;&lt;p&gt;When it comes to building Haskell, you have options. And frankly, most of them are pretty good. There was a time when &lt;code&gt;cabal-install&lt;/code&gt; had a (warranted) reputation for being nearly impossible to use and regularly creating dependency hell, but I don’t think that’s the case anymore (though you &lt;em&gt;do&lt;/em&gt; need to be a little careful about how you use it). Sandboxed builds work alright, and &lt;code&gt;cabal new-build&lt;/code&gt; and the other &lt;code&gt;cabal new-*&lt;/code&gt; commands are even better. That said, the UX of &lt;code&gt;cabal-install&lt;/code&gt; is still less-than-stellar, and it has sharp edges, especially for someone coming from an ecosystem without a heavyweight compilation process like JavaScript, Ruby, or Python.&lt;/p&gt;&lt;p&gt;Nix is an alternative way to manage Haskell dependencies, and it seems pretty cool. It has a reputation for being large and complicated, and that reputation does not seem especially unfair, but you get lots of benefits if you’re willing to pay the cost. Unfortunately, I have never used it (though I’ve read a lot about it), so I can’t comment much on it here. Perhaps I’ll try to go all-in with Nix when I purchase my next computer, but for now, my workflow works well enough that I don’t feel compelled to switch.&lt;/p&gt;&lt;p&gt;Personally, I use &lt;code&gt;stack&lt;/code&gt; as my Haskell build tool. It’s easy to use, it works out of the box, and while it doesn’t enjoy the same amount of caching as &lt;code&gt;cabal new-build&lt;/code&gt; or Nix, it caches most packages, and it also makes things like git-hosted sources incredibly easy, which (as far as I can tell) can’t be done with &lt;code&gt;cabal-install&lt;/code&gt; alone.&lt;/p&gt;&lt;p&gt;This section is going to be a guide on how &lt;em&gt;I&lt;/em&gt; use &lt;code&gt;stack&lt;/code&gt;. If you use &lt;code&gt;cabal-install&lt;/code&gt; with or without Nix, great! Those tools seem good, too. This is not an endorsement of &lt;code&gt;stack&lt;/code&gt; over the other build tools, just a description of how I use it, the issues I ran into, and my solutions to them.&lt;/p&gt;&lt;h3&gt;&lt;a name="understanding-stack-s-model-and-avoiding-its-biggest-gotcha"&gt;&lt;/a&gt;Understanding &lt;code&gt;stack&lt;/code&gt;’s model and avoiding its biggest gotcha&lt;/h3&gt;&lt;p&gt;Before using &lt;code&gt;stack&lt;/code&gt;, there are a few things every programmer should know:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;stack&lt;/code&gt; is not a package manager, it is a build tool. It does not manage a set of “installed” packages; it simply builds targets and their dependencies.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The command to build a target is &lt;code&gt;stack build &amp;lt;target&amp;gt;&lt;/code&gt;. Just using &lt;code&gt;stack build&lt;/code&gt; on its own will build the current project’s targets.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;You almost certainly do not want to use &lt;code&gt;stack install&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This is the biggest point of confusion I see among new users of &lt;code&gt;stack&lt;/code&gt;. After all, when you want to install a package with &lt;code&gt;npm&lt;/code&gt;, you type &lt;code&gt;npm install &amp;lt;package&amp;gt;&lt;/code&gt;. So a new Haskeller decides to install &lt;code&gt;lens&lt;/code&gt;, types &lt;code&gt;stack install lens&lt;/code&gt;, and then later tries &lt;code&gt;stack uninstall lens&lt;/code&gt;, only to discover that no such command exists. What happened?&lt;/p&gt;&lt;p&gt;&lt;code&gt;stack install&lt;/code&gt; is not like &lt;code&gt;npm install&lt;/code&gt;. &lt;code&gt;stack install&lt;/code&gt; is like &lt;code&gt;make install&lt;/code&gt;. It is nothing more than an alias for &lt;code&gt;stack build --copy-bins&lt;/code&gt;, and &lt;em&gt;all&lt;/em&gt; it does is build the target and copy all of its executables into some relatively global location like &lt;code&gt;~/.local/bin&lt;/code&gt;. This is usually not what you want.&lt;/p&gt;&lt;p&gt;This design decision is not unique to &lt;code&gt;stack&lt;/code&gt;; &lt;code&gt;cabal-install&lt;/code&gt; suffers from it as well. One can argue that it isn’t unintuitive because it really is just following what &lt;code&gt;make install&lt;/code&gt; conventionally does, and the fact that it happens to conflict with things like &lt;code&gt;npm install&lt;/code&gt; or even &lt;code&gt;apt-get install&lt;/code&gt; is just a naming clash. I think that argument is a poor one, however, and I think the decision to even include a &lt;code&gt;stack install&lt;/code&gt; command was a bad idea.&lt;/p&gt;&lt;p&gt;So, remember: don’t use &lt;code&gt;stack install&lt;/code&gt;! &lt;code&gt;stack&lt;/code&gt; works best when everything lives inside the current project’s &lt;em&gt;local&lt;/em&gt; sandbox, and &lt;code&gt;stack install&lt;/code&gt; copies executables into a &lt;em&gt;global&lt;/em&gt; location by design. While it might sometimes appear to work, it’s almost always wrong. The &lt;em&gt;only&lt;/em&gt; situation in which &lt;code&gt;stack install&lt;/code&gt; is the right answer is when you want to install an executable for a use unrelated to Haskell development (that is, something like &lt;code&gt;pandoc&lt;/code&gt;) that just so happens to be provided by a Haskell package. &lt;strong&gt;This means no running &lt;code&gt;stack install ghc-mod&lt;/code&gt; or &lt;code&gt;stack install intero&lt;/code&gt; either, no matter what READMEs might tell you!&lt;/strong&gt; Don’t worry: I’ll cover the proper way to install those things later.&lt;/p&gt;&lt;h3&gt;&lt;a name="actually-building-your-project-with-stack"&gt;&lt;/a&gt;Actually building your project with &lt;code&gt;stack&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Okay, so now that you know to never use &lt;code&gt;stack install&lt;/code&gt;, what &lt;em&gt;do&lt;/em&gt; you use? Well, &lt;code&gt;stack build&lt;/code&gt; is probably all you need. Let’s cover some variations of &lt;code&gt;stack build&lt;/code&gt; that I use most frequently.&lt;/p&gt;&lt;p&gt;Once you have a &lt;code&gt;stack&lt;/code&gt; project, you can build it by simply running &lt;code&gt;stack build&lt;/code&gt; within the project directory. However, for local development, this is usually unnecessarily slow because it runs the GHC optimizer. For faster development build times, pass the &lt;code&gt;--fast&lt;/code&gt; flag to disable optimizations:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack build --fast
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By default, &lt;code&gt;stack&lt;/code&gt; builds dependencies with coarse-grained, package-level parallelism, but you can enable more fine-grained, module-level parallel builds by adding &lt;code&gt;--ghc-options=-j&lt;/code&gt;. Unfortunately, there are conflicting accounts on whether or not this actually makes things faster or slower in practice, and I haven’t extensively tested to see whether or not this is the case, so I mostly leave it off.&lt;/p&gt;&lt;p&gt;Usually, you also want to build and run the tests along with your code, which you can enable with the &lt;code&gt;--test&lt;/code&gt; flag. Additionally, &lt;code&gt;stack test&lt;/code&gt; is an alias for &lt;code&gt;stack build --test&lt;/code&gt;, so these two commands are equivalent:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack build --fast --test
$ stack test --fast
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, it is useful to build documentation as well as code! You can do this by passing the &lt;code&gt;--haddock&lt;/code&gt; flag, but unfortunately, I find Haddock sometimes takes an unreasonably long time to run. Therefore, since I usually only care about running Haddock on my dependencies, I usually pass the &lt;code&gt;--haddock-deps&lt;/code&gt; flag instead, which prevents having to re-run Haddock every time you build:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack test --fast --haddock-deps
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, I usually want to build and test my project in the background whenever my code changes. Fortunately, this can be done easily by using the &lt;code&gt;--file-watch&lt;/code&gt; flag, making it easy to incrementally change project code and immediately see results:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack test --fast --haddock-deps --file-watch
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the command I usually use to develop my Haskell projects.&lt;/p&gt;&lt;h3&gt;&lt;a name="accessing-local-documentation"&gt;&lt;/a&gt;Accessing local documentation&lt;/h3&gt;&lt;p&gt;While Haskell does not always excel on the documentation front, a small amount of documentation is almost always better than no documentation at all, and I find my dependencies’ documentation to be an invaluable resource while developing. I find many people just look at docs on Hackage or use the hosted instance of Hoogle, but this sometimes leads people astray: they might end up looking at the wrong version of the documentation! Fortunately, there’s an easy solution to this problem, which is to browse the documentation &lt;code&gt;stack&lt;/code&gt; installs locally, which is guaranteed to match the version you are using in your current project.&lt;/p&gt;&lt;p&gt;The easiest way to open local documentation for a particular package is to use the &lt;code&gt;stack haddock --open&lt;/code&gt; command. For example, to open the documentation for &lt;code&gt;lens&lt;/code&gt;, you could use the following command:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack haddock --open lens
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will open the local documentation in your web browser, and you can browse it at your leisure. If you have already built the documentation using the &lt;code&gt;--haddock-deps&lt;/code&gt; option I recommended in the previous section, this command should complete almost instantly, but if you haven’t built the documentation yet, you’ll have to wait as &lt;code&gt;stack&lt;/code&gt; builds it for you on-demand.&lt;/p&gt;&lt;p&gt;While this is a good start, it isn’t perfect. Ideally, I want to have &lt;em&gt;searchable&lt;/em&gt; documentation, and fortunately, this is possible to do by running Hoogle locally. This is easy enough with modern versions of &lt;code&gt;stack&lt;/code&gt;, which have built-in Hoogle integration, but it still requires a little bit of per-project setup, since you need to build the Hoogle search index with the following command:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack hoogle -- generate --local
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will install Hoogle into the current project if it isn’t already installed, and it will index your dependencies’ documentation and generate a new Hoogle database. Once you’ve done that, you can start a web server that serves a local Hoogle search page with the following command:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack hoogle -- server --local --port=8080
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Navigate to &lt;code&gt;http://localhost:8080&lt;/code&gt; in your web browser, and you’ll have a fully-searchable index of all your Haskell packages’ documentation. Isn’t that neat?&lt;/p&gt;&lt;p&gt;Unfortunately, you &lt;em&gt;will&lt;/em&gt; have to manually regenerate the Hoogle database when you install new packages and their documentation, which you can do by re-running &lt;code&gt;stack hoogle -- generate --local&lt;/code&gt;. Fortunately, regenerating the database doesn’t take very long, as long as you’ve been properly rebuilding the documentation with &lt;code&gt;--haddock-deps&lt;/code&gt;.&lt;/p&gt;&lt;h3&gt;&lt;a name="configuring-your-project"&gt;&lt;/a&gt;Configuring your project&lt;/h3&gt;&lt;p&gt;Every project built with &lt;code&gt;stack&lt;/code&gt; is configured with two separate files:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The &lt;code&gt;stack.yaml&lt;/code&gt; file, which controls which packages are built and what versions to pin your dependencies to.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The &lt;code&gt;&amp;lt;project&amp;gt;.cabal&lt;/code&gt; file &lt;em&gt;or&lt;/em&gt; &lt;code&gt;package.yaml&lt;/code&gt; file, which specifies build targets, their dependencies, and which GHC options to apply, among other things.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The &lt;code&gt;.cabal&lt;/code&gt; file is, ultimately, what is used to build your project, but modern versions of &lt;code&gt;stack&lt;/code&gt; generate projects that use hpack, which uses an alternate configuration file, the &lt;code&gt;package.yaml&lt;/code&gt; file, to generate the &lt;code&gt;.cabal&lt;/code&gt; file. This can get a little bit confusing, since it means you have &lt;em&gt;three&lt;/em&gt; configuration files in your project, one of which is generated from the other one.&lt;/p&gt;&lt;p&gt;I happen to use and like hpack, so I use a &lt;code&gt;package.yaml&lt;/code&gt; file and allow hpack to generate the &lt;code&gt;.cabal&lt;/code&gt; file. I have no real love for YAML, and in fact I think custom configuration formats are completely fine, but the primary advantage of hpack is the ability to specify things like GHC options and default language extensions for all targets at once, instead of needing to duplicate them per-target.&lt;/p&gt;&lt;p&gt;You can think of the &lt;code&gt;.cabal&lt;/code&gt; or &lt;code&gt;package.yaml&lt;/code&gt; file as a specification for &lt;em&gt;how&lt;/em&gt; your project is built and &lt;em&gt;what packages&lt;/em&gt; it depends on, but the &lt;code&gt;stack.yaml&lt;/code&gt; file is a specification of precisely &lt;em&gt;which version&lt;/em&gt; of each package should be used and where it should be fetched from. Also, each &lt;code&gt;.cabal&lt;/code&gt; file corresponds to precisely &lt;em&gt;one&lt;/em&gt; Haskell package (though it may have any number of executable targets), but a &lt;code&gt;stack.yaml&lt;/code&gt; file can specify multiple different packages to build, useful for multi-project builds that share a common library. The details here can be a little confusing, more than I am likely going to be able to explain in this blog post, but for the most part, you can get away with the defaults unless you’re doing something fancy.&lt;/p&gt;&lt;h3&gt;&lt;a name="setting-up-editor-integration"&gt;&lt;/a&gt;Setting up editor integration&lt;/h3&gt;&lt;p&gt;Currently, I use Atom to write Haskell. Atom is not a perfect editor by any means, and it leaves a lot to be desired, but it’s easy to set up, and the Haskell editor integration is decent.&lt;/p&gt;&lt;p&gt;Atom’s editor integration is powered by &lt;code&gt;ghc-mod&lt;/code&gt;, a program that uses the GHC API to provide tools to inspect Haskell programs. Installing &lt;code&gt;ghc-mod&lt;/code&gt; must be done manually so that Atom’s &lt;code&gt;haskell-ghc-mod&lt;/code&gt; package can find it, and this is where a lot of people get tripped up. They run &lt;code&gt;stack install ghc-mod&lt;/code&gt;, it installs &lt;code&gt;ghc-mod&lt;/code&gt; into &lt;code&gt;~/.local/bin&lt;/code&gt;, they put that in their &lt;code&gt;PATH&lt;/code&gt;, and things work! …except when a new version of GHC is released a few months later, everything stops working.&lt;/p&gt;&lt;p&gt;As mentioned above, &lt;strong&gt;&lt;code&gt;stack install&lt;/code&gt; is not what you want&lt;/strong&gt;. Tools like &lt;code&gt;ghc-mod&lt;/code&gt;, &lt;code&gt;hlint&lt;/code&gt;, &lt;code&gt;hoogle&lt;/code&gt;, &lt;code&gt;weeder&lt;/code&gt;, and &lt;code&gt;intero&lt;/code&gt; work best when installed as part of the sandbox, &lt;em&gt;not&lt;/em&gt; globally, since that ensures they will match the current GHC version your project is using. This can be done per-project using the ordinary &lt;code&gt;stack build&lt;/code&gt; command, so the easiest way to properly install &lt;code&gt;ghc-mod&lt;/code&gt; into a &lt;code&gt;stack&lt;/code&gt; project is with the following command:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack build ghc-mod
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unfortunately, this means you will need to run that command inside every single &lt;code&gt;stack&lt;/code&gt; project individually in order to properly set it up so that &lt;code&gt;stack exec -- ghc-mod&lt;/code&gt; will find the correct executable. One way to circumvent this is by using a recently-added &lt;code&gt;stack&lt;/code&gt; flag designed for this explicit purpose, &lt;code&gt;--copy-compiler-tool&lt;/code&gt;. This is like &lt;code&gt;--copy-bins&lt;/code&gt;, but it copies the executables into a &lt;em&gt;compiler-specific location&lt;/em&gt;, so a tool built for GHC 8.0.2 will be stored separately from the same tool built for GHC 8.2.2. &lt;code&gt;stack exec&lt;/code&gt; arranges for the executables for the current compiler version to end up in the &lt;code&gt;PATH&lt;/code&gt;, so you only need to build and install your tools once per compiler version.&lt;/p&gt;&lt;p&gt;Does this kind of suck? Yes, a little bit, but it sucks a whole lot less than all your editor integration breaking every time you switch to a project that uses a different version of GHC. I use the following command in a fresh sandbox when a Stackage LTS comes out for a new version of GHC:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack build --copy-compiler-tool ghc-mod hoogle weeder
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This way, I only have to build those tools once, and I don’t worry about rebuilding them again until a the next release of GHC. To verify that things are working properly, you should be able to create a fresh &lt;code&gt;stack&lt;/code&gt; project, run a command like this one, and get a similar result:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ stack exec -- which ghc-mod
/Users/alexis/.stack/compiler-tools/x86_64-osx/ghc-8.2.2/bin/ghc-mod
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that this path is scoped to my operating system and my compiler version, but nothing else—no LTS or anything like that.&lt;/p&gt;&lt;h2&gt;&lt;a name="warning-flags-for-a-safe-build"&gt;&lt;/a&gt;Warning flags for a safe build&lt;/h2&gt;&lt;p&gt;Haskell is a relatively strict language as programming languages go, but in my experience, it isn’t quite strict enough. Many things are not errors that probably ought to be, like orphan instances and inexhaustive pattern matches. Fortunately, GHC provides &lt;em&gt;warnings&lt;/em&gt; that catch these problems statically, which fill in the gaps. I recommend using the following flags on all projects to ensure everything is caught:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wall"&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wcompat"&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-record-updates"&gt;&lt;code&gt;-Wincomplete-record-updates&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-uni-patterns"&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wredundant-constraints"&gt;&lt;code&gt;-Wredundant-constraints&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wall"&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; option turns on &lt;em&gt;most&lt;/em&gt; warnings, but (ironically) not all of them. The &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Weverything"&gt;&lt;code&gt;-Weverything&lt;/code&gt;&lt;/a&gt; flag truly turns on &lt;em&gt;all&lt;/em&gt; warnings, but some of the warnings left disabled by &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wall"&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; really are quite silly, like warning when type signatures on polymorphic local bindings are omitted. Some of them, however, are legitimately useful, so I recommend turning them on explicitly.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wcompat"&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; enables warnings that make your code more robust in the face of future backwards-incompatible changes. These warnings are trivial to fix and serve as free future-proofing, so I see no reason not to turn these warnings on.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-record-updates"&gt;&lt;code&gt;-Wincomplete-record-updates&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-uni-patterns"&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt; are things I think ought to be enabled by &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wall"&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; because they both catch what are essentially partial pattern-matches (and therefore runtime errors waiting to happen). The fact that &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-uni-patterns"&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt; &lt;em&gt;isn’t&lt;/em&gt; enabled by &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wall"&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; is so surprising that it can lead to bugs being overlooked, since the extremely similar &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-patterns"&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; &lt;em&gt;is&lt;/em&gt; enabled by &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wall"&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wredundant-constraints"&gt;&lt;code&gt;-Wredundant-constraints&lt;/code&gt;&lt;/a&gt; is a useful warning that helps to eliminate unnecessary typeclass constraints on functions, which can sometimes occur if a constraint was previously necessary but ends up becoming redundant due to a change in the function’s behavior.&lt;/p&gt;&lt;p&gt;I put all five of these flags in the &lt;code&gt;.cabal&lt;/code&gt; file (or &lt;code&gt;package.yaml&lt;/code&gt;), which enables them everywhere, but this alone is unlikely to enforce a warning-free codebase, since the build will still succeed even in the presence of warnings. Therefore, when building projects in CI, I pass the &lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Werror"&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag (using &lt;code&gt;--ghc-options=-Werror&lt;/code&gt; for &lt;code&gt;stack&lt;/code&gt;), which treats warnings as errors and halts the build if any warnings are found. This is useful, since it means warnings don’t halt the whole build while developing, making it possible to write some code that has warnings and still run the test suite, but it still enforces that pushed code be warning-free.&lt;/p&gt;&lt;h2&gt;&lt;a name="any-flavor-you-like"&gt;&lt;/a&gt;Any flavor you like&lt;/h2&gt;&lt;p&gt;Haskell is both a language and a spectrum of languages. It is both a standard and a specific implementation. Haskell 98 and Haskell 2010 are good, small languages, and there are a few different implementations, but when people talk about “Haskell”, unqualified, they’re almost always talking about GHC.&lt;/p&gt;&lt;p&gt;GHC Haskell, in stark contrast to standard Haskell, is neither small nor particularly specific, since GHC ships with &lt;em&gt;dozens&lt;/em&gt; of knobs and switches that can be used to configure the language. In theory, this is a little terrifying. How could anyone ever hope to talk about Haskell and agree upon how to write it if there are so many &lt;em&gt;different&lt;/em&gt; Haskells, each a little bit distinct? Having a cohesive ecosystem would be completely hopeless.&lt;/p&gt;&lt;p&gt;Fortunately, in practice, this is not nearly as bad as it seems. The majority of GHC extensions are simple switches: a feature is either on or it is off. Turning a feature on rarely affects code that does not use it, so most extensions can be turned on by default, and programmers may simply avoid the features they do not wish to use, just as any programmer in any programming language likely picks a subset of their language’s features to use on a daily basis. Writing Haskell is not different in this regard, only in the sense that it does not allow all features to be used by default; everything from minor syntactic tweaks to entirely new facets of the type system are opt-in.&lt;/p&gt;&lt;p&gt;Frankly, I think the UX around this is terrible. I recognize the desire to implement a standard Haskell, and the old &lt;code&gt;-fglasgow-exts&lt;/code&gt; was not an especially elegant solution for people wishing to use nonstandard Haskell, but having to insert &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas at the top of every module just to take advantage of the best features GHC has to offer is a burden, and it is unnecessarily intimidating. I think much of the Haskell community finds the use of &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas preferable to enabling extensions globally using the &lt;code&gt;default-extensions&lt;/code&gt; list in the &lt;code&gt;.cabal&lt;/code&gt; file, but I cut across the grain on that issue &lt;em&gt;hard&lt;/em&gt;. The vast majority of language extensions I use are extensions I want enabled all the time; a list of them at the top of a module is just distracting noise, and it only serves to bury the extensions I really do want to enable on a module-by-module basis. It also makes it tricky to communicate with a team which extensions are acceptable (or even preferable) and which are discouraged.&lt;/p&gt;&lt;p&gt;My &lt;em&gt;&lt;strong&gt;strong&lt;/strong&gt;&lt;/em&gt; recommendation if you decide to write GHC Haskell on a team is to agree as a group to a list of extensions the team is happy with enabling everywhere and putting those extensions in the &lt;code&gt;default-extensions&lt;/code&gt; list in the &lt;code&gt;.cabal&lt;/code&gt; file. This eliminates clutter, busywork, and the conceptual overhead of remembering which extensions are in favor, and which are discouraged. This is a net win, and it isn’t at all difficult to look in the &lt;code&gt;.cabal&lt;/code&gt; file when you want to know which extensions are in use.&lt;/p&gt;&lt;p&gt;Now, with that small digression out of the way, the question becomes precisely which extensions should go into that &lt;code&gt;default-extensions&lt;/code&gt; list. I happen to like using most of the features GHC makes available, so I enable a whopping &lt;strong&gt;34&lt;/strong&gt; language extensions &lt;em&gt;by default&lt;/em&gt;. As of GHC 8.2, here is my list:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XApplicativeDo"&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XBangPatterns"&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XConstraintKinds"&gt;&lt;code&gt;ConstraintKinds&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDataKinds"&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDefaultSignatures"&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveFoldable"&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveFunctor"&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveGeneric"&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveLift"&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveTraversable"&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDerivingStrategies"&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XEmptyCase"&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XExistentialQuantification"&gt;&lt;code&gt;ExistentialQuantification&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFlexibleContexts"&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFlexibleInstances"&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFunctionalDependencies"&gt;&lt;code&gt;FunctionalDependencies&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs"&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGeneralizedNewtypeDeriving"&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XInstanceSigs"&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XKindSignatures"&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XLambdaCase"&gt;&lt;code&gt;LambdaCase&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMultiParamTypeClasses"&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMultiWayIf"&gt;&lt;code&gt;MultiWayIf&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XNamedFieldPuns"&gt;&lt;code&gt;NamedFieldPuns&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XOverloadedStrings"&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XPatternSynonyms"&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XRankNTypes"&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XScopedTypeVariables"&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XStandaloneDeriving"&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTupleSections"&gt;&lt;code&gt;TupleSections&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeApplications"&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilies"&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilyDependencies"&gt;&lt;code&gt;TypeFamilyDependencies&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeOperators"&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This is a lot, and a few of them are likely to be more controversial than others. Since I do not imagine everyone will agree with everything in this list, I’ve broken it down into smaller chunks, arranged from what I think ought to be least controversial to most controversial, along with a little bit of justification why each extension is in each category. If you’re interested in coming up with your own list of extensions, the rest of this section is for you.&lt;/p&gt;&lt;h3&gt;&lt;a name="trivial-lifting-of-standards-imposed-limitations"&gt;&lt;/a&gt;Trivial lifting of standards-imposed limitations&lt;/h3&gt;&lt;p&gt;A few extensions are tiny changes that lift limitations that really have no reason to exist, other than that they are mandated by the standard. I am not sure why these restrictions are in the standard to begin with, other than perhaps a misguided attempt at making the language simpler. These extensions include the following:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XEmptyCase"&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFlexibleContexts"&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFlexibleInstances"&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XInstanceSigs"&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMultiParamTypeClasses"&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;These extensions have no business &lt;em&gt;not&lt;/em&gt; being turned on everywhere. &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFlexibleContexts"&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFlexibleInstances"&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt; end up being turned on in almost any nontrivial Haskell module, since without them, the typeclass system is pointlessly and artificially limited.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XInstanceSigs"&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/a&gt; is extremely useful, completely safe, and has zero downsides.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMultiParamTypeClasses"&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; are almost impossible to avoid, given how many libraries use them, and they are a completely obvious generalization of single-parameter typeclasses. Much like &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFlexibleContexts"&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFlexibleInstances"&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, I see no real reason to ever leave these disabled.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XEmptyCase"&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt; is even stranger to me, since &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XEmptyDataDecls"&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; is in Haskell 2010, so it’s possible to define empty datatypes in standard Haskell but not exhaustively pattern-match on them! This is silly, and &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XEmptyCase"&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt; should be standard Haskell.&lt;/p&gt;&lt;h3&gt;&lt;a name="syntactic-conveniences"&gt;&lt;/a&gt;Syntactic conveniences&lt;/h3&gt;&lt;p&gt;A few GHC extensions are little more than trivial, syntactic abbreviations. These things would be tiny macros in a Lisp, but they need to be extensions to the compiler in Haskell:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XLambdaCase"&gt;&lt;code&gt;LambdaCase&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMultiWayIf"&gt;&lt;code&gt;MultiWayIf&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XNamedFieldPuns"&gt;&lt;code&gt;NamedFieldPuns&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTupleSections"&gt;&lt;code&gt;TupleSections&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;All of these extensions are only triggered by explicit use of new syntax, so existing programs will never change behavior when these extensions are introduced.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XLambdaCase"&gt;&lt;code&gt;LambdaCase&lt;/code&gt;&lt;/a&gt; only saves a few characters, but it eliminates the need to come up with a fresh, unique variable name that will only be used once, which is sometimes hard to do and leads to worse names overall. Sometimes, it really is better to leave something unnamed.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMultiWayIf"&gt;&lt;code&gt;MultiWayIf&lt;/code&gt;&lt;/a&gt; isn’t something I find I commonly need, but when I do, it’s nice to have. It’s far easier to read than nested &lt;code&gt;if...then...else&lt;/code&gt; chains, and it uses the existing guard syntax already used with function declarations and &lt;code&gt;case...of&lt;/code&gt;, so it’s easy to understand, even to those unfamiliar with the extension.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XNamedFieldPuns"&gt;&lt;code&gt;NamedFieldPuns&lt;/code&gt;&lt;/a&gt; avoids headaches and clutter when using Haskell records without the &lt;a href="https://www.reddit.com/r/haskell/comments/6jaa5f/recordwildcards_and_binary_parsing/djd5ugj/"&gt;accidental identifier capture issues&lt;/a&gt; of &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XRecordWildCards"&gt;&lt;code&gt;RecordWildCards&lt;/code&gt;&lt;/a&gt;. It’s a nice, safe compromise that brings some of the benefits of &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XRecordWildCards"&gt;&lt;code&gt;RecordWildCards&lt;/code&gt;&lt;/a&gt; without any downsides.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTupleSections"&gt;&lt;code&gt;TupleSections&lt;/code&gt;&lt;/a&gt; is a logical generalization of tuple syntax in the same vein as standard operator sections, and it’s quite useful when using applicative notation. I don’t see any reason to not enable it.&lt;/p&gt;&lt;h3&gt;&lt;a name="extensions-to-the-deriving-mechanism"&gt;&lt;/a&gt;Extensions to the deriving mechanism&lt;/h3&gt;&lt;p&gt;GHC’s typeclass deriving mechanism is one of the things that makes Haskell so pleasant to write, and in fact I think Haskell would be nearly unpalatable to write without it. Boilerplate generation is a good thing, since it defines operations in terms of a single source of truth, and generated code is code you do not need to maintain. There is rarely any reason to write a typeclass instance by hand when the deriving mechanism will write it automatically.&lt;/p&gt;&lt;p&gt;These extensions give GHC’s typeclass deriving mechanism more power without any cost. Therefore, I see no reason &lt;em&gt;not&lt;/em&gt; to enable them:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveFoldable"&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveFunctor"&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveGeneric"&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveLift"&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveTraversable"&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDerivingStrategies"&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGeneralizedNewtypeDeriving"&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XStandaloneDeriving"&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The first five of these simply extend the list of typeclasses GHC knows how to derive, something that will only ever be triggered if the user explicitly requests GHC derive one of those classes. &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGeneralizedNewtypeDeriving"&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is quite possibly one of the most important extensions in all of Haskell, since it dramatically improves &lt;code&gt;newtype&lt;/code&gt;s’ utility. Wrapper types can inherit instances they need without any boilerplate, and making increased type safety easier and more accessible is always a good thing in my book.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDerivingStrategies"&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; is new to GHC 8.2, but it finally presents the functionality of GHC’s &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveAnyClass"&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extension in a useful way. &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveAnyClass"&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is useful when used with certain libraries that use &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDefaultSignatures"&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt; (discussed later) with &lt;code&gt;GHC.Generics&lt;/code&gt; to derive instances of classes without the deriving being baked into GHC. Unfortunately, enabling &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveAnyClass"&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; essentially disables the far more useful &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGeneralizedNewtypeDeriving"&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;, so I do &lt;em&gt;not&lt;/em&gt; recommend enabling &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDeriveAnyClass"&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;. Fortunately, with &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDerivingStrategies"&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt;, it’s possible to opt into the &lt;code&gt;anyclass&lt;/code&gt; deriving strategy on a case-by-case basis, getting some nice boilerplate reduction in the process.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XStandaloneDeriving"&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; is useful when GHC’s deriving algorithms aren’t &lt;em&gt;quite&lt;/em&gt; clever enough to deduce the instance context automatically, so it allows specifying it manually. This is only useful in a few small situations, but it’s nice to have, and there are no downsides to enabling it, so it ought to be turned on.&lt;/p&gt;&lt;h3&gt;&lt;a name="lightweight-syntactic-adjustments"&gt;&lt;/a&gt;Lightweight syntactic adjustments&lt;/h3&gt;&lt;p&gt;A couple extensions tweak Haskell’s syntax in more substantial ways than things like &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XLambdaCase"&gt;&lt;code&gt;LambdaCase&lt;/code&gt;&lt;/a&gt;, but not in a significant enough way for them to really be at all surprising:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XBangPatterns"&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XKindSignatures"&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeOperators"&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XBangPatterns"&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt; mirror strictness annotations on datatypes, so they are unlikely to be confusing, and they provide a much more pleasant notation for annotating the strictness of bindings than explicit uses of &lt;code&gt;seq&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XKindSignatures"&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt; are also fairly self-explanatory: they’re just like type annotations, but for types instead of values. Writing kind signatures explicitly is usually unnecessary, but they can be helpful for clarity or for annotating phantom types when &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XPolyKinds"&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is not enabled. Enabling &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XKindSignatures"&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt; doesn’t have any adverse effects, so I see no reason not to enable it everywhere.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeOperators"&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; adjusts the syntax of types slightly, allowing operators to be used as type constructors and written infix, which is technically backwards-incompatible, but I’m a little suspicious of anyone using &lt;code&gt;(!@#$)&lt;/code&gt; as a type variable (especially since standard Haskell does not allow them to be written infix). This extension is useful with some libraries like &lt;code&gt;natural-transformations&lt;/code&gt; that provide infix type constructors, and it makes the type language more consistent with the value language.&lt;/p&gt;&lt;h3&gt;&lt;a name="polymorphic-string-literals"&gt;&lt;/a&gt;Polymorphic string literals&lt;/h3&gt;&lt;p&gt;I’m putting this extension in a category all of its own, mostly because I don’t think any other Haskell extensions have quite the same set of tradeoffs:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XOverloadedStrings"&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;For me, &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XOverloadedStrings"&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is not optional. Haskell’s infamous “string problem” (discussed in more detail at the end of this blog post) means that &lt;code&gt;String&lt;/code&gt; is a linked list of characters, and all code that cares about performance actually uses &lt;code&gt;Text&lt;/code&gt;. Manually invoking &lt;code&gt;pack&lt;/code&gt; on every single string literal in a program is just noise, and &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XOverloadedStrings"&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; solves that noise.&lt;/p&gt;&lt;p&gt;That said, I actually find I don’t use the polymorphism of string literals very often, and I’d be alright with monomorphic literals if I could make them &lt;em&gt;all&lt;/em&gt; have type &lt;code&gt;Text&lt;/code&gt;. Unfortunately, there isn’t a way to do this, so &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XOverloadedStrings"&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is the next best thing, even if it sometimes causes some unnecessary ambiguities that require type annotations to resolve.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XOverloadedStrings"&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is an extension that I use so frequently, in so many modules (especially in my test suites) that I would rather keep it on everywhere so I don’t have to care about whether or not it’s enabled in the module I’m currently writing. On the other hand, it certainly isn’t my favorite language extension, either. I wouldn’t go as far as to call it a necessary evil, since I don’t think it’s truly “evil”, but it does seem to be necessary.&lt;/p&gt;&lt;h3&gt;&lt;a name="simple-extensions-to-aid-type-annotation"&gt;&lt;/a&gt;Simple extensions to aid type annotation&lt;/h3&gt;&lt;p&gt;The following two extensions significantly round out Haskell’s language for referring to types, making it much easier to insert type annotations where necessary (for removing ambiguity or for debugging type errors):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XScopedTypeVariables"&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeApplications"&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;That the behavior of &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XScopedTypeVariables"&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; the default is actually one of the most common gotchas for new Haskellers. Sadly, it can theoretically adjust the behavior of existing Haskell programs, so I cannot include it in the list of trivial changes, but I would argue such programs were probably confusing to begin with, and I have never seen a program in practice that was impacted by that problem. I think leaving &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XScopedTypeVariables"&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; off is much, much more likely to be confusing than turning it on.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeApplications"&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; is largely unrelated, but I include it in this category because it’s quite useful and cooperates well with &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XScopedTypeVariables"&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;. Use of &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeApplications"&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; makes instantiation much more lightweight than full-blown type annotations, and once again, it has no downsides if it is enabled and unused (since it is a syntactic addition). I recommend enabling it.&lt;/p&gt;&lt;h3&gt;&lt;a name="simple-extensions-to-the-haskell-type-system"&gt;&lt;/a&gt;Simple extensions to the Haskell type system&lt;/h3&gt;&lt;p&gt;A few extensions tweak the Haskell type system in ways that I think are simple enough to be self-explanatory, even to people who might not have known they existed. These are as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XConstraintKinds"&gt;&lt;code&gt;ConstraintKinds&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XRankNTypes"&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XConstraintKinds"&gt;&lt;code&gt;ConstraintKinds&lt;/code&gt;&lt;/a&gt; is largely just used to define typeclass aliases, which is both useful and self-explanatory. Unifying the type and constraint language also has the effect of allowing type-level programming with constraints, which is sometimes useful, but far rarer in practice than the aforementioned use case.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XRankNTypes"&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; are uncommon, looking at the average type in a Haskell program, but they’re certainly nice to have when you need them. The idea of pushing &lt;code&gt;forall&lt;/code&gt;s further into a type to adjust how variables are quantified is something that I find people find fairly intuitive, especially after seeing them used once or twice, and higher-rank types do crop up regularly, if infrequently.&lt;/p&gt;&lt;h3&gt;&lt;a name="intermediate-syntactic-adjustments"&gt;&lt;/a&gt;Intermediate syntactic adjustments&lt;/h3&gt;&lt;p&gt;Three syntactic extensions to Haskell are a little bit more advanced than the ones I’ve already covered, and none of them are especially related:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XApplicativeDo"&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDefaultSignatures"&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XPatternSynonyms"&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XApplicativeDo"&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; is, on the surface, simple. It changes &lt;code&gt;do&lt;/code&gt; notation to use &lt;code&gt;Applicative&lt;/code&gt; operations where possible, which allows using &lt;code&gt;do&lt;/code&gt; notation with applicative functors that are not monads, and it also makes operations potentially more performant when &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; can be implemented more efficiently than &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt;. In theory, it sounds like there are no downsides to enabling this everywhere. However, there are are a few drawbacks that lead me to put it so low on this list:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;It considerably complicates the desugaring of &lt;code&gt;do&lt;/code&gt; blocks, to the point where the algorithm cannot even be easily syntactically documented. In fact, an additional compiler flag, &lt;code&gt;-foptimal-applicative-do&lt;/code&gt;, is a way to &lt;em&gt;opt into&lt;/em&gt; optimal solutions for &lt;code&gt;do&lt;/code&gt; block expansions, tweaking the desugaring algorithm to have an &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt;) time complexity! This means that the default behavior is guided by a heuristic, and desugaring isn’t even especially predictable. This isn’t necessarily so bad, since it’s really only intended as an optimization when some &lt;code&gt;Monad&lt;/code&gt; operations are still necessary, but it does dramatically increase the complexity of one of Haskell’s core forms.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The desugaring, despite being &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;) by default, isn’t even especially clever. It relies on a rather disgusting hack that recognizes &lt;code&gt;return e&lt;/code&gt;, &lt;code&gt;return $ e&lt;/code&gt;, &lt;code&gt;pure e&lt;/code&gt;, or &lt;code&gt;pure $ e&lt;/code&gt; expressions &lt;em&gt;syntactically&lt;/em&gt;, and it completely gives up if an expression with precisely that shape is not the final statement in a &lt;code&gt;do&lt;/code&gt; block. This is a bit awkward, since it effectively turns &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;pure&lt;/code&gt; into syntax when before they were merely functions, but that isn’t all. It also means that the following &lt;code&gt;do&lt;/code&gt; block is &lt;em&gt;not&lt;/em&gt; desugared using &lt;code&gt;Applicative&lt;/code&gt; operations:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;do&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
   &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;
   &lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will use the normal, monadic desugaring, despite the fact that it is trivially desugared into &lt;code&gt;Applicative&lt;/code&gt; operations as &lt;code&gt;foo a b *&amp;gt; bar s t *&amp;gt; baz y z&lt;/code&gt;. In order to get &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XApplicativeDo"&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; to trigger here, the &lt;code&gt;do&lt;/code&gt; block must be contorted into the following:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;do&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
   &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;
   &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;
   &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This seems like an odd oversight.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTemplateHaskell"&gt;&lt;code&gt;TemplateHaskell&lt;/code&gt;&lt;/a&gt; doesn’t seem able to cope with &lt;code&gt;do&lt;/code&gt; blocks when &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XApplicativeDo"&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; is enabled. I reported this as &lt;a href="https://ghc.haskell.org/trac/ghc/ticket/14471"&gt;an issue on the GHC bug tracker&lt;/a&gt;, but it hasn’t received any attention, so it’s not likely to get fixed unless someone takes the initiative to do so.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Enabling &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XApplicativeDo"&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; can cause problems with code that may have assumed &lt;code&gt;do&lt;/code&gt; would always be monadic, and sometimes, that can cause code that typechecks to lead to an infinite loop at runtime. Specifically, if &lt;code&gt;do&lt;/code&gt; notation is used to define &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; in terms of &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt;, enabling &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XApplicativeDo"&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; will cause the definition of &lt;code&gt;(&amp;lt;*&amp;gt;)&lt;/code&gt; to become self-referential and therefore divergent. Fortunately, this issue can be easily mitigated by simply writing &lt;code&gt;(&amp;lt;*&amp;gt;) = ap&lt;/code&gt; instead, which is clearer and shorter than the equivalent code using &lt;code&gt;do&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Given all these things, it seems &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XApplicativeDo"&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; is a little too new in a few places, and it isn’t quite baked. Still, I keep it enabled by default. Why? Well, &lt;em&gt;usually&lt;/em&gt; it works fine without any problems, and when I run into issues, I can disable it on a per-module basis by writing &lt;code&gt;{-# LANGUAGE NoApplicativeDo #-}&lt;/code&gt;. I still find that keeping it enabled by default is fine the vast majority of the time, I just sometimes need to work around the bugs.&lt;/p&gt;&lt;p&gt;In contrast, &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDefaultSignatures"&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt; isn’t buggy at all, as far as I can tell, it’s just not usually useful without fairly advanced features like &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs"&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; (for type equalities) or &lt;code&gt;GHC.Generics&lt;/code&gt;. I mostly use it for &lt;a href="/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/"&gt;making lifting instances for &lt;code&gt;mtl&lt;/code&gt;-style typeclasses easier to write&lt;/a&gt;, which I’ve found to be a tiny bit tricky to explain (mostly due to the use of type equalities in the context), but it works well. I don’t see any real reason to leave this disabled, but if you don’t think you’re going to use it anyway, it doesn’t really matter one way or the other.&lt;/p&gt;&lt;p&gt;Finally, &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XPatternSynonyms"&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt; allow users to extend the pattern language just as they are allowed to extend the value language. Bidirectional pattern synonyms are isomorphisms, and it’s quite useful to allow those isomorphisms to be used with Haskell’s usual pattern-matching syntax. I think this extension is actually quite benign, but I put it so low on this list because it seems infrequently used, and I get the sense most people consider it fairly advanced. I would argue, however, that it’s a very pleasant, useful extension, and it’s no more complicated than a number of the features in Haskell 98.&lt;/p&gt;&lt;h3&gt;&lt;a name="intermediate-extensions-to-the-haskell-type-system"&gt;&lt;/a&gt;Intermediate extensions to the Haskell type system&lt;/h3&gt;&lt;p&gt;Now we’re getting into the meat of things. Everything up to this point has been, in my opinion, completely self-evident in its usefulness and simplicity. As far as I’m concerned, the extensions in the previous six sections have no business ever being left disabled. Starting in this section, however, I could imagine a valid argument being made either way.&lt;/p&gt;&lt;p&gt;The following three extensions add some complexity to the Haskell type system in return for some added expressive power:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XExistentialQuantification"&gt;&lt;code&gt;ExistentialQuantification&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFunctionalDependencies"&gt;&lt;code&gt;FunctionalDependencies&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs"&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XExistentialQuantification"&gt;&lt;code&gt;ExistentialQuantification&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs"&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; are related, given that the former is subsumed by the latter, but &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs"&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; also enables an alternative syntax. Both syntaxes allow packing away a typeclass dictionary or equality constraint that is brought into scope upon a successful pattern-match against a data constructor, something that is sometimes quite useful but certainly a departure from Haskell’s simple ADTs.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFunctionalDependencies"&gt;&lt;code&gt;FunctionalDependencies&lt;/code&gt;&lt;/a&gt; extend multi-parameter typeclasses, and they are almost unavoidable, given their use in the venerable &lt;code&gt;mtl&lt;/code&gt; library. Like &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs"&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFunctionalDependencies"&gt;&lt;code&gt;FunctionalDependencies&lt;/code&gt;&lt;/a&gt; add an additional layer of complexity to the typeclass system in order to express certain things that would otherwise be difficult or impossible.&lt;/p&gt;&lt;p&gt;All of these extensions involve a tradeoff. Enabling &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs"&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; also implies &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMonoLocalBinds"&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;, which disables let generalization, one of the most likely ways a program that used to typecheck might subsequently fail to do so. Some might argue that this is a good reason to turn &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs"&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; on in a per-module basis, but I disagree: I actually want my language to be fairly consistent, and given that I know I am likely going to want to use &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XGADTs"&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; &lt;em&gt;somewhere&lt;/em&gt;, I want &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMonoLocalBinds"&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; enabled &lt;em&gt;everywhere&lt;/em&gt;, not inconsistently and sporadically.&lt;/p&gt;&lt;p&gt;That aside, all these extensions are relatively safe. They are well-understood, and they are fairly self-contained extensions to the Haskell type system. I think these extensions have a very good power to cost ratio, and I find myself using them regularly (especially &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFunctionalDependencies"&gt;&lt;code&gt;FunctionalDependencies&lt;/code&gt;&lt;/a&gt;), so I keep them enabled globally.&lt;/p&gt;&lt;h3&gt;&lt;a name="advanced-extensions-to-the-haskell-type-system"&gt;&lt;/a&gt;Advanced extensions to the Haskell type system&lt;/h3&gt;&lt;p&gt;Finally, we arrive at the last set of extensions in this list. These are the most advanced features Haskell’s type system currently has to offer, and they are likely to be the most controversial to enable globally:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDataKinds"&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilies"&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilyDependencies"&gt;&lt;code&gt;TypeFamilyDependencies&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;All of these extensions exist exclusively for the purpose of type-level programming. &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDataKinds"&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt; allows datatype promotion, creating types that are always uninhabited and therefore can only be used phantom. &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilies"&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; allows the definition of type-level functions that map types to other types. Both of these are minor extensions to Haskell’s surface area, but they have rather significant ramifications on the sort of programming that can be done and the way GHC’s typechecker must operate.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilies"&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; is an interesting extension because it comes in so many flavors: associated type synonyms, associated datatypes, open and closed type synonym families, and open and closed datatype families. Associated types tend to be easier to grok and easier to use, though they can also be replaced by functional dependencies. Open type families are also quite similar to classes and instances, so they aren’t &lt;em&gt;too&lt;/em&gt; tricky to understand. Closed type families, on the other hand, are a rather different beast, and they can be used to do fairly advanced things, &lt;em&gt;especially&lt;/em&gt; in combination with &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDataKinds"&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;I happen to appreciate GHC’s support for these features, and while I’m hopeful that an eventual &lt;code&gt;DependentHaskell&lt;/code&gt; will alleviate many of the existing infelicities with dependently typed programming in GHC, in the meantime, it’s often useful to enjoy what exists where practically applicable. Therefore, I have little problem keeping them enabled, since, like the vast majority of extensions on this list, these extensions merely lift restrictions, not adjust semantics of the language without the extensions enabled. When I am going to write a type family, I am going to turn on &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilies"&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;; I see no reason to annotate the modules in which I decide to do so. I do not write an annotation at the top of each module in which I define a typeclass or a datatype, so why should I do so with type families?&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilyDependencies"&gt;&lt;code&gt;TypeFamilyDependencies&lt;/code&gt;&lt;/a&gt; is a little bit different, since it’s a very new extension, and it doesn’t seem to always work as well as I would hope. Still, when it doesn’t work, it fails with a very straightforward error message, and when it works, it is legitimately useful, so I don’t see any real reason to leave it off if &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilies"&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; is enabled.&lt;/p&gt;&lt;h3&gt;&lt;a name="extensions-intentionally-left-off-this-list"&gt;&lt;/a&gt;Extensions intentionally left off this list&lt;/h3&gt;&lt;p&gt;Given what I’ve said so far, it may seem like I would advocate flipping on absolutely every lever GHC has to offer, but that isn’t actually true. There are a few extensions I quite intentionally do &lt;em&gt;not&lt;/em&gt; enable.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XUndecidableInstances"&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; is something I turn on semi-frequently, since GHC’s termination heuristic is not terribly advanced, but I turn it on per-module, since it’s useful to know when it’s necessary (and in application code, it rarely is). &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XOverlappingInstances"&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XIncoherentInstances"&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;, in contrast, are completely banned—not only are they almost always a bad idea, GHC has a better, more fine-grained way to opt into overlapping instances, using the &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt;, and &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt; pragmas.&lt;/p&gt;&lt;p&gt;&lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTemplateHaskell"&gt;&lt;code&gt;TemplateHaskell&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XQuasiQuotes"&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; are tricky ones. Anecdotes seem to suggest that enabling &lt;a href="https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTemplateHaskell"&gt;&lt;code&gt;TemplateHaskell&lt;/code&gt;&lt;/a&gt; everywhere leads to worse compile times, but after trying this on a few projects and measuring, I wasn’t able to detect any meaningful difference. Unless I manage to come up with some evidence that these extensions actually slow down compile times just by being &lt;em&gt;enabled&lt;/em&gt;, even if they aren’t used, then I may add them to my list of globally-enabled extensions, since I use them regularly.&lt;/p&gt;&lt;p&gt;Other extensions I haven’t mentioned are probably things I just don’t use very often and therefore haven’t felt the need to include on this list. It certainly isn’t exhaustive, and I add to it all the time, so I expect I will continue to do so in the future. This is just what I have for now, and if your favorite extension isn’t included, it probably isn’t a negative judgement against that extension. I just didn’t think to mention it.&lt;/p&gt;&lt;h2&gt;&lt;a name="libraries-a-field-guide"&gt;&lt;/a&gt;Libraries: a field guide&lt;/h2&gt;&lt;p&gt;Now that you’re able to build a Haskell project and have chosen which handpicked flavor of Haskell you are going to write, it’s time to decide which libraries to use. Haskell is an expressive programming language, and the degree to which different libraries can shape the way you structure your code is significant. Picking the right libraries can lead to clean code that’s easy to understand and maintain, but picking the wrong ones can lead to disaster.&lt;/p&gt;&lt;p&gt;Of course, there are &lt;em&gt;thousands&lt;/em&gt; of Haskell libraries on Hackage alone, so I cannot hope to cover all of the ones I have ever found useful, and I certainly cannot cover ones that would be useful but I did not have the opportunity to try (of which there are certainly many). This blog post is long enough already, so I’ll just cover a few categories of libraries that I think I can offer interesting commentary on; most libraries can generally speak for themselves.&lt;/p&gt;&lt;h3&gt;&lt;a name="having-an-effect"&gt;&lt;/a&gt;Having an effect&lt;/h3&gt;&lt;p&gt;One of the first questions Haskell programmers bump into when they begin working on a large application is how they’re going to model effects. Few practical programming languages are pure, but Haskell is one of them, so there’s no getting away from coming up with a way to manage side-effects.&lt;/p&gt;&lt;p&gt;For some applications, Haskell’s built-in solution might be enough: &lt;code&gt;IO&lt;/code&gt;. This can work decently for data processing programs that do very minimal amounts of I/O, and the types of side-effects they perform are minimal. For these applications, most of the logic is likely to be pure, which means it’s already easy to reason about and easy to test. For other things, like web applications, it’s more likely that a majority of the program logic is going to be side-effectful by its nature—it may involve making HTTP requests to other services, interacting with a database, and writing to logfiles.&lt;/p&gt;&lt;p&gt;Figuring out how to structure these effects in a type-safe, decoupled, composable way can be tricky, especially since Haskell has so many different solutions. I could not bring myself to choose just one, but I did choose two: the so-called “&lt;code&gt;mtl&lt;/code&gt; style” and freer monads.&lt;/p&gt;&lt;p&gt;&lt;code&gt;mtl&lt;/code&gt; style is so named because it is inspired by the technique of interlocking monadic typeclasses and lifting instances used to model effects using constraints that is used in the &lt;a href="https://hackage.haskell.org/package/mtl"&gt;&lt;code&gt;mtl&lt;/code&gt;&lt;/a&gt; library. Here is a small code example of what &lt;code&gt;mtl&lt;/code&gt; style typeclasses and handlers look like:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;

  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Prelude&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readFile&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Prelude&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;writeFile&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MaybeT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;InMemoryFileSystemT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;InMemoryFileSystemT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;InMemoryFileSystemT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;InMemoryFileSystemT&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;vfs&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;
    &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;lookup&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;vfs&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
      &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;
      &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"readFile: no such file "&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;InMemoryFileSystemT&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;modify&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;vfs&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;vfs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the most prevalent way to abstract over effects in Haskell, and it’s been around for a long time. Due to the way it uses the typeclass system, it’s also very fast, since GHC can often specialize and inline the typeclass dictionaries to avoid runtime dictionary passing. The main drawbacks are the amount of boilerplate required and the conceptual difficulty of understanding exactly how monad transformers, monadic typeclasses, and lifting instances all work together to discharge &lt;code&gt;mtl&lt;/code&gt; style constraints.&lt;/p&gt;&lt;p&gt;There are various alternatives to &lt;code&gt;mtl&lt;/code&gt;’s direct approach to effect composition, most of which are built around the idea of reifying a computation as a data structure and subsequently interpreting it. The most popular of these is the &lt;code&gt;Free&lt;/code&gt; monad, a clever technique for deriving a monad from a functor that happens to be useful for modeling programs. Personally, I think &lt;code&gt;Free&lt;/code&gt; is overhyped. It’s a cute, mathematically elegant technique, but it involves a lot of boilerplate, and composing effect algebras is still a laborious process. The additional expressive power of &lt;code&gt;Free&lt;/code&gt;, namely its ability to choose an interpreter dynamically, at runtime, is rarely necessary or useful, and it adds complexity and reduces performance for few benefits. (And in fact, this is still possible to do with &lt;code&gt;mtl&lt;/code&gt; style, it’s just uncommon because there is rarely any need to do so.)&lt;/p&gt;&lt;p&gt;A 2017 blog post entitled &lt;a href="https://markkarpov.com/post/free-monad-considered-harmful.html"&gt;Free monad considered harmful&lt;/a&gt; discussed &lt;code&gt;Free&lt;/code&gt; in comparison with &lt;code&gt;mtl&lt;/code&gt; style, and unsurprisingly cast &lt;code&gt;Free&lt;/code&gt; in a rather unflattering light. I largely agree with everything outlined in that blog post, so I will not retread its arguments here. I do, however, think that there is another abstraction that &lt;em&gt;is&lt;/em&gt; quite useful: the so-called “freer monad” used to implement extensible effects.&lt;/p&gt;&lt;p&gt;Freer moves even further away from worrying about functors and monads, since its effect algebras do not even need to be functors. Instead, freer’s effect algebras are ordinary GADTs, and reusable, composable effect handlers are easily written to consume elements of these datatypes. Unfortunately, the way this works means that GHC is still not clever enough to optimize freer monads as efficiently as &lt;code&gt;mtl&lt;/code&gt; style, since it can’t easily detect when the interpreter is chosen statically and use that information to specialize and inline effect implementations, but the cost difference is significantly reduced, and I’ve found that in real application code, the vast majority of the cost does not come from the extra overhead introduced by a more expensive &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;There are a few different implementations of freer monads, but I, sadly, was not satisfied with any of them, so I decided to contribute to the problem by creating yet another one. My implementation is called &lt;a href="https://hackage.haskell.org/package/freer-simple"&gt;&lt;code&gt;freer-simple&lt;/code&gt;&lt;/a&gt;, and it includes a streamlined API with &lt;a href="https://hackage.haskell.org/package/freer-simple-1.0.1.1/docs/Control-Monad-Freer.html"&gt;more documentation than any other freer implementation&lt;/a&gt;. Writing the above &lt;code&gt;mtl&lt;/code&gt; style example using &lt;code&gt;freer-simple&lt;/code&gt; is more straightforward:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;FileSystem&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;ReadFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FileSystem&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
  &lt;span class="kt"&gt;WriteFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FileSystem&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;

&lt;span class="nf"&gt;readFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Member&lt;/span&gt; &lt;span class="kt"&gt;FileSystem&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Eff&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;span class="nf"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;send&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;ReadFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="nf"&gt;writeFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Member&lt;/span&gt; &lt;span class="kt"&gt;FileSystem&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Eff&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;send&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kt"&gt;WriteFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nf"&gt;runFileSystemIO&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;LastMember&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Eff&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FileSystem&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: r) ~&amp;gt; Eff r&lt;/span&gt;
&lt;span class="nf"&gt;runFileSystemIO&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;interpretM&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;case&lt;/span&gt;
  &lt;span class="kt"&gt;ReadFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Prelude&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="kt"&gt;WriteFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Prelude&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nf"&gt;runFileSystemInMemory&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Eff&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FileSystem&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: effs) ~&amp;gt; Eff effs&lt;/span&gt;
&lt;span class="nf"&gt;runFileSystemInMemory&lt;/span&gt; &lt;span class="n"&gt;initVfs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;runState&lt;/span&gt; &lt;span class="n"&gt;initVfs&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;fsToState&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;fsToState&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Eff&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FileSystem&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;: effs) ~&amp;gt; Eff (State [(FilePath, String)]&lt;/span&gt;&lt;span class="sc"&gt; &amp;#39;&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;effs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;fsToState&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;reinterpret&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt;
    &lt;span class="kt"&gt;ReadFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;vfs&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;lookup&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;vfs&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
      &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;
      &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"readFile: no such file "&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kt"&gt;WriteFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;modify&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;vfs&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;vfs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(It could be simplified further with a little bit of Template Haskell to generate the &lt;code&gt;readFile&lt;/code&gt; and &lt;code&gt;writeFile&lt;/code&gt; function definitions, but I haven’t gotten around to writing that.)&lt;/p&gt;&lt;p&gt;So which effect system do I recommend? I used to recommend &lt;code&gt;mtl&lt;/code&gt; style, but as of only two months ago, I now recommend &lt;code&gt;freer-simple&lt;/code&gt;. It’s easier to understand, involves less boilerplate, achieves “good enough” performance, and generally gets out of the way wherever possible. Its API is designed to make it easy to do the sorts of the things you most commonly need to do, and it provides a core set of effects that can be used to build a real-world application.&lt;/p&gt;&lt;p&gt;That said, freer is indisputably relatively new and relatively untested. It has success stories, but &lt;code&gt;mtl&lt;/code&gt; style is still the approach used by the majority of the ecosystem. &lt;code&gt;mtl&lt;/code&gt; style has more library support, its performance characteristics are better understood, and it is a tried and true way to structure effects in a Haskell application. If you understand it well enough to use it, and you are happy with it in your application, my recommendation is to stick with it. If you find it confusing, however, or you end up running up against its limits, give &lt;code&gt;freer-simple&lt;/code&gt; a try.&lt;/p&gt;&lt;h3&gt;&lt;a name="through-the-looking-glass-to-lens-or-not-to-lens"&gt;&lt;/a&gt;Through the looking glass: to lens or not to lens&lt;/h3&gt;&lt;p&gt;There’s no getting around it: &lt;a href="https://hackage.haskell.org/package/lens"&gt;&lt;code&gt;lens&lt;/code&gt;&lt;/a&gt; is a behemoth of a library. For a long time, I wrote Haskell without it, and honestly, it worked out alright. I just wasn’t doing a whole lot of work that involved complicated, deeply-nested data structures, and I didn’t feel the need to bring in a library with such a reputation for having impenetrable operators and an almost equally impenetrable learning curve.&lt;/p&gt;&lt;p&gt;But, after some time, I decided I wanted to take the plunge. So I braced myself for the worst, pulled out my notebook, and started writing some code. To my surprise… it wasn’t that hard. It made sense. Sure, I still don’t know how it works on the inside, and I never did learn the majority of the exports in &lt;code&gt;Control.Lens.Operators&lt;/code&gt;, but I had no need to. Lenses were useful in the way I had expected them to be, and so were prisms. One thing led to another, and before long, I understood the relationship between the various optics, the most notable additions to my toolkit being folds and traversals. Sure, the type errors were completely opaque much of the time, but I was able to piece things together with ample type annotations and time spent staring at ill-typed expressions. Before long, I had developed an intuition for &lt;code&gt;lens&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;After using it for a while, I retrospected on whether or not I liked it, and honestly, I still can’t decide. Some lensy expressions were straightforward to read and were a pleasant simplification, like this one:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;paramSpecs&lt;/span&gt; &lt;span class="o"&gt;^..&lt;/span&gt; &lt;span class="n"&gt;folded&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_Required&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Others were less obviously improvements, such as this beauty:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kt"&gt;M&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fromList&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;paramSpecs&lt;/span&gt; &lt;span class="o"&gt;^..&lt;/span&gt; &lt;span class="n"&gt;folded&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filtered&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;_2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_UsePreviousValue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But operator soup aside, there was something deeper about &lt;code&gt;lens&lt;/code&gt; that bothered me, and I just wasn’t sure what. I didn’t know how to articulate my vague feelings until I read a 2014 blog post entitled &lt;a href="https://ro-che.info/articles/2014-04-24-lens-unidiomatic"&gt;Lens is unidiomatic Haskell&lt;/a&gt;, which includes a point that I think is spot-on:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Usually, types in Haskell are rigid. This leads to a distinctive style of composing programs: look at the types and see what fits where. This is impossible with &lt;code&gt;lens&lt;/code&gt;, which takes overloading to the level mainstream Haskell probably hasn’t seen before.&lt;/p&gt;&lt;p&gt;We have to learn the new language of the &lt;code&gt;lens&lt;/code&gt; combinators and how to compose them, instead of enjoying our knowledge of how to compose Haskell functions. Formally, &lt;code&gt;lens&lt;/code&gt; types are Haskell function types, but while with ordinary Haskell functions you immediately see from types whether they can be composed, with &lt;code&gt;lens&lt;/code&gt; functions this is very hard in practice.&lt;/p&gt;&lt;p&gt;[…]&lt;/p&gt;&lt;p&gt;Now let me clarify that this doesn’t necessarily mean that &lt;code&gt;lens&lt;/code&gt; is a bad library. It’s an &lt;em&gt;unusual&lt;/em&gt; library. It’s almost a separate language, with its own idioms, embedded in Haskell.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The way &lt;code&gt;lens&lt;/code&gt; structures its types deliberately introduces a sort of subtyping relationship—for example, all lenses are traversals and all traversals are folds, but not vice versa—and indeed, knowing this subtyping relationship is essential to working with the library and understanding how to use it. It is helpfully documented with a large diagram on &lt;a href="https://hackage.haskell.org/package/lens"&gt;the &lt;code&gt;lens&lt;/code&gt; package overview page&lt;/a&gt;, and that diagram was most definitely an invaluable resource for me when I was learning how to use the library.&lt;/p&gt;&lt;p&gt;On the surface, this isn’t unreasonable. Subtyping is an enormously useful concept! The only reason Haskell dispenses with it entirely is because it makes type inference notoriously difficult. The subtyping relation between optics is one of the things that makes them so useful, since it allows you to easily compose a lens with a prism and get a traversal out. Unfortunately, the downside of all this is that Haskell does not truly have subtyping, so all of &lt;code&gt;lens&lt;/code&gt;’s “types” really must be type aliases for types of roughly the same shape, namely functions. This makes type errors completely &lt;em&gt;baffling&lt;/em&gt;, since the errors do not mention the aliases, only the fully-expanded types (which are often rather complicated, and their meaning is not especially clear without knowing how &lt;code&gt;lens&lt;/code&gt; works under the hood).&lt;/p&gt;&lt;p&gt;So the above quote is correct: working with &lt;code&gt;lens&lt;/code&gt; really &lt;em&gt;is&lt;/em&gt; like working in a separate embedded language, but I’m usually okay with that. Embedded, domain-specific languages are good! Unfortunately, in this case, the host language is not very courteous to its guest. Haskell does not appear to be a powerful enough language for &lt;code&gt;lens&lt;/code&gt; to be a language in its own right, so it must piggyback on top of Haskell’s error reporting mechanisms, which are insufficient for &lt;code&gt;lens&lt;/code&gt; to be a cohesive linguistic abstraction. Just as debugging code by stepping through the assembly it produces (or, perhaps more relevant in 2018, debugging a compile-to-JS language by looking at the emitted JavaScript instead of the source code) makes for an unacceptably leaky language. We would never stand for such a thing in our general-purpose language tooling, and we should demand better even in our embedded languages.&lt;/p&gt;&lt;p&gt;That said, &lt;code&gt;lens&lt;/code&gt; is just too useful to ignore. It is a hopelessly leaky abstraction, but it’s still an abstraction, and a powerful one at that. Given my selection of default extensions as evidence, I think it’s clear I have zero qualms with “advanced” Haskell; I will happily use even &lt;code&gt;singletons&lt;/code&gt; where it makes sense. Haskell’s various language extensions are sometimes confusing in their own right, but their complexity is usually fundamental to the expressive power they bring. &lt;code&gt;lens&lt;/code&gt; has some fundamental complexity, too, but it is mostly difficult for the wrong reasons. Still, while it is not the first library I reach for on every new Haskell project, manipulating nested data without &lt;code&gt;lens&lt;/code&gt; is just too unpleasant after tasting the nectar, so I can’t advise against it in good faith.&lt;/p&gt;&lt;p&gt;Sadly, this means I’m a bit wishy-washy when it comes to using &lt;code&gt;lens&lt;/code&gt;, but I do have at least one recommendation: if you decide to use &lt;code&gt;lens&lt;/code&gt;, it’s better to go all-in. Don’t generate lenses for just a handful of datatypes, do it for &lt;em&gt;all&lt;/em&gt; of them. You can definitely stick to a subset of the &lt;code&gt;lens&lt;/code&gt; library’s features, but don’t apply it in some functions but not others. Having too many different, equally valid ways of doing things leads to confusion and inconsistency, and inconsistency minimizes code reuse and leads to duplication and spaghetti. Commit to using &lt;code&gt;lens&lt;/code&gt;, or don’t use it at all.&lt;/p&gt;&lt;h3&gt;&lt;a name="mitigating-the-string-problem"&gt;&lt;/a&gt;Mitigating the string problem&lt;/h3&gt;&lt;p&gt;Finally, Haskell has a problem with strings. Namely, &lt;code&gt;String&lt;/code&gt; is a type alias for &lt;code&gt;[Char]&lt;/code&gt;, a lazy, singly linked list of characters, which is an awful representation of text. Fortunately, the answer to this problem is simple: ban &lt;code&gt;String&lt;/code&gt; in your programs.&lt;/p&gt;&lt;p&gt;Use &lt;code&gt;Text&lt;/code&gt; everywhere. I don’t really care if you pick strict &lt;code&gt;Text&lt;/code&gt; or lazy &lt;code&gt;Text&lt;/code&gt;, but pick one and stick to it. Don’t ever use &lt;code&gt;String&lt;/code&gt;, and &lt;em&gt;especially&lt;/em&gt; don’t ever, &lt;em&gt;ever&lt;/em&gt;, &lt;em&gt;&lt;strong&gt;ever&lt;/strong&gt;&lt;/em&gt; use &lt;code&gt;ByteString&lt;/code&gt; to represent text! There are enormously few legitimate cases for using &lt;code&gt;ByteString&lt;/code&gt; in a program that is not explicitly about reading or writing raw data, and even at that level, &lt;code&gt;ByteString&lt;/code&gt; should only be used at program boundaries. In that sense, I treat &lt;code&gt;ByteString&lt;/code&gt; much the same way I treat &lt;code&gt;IO&lt;/code&gt;: push it to the boundaries of your program.&lt;/p&gt;&lt;p&gt;One of Haskell’s core tenets is making illegal states unrepresentable. Strings are not especially useful datatypes for this, since they are sequences of arbitrary length made up of atoms that can be an enormously large number of different things. Still, string types enforce a very useful invariant, a notion of a sequence of human-readable characters. In the presence of Unicode, this is a more valuable abstraction than it might seem, and the days of treating strings as little different from sequences of bytes are over. While strings make a poor replacement for enums, they are quite effective at representing the incredible amount of text humans produce in a staggeringly large number of languages, and they are the right type for that job.&lt;/p&gt;&lt;p&gt;&lt;code&gt;ByteString&lt;/code&gt;, on the other hand, is essentially never the right type for any job. If a type classifies a set of values, &lt;code&gt;ByteString&lt;/code&gt; is no different from &lt;code&gt;Any&lt;/code&gt;. It is the structureless type, the all-encompassing blob of bits. A &lt;code&gt;ByteString&lt;/code&gt; could hold anything at all—some text, an image, an executable program—and the type system certainly isn’t going to help to answer that question. The only use case I can possibly imagine for passing around a &lt;code&gt;ByteString&lt;/code&gt; in your program rather than decoding it into a more precise type is if it truly holds opaque data, e.g. some sort of token or key provided by a third party with no structure guaranteed whatsoever. Still, even this should be wrapped in a &lt;code&gt;newtype&lt;/code&gt; so that the type system enforces this opaqueness.&lt;/p&gt;&lt;p&gt;Troublingly, &lt;code&gt;ByteString&lt;/code&gt; shows up in many libraries’ APIs where it has no business being. In many cases, this seems to be things where ASCII text is expected, but this is hardly a good reason to willingly accept absolutely anything and everything! Make an &lt;code&gt;ASCII&lt;/code&gt; type that forbids non-ASCII characters, and provide a &lt;code&gt;ByteString -&amp;gt; Maybe ASCII&lt;/code&gt; function. Alternatively, think harder about your problem in question to properly support Unicode as you almost certainly ought to.&lt;/p&gt;&lt;p&gt;Other places &lt;code&gt;ByteString&lt;/code&gt; appears are similarly unfortunate. Base-64 encoding, for example, could be given the wonderfully illustrative type &lt;code&gt;ByteString -&amp;gt; Text&lt;/code&gt;, or even &lt;code&gt;ByteString -&amp;gt; ASCII&lt;/code&gt;! Such a type makes it immediately clear why base-64 is useful: it allows transforming arbitrary binary data into a reliable textual encoding. If we consider that &lt;code&gt;ByteString&lt;/code&gt; is essentially &lt;code&gt;Any&lt;/code&gt;, this function has the type &lt;code&gt;Any -&amp;gt; ASCII&lt;/code&gt;, which is amazingly powerful! We can convert &lt;em&gt;anything&lt;/em&gt; to ASCII text!&lt;/p&gt;&lt;p&gt;Existing libraries, however, just provide the boring, disappointingly inaccurate type &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt;, which is one of the most useless types there is. It is essentially &lt;code&gt;Any -&amp;gt; Any&lt;/code&gt;, the meaningless function type. It conveys nothing about what it does, other than that it is pure. Giving a function this type is scarcely better than dynamic typing. Its mere existence is a failure of Haskell library design.&lt;/p&gt;&lt;p&gt;But wait, it gets worse! &lt;code&gt;Data.Text.Encoding&lt;/code&gt; exports a function called &lt;code&gt;decodeUtf8&lt;/code&gt;, which has type &lt;code&gt;ByteString -&amp;gt; Text&lt;/code&gt;. What an incredible function with a captivating type! Whatever could it possibly do? Again, this function’s type is basically &lt;code&gt;Any -&amp;gt; Text&lt;/code&gt;, which is remarkable in the power it gives us. Let’s try it out, shall we?&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ghci&amp;gt; decodeUtf8 "\xc3\x28"
"*** Exception: Cannot decode byte '\x28': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Oh. Well, that’s a disappointment.&lt;/p&gt;&lt;p&gt;Haskell’s string problem goes deeper than &lt;code&gt;String&lt;/code&gt; versus &lt;code&gt;Text&lt;/code&gt;; it seems to have wound its way around the collective consciousness of the Haskell community and made it temporarily forget that it cares about types and totality. This isn’t that hard, I swear! I can only express complete befuddlement at how many of these APIs are just completely worthless.&lt;/p&gt;&lt;p&gt;Fortunately, there is a way out, and that way out is &lt;a href="https://hackage.haskell.org/package/text-conversions"&gt;&lt;code&gt;text-conversions&lt;/code&gt;&lt;/a&gt;. It is the first Haskell library I ever wrote. It provides &lt;em&gt;type safe&lt;/em&gt;, &lt;em&gt;total&lt;/em&gt; conversions between &lt;code&gt;Text&lt;/code&gt; and various other types, and it is encoding aware. It provides appropriately-typed base-16 and base-64 conversion functions, and is guaranteed to never raise any exceptions. Use it, and apply the Haskell philosophy to your strings, just as you already do for everything else in your program.&lt;/p&gt;&lt;h2&gt;&lt;a name="closing-thoughts"&gt;&lt;/a&gt;Closing thoughts&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Phew.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;When I started writing this blog post, it used the phrase “short overview” in the introduction. It is now over ten thousand words long. I think that’s all I have it in me to say for now.&lt;/p&gt;&lt;p&gt;Haskell is a wonderful language built by a remarkable group of people. Its community is often fraught with needlessly inflammatory debates about things like the value of codes of conduct, the evils of Hackage revisions, and precisely how much or how little people ought to care about the monad laws. These flame wars frustrate me to no end, and they sometimes go so far as to make me ashamed to call myself a part of the Haskell community. Many on the “outside” seem to view Haskellers as an elitist, mean-spirited cult, more interested in creating problems for itself than solving them.&lt;/p&gt;&lt;p&gt;That perception is categorically wrong.&lt;/p&gt;&lt;p&gt;I have never been in a community of programmers so dedicated and passionate about applying thought and rigor to building software, then going out and &lt;em&gt;actually doing it&lt;/em&gt;. I don’t know anywhere else where a cutting-edge paper on effect systems is discussed by the very same people who are figuring out how to reliably deploy distributed services to AWS. Some people view the Haskell community as masturbatory, and to some extent, they are probably right. One of my primary motivators for writing Haskell is that it is fun and it challenges me intellectually in ways that other languages don’t. But that challenge is not a sign of uselessness, it is a sign that Haskell is &lt;em&gt;so close&lt;/em&gt; to letting me do the right thing, to solving the problem the right way, to letting me work without compromises. When I write in most programming languages, I must constantly accept that my program will never be robust in all the ways I want it to be, and I might as well give up before I even start. Haskell’s greatest weakness is that it tempts me to try.&lt;/p&gt;&lt;p&gt;Haskell is imperfect, as it will always be. I doubt I will ever be satisfied by any language or any ecosystem. There will always be more to learn, more to discover, better tools and abstractions to develop. Many of them will not look anything like Haskell; they may not involve formal verification or static types or effect systems at all. Perhaps live programming, structural editors, and runtime hotswapping will finally take over the world, and we will find that the problems we thought we were solving were irrelevant to begin with. I can’t predict the future, and while I’ve found great value in the Haskell school of program construction, I dearly hope that we do not develop such tunnel vision that we cannot see that there may be other ways to solve these problems. Many of the solutions are things we likely have not even begun to think about. Still, whether that happens or not, it is clear to me that Haskell is a point in the design space unlike any other, and we learn almost as much from the things it gets wrong as we do from the things it gets right.&lt;/p&gt;&lt;p&gt;It’s been a wonderful two years, Haskell. I won’t be a stranger.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>A space of their own: adding a type namespace to Hackett</title><link>https://lexi-lambda.github.io/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/</guid><pubDate>27 Oct 2017</pubDate><description>&lt;article&gt;&lt;p&gt;As previously discussed on this blog, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;my programming language, Hackett&lt;/a&gt;, is a fusion of two languages, Haskell and Racket. What happens when two distinctly different programming languages collide? Hackett recently faced that very problem when it came to the question of namespacing: Haskell has two namespaces, one for values and another for types, but Racket is a staunch Lisp-1 with a single namespace for all bindings. Which convention should Hackett adopt?&lt;/p&gt;&lt;p&gt;For now, at least, the answer is that Hackett will emulate Haskell: &lt;strong&gt;Hackett now has two namespaces&lt;/strong&gt;. Of course, Hackett is embedded in Racket, so what did it take to add an entirely new namespace to a language that possesses only one? The answer was a little more than I had hoped, but it was still remarkably simple given the problem: after two weeks of hacking, I’ve managed to get something working.&lt;/p&gt;&lt;h2&gt;&lt;a name="why-two-namespaces"&gt;&lt;/a&gt;Why two namespaces?&lt;/h2&gt;&lt;p&gt;Before delving into the mechanics of how multi-namespace Hackett is implemented, it’s important to understand what Hackett’s namespaces actually are and why they exist in the first place. Its host language, Racket, is a descendant of Scheme, a Lisp derivative that famously chose to only use a single namespace. This means everything—from values to functions to classes—lives in a single namespace in Racket.&lt;/p&gt;&lt;p&gt;This is in stark contrast to Common Lisp, which opts to divide bindings into many namespaces, most notably pushing functions into a separate namespace from other variables. You can see this difference most strikingly when applying higher-order functions. In Racket, Clojure, and Scheme, functions can be passed freely as values:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ss"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ss"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ss"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In Common Lisp and other languages with two namespaces, functions may still be passed as values, but the programmer must explicitly &lt;em&gt;annotate&lt;/em&gt; when they wish to use a value from a different namespace:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcar&lt;/span&gt; &lt;span class="nf"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The Common Lisp &lt;code&gt;#'x&lt;/code&gt; reader abbreviation is equivalent to &lt;code&gt;(function x)&lt;/code&gt;, and &lt;code&gt;function&lt;/code&gt; is a special form that references a value in the function namespace.&lt;/p&gt;&lt;p&gt;While this distinction is somewhat arbitrary, it is generally my belief that the Scheme approach was, indeed, the right one. Runtime values are values, whether they are numbers, strings, or functions, and they ought to all be treated as equal citizens. After all, if a programmer wishes to define their own function-like thing, they should not be forced to make their abstraction a second-class citizen merely because it is slightly different from the built-in notion of a function. Higher-order functional programming encourages treating functions as ordinary values, and an arbitrary stratification of the namespace is antithetical to that mental model.&lt;/p&gt;&lt;p&gt;However, Hackett is a little different from all of the aforementioned languages because Hackett has &lt;em&gt;types&lt;/em&gt;. Types are rather different from runtime values because they do not exist at all at runtime. One cannot use a type where a value is expected, nor can one use a value where a type is expected, so this distinction is &lt;em&gt;always&lt;/em&gt; syntactically unambiguous.&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;1&lt;/a&gt;&lt;/sup&gt; Even if types and values live in separate namespaces, there is no need for a &lt;code&gt;type&lt;/code&gt; form a la CL’s &lt;code&gt;function&lt;/code&gt; because it can always be determined implicitly.&lt;/p&gt;&lt;p&gt;For this reason, it makes a great deal of sense for Hackett to have separate type and value namespaces, permitting declarations such as the following:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tuple&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tuple&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This defines a binding named &lt;code&gt;Tuple&lt;/code&gt; at the type level, which is a &lt;em&gt;type constructor&lt;/em&gt; of two arguments that produces a type of kind &lt;code&gt;*&lt;/code&gt;,&lt;sup&gt;&lt;a href="#footnote-2" id="footnote-ref-2-1"&gt;2&lt;/a&gt;&lt;/sup&gt; and another binding named &lt;code&gt;Tuple&lt;/code&gt; at the value level, which is a &lt;em&gt;value constructor&lt;/em&gt; of two arguments that produces a value of type &lt;code&gt;(Tuple a b)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;But why do we want to overload names in this way, anyway? How hard would it really be to just name the value constructor &lt;code&gt;tuple&lt;/code&gt; instead of &lt;code&gt;Tuple&lt;/code&gt;? Well, it wouldn’t be hard at all, if it weren’t for the unpleasant ambiguity such a naming convention introduces when pattern-matching. Consider the following code snippet:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;foo-&amp;gt;integer&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;    &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This works fine. But what happens if the programmer decides to change the name of the &lt;code&gt;bar&lt;/code&gt; value?&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;qux&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;foo-&amp;gt;integer&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;    &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Can you spot the bug? Disturbingly, this code &lt;em&gt;still compiles&lt;/em&gt;! Even though &lt;code&gt;bar&lt;/code&gt; is not a member of &lt;code&gt;Foo&lt;/code&gt; anymore, it’s still a valid pattern, since names used as patterns match anything, just as the &lt;code&gt;y&lt;/code&gt; pattern matches against any integer inside the &lt;code&gt;baz&lt;/code&gt; constructor. If Hackett had a pattern redundancy checker, it could at least hopefully catch this mistake, but as things are, this could would silently compile and do the wrong thing: &lt;code&gt;(foo-&amp;gt;integer (baz 42))&lt;/code&gt; will still produce &lt;code&gt;0&lt;/code&gt;, not &lt;code&gt;42&lt;/code&gt;, since the first case always matches.&lt;/p&gt;&lt;p&gt;Haskell escapes this flaw by syntactically distinguishing between patterns and ordinary bindings by requiring all constructors start with an uppercase letter. This means that programmers often want to define data constructors and type constructors with the same name, such as the &lt;code&gt;Tuple&lt;/code&gt; example above, which is illegal if a programming language only supports a single namespace.&lt;/p&gt;&lt;p&gt;Although Hackett now supports two namespaces, it does not currently enforce this naming convention, but it seems like an increasingly good idea. Separating the namespaces is the biggest hurdle needed to implement such a feature, and happily, it is now complete. The &lt;code&gt;Tuple&lt;/code&gt; example from above is perfectly legal Hackett.&lt;/p&gt;&lt;h2&gt;&lt;a name="adding-namespaces-to-a-language"&gt;&lt;/a&gt;Adding namespaces to a language&lt;/h2&gt;&lt;p&gt;Hopefully, we now agree that it would be nice if Hackett had two namespaces, but that doesn’t really get us any closer to being able to &lt;em&gt;implement&lt;/em&gt; such a feature. At its core, Hackett is still a Racket language, and Racket’s binding structure has no notion of namespaces. How can it possibly support a language with more than one namespace?&lt;/p&gt;&lt;p&gt;Fortunately, Racket is no ordinary language—it is a language with a highly formalized notion of lexical scope, and many of its low-level scope control features are accessible to ordinary programmers. Before we get into the details, however, a forewarning: &lt;strong&gt;the remainder of this blog post is &lt;em&gt;highly technical&lt;/em&gt;, and some of it involves some of the more esoteric corners of Racket’s macro system&lt;/strong&gt;. This blog post is &lt;em&gt;not&lt;/em&gt; representative of most macros written in Racket, nor is it at all necessary to understand these things to be a working Racket or Hackett macrologist. It is certainly not a tutorial on any of these concepts, so if you find it intimidating, there is no shame in skipping the rest of this post! If, however, you think you can handle it, or if you simply want to stare into the sun, by all means, read on.&lt;/p&gt;&lt;h3&gt;&lt;a name="namespaces-as-scopes"&gt;&lt;/a&gt;Namespaces as scopes&lt;/h3&gt;&lt;p&gt;With that disclaimer out of the way, let’s begin. As of this writing, the current Racket macroexpander uses a scoping model known as &lt;a href="https://www.cs.utah.edu/plt/scope-sets/"&gt;&lt;em&gt;sets of scopes&lt;/em&gt;&lt;/a&gt;, which characterizes the binding structure of a program by annotating identifiers with sets of opaque markers known as “scopes”. The details of Racket’s macro system are well outside the scope of this blog post, but essentially, two identifiers with the same name can be made to refer to different bindings by adding a unique scope to each identifier.&lt;/p&gt;&lt;p&gt;Using this system of scopes, it is surprisingly simple to create a system of two namespaces: we only need to arrange for all identifiers in a value position to have a particular scope, which we will call the &lt;em&gt;value scope&lt;/em&gt;, and all identifiers in type position must have a different scope, which we will call the &lt;em&gt;type scope&lt;/em&gt;. How do we create these scopes and apply them to identifiers? In Racket, we use a function called &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._make-syntax-introducer%29%29"&gt;&lt;code&gt;make-syntax-introducer&lt;/code&gt;&lt;/a&gt;, which produces a function that encapsulates a fresh scope. This function can be applied to any syntax object (Racket’s structured representation of code that includes lexical binding information) to do one of three things: it can &lt;em&gt;add&lt;/em&gt; the scope to all pieces of the syntax object, &lt;em&gt;remove&lt;/em&gt; the scope, or &lt;em&gt;flip&lt;/em&gt; the scope (that is, add it to pieces of the syntax object that do not have it and remove it from pieces that do have it). In practice, this means we need to call &lt;code&gt;make-syntax-introducer&lt;/code&gt; once for each namespace:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We define these in a &lt;code&gt;begin-for-syntax&lt;/code&gt; block because these definitions will be used in our compile-time macros (aka “phase 1”), not in runtime code (aka “phase 0”). Now, we can write some macros that use these introducer functions to apply the proper scopes to their contents:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Each of these two forms is like &lt;code&gt;begin&lt;/code&gt;, which is a Racket form that is, for our purposes, essentially a no-op, but it applies &lt;code&gt;value-introducer&lt;/code&gt; or &lt;code&gt;type-introducer&lt;/code&gt; to add the appropriate scope. We can test that this works by writing a program that uses the two namespaces:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;value-x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;type-x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This program produces the following output:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;'value-x
'type-x
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It works! Normally, if you try to define two bindings with the same name in Racket, it will produce a compile-time error, but by assigning them different scopes, we have essentially managed to create two separate namespaces.&lt;/p&gt;&lt;p&gt;However, although this is close, it isn’t &lt;em&gt;quite&lt;/em&gt; right. What happens if we nest the two inside each other?&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;x: identifier's binding is ambiguous
  context...:
   #(189267 module) #(189268 module anonymous-module 0) #(189464 use-site)
   #(189465 use-site) #(190351 use-site) #(190354 use-site) #(190358 local)
   #(190359 intdef)
  matching binding...:
   #&amp;lt;module-path-index:()&amp;gt;
   #(189267 module) #(189268 module anonymous-module 0) #(189464 use-site)
  matching binding...:
   #&amp;lt;module-path-index:()&amp;gt;
   #(189267 module) #(189268 module anonymous-module 0) #(189465 use-site)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Oh no! That didn’t work at all. The error is a bit of a scary one, but the top of the error message is essentially accurate: the use of &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;ambiguous&lt;/em&gt; because it has both scopes on it, so it could refer to either binding. What we really want is for nested uses of &lt;code&gt;begin/value&lt;/code&gt; or &lt;code&gt;begin/type&lt;/code&gt; to &lt;em&gt;override&lt;/em&gt; outer ones, ensuring that a use can only be in a single namespace at a time.&lt;/p&gt;&lt;p&gt;To do this, we simply need to adjust &lt;code&gt;begin/value&lt;/code&gt; and &lt;code&gt;begin/type&lt;/code&gt; to remove the other scope in addition to adding the appropriate one:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now our nested program runs, and it produces &lt;code&gt;'type-x&lt;/code&gt;, which is exactly what we want—the “nearest” scope wins.&lt;/p&gt;&lt;p&gt;With just a few lines of code, we’ve managed to implement the two-namespace system Hackett needs: we simply maintain two scopes, one for each namespace, and arrange for all the types to have the type scope applied and everything else to have the value scope applied. Easy, right? Well, not quite. Things start to get a lot more complicated once our programs span more than a single module.&lt;/p&gt;&lt;h3&gt;&lt;a name="namespaces-that-cross-module-boundaries"&gt;&lt;/a&gt;Namespaces that cross module boundaries&lt;/h3&gt;&lt;p&gt;The system of using two syntax introducers to manage scopes is wonderfully simple as long as all of our programs are contained within a single module, but obviously, that is never true in practice. It is critical that users are able to export both values and types from one module and import them into another, as that is a pretty fundamental feature of any language. This is, unfortunately, where we start to run into problems.&lt;/p&gt;&lt;p&gt;Racket’s notion of hygiene is pervasive, but it is still essentially scoped to a single module. This makes sense, since each module conceptually has its own “module scope”, and it wouldn’t be very helpful to inject a binding from a different module with the &lt;em&gt;other&lt;/em&gt; module’s scope—it would be impossible to reference the binding in the importing module. Instead, Racket’s modules essentially export &lt;em&gt;symbols&lt;/em&gt;, not identifiers (which, in Racket terminology, are symbols packaged together with their lexical scope). When a Racket module provides a binding named &lt;code&gt;foo&lt;/code&gt;, there is no other information attached to that binding. It does not have any scopes attached to it, since it is the &lt;code&gt;require&lt;/code&gt; form’s job to attach the correct scopes to imported identifiers.&lt;/p&gt;&lt;p&gt;This completely makes sense for all normal uses of the Racket binding system, but it has unfortunate implications for our namespace system: Racket modules cannot export more than one binding with a given symbolic name!&lt;sup&gt;&lt;a href="#footnote-3" id="footnote-ref-3-1"&gt;3&lt;/a&gt;&lt;/sup&gt; This won’t work at all, since a Hackett programmer might very well want to export a type and value with the same name from a single module. Indeed, this capability is one of the primary &lt;em&gt;points&lt;/em&gt; of having multiple namespaces.&lt;/p&gt;&lt;p&gt;What to do? Sadly, Racket does not have nearly as elegant a solution for this problem, at least not at the time of this writing. Fortunately, hope is not lost. While far from perfect, we can get away with a relatively simple name-mangling scheme to prefix types upon export and unprefix them upon import. Since Racket’s &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;provide&lt;/code&gt; forms are extensible, it’s even possible to implement this mangling in a completely invisible way.&lt;/p&gt;&lt;p&gt;Currently, the scheme that Hackett uses is to prefix &lt;code&gt;#%hackett-type:&lt;/code&gt; onto the beginning of any type exports. This can be defined in terms of a &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28tech._provide._pre._transformer%29"&gt;&lt;em&gt;provide pre-transformer&lt;/em&gt;&lt;/a&gt;, which is essentially a macro that cooperates with Racket’s &lt;code&gt;provide&lt;/code&gt; form to control the export process. In this case, we can define our &lt;code&gt;type-out&lt;/code&gt; provide pre-transformer in terms of &lt;a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prefix-out%29%29"&gt;&lt;code&gt;prefix-out&lt;/code&gt;&lt;/a&gt;, a form built-in to Racket that allows prefixing the names of exports:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;type-out&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-provide-pre-transformer&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="n"&gt;modes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
       &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;provide-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre-expand-export&lt;/span&gt;
         &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-out&lt;/span&gt; &lt;span class="n"&gt;#%hackett-type:&lt;/span&gt;
                       &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt;
                          &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;combine-out&lt;/span&gt; &lt;span class="n"&gt;provide-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="n"&gt;modes&lt;/span&gt;&lt;span class="p"&gt;)]))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that we call &lt;code&gt;type-introducer&lt;/code&gt; in this macro! That’s because we want to ensure that, when a user writes &lt;code&gt;(provide (type-out Foo))&lt;/code&gt;, we look for &lt;code&gt;Foo&lt;/code&gt; in the module’s type namespace. Of course, once it is provided, all that scoping information is thrown away, but we still need it around so that &lt;code&gt;provide&lt;/code&gt; knows &lt;em&gt;which&lt;/em&gt; &lt;code&gt;Foo&lt;/code&gt; is being provided.&lt;/p&gt;&lt;p&gt;Once we have referenced the correct binding, the use of &lt;code&gt;prefix-out&lt;/code&gt; will appropriately add the &lt;code&gt;#%hackett-type:&lt;/code&gt; prefix, so the exporting side is already done. Users do need to explicitly write &lt;code&gt;(type-out ....)&lt;/code&gt; if they are exporting a particular type-level binding, but this is rarely necessary, since most users use &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; to export datatypes or typeclasses respectively, which can be modified to use &lt;code&gt;type-out&lt;/code&gt; internally. Very little user code actually needs to change to support this adjustment.&lt;/p&gt;&lt;p&gt;Handling imports is, comparatively, tricky. When exporting, we can just force the user to annotate which exports are types, but we don’t have that luxury when importing, since it is merely whether or not a binding has the &lt;code&gt;#%hackett-type:&lt;/code&gt; prefix that indicates which namespace it should be imported into. This means we’ll need to explicitly iterate through every imported binding and check if it has the prefix or not. If it does, we need to strip it off and add the type namespace; otherwise, we just pass it through unchanged.&lt;/p&gt;&lt;p&gt;Just as we extended &lt;code&gt;provide&lt;/code&gt; with a provide pre-transformer, we can extend &lt;code&gt;require&lt;/code&gt; using a &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28tech._require._transformer%29"&gt;&lt;em&gt;require transformer&lt;/em&gt;&lt;/a&gt;. In code, this entire process looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unmangle-type-name&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;and~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;regexp-match&lt;/span&gt; &lt;span class="sr"&gt;#rx"^#%hackett-type:(.+)$"&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;unmangle-types-in&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-require-transformer&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
     &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;imports&lt;/span&gt; &lt;span class="n"&gt;sources&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-import&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;combine-in&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match-lambda&lt;/span&gt;
              &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;local-id&lt;/span&gt; &lt;span class="n"&gt;src-sym&lt;/span&gt; &lt;span class="n"&gt;src-mod-path&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;req-mode&lt;/span&gt; &lt;span class="n"&gt;orig-mode&lt;/span&gt; &lt;span class="n"&gt;orig-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;local-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol-&amp;gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-e&lt;/span&gt; &lt;span class="n"&gt;local-id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;unmangled-type-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unmangle-type-name&lt;/span&gt; &lt;span class="n"&gt;local-name&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;unmangled-type-name&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;unmangled-id&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;local-id&lt;/span&gt;
                                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;string-&amp;gt;symbol&lt;/span&gt; &lt;span class="n"&gt;unmangled-type-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                            &lt;span class="n"&gt;local-id&lt;/span&gt;
                                            &lt;span class="n"&gt;local-id&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="n"&gt;unmangled-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                               &lt;span class="n"&gt;src-sym&lt;/span&gt; &lt;span class="n"&gt;src-mod-path&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;req-mode&lt;/span&gt; &lt;span class="n"&gt;orig-mode&lt;/span&gt; &lt;span class="n"&gt;orig-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                     &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
            &lt;span class="n"&gt;imports&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;sources&lt;/span&gt;&lt;span class="p"&gt;)])))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a little intimidating if you are not familiar with the intricacies of Racket’s low-level macro system, but the bulk of the code isn’t as scary as it may seem. It essentially does three things:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;It iterates over each import and calls &lt;code&gt;unmangle-type-name&lt;/code&gt; on the imported symbol. If the result is &lt;code&gt;#f&lt;/code&gt;, that means the import does not have the &lt;code&gt;#%hackett-type:&lt;/code&gt; prefix, and it can be safely passed through unchanged.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If &lt;code&gt;unmangle-type-name&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; return &lt;code&gt;#f&lt;/code&gt;, then it returns the unprefixed name, which is then provided to &lt;code&gt;datum-&amp;gt;syntax&lt;/code&gt;, which allows users to forge new identifiers in an &lt;em&gt;unhygienic&lt;/em&gt; (or “hygiene-bending”) way. In this case, we want to forge a new identifier with the name we get back from &lt;code&gt;unmangle-type-name&lt;/code&gt;, but with the lexical context of the original identifier.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, we pass the new identifier to &lt;code&gt;type-introducer&lt;/code&gt; to properly add the type scope, injecting the fresh binding into the type namespace.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;With this in place, we now have a way for Hackett users to import and export type bindings, but while it is not much of a burden to write &lt;code&gt;type-out&lt;/code&gt; when exporting types, it is unlikely that users will want to write &lt;code&gt;unmangle-types-in&lt;/code&gt; around each and every import in their program. For that reason, we can define a slightly modified version of &lt;code&gt;require&lt;/code&gt; that implicitly wraps all of its subforms with &lt;code&gt;unmangle-types-in&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;rename-out&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;require/unmangle&lt;/span&gt; &lt;span class="k"&gt;require&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;require/unmangle&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unmangle-types-in&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;…and we’re done. Now, Hackett modules can properly import and export type-level bindings.&lt;/p&gt;&lt;h3&gt;&lt;a name="namespaces-plus-submodules-the-devil-s-in-the-details"&gt;&lt;/a&gt;Namespaces plus submodules: the devil’s in the details&lt;/h3&gt;&lt;p&gt;Up until this point, adding namespaces has required some understanding of the nuances of Racket’s macro system, but it hasn’t been particularly difficult to implement. However, getting namespaces right is a bit trickier than it appears. One area where namespaces are less than straightforward is Racket’s system of &lt;em&gt;submodules&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Submodules are a Racket feature that allows the programmer to arbitrarily nest modules. Each file always corresponds to a single outer module, but that module can contain an arbitrary number of submodules. Each submodule can have its own “module language”, which even allows different languages to be mixed within a single file.&lt;/p&gt;&lt;p&gt;Submodules in Racket come in two flavors: &lt;code&gt;module&lt;/code&gt; and &lt;code&gt;module*&lt;/code&gt;. The difference is what order, semantically, they are defined in. Submodules defined with &lt;code&gt;module&lt;/code&gt; are essentially defined &lt;em&gt;before&lt;/em&gt; their enclosing module, so they cannot import their enclosing module, but their enclosing module can import them. Modules defined with &lt;code&gt;module*&lt;/code&gt; are the logical dual to this: they are defined after their enclosing module, so they can import their enclosing module, but the enclosing module cannot import them.&lt;/p&gt;&lt;p&gt;How do submodules interact with namespaces? Well, for the most part, they work totally fine. This is because submodules are really, for the most part, treated like any other module, so the same machinery that works for ordinary Racket modules works fine with submodules.&lt;/p&gt;&lt;p&gt;However, there is &lt;a href="https://docs.racket-lang.org/guide/Module_Syntax.html#%28part._submodules%29"&gt;a special sort of &lt;code&gt;module*&lt;/code&gt; submodule that uses &lt;code&gt;#f&lt;/code&gt; in place of a module language&lt;/a&gt;, which gives a module access to &lt;em&gt;all&lt;/em&gt; of its enclosing module’s bindings, even ones that aren’t exported! This is commonly used to create a &lt;code&gt;test&lt;/code&gt; submodule that contains unit tests, and functions can be tested in such a submodule even if they are not part of the enclosing module’s public API:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="c1"&gt;; not provided&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;private-add1&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module*&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;rackunit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-equal?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;private-add1&lt;/span&gt; &lt;span class="mi"&gt;41&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It would be nice to be able to use these sorts of submodules in Hackett, too, but if we try, we’ll find that types from the enclosing module mysteriously can’t be referenced by the submodule. Why? Well, the issue is in how we naïvely create our type and value introducers:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Remember that &lt;code&gt;make-syntax-introducer&lt;/code&gt; is generative—each time it is called, it produces a function that operates on a fresh scope. This is a problem, since those functions will be re-evaluated on every module &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28tech._instantiate%29"&gt;instantiation&lt;/a&gt;, as ensured by Racket’s &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._separate-compilation%29"&gt;separate compilation guarantee&lt;/a&gt;. This means that each module gets its &lt;em&gt;own&lt;/em&gt; pair of scopes. This means the body of a &lt;code&gt;module*&lt;/code&gt; submodule will have different scopes from its enclosing module, and the enclosing modules bindings will not be accessible.&lt;/p&gt;&lt;p&gt;Fortunately, there is a way to circumvent this. While we cannot directly preserve syntax introducers across module instantiations, we &lt;em&gt;can&lt;/em&gt; preserve syntax objects by embedding them in the expanded program, and we can attach scopes to syntax objects. Using &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._make-syntax-delta-introducer%29%29"&gt;&lt;code&gt;make-syntax-delta-introducer&lt;/code&gt;&lt;/a&gt;, we can create a syntax introducer the adds or removes the &lt;em&gt;difference&lt;/em&gt; between scopes on two syntax objects. Pairing this with a little bit of clever indirection, we can arrange for &lt;code&gt;value-introducer&lt;/code&gt; and &lt;code&gt;type-introducer&lt;/code&gt; to always operate on the same scopes on each module instantiation:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-value/type-introducers&lt;/span&gt;
                       &lt;span class="n"&gt;value-introducer:id&lt;/span&gt; &lt;span class="n"&gt;type-introducer:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;scopeless-id&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;introducer-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;value-id&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;type-id&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-delta-introducer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value-id&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-delta-introducer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;type-id&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-value/type-introducers&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The way this trick works is subtle, but to understand it, it’s important to understand that when a module is compiled, its macro uses are only evaluated once. Subsequent imports of the same module will not re-expand the module. &lt;em&gt;However&lt;/em&gt;, code inside &lt;code&gt;begin-for-syntax&lt;/code&gt; blocks is still re-evaluated every time the module is instantiated! This means we are &lt;em&gt;not&lt;/em&gt; circumventing that re-evaluation directly, we are merely arranging for each re-evaluation to always produce the same result.&lt;/p&gt;&lt;p&gt;We still use &lt;code&gt;make-syntax-introducer&lt;/code&gt; to create our two scopes, but critically, we only call &lt;code&gt;make-syntax-introducer&lt;/code&gt; inside the &lt;code&gt;define-value/type-introducers&lt;/code&gt; macro, which is, again, only run once (when the module is expanded). The resulting compiled module embeds &lt;code&gt;value-id&lt;/code&gt; and &lt;code&gt;type-id&lt;/code&gt; as syntax objects in the fully-expanded program, so they never change on each module instantiation, and they already contain the appropriate scopes. We can use &lt;code&gt;make-syntax-delta-introducer&lt;/code&gt; to convert the “inert” scopes into introducer functions that we can use to apply the scopes to other syntax objects as we see fit.&lt;/p&gt;&lt;p&gt;By guaranteeing each namespace’s scope is always the same, even for different modules, &lt;code&gt;module*&lt;/code&gt; submodules now work properly, and they are able to refer to bindings inherited from their enclosing module as desired.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-final-stretch-making-scribble-documentation-namespace-aware"&gt;&lt;/a&gt;The final stretch: making Scribble documentation namespace-aware&lt;/h3&gt;&lt;p&gt;As discussed in &lt;a href="/blog/2017/08/28/hackett-progress-report-documentation-quality-of-life-and-snake/"&gt;my previous blog post&lt;/a&gt;, Hackett has comprehensive documentation powered by Racket’s excellent documentation tool, Scribble. Fortunately for Hackett, Scribble is incredibly flexible, and it can absolutely cope with a language with multiple namespaces. Less fortunately, it is clear that Scribble’s built-in documentation forms were not at all designed with multiple namespaces in mind.&lt;/p&gt;&lt;p&gt;In general, documenting such a language is tricky, assuming one wishes all identifiers to be properly hyperlinked to their appropriate definition (which, of course, I do). However, documentation is far more ambiguous than code when attempting to determine which identifiers belong in which namespace. When actually writing Hackett code, forms can always syntactically deduce the appropriate namespace for their subforms and annotate them accordingly, but this is not true in documentation. Indeed, it’s entirely possible that a piece of documentation might include intentionally incorrect code, which cannot be expanded at all!&lt;/p&gt;&lt;p&gt;Haskell’s documentation tool, Haddock, does not appear to attempt to tackle this problem at all—when given an identifier that exists in both namespaces, it will generate a hyperlink to the type, not the value. I do not know if there is a way around this, but if there is, it isn’t documented. This works alright for Haddock because Haskell’s documentation generally contains fewer examples, and Haskell programmers do not expect all examples to be appropriately hyperlinked, so a best-effort approach is accepted. Racket programmers, however, are used to a very high standard of documentation, and incorrectly hyperlinked docs are unacceptable.&lt;/p&gt;&lt;p&gt;To work around this problem, Hackett’s documentation requires that users explicitly annotate which identifiers belong to the type namespace. Identifiers in the type namespace are prefixed with &lt;code&gt;t:&lt;/code&gt; upon import, and they are bound to Scribble &lt;a href="https://docs.racket-lang.org/scribble/scheme.html#%28tech._element._transformer%29"&gt;&lt;em&gt;element transformers&lt;/em&gt;&lt;/a&gt; that indicate they should be typeset without the &lt;code&gt;t:&lt;/code&gt; prefix. Fortunately, Scribble’s documentation forms &lt;em&gt;do&lt;/em&gt; understand Racket’s model of lexical scope (mostly), so they can properly distinguish between two identifiers with the same name but different lexical context.&lt;/p&gt;&lt;p&gt;In practice, this means Hackett documentation must now include a proliferation of &lt;code&gt;t:&lt;/code&gt; prefixes. For example, here is the code for a typeset REPL interaction:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="n"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hackett-examples&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;square&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t:-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t:Integer&lt;/span&gt; &lt;span class="n"&gt;t:Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;}])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;square&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note the use of &lt;code&gt;t:-&amp;gt;&lt;/code&gt; and &lt;code&gt;t:Integer&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;Integer&lt;/code&gt;. When the documentation is rendered and the example is evaluated, the prefixes are stripped, resulting in properly-typeset Hackett code.&lt;/p&gt;&lt;p&gt;This also means Hackett’s documentation forms have been updated to understand multiple namespaces. Hackett now provides &lt;code&gt;deftype&lt;/code&gt; and &lt;code&gt;deftycon&lt;/code&gt; forms for documenting types and type constructors, respectively, which will use the additional lexical information attached to &lt;code&gt;t:&lt;/code&gt;-prefixed identifiers to properly index documented forms. Similarly, &lt;code&gt;defdata&lt;/code&gt; and &lt;code&gt;defclass&lt;/code&gt; have been updated with an understanding of types.&lt;/p&gt;&lt;p&gt;The implementation details of these changes is less interesting than the ones made to the code itself, since it mostly just involved tweaking Racket’s implementation of &lt;code&gt;defform&lt;/code&gt; slightly to cooperate with the prefixed identifiers. To summarize, Hackett defines a notion of “type binding transformers” that include information about both prefixed and unprefixed versions of types, and Hackett provides documentation forms that consume that information when typesetting. A require transformer converts imported bindings into &lt;code&gt;t:&lt;/code&gt;-prefixed ones and attaches the necessary compile-time information to them. It isn’t especially elegant, but it works.&lt;/p&gt;&lt;h2&gt;&lt;a name="analysis-and-unsolved-problems"&gt;&lt;/a&gt;Analysis and unsolved problems&lt;/h2&gt;&lt;p&gt;When laid out from top to bottom in this blog post, the amount of code it takes to actually implement multiple namespaces in Racket is surprisingly small. In hindsight, it does not feel like two weeks worth of effort, but it would be disingenuous to suggest that any of this was obvious. I tried a variety of different implementation strategies and spent a great deal of time staring at opaque error messages and begging &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt; for help before I got things working properly. Fortunately, with everything in place, the implementation seems reliable, predictable, and useful for Hackett’s users (or, as the case may be, users-to-be).&lt;/p&gt;&lt;p&gt;For the most part, all the machinery behind multiple namespaces is invisible to the average Hackett programmer, and it seems to “just work”. For completeness, however, I must mention one unfortunate exception: remember the work needed to unmangle type names? While it’s true that all imports into Hackett modules are automatically unmangled by the custom &lt;code&gt;require&lt;/code&gt; form, types provided by a module’s &lt;em&gt;language&lt;/em&gt; are not automatically unmangled. This is because Racket does not currently provide a hook to customize how bindings from a module language are introduced, unlike &lt;code&gt;require&lt;/code&gt;’s require transformers.&lt;/p&gt;&lt;p&gt;To circumvent this restriction, &lt;code&gt;#lang hackett&lt;/code&gt;’s reader includes a somewhat ad-hoc solution that actually inserts a &lt;code&gt;require&lt;/code&gt; into users’ programs that unmangles and imports all the types provided by the module. This mostly works, but due to the way Racket’s imports work, it isn’t possible for Racket programmers to import different types with the same names as Hackett core types; the two bindings will conflict, and there is no way for users to hide these implicitly imported bindings. Whether or not this is actually a common problem remains to be seen. If it is rare, it might be sufficient to introduce an ad-hoc mechanism to hide certain type imports, but it might be better to extend Racket in some way to better support this use-case.&lt;/p&gt;&lt;p&gt;That issue aside, multi-namespace Hackett is now working smoothly. It’s worth nothing that I did not have to do &lt;em&gt;any&lt;/em&gt; special work to help Racket’s tooling, such as DrRacket’s Check Syntax tool, understand the binding structure of Hackett programs. Since other tools, such as racket-mode for Emacs, use the same mechanisms under the hood, Racket programmers’ existing tools will be able to properly locate the distinct definition sites for types and values with the same name, another example of how Racket successfully &lt;a href="http://www.ccs.neu.edu/home/matthias/manifesto/sec_intern.html"&gt;internalizes extra-linguistic mechanisms&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;As closing notes, even if the majority of this blog post was gibberish to you, do note that Hackett has come quite a long way in just the past two months, adding much more than just a separate type namespace. I might try and give a more comprehensive update at a later date, but here’s a quick summary of the meaningful changes for those interested:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Multi-parameter typeclasses&lt;/strong&gt; are implemented, along with &lt;strong&gt;default typeclass method implementations&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Pattern-matching performs basic &lt;strong&gt;exhaustiveness checking&lt;/strong&gt;, so unmatched cases are a compile-time error.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hackett ships with a &lt;strong&gt;larger standard library&lt;/strong&gt;, including an &lt;code&gt;Either&lt;/code&gt; type and appropriate functions, an &lt;code&gt;Identity&lt;/code&gt; type, a &lt;code&gt;MonadTrans&lt;/code&gt; typeclass, and the &lt;code&gt;ReaderT&lt;/code&gt; and &lt;code&gt;ErrorT&lt;/code&gt; monad transformers.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;More things are documented&lt;/strong&gt;, and parts of the documentation are slightly improved. Additionally, &lt;strong&gt;Hackett’s internals are much more heavily commented&lt;/strong&gt;, hopefully making the project more accessible to new contributors.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Parts of the typechecker are dramatically simplified&lt;/strong&gt;, improving the mechanisms behind dictionary elaboration and clearing the way for a variety of additional long-term improvements, including multiple compilation targets and a type-aware optimizer.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;As always, various bug fixes.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Finally, special mention to two new contributors to Hackett, &lt;a href="https://github.com/iitalics"&gt;Milo Turner&lt;/a&gt; and &lt;a href="https://github.com/Shamrock-Frost"&gt;Brendan Murphy&lt;/a&gt;. Also special thanks to &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt; and &lt;a href="https://github.com/michaelballantyne"&gt;Michael Ballantyne&lt;/a&gt; for helping me overcome two of the trickiest macro-related problems I’ve encountered in Hackett to date. It has now been just over a year since Hackett’s original conception and roughly six months since the first commit of its current implementation, and the speed at which I’ve been able to work would not have been possible without the valuable help of the wonderful Racket community. Here’s hoping this is only the beginning.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;“But what about dependent types?” you may ask. Put simply, Hackett is not dependently typed, and it is not going to be dependently typed. Dependent types are currently being bolted onto Haskell, but Haskell does not have &lt;code&gt;#lang&lt;/code&gt;. Racket does. It seems likely that a dependently-typed language would be much more useful as a separate &lt;code&gt;#lang&lt;/code&gt;, not a modified version of Hackett, so Hackett can optimize its user experience for what it &lt;em&gt;is&lt;/em&gt;, not what it might be someday. &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-2"&gt;&lt;p&gt;Hackett does not actually have a real kind system yet, but pleasantly, this same change will allow &lt;code&gt;*&lt;/code&gt; to be used to mean “type” at the kind level and “multiply” at the value level. &lt;a href="#footnote-ref-2-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id="footnote-3"&gt;&lt;p&gt;This isn’t strictly true, as readers familiar with Racket’s macro system may likely be aware that Racket modules export bindings at different “phase levels”, where phase levels above 0 correspond to compile-time macroexpansion phases. Racket modules are allowed to export a single binding per name, &lt;em&gt;per phase&lt;/em&gt;, so the same symbolic name can be bound to different things at different phases. This isn’t meaningfully relevant for Hackett, however, since types and values are both exported at phase 0, and there are reasons that must be the case, this phase separation does not make this problem any simpler. &lt;a href="#footnote-ref-3-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Hackett progress report: documentation, quality of life, and snake</title><link>https://lexi-lambda.github.io/blog/2017/08/28/hackett-progress-report-documentation-quality-of-life-and-snake/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2017/08/28/hackett-progress-report-documentation-quality-of-life-and-snake/</guid><pubDate>28 Aug 2017</pubDate><description>&lt;article&gt;&lt;p&gt;Three months ago, &lt;a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/"&gt;I wrote a blog post describing my new, prototype implementation of my programming language, Hackett&lt;/a&gt;. At the time, some things looked promising—the language already included algebraic datatypes, typeclasses, laziness, and even a mini, proof of concept web server. It was, however, clearly still rather rough around the edges—error messages were poor, features were sometimes brittle, the REPL experience was less than ideal, and there was no documentation to speak of. In the time since, while the language is still experimental, I have tackled a handful of those issues, and I am excited to announce &lt;a href="https://pkg-build.racket-lang.org/doc/hackett@hackett-doc/"&gt;&lt;strong&gt;the first (albeit quite incomplete) approach to Hackett’s documentation&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;I’d recommend clicking that link above and at least skimming around before reading the rest of this blog post, as its remainder will describe some of the pieces that didn’t end up in the documentation: the development process, the project’s status, a small demo, and some other details from behind the scenes.&lt;/p&gt;&lt;h2&gt;&lt;a name="a-philosophy-of-documentation"&gt;&lt;/a&gt;A philosophy of documentation&lt;/h2&gt;&lt;p&gt;Racket, as a project, has always had &lt;a href="http://docs.racket-lang.org"&gt;wonderful documentation&lt;/a&gt;. There are many reasons for this—Racket’s educational origins almost certainly play a part, and it helps that the core packages set the bar high—but one of the biggest reasons is undoubtably &lt;a href="http://docs.racket-lang.org/scribble/index.html"&gt;Scribble, the Racket documentation tool&lt;/a&gt;. Scribble is, in many ways, the embodiment of the Racket philosophy: it is a user-extensible, fully-featured, domain-specific programming language designed for typesetting, with &lt;a href="http://docs.racket-lang.org/scribble/plt-manuals.html"&gt;a powerful library for documenting Racket code&lt;/a&gt;. Like the Racket language itself, Scribble comes with a hygienic macro system, and in fact, all Racket libraries are trivially usable from within Scribble documents, if desired. The macro system is used to great effect to provide typesetting forms tailored to the various sorts of things a Racket programmer might wish to document, such as procedures, structures, and macros.&lt;/p&gt;&lt;p&gt;Scribble documents are decoupled from a rendering backend, so a single Scribble document can be rendered to plain text, a PDF, or HTML, but the HTML backend is the most useful for writing docs. Scribble documents themselves use a syntax inspired by (La)TeX’s syntax, but Scribble uses an &lt;code&gt;@&lt;/code&gt; character instead of &lt;code&gt;\&lt;/code&gt;. It also generalizes and regularizes TeX in many ways, creating a much more uniform language without nearly so much magic or complexity. Since Scribble’s “at-expressions” are merely an alternate syntax for Racket’s more traditional s-expressions, Scribble documents can be built out of ordinary Racket macros. For example, to document a procedure in Racket, one would use &lt;a href="http://docs.racket-lang.org/scribble/doc-forms.html#%28form._%28%28lib._scribble%2Fmanual..rkt%29._defproc%29%29"&gt;the provided &lt;code&gt;defproc&lt;/code&gt; form&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="n"&gt;@defproc&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;add1&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="nb"&gt;number?&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="nb"&gt;number?&lt;/span&gt;&lt;span class="p"&gt;]{&lt;/span&gt;
&lt;span class="n"&gt;Returns&lt;/span&gt; &lt;span class="n"&gt;@racket&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This syntax may look alien to someone more familiar with traditional, Javadoc-style documentation comments, but the results are quite impressive. The above snippet renders into &lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._add1%29%29"&gt;something like this&lt;/a&gt;:&lt;/p&gt;&lt;p&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._add1%29%29"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The fact that Scribble documents are fully-fledged &lt;em&gt;programs&lt;/em&gt; equips the programmer with a lot of power. One of the most remarkable tools Scribble provides is &lt;a href="http://docs.racket-lang.org/scribble/eval.html"&gt;the &lt;code&gt;scribble/example&lt;/code&gt; module&lt;/a&gt;, a library that performs sandboxed evaluation as part of the rendering process. This allows Scribble documents to include REPL-style examples inline, automatically generated as part of typesetting, always kept up to date from a single source of truth: the implementation. It even provides a special &lt;code&gt;eval:check&lt;/code&gt; form that enables &lt;a href="https://docs.python.org/3/library/doctest.html"&gt;doctest&lt;/a&gt;-like checking, which allows documentation to serve double duty as a test suite.&lt;/p&gt;&lt;p&gt;Of course, Hackett is not Racket, though it shares many similarities. Fortunately, all of Racket is &lt;em&gt;designed&lt;/em&gt; with the goal of supporting many different programming languages, and Scribble is no exception. Things like &lt;a href="http://docs.racket-lang.org/scribble/eval.html"&gt;&lt;code&gt;scribble/example&lt;/code&gt;&lt;/a&gt; essentially work out of the box with Hackett, and most of &lt;a href="http://docs.racket-lang.org/scribble/plt-manuals.html"&gt;&lt;code&gt;scribble/manual&lt;/code&gt;&lt;/a&gt; can be reused. However, what about documenting algebraic datatypes? What about documenting typeclasses? Well, remember: Scribble is extensible. The &lt;code&gt;defproc&lt;/code&gt; and &lt;code&gt;defstruct&lt;/code&gt; forms are hardly builtins; they are defined as part of the &lt;code&gt;scribble/manual&lt;/code&gt; library in terms of Scribble primitives, and &lt;a href="https://github.com/lexi-lambda/hackett/blob/f472859cfc03086d39563e5c0eb81dcb2ceb49dc/hackett-doc/scribble/manual/hackett.rkt"&gt;we can do the same&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Hackett’s documentation already defines three new forms, &lt;code&gt;defdata&lt;/code&gt;, &lt;code&gt;defclass&lt;/code&gt;, and &lt;code&gt;defmethod&lt;/code&gt;, for documenting algebraic datatypes, typeclasses, and typeclass methods, respectively. They typeset documentation custom-tailored to Hackett’s needs, so Hackett’s documentation need not be constrained by Racket’s design decisions. For example, one could document the &lt;code&gt;Functor&lt;/code&gt; typeclass using &lt;code&gt;defclass&lt;/code&gt; like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="n"&gt;@defclass&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Functor&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)})]]{&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;@deftech&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;functors&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;essentially&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;mapping&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;“piercing”&lt;/span&gt; &lt;span class="n"&gt;operation.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;@racket&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;viewed&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;
&lt;span class="n"&gt;different&lt;/span&gt; &lt;span class="n"&gt;ways:&lt;/span&gt;

&lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With only a little more than the above code, &lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._.Functor%29%29"&gt;Hackett’s documentation includes a beautifully-typeset definition of the &lt;code&gt;Functor&lt;/code&gt; typeclass&lt;/a&gt;, including examples and rich prose:&lt;/p&gt;&lt;p&gt;&lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._.Functor%29%29"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Scribble makes Hackett’s documentation shine.&lt;/p&gt;&lt;h3&gt;&lt;a name="a-tale-of-two-users"&gt;&lt;/a&gt;A tale of two users&lt;/h3&gt;&lt;p&gt;For a programming language, documentation is critical. Once we have grown comfortable with a language, it’s easy to take for granted our ability to work within it, but there is always a learning period, no matter how simple or familiar the language may be. When learning a new language, we often relate the languages’ concepts and features to those which we already know, which is why having a broad vocabulary of languages makes picking up new ones so much easier.&lt;/p&gt;&lt;p&gt;A new user of a language needs a gentle introduction to its features, structured in a logical way, encouraging this period of discovery and internalization. Such an introduction should come equipped with plenty of examples, and it shouldn’t worry itself with being an authoritative reference. Some innocent simplifications are often conducive to learning, and it is unlikely to be helpful to force the full power of a language onto a user all at once.&lt;/p&gt;&lt;p&gt;However, for experienced users, an authoritative reference is &lt;em&gt;exactly&lt;/em&gt; what they need. While learners want tutorial-style documentation that encourages experimentation and exploration, working users of a language need something closer to a dictionary or encyclopedia: a way to look up forms and functions by name and find precise definitions, complete explanations, and hopefully a couple of examples. Such a user does not want information to be scattered across multiple chapters of explanatory text; they simply need a focused, targeted, one-stop shop for the information they’re looking for.&lt;/p&gt;&lt;p&gt;This dichotomy is rarely well-served by existing programming language documentation. Most programming languages suffer from either failing entirely to serve both types of users, or doing so in a way that enforces too strong a separation between the styles of documentation. For example:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Java ships with a quintessential example of a documentation generator: Javadoc. Java is a good case study because, although its documentation is not particularly good, it still manages to be considerably better than most languages’ docs.&lt;/p&gt;&lt;p&gt;&lt;a href="https://docs.oracle.com/javase/8/docs/api/"&gt;Java’s API documentation&lt;/a&gt; documents its standard library, but it doesn’t document the language. Reference-style language documentation is largely relegated to the Java Language Specification, which is highly technical and rather low-level. It is more readable than the standards for some other languages, but it’s still mostly only useful to language lawyers. For Java, this ends up being mostly okay, largely because Java is a fairly &lt;em&gt;small&lt;/em&gt; language that does not often change.&lt;/p&gt;&lt;p&gt;On the other hand, Java’s reference documentation is inconsistent, rarely provides any examples, and certainly does not do a good job of serving new users. Java &lt;em&gt;does&lt;/em&gt; provide guide-style documentation in the form of the &lt;a href="https://docs.oracle.com/javase/tutorial/"&gt;Java Tutorials&lt;/a&gt;, but they are of inconsistent quality.&lt;/p&gt;&lt;p&gt;More importantly, while the Java tutorials link to the API docs, the reverse is &lt;strong&gt;not&lt;/strong&gt; true, which is a real disservice. One of the most beautiful things about the web is how information can be extensively cross-linked, and exploring links is many times easier than turning pages of a physical book. Anyone who’s explored topics on Wikipedia for an hour (or more) at a time knows how amazing this can be.&lt;/p&gt;&lt;p&gt;Language documentation isn’t quite the same as an encyclopedia, but it’s a shame that Java’s documentation does not lend itself as easily to curious, open-ended learning. If the API docs frequently linked to relevant portions of the tutorials, then a user could open the Javadoc for a class or method they are using, then quickly jump to the relevant guide. As the documentation is currently organized, this is nearly impossible, and tutorials are only discovered when explicitly looking for them.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Other languages, such as JavaScript, are in even worse boats than Java when it comes to documentation. For whatever reason, structured documentation of any kind doesn’t seem to have caught on in the JavaScript world, probably largely because no documentation tool ships with the language, and no such tool ever became standard. Whatever the reason, JavaScript libraries’ documentation largely resides in markdown documents spread across version control repositories and various webpages.&lt;/p&gt;&lt;p&gt;The closest thing that JavaScript has to official language documentation, aside from the (largely incomprehensible) language standard, is &lt;a href="https://developer.mozilla.org/en-US/"&gt;MDN&lt;/a&gt;. MDN’s docs are actually quite good, and they tend to mix lots of examples together with reference-style documentation. They’re indexed and searchable, and they have a great Google search ranking. MDN is easily my go-to place to read about core JavaScript functions.&lt;/p&gt;&lt;p&gt;The trouble, of course, is that MDN only houses documentation for the standard library, and while new standards make it bigger than ever, huge amounts of critical functionality are often offloaded to separate packages. These libraries all have their own standards and styles of documentation, and virtually none of them even compare to MDN.&lt;/p&gt;&lt;p&gt;This means that documentation for JavaScript libraries, even the most popular ones, tends to be all over the map. &lt;a href="http://ramdajs.com/docs/"&gt;Ramda’s documentation is nothing but a reference&lt;/a&gt;, which makes it easy to look up information about a specific function, but nearly impossible to find anything if you don’t have a specific name to look for. In contrast, &lt;a href="http://passportjs.org/docs"&gt;Passport’s docs are essentially &lt;em&gt;only&lt;/em&gt; a set of tutorials&lt;/a&gt;, which is great for learners, but enormously frustrating if I just want to look up what the heck a specific function or method &lt;em&gt;does&lt;/em&gt;. Fortunately, &lt;a href="https://facebook.github.io/react/docs/hello-world.html"&gt;there are some libraries, like React&lt;/a&gt;, that absolutely &lt;em&gt;nail&lt;/em&gt; this, and they have both styles of documentation that are &lt;strong&gt;actually cross-referenced&lt;/strong&gt;. Unfortunately, those are mostly the exceptions, not the norm.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://docs.python.org/3/index.html"&gt;Python’s documentation is interesting&lt;/a&gt;, since it includes a set of tutorials alongside the API reference, and it &lt;em&gt;also&lt;/em&gt; ships a language reference written for ordinary users. In many ways, it does everything right, but disappointingly, it generally doesn’t link back to the tutorials from the API docs, even though the reverse is true. For example, the section in the tutorial on &lt;code&gt;if&lt;/code&gt; links to the section in the reference about &lt;code&gt;if&lt;/code&gt;, but nothing goes in the other direction, which is something of a missed opportunity.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/base"&gt;Haskell manages to be especially bad here&lt;/a&gt; (maybe even notoriously bad) despite having an ubiquitous documentation generator, Haddock. Unfortunately, Haddock’s format makes writing prose and examples somewhat unpleasant, and very few packages provide any sort of tutorial. For those that do, the tutorial is often not included in the API docs, a common theme at this point.&lt;/p&gt;&lt;p&gt;It’s generally a bad sign when your documentation tool isn’t even powerful enough to document itself, and &lt;a href="https://www.haskell.org/haddock/"&gt;Haddock’s docs are pretty impressively bad, though mostly serviceable if you’re willing to look&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The takeaway here is that I just don’t think most languages’ documentation is particularly good, and programmers seem to have gotten so used to this state of affairs that the bar is set disappointingly low. Fortunately, this is another area where Racket delivers. Racket, like Python, ships with &lt;em&gt;two&lt;/em&gt; pieces of documentation: the &lt;a href="http://docs.racket-lang.org/guide/index.html"&gt;Racket Guide&lt;/a&gt; and the &lt;a href="http://docs.racket-lang.org/reference/index.html"&gt;Racket Reference&lt;/a&gt;. The guide includes over &lt;strong&gt;one hundred thousand&lt;/strong&gt; words of explanations and examples, and the reference includes roughly &lt;strong&gt;half a million&lt;/strong&gt;. Racket’s documentation is impressive on its own, but what’s equally impressive is how carefully and methodically cross-linked it is. Margin notes often provide links to corresponding sections in the relevant companion manual, so it’s easy to look up a form or function by name, then quickly jump to the section of the guide explaining it.&lt;/p&gt;&lt;p&gt;Hackett is obviously not going to have hundreds of thousands of words worth of documentation in its first few months of existence, but it already has nearly ten thousand, and that’s not nothing. More importantly, it is structured the same way that Racket’s docs are: it’s split into the &lt;a href="http://docs.racket-lang.org/hackett/guide.html"&gt;Hackett Guide&lt;/a&gt; and the &lt;a href="http://docs.racket-lang.org/hackett/reference.html"&gt;Hackett Reference&lt;/a&gt;, and the two are cross-referenced as much as possible. Haskell is a notoriously difficult language to learn, but my hope is that does not necessarily &lt;em&gt;need&lt;/em&gt; to be the case. Documentation cannot make the language trivial, but my hope is that it can make it a &lt;em&gt;lot&lt;/em&gt; more accessible without making it any less useful for power users.&lt;/p&gt;&lt;h2&gt;&lt;a name="rounding-hackett-s-library-sanding-its-edges"&gt;&lt;/a&gt;Rounding Hackett’s library, sanding its edges&lt;/h2&gt;&lt;p&gt;One of the best things about sitting down and writing documentation—whether it’s for a tool, a library, or a language—is how it forces you, the author, to think about how someone else might perceive the project when seeing it for the first time. This encompasses everything: error messages, ease of installation, completeness of a standard library, friendliness of tooling, etc. Writing Hackett’s documentation forced me to make a &lt;em&gt;lot&lt;/em&gt; of improvements, and while very few of them are flashy features, they make Hackett feel much less like a toy and more like a tool.&lt;/p&gt;&lt;p&gt;Hackett currently has no formal changelog because it is considered alpha quality, and its API is still unstable. There is no guarantee that things won’t change at any moment. Still, it’s useful to put together an ad-hoc list of changes made in the past few months. Here’s a very brief summary:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Hackett includes a &lt;a href="http://docs.racket-lang.org/hackett/reference-datatypes.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._.Double%29%29"&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/a&gt; type for working with IEEE 754 double-precision floating-point numbers.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Local definitions are supported via the &lt;a href="http://docs.racket-lang.org/hackett/reference-syntactic-forms.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._let%29%29"&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; and &lt;a href="http://docs.racket-lang.org/hackett/reference-syntactic-forms.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._letrec%29%29"&gt;&lt;code&gt;letrec&lt;/code&gt;&lt;/a&gt; forms.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The prelude includes many more functions, especially &lt;a href="http://docs.racket-lang.org/hackett/reference-datatypes.html#%28part._reference-lists%29"&gt;functions on lists&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The Hackett reader has been adjusted to support using &lt;code&gt;.&lt;/code&gt; as a bare symbol, since &lt;a href="http://docs.racket-lang.org/hackett/reference-datatypes.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._..%29%29"&gt;&lt;code&gt;.&lt;/code&gt; is the function composition operator&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The Hackett REPL supports many more forms, including &lt;a href="http://docs.racket-lang.org/hackett/reference-datatypes.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._data%29%29"&gt;ADT&lt;/a&gt;, &lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._class%29%29"&gt;class&lt;/a&gt;, and &lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28form._%28%28lib._hackett%2Fmain..rkt%29._instance%29%29"&gt;instance&lt;/a&gt; definitions. Additionally, the REPL now uses &lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._.Show%29%29"&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/a&gt; instances to display the results of expressions. To compensate for the inability to print non-&lt;a href="http://docs.racket-lang.org/hackett/reference-typeclasses.html#%28def._%28%28lib._hackett%2Fmain..rkt%29._.Show%29%29"&gt;&lt;code&gt;Show&lt;/code&gt;&lt;/a&gt;able things, a new &lt;code&gt;(#:type expr)&lt;/code&gt; syntax is permitted to print the type of &lt;em&gt;any&lt;/em&gt; expression.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Missing instance errors are now dramatically improved, now correctly highlighting the source location of expressions that led to the error.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Alongside these changes are a variety of internal code improvements that make the Hackett code simpler, more readable, and hopefully more accessible to contributors. Many of the trickiest functions are now &lt;a href="https://github.com/lexi-lambda/hackett/blob/f472859cfc03086d39563e5c0eb81dcb2ceb49dc/hackett-lib/hackett/private/base.rkt#L77-L189"&gt;heavily commented&lt;/a&gt; with the hope that the codebase won’t be so intimidating to people unfamiliar with Racket or the techniques behind Hackett’s typechecker. I will continue to document the internals of Hackett as I change different places of the codebase, and I have even considered writing a separate Scribble document describing the Hackett internals. It certainly wouldn’t hurt.&lt;/p&gt;&lt;p&gt;One of the most exciting things about documenting Hackett has been realizing just &lt;em&gt;how much&lt;/em&gt; already exists. Seriously, if you have gotten to this point in the blog post but haven’t read &lt;a href="https://pkg-build.racket-lang.org/doc/hackett@hackett-doc/"&gt;the actual documentation&lt;/a&gt; yet, I would encourage you to do so. No longer does the idea of writing real programs in this language feel out of reach; indeed, aside from potential performance problems, the language is likely extremely close to being usable for very simple things. After all, that’s the goal, isn’t it? As I’ve mentioned before, I’m writing Hackett for other people, but I’m also very much writing it for &lt;em&gt;me&lt;/em&gt;: it’s a language I’d like to use.&lt;/p&gt;&lt;p&gt;Still, writing a general-purpose programming language is a lot of work, and I’ve known from the start that it isn’t something I can accomplish entirely on my own. While this iteration of work on Hackett is a sort of “documentation release”, it might be more accurate to call it an “accessibility release”. If you’re interested in contributing, I finally feel comfortable encouraging you to get involved!&lt;/p&gt;&lt;h2&gt;&lt;a name="a-demo-with-pictures"&gt;&lt;/a&gt;A demo with pictures&lt;/h2&gt;&lt;p&gt;Now, if you’re like me, all of this documentation stuff is already pretty exciting. Still, even I view documentation as simply a means to an end, not an end in itself. Documentation is successful when it gets out of the way and makes it possible to write good code that does cool things. Let’s write some, shall we?&lt;/p&gt;&lt;p&gt;Hackett ships with a special package of demo libraries in the aptly-named &lt;code&gt;hackett-demo&lt;/code&gt; package, which are essentially simple, lightweight bindings to existing, dynamically-typed Racket libraries. In &lt;a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/"&gt;the previous Hackett blog post&lt;/a&gt;, I demonstrated the capabilities of &lt;code&gt;hackett/demo/web-server&lt;/code&gt;. In this blog post, we’re going to use &lt;code&gt;hackett/demo/pict&lt;/code&gt; and &lt;code&gt;hackett/demo/pict/universe&lt;/code&gt;, which make it possible to write interactive, graphical programs in Hackett with just a few lines of code!&lt;/p&gt;&lt;p&gt;As always, we’ll start with &lt;code&gt;#lang hackett&lt;/code&gt;, and we’ll import the necessary libraries:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;hackett/demo/pict&lt;/span&gt;
         &lt;span class="n"&gt;hackett/demo/pict/universe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With that, we can start immediately with a tiny example. Just to see how &lt;code&gt;hackett/demo/pict&lt;/code&gt; works, let’s start by rendering a red square. We can do this by writing a &lt;code&gt;main&lt;/code&gt; action that calls &lt;code&gt;print-pict&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-pict&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filled-square&lt;/span&gt; &lt;span class="mf"&gt;50.0&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you run the above program in DrRacket, you should see a 50 pixel red square printed into the interactions window!&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Using the REPL, we can inspect the type of &lt;code&gt;print-pict&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;#:type&lt;/span&gt; &lt;span class="n"&gt;print-pict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;Unit&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unsurprisingly, displaying a picture to the screen needs &lt;code&gt;IO&lt;/code&gt;. However, what’s interesting is that the rest of the expression is totally pure. Take a look at the type of &lt;code&gt;filled-square&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;#:type&lt;/span&gt; &lt;span class="n"&gt;filled-square&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Double&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;No &lt;code&gt;IO&lt;/code&gt; to be seen! This is because “picts” are entirely &lt;em&gt;pure&lt;/em&gt; values that represent images built out of simple shapes, and they can be put together to make more complex images. For example, we can put two squares next to one another:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;print-pict&lt;/span&gt; &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filled-square&lt;/span&gt; &lt;span class="mf"&gt;50.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="n"&gt;hc-append&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filled-square&lt;/span&gt; &lt;span class="mf"&gt;50.0&lt;/span&gt;&lt;span class="p"&gt;))}))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code will print out a red square to the left of a blue one.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Again, &lt;code&gt;hc-append&lt;/code&gt; is a simple, pure function, a binary composition operator that places two picts side by side to produce a new one:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;#:type&lt;/span&gt; &lt;span class="n"&gt;hc-append&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using the various features of this toolkit, not only can we make interesting pictures and diagrams, we can even create a foundation for a game!&lt;/p&gt;&lt;h3&gt;&lt;a name="implementing-a-snake-clone"&gt;&lt;/a&gt;Implementing a snake clone&lt;/h3&gt;&lt;p&gt;This blog post is not a Hackett tutorial; it is merely a demo. For that reason, I am not going to spend much time explaining how the following program is built. This section is closer to annotated source code than a guide to the &lt;code&gt;pict&lt;/code&gt; or &lt;code&gt;universe&lt;/code&gt; libraries. Hopefully it’s still illustrative.&lt;/p&gt;&lt;p&gt;We’ll start by writing some type definitions. We’ll need a type to represent 2D points on a grid, as well as a type to represent a cardinal direction (to keep track of which direction the player is moving, for example). We’ll also want an &lt;code&gt;Eq&lt;/code&gt; instance for our points.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Direction&lt;/span&gt; &lt;span class="n"&gt;d:left&lt;/span&gt; &lt;span class="n"&gt;d:right&lt;/span&gt; &lt;span class="n"&gt;d:up&lt;/span&gt; &lt;span class="n"&gt;d:down&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Eq&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;==&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;==&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;}})])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With these two datatypes, we can implement a &lt;code&gt;move&lt;/code&gt; function that accepts a point and a direction and produces a new point for an adjacent tile:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;move&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Direction&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d:left&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d:right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d:up&lt;/span&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d:down&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The next step is to define a type for our world state. The &lt;code&gt;big-bang&lt;/code&gt; library operates using a game loop, with a function to update the state that’s called each “tick”. Our state will need to hold all the information about our game, which in this case, is just three things:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;World-State&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt;
                   &lt;span class="n"&gt;Direction&lt;/span&gt;    &lt;span class="c1"&gt;; snake direction&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; snake blocks&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; food blocks&lt;/span&gt;
                   &lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will also be useful to have a functional setter for the direction, which we’ll have to write ourselves, since Hackett does not (currently) have anything like Haskell’s record syntax:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, we’ll write some top-level constants that we’ll use in our rendering function, such as the number of tiles in the game board, the size of each tile in pixels, and some simple picts that represent the tiles we’ll use to draw our game:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;board-width&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;board-height&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;d*&lt;/span&gt; &lt;span class="mf"&gt;15.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;integer-&amp;gt;double&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;empty-board&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;blank-rect&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="n"&gt;board-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="n"&gt;board-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filled-square&lt;/span&gt; &lt;span class="mf"&gt;13.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;food-block&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;snake-block&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colorize&lt;/span&gt; &lt;span class="n"&gt;black&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can write our actual &lt;code&gt;render&lt;/code&gt; function. To do this, we simply need to render each &lt;code&gt;Point&lt;/code&gt; in our &lt;code&gt;World-State&lt;/code&gt;’s two lists as a block on an &lt;code&gt;empty-board&lt;/code&gt;. We’ll write a helper function, &lt;code&gt;render-on-board&lt;/code&gt;, which does exactly that:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;render-on-board&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Pict&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;pict&lt;/span&gt; &lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;foldr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pin-over&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tile-&amp;gt;absolute&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pict&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="n"&gt;empty-board&lt;/span&gt; &lt;span class="n"&gt;points&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function uses &lt;code&gt;foldr&lt;/code&gt; to collect each point and place the provided pict at the right location using &lt;code&gt;pin-over&lt;/code&gt; on an empty board. Using &lt;code&gt;render-on-board&lt;/code&gt;, we can write the &lt;code&gt;render&lt;/code&gt; function in just a couple of lines:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;render&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;World-State&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Pict&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pin-over&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;render-on-board&lt;/span&gt; &lt;span class="n"&gt;snake-block&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;render-on-board&lt;/span&gt; &lt;span class="n"&gt;food-block&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, we’ll need to handle the update logic. On each tick, the snake should advance by a single tile in the direction it’s currently moving. If it runs into a food tile, it should grow one tile larger, and we need to generate a new food tile elsewhere on the board. To help with that last part, the &lt;code&gt;big-bang&lt;/code&gt; library provides a &lt;code&gt;random-integer&lt;/code&gt; function, which we can use to write a &lt;code&gt;random-point&lt;/code&gt; action:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;random-point&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="n"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;random-integer&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;board-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;random-integer&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;board-height&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Hackett supports applicative notation using infix operators, so &lt;code&gt;random-point&lt;/code&gt; looks remarkably readable. It also runs in &lt;code&gt;IO&lt;/code&gt;, since the result is, obviously, random. Fortunately, the &lt;code&gt;on-tick&lt;/code&gt; function runs in &lt;code&gt;IO&lt;/code&gt; as well (unlike &lt;code&gt;render&lt;/code&gt;, which must be completely pure), so we can use &lt;code&gt;random-point&lt;/code&gt; when necessary to generate a new food block:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;init!&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)})&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;reverse&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;tail!&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nb"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;on-tick&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;World-State&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;World-State&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head!&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="n"&gt;elem?&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;new-food-point&lt;/span&gt; &lt;span class="n"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;random-point&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                                &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;new-food-point&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;)})))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;new-snake-point&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init!&lt;/span&gt; &lt;span class="n"&gt;snake-points&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
                            &lt;span class="n"&gt;food-points&lt;/span&gt;&lt;span class="p"&gt;))))])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function is the most complicated one in the whole program, but it’s still not terribly complex. It figures out what the snake’s next location is and binds it to &lt;code&gt;new-snake-point&lt;/code&gt;, then checks if there is a food block at that location. If there is, it generates a &lt;code&gt;new-food-point&lt;/code&gt;, then puts it in the new world state. Otherwise, it removes the last snake point and continues as usual.&lt;/p&gt;&lt;p&gt;The game is already almost completely written. The next step is just to handle key events, which are obviously important for allowing the player to control the snake. Fortunately, this is easy, since we can just use our &lt;code&gt;set-ws-direction&lt;/code&gt; function that we wrote earlier:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;on-key&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;KeyEvent&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;World-State&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;World-State&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ke:left&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="n"&gt;d:left&lt;/span&gt;&lt;span class="p"&gt;)}]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ke:right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="n"&gt;d:right&lt;/span&gt;&lt;span class="p"&gt;)}]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ke:up&lt;/span&gt;   &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="n"&gt;d:up&lt;/span&gt;&lt;span class="p"&gt;)}]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ke:down&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;set-ws-direction&lt;/span&gt; &lt;span class="n"&gt;d:down&lt;/span&gt;&lt;span class="p"&gt;)}]&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;       &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;}])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;on-key&lt;/code&gt; function runs in &lt;code&gt;IO&lt;/code&gt;, but we don’t actually need that power, since all of our keypress update logic is completely pure, so we just wrap everything in &lt;code&gt;pure&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;We’re almost done now—all we need to do is set up the &lt;em&gt;initial&lt;/em&gt; state when the game begins. We’ll write a small binding that creates a world state with the snake in the middle of the board and some random food locations scattered about:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;initial-state&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;initial-food&lt;/span&gt; &lt;span class="n"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequence&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="n"&gt;random-point&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;world-state&lt;/span&gt; &lt;span class="n"&gt;d:right&lt;/span&gt;
                         &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="n"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                         &lt;span class="n"&gt;initial-food&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notably, we can use the &lt;code&gt;repeat&lt;/code&gt; function to create an infinite list of &lt;code&gt;random-point&lt;/code&gt; actions, &lt;code&gt;take&lt;/code&gt; the first five of them, then call &lt;code&gt;sequence&lt;/code&gt; to execute them from left to right. Now, all we have to do is put the pieces together in a &lt;code&gt;main&lt;/code&gt; block:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="n"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;initial-state&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;big-bang&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;
            &lt;span class="kd"&gt;#:to-draw&lt;/span&gt; &lt;span class="n"&gt;render&lt;/span&gt;
            &lt;span class="kd"&gt;#:on-tick&lt;/span&gt; &lt;span class="n"&gt;on-tick&lt;/span&gt; &lt;span class="mf"&gt;0.2&lt;/span&gt;
            &lt;span class="kd"&gt;#:on-key&lt;/span&gt; &lt;span class="n"&gt;on-key&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And that’s it! We haven’t implemented any win or loss conditions, but the basics are all there. In 80 lines of code, we’ve implemented a working snake game in Hackett.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name="contributing-to-hackett"&gt;&lt;/a&gt;Contributing to Hackett&lt;/h2&gt;&lt;p&gt;If you are excited enough about Hackett to be interested in contributing, your first question is very likely “What can I do?” or “Where do I start?” My answer to that is (perhaps a little unhelpfully): it depends! My general recommendation is to try and write something with Hackett, and if you run into anything that prevents you from accomplishing your goal, look into what would need to be changed to support your program. Having a use case is a great way to come up with useful improvements.&lt;/p&gt;&lt;p&gt;On the other hand, you might not have anything in mind, or you might find Hackett’s scope a little too overwhelming to just jump right in and start contributing. Fortunately, &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;Hackett has an issue tracker&lt;/a&gt;, so feel free to take a look and pick something that looks interesting and achievable. Alternatively, the standard library can always use fleshing out, and quite a lot of that can be written without ever even touching the scary Hackett internals.&lt;/p&gt;&lt;p&gt;Additionally, if you have any questions, please don’t hesitate to ask them! If you have a question about the codebase, get stuck implementing something, or just don’t know where to start, feel free to &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;open an issue on GitHub&lt;/a&gt;, send me a message on the &lt;code&gt;#racket&lt;/code&gt; IRC channel on Freenode, or ping me on &lt;a href="http://racket-slack.herokuapp.com"&gt;the Racket Slack team&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name="acknowledgements"&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;&lt;p&gt;Speaking of contributors, I’m excited to say that this is the first time I can truly say Hackett includes code written by someone other than me! I want to call attention to &lt;a href="https://github.com/gelisam"&gt;Samuel Gélineau, aka gelisam&lt;/a&gt;, who is officially the second contributor to Hackett. He helped to implement the new approach the Hackett REPL uses for printing expressions, which ended up being quite useful when implementing some of the other REPL improvements.&lt;/p&gt;&lt;p&gt;Additionally, I want to specially thank &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, &lt;a href="http://eecs.northwestern.edu/~robby/"&gt;Robby Findler&lt;/a&gt;, and &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt; for being especially responsive and helpful to my many questions about Scribble and the Racket top level. Racket continues to be extremely impressive, both as a project and as a community.&lt;/p&gt;&lt;p&gt;Finally, many thanks to the various people who have expressed interest in the project and continue to push me and ask questions. Working on Hackett is a lot of work—both time and effort—and it’s your continued enthusiasm that inspires me to put in the hours.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>User-programmable infix operators in Racket</title><link>https://lexi-lambda.github.io/blog/2017/08/12/user-programmable-infix-operators-in-racket/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2017/08/12/user-programmable-infix-operators-in-racket/</guid><pubDate>12 Aug 2017</pubDate><description>&lt;article&gt;&lt;p&gt;Lisps are not known for infix operators, quite the opposite; infix operators generally involve more syntax and parsing than Lispers are keen to support. However, in &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Hackett&lt;/a&gt;, all functions are curried, and variable-arity functions do not exist. Infix operators are almost necessary for that to be palatable, and though there are other reasons to want them, it may not be obvious how to support them without making the reader considerably more complex.&lt;/p&gt;&lt;p&gt;Fortunately, if we require users to syntactically specify where they wish to use infix expressions, support for infix operators is not only possible, but can support be done &lt;em&gt;without&lt;/em&gt; modifying the stock &lt;code&gt;#lang racket&lt;/code&gt; reader. Futhermore, the resulting technique makes it possible for fixity information to be specified locally in a way that cooperates nicely with the Racket macro system, allowing the parsing of infix expressions to be manipulated at compile-time by users’ macros.&lt;/p&gt;&lt;h2&gt;&lt;a name="our-mission"&gt;&lt;/a&gt;Our mission&lt;/h2&gt;&lt;p&gt;Before we embark, let’s clarify our goal. We want to support infix operators in Racket, of course, but that could mean a lot of different things! Let’s start with what we &lt;em&gt;do&lt;/em&gt; want:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Infix operators should be user-extensible, not limited to a special set of built-in operators.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Furthermore, operators’ names should not be restricted to a separate “operator” character set. Any valid Lisp identifier should be usable as an infix operator.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;We want to be able to support fixity/associativity annotations. Some operators should associate to the left, like subtraction, but others should associate to the right, like &lt;code&gt;cons&lt;/code&gt;. This allows &lt;code&gt;5 - 1 - 2&lt;/code&gt; to be parsed as &lt;code&gt;(- (- 5 1) 2)&lt;/code&gt;, but &lt;code&gt;5 :: 1 :: nil&lt;/code&gt; to be parsed as &lt;code&gt;(:: 5 (:: 1 nil))&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;These are nice goals, but we also won’t be too ambitious. In order to keep things simple and achievable, we’ll keep the following restrictions:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;We will &lt;strong&gt;not&lt;/strong&gt; permit infix expressions in arbitrary locations, since that would be impossible to parse given how we want to allow users to pick any names for operators they wish. Instead, infix expressions must be wrapped in curly braces, e.g. replacing &lt;code&gt;(+ 1 2)&lt;/code&gt; with &lt;code&gt;{1 + 2}&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Our implementation will &lt;strong&gt;not&lt;/strong&gt; support any notion of operator precedence; all operators will have equal precedence, and it will be illegal to mix operators of different associativity in the same expression. Precedence is entirely possible to implement in theory, but it would be considerably more work, so this blog post does not include it.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;All operators will be binary, and we will &lt;strong&gt;not&lt;/strong&gt; support unary or mixfix operators. My intuition is that this technique should be able to be generalized to both of those things, but it would be considerably more complicated.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;With those points in mind, what would the interface for our infix operator library look like for our users? Ideally, something like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-in&lt;/span&gt; &lt;span class="n"&gt;racket/base/&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="s2"&gt;"infix.rkt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;racket/base/-&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; &amp;#39;(1 7)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let’s get started.&lt;/p&gt;&lt;h2&gt;&lt;a name="implementing-infix-operators"&gt;&lt;/a&gt;Implementing infix operators&lt;/h2&gt;&lt;p&gt;Now that we know what we want, how do we get there? Well, there are a few pieces to this puzzle. We’ll need to solve a two main problems:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;How do we “hook into” expressions wrapped with curly braces so that we can perform a desugaring pass?&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;How can we associate fixity information with certain operators?&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;We’ll start by tackling the first problem, since its solution will inform the answer to the second. Since we won’t have any fixity information to start with, we’ll just assume that all operators associate left by default.&lt;/p&gt;&lt;p&gt;So, how &lt;em&gt;do&lt;/em&gt; we detect if a Racket expression is surrounded by curly braces? Normally, in &lt;code&gt;#lang racket&lt;/code&gt;, parentheses, square brackets, and curly braces are all interchangeable. Indeed, if you use curly braces in the REPL, you will find that they are treated &lt;em&gt;exactly&lt;/em&gt; the same as parentheses:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If they are treated identically, giving them special behavior might seem hopeless, but don’t despair! Racket is no ordinary programming language, and it provides some tools to help us out here.&lt;/p&gt;&lt;p&gt;Someone who has worked with Lisps before is likely already aware that Lisp source code is a very direct representation of its AST, composed mostly of lists, pairs, symbols, numbers, and strings. In Racket, this is also true, but Racket also wraps these datums in boxes known as &lt;a href="http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29"&gt;&lt;em&gt;syntax objects&lt;/em&gt;&lt;/a&gt;. Syntax objects contain extra metadata about the code, most notably its lexical context, necessary for Racket’s hygiene system. However, syntax objects can also contain arbitrary metadata, known as &lt;a href="http://docs.racket-lang.org/reference/stxprops.html#%28tech._syntax._property%29"&gt;&lt;em&gt;syntax properties&lt;/em&gt;&lt;/a&gt;. Macros can attach arbitrary values to the syntax objects they produce using syntax properties, and other macros can inspect them. Racket’s &lt;a href="http://docs.racket-lang.org/guide/Pairs__Lists__and_Racket_Syntax.html#%28tech._reader%29"&gt;&lt;em&gt;reader&lt;/em&gt;&lt;/a&gt; (the syntax parser that turns program text into Racket syntax objects) also attaches certain syntax properties as part of its parsing process. One of those is named &lt;a href="http://docs.racket-lang.org/reference/reader.html#%28idx._%28gentag._30._%28lib._scribblings%2Freference%2Freference..scrbl%29%29%29"&gt;&lt;code&gt;'paren-shape&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This syntax property, as the name implies, keeps track of the shape of parentheses in syntax objects. You can see that for yourself by inspecting the property’s value for different syntax objects in the REPL:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="no"&gt;#f&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="sc"&gt;#\[&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-property&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="sc"&gt;#\{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This syntax property gives us the capability to distinguish between syntax objects that use curly braces and those that don’t, which is a step in the right direction, but it still doesn’t give us any hook with which we can change the behavior of certain expressions. Fortunately, there’s something else that can.&lt;/p&gt;&lt;h3&gt;&lt;a name="customizing-application"&gt;&lt;/a&gt;Customizing application&lt;/h3&gt;&lt;p&gt;Racket is a language &lt;em&gt;designed&lt;/em&gt; to be extended, and it provides a variety of hooks in the language for the purposes of tweaking pieces in minor ways. One such hook is named &lt;a href="http://docs.racket-lang.org/reference/application.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~23~25app%29%29"&gt;&lt;code&gt;#%app&lt;/code&gt;&lt;/a&gt;, which is automatically introduced by the macroexpander whenever it encounters a function application. That means it effectively turns this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;…into this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;#%app&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What’s special about &lt;code&gt;#%app&lt;/code&gt; is that the macroexpander will use whichever &lt;code&gt;#%app&lt;/code&gt; is in scope in the expression’s lexical context, so if we write our own version of &lt;code&gt;#%app&lt;/code&gt;, it will be used instead of the one from &lt;code&gt;#lang racket&lt;/code&gt;. This is what we will use to hook into ordinary Racket expressions.&lt;/p&gt;&lt;p&gt;To write our custom version of &lt;code&gt;#%app&lt;/code&gt;, we will use the usual tool: Racket’s industrial-strength macro-authoring DSL, &lt;a href="http://docs.racket-lang.org/syntax/stxparse.html"&gt;&lt;code&gt;syntax/parse&lt;/code&gt;&lt;/a&gt;. We’ll also use a helper library that provides some tools for pattern-matching on syntax objects with the &lt;code&gt;'paren-shape&lt;/code&gt; syntax property, &lt;a href="http://docs.racket-lang.org/syntax-classes/index.html#%28mod-path._syntax%2Fparse%2Fclass%2Fparen-shape%29"&gt;&lt;code&gt;syntax/parse/class/paren-shape&lt;/code&gt;&lt;/a&gt;. Using these, we can transform expressions that are surrounded in curly braces differently from how we would transform expressions surrounded by parentheses:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/class/paren-shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-in&lt;/span&gt; &lt;span class="n"&gt;racket/base/&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="k"&gt;#%app&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~braces&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code will transform any applications surrounded in curly braces into one that starts with &lt;code&gt;#%infix&lt;/code&gt; instead of &lt;code&gt;#%app&lt;/code&gt;, so &lt;code&gt;{1 + 2}&lt;/code&gt; will become &lt;code&gt;(#%infix 1 + 2)&lt;/code&gt;, for example. The identifier &lt;code&gt;#%infix&lt;/code&gt; isn’t actually special in any way, it just has a funny name, but we haven’t actually defined &lt;code&gt;#%infix&lt;/code&gt; yet, so we need to do that next!&lt;/p&gt;&lt;p&gt;To start, we’ll just handle the simplest case: infix expressions with precisely three subexpressions, like &lt;code&gt;{1 + 2}&lt;/code&gt;, should be converted into the equivalent prefix expressions, in this case &lt;code&gt;(+ 1 2)&lt;/code&gt;. We can do this with a simple macro:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Due to the way Racket propagates syntax properties, we explicitly indicate that the resulting expansion should use the &lt;code&gt;#%app&lt;/code&gt; from &lt;code&gt;racket/base&lt;/code&gt;, which will avoid any accidental infinite recursion between our &lt;code&gt;#%app&lt;/code&gt; and &lt;code&gt;#%infix&lt;/code&gt;. With this in place, we can now try our code out in the REPL, and believe it or not, we now support infix expressions with just those few lines of code:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That’s pretty cool!&lt;/p&gt;&lt;p&gt;Of course, we probably want to support infix applications with more than just a single binary operator, such as &lt;code&gt;{1 + 2 + 3}&lt;/code&gt;. We can implement that just by adding another case to &lt;code&gt;#%infix&lt;/code&gt; that handles more subforms:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;…and now, just by adding those two lines, we support arbitrarily-large sequences of infix operators:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I don’t know about you, but I think being able to do this in less than 20 lines of code is pretty awesome. We can even mix different operators in the same expression:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course, all of our infix expressions currently assume that all operators associate left, as was our plan. In general, though, there are lots of useful operators that associate right, such as &lt;code&gt;cons&lt;/code&gt;, nested &lt;code&gt;-&amp;gt;&lt;/code&gt; types or contracts for curried functions, and &lt;code&gt;expt&lt;/code&gt;, the exponentiation operator.&lt;/p&gt;&lt;h3&gt;&lt;a name="tracking-operator-fixity"&gt;&lt;/a&gt;Tracking operator fixity&lt;/h3&gt;&lt;p&gt;Clearly, we need some way to associate operator fixity with certain identifiers, and we need to be able to do it at compile-time. Fortunately, Racket has a very robust mechanism for creating compile-time values. Unfortunately, simply associating metadata with an identifier is a little less convenient than it could be, but there is a general technique that can be done with little boilerplate.&lt;/p&gt;&lt;p&gt;Essentially, Racket (like Scheme) uses a &lt;code&gt;define-syntax&lt;/code&gt; form to define macros, which is what &lt;code&gt;define-syntax-parser&lt;/code&gt; eventually expands into. However, unlike Scheme, Racket’s &lt;code&gt;define-syntax&lt;/code&gt; is not &lt;em&gt;just&lt;/em&gt; for defining macros—it’s for defining arbitrary bindings with compile-time (aka “phase 1”) values. Using this, we can define bindings that have entirely arbitrary values at compile-time, including plain data like numbers or strings:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Once a binding has been defined using &lt;code&gt;define-syntax&lt;/code&gt;, a macro can look up the value associated with it by using the &lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-value%29%29"&gt;&lt;code&gt;syntax-local-value&lt;/code&gt;&lt;/a&gt; function, which returns the compile-time value associated with an identifier:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; 3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The cool thing is that &lt;code&gt;syntax-local-value&lt;/code&gt; gets the value associated with a specific &lt;em&gt;binding&lt;/em&gt;, not a specific name. This means a macro can look up the compile-time value associated with an identifier provided to it as a subform. This is close to what we want, since we could use &lt;code&gt;syntax-local-value&lt;/code&gt; to look up something associated with our infix operator bindings, but the trouble is that they would then cease to be usable as ordinary functions. For example, if you try and use the &lt;code&gt;foo&lt;/code&gt; binding from the above example as an expression, Racket will complain about an “illegal use of syntax”, which makes sense, because &lt;code&gt;foo&lt;/code&gt; is not bound to anything at runtime.&lt;/p&gt;&lt;p&gt;To solve this problem, we can use something of a trick: any compile-time binding that happens to have a procedure as its value will be treated like a macro—that is, using it as an expression will cause the macroexpander to invoke the procedure with a syntax object representing the macro invocation, and the procedure is expected to produce a new syntax object as output. Additionally, Racket programmers can make custom datatypes valid procedures by using the &lt;a href="http://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29"&gt;&lt;code&gt;prop:procedure&lt;/code&gt;&lt;/a&gt; structure type property.&lt;/p&gt;&lt;p&gt;If you are not familiar with the Racket macro system, this probably sounds rather complicated, but in practice, it’s not as confusing as it might seem. The trick here is to create a custom structure type at compile-time that we can use to track operator fixity alongside its runtime binding:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/transformer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runtime-binding&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:property&lt;/span&gt; &lt;span class="nb"&gt;prop:procedure&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;set!-transformer-procedure&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-runtime-binding&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is quite the magical incantation, and all the details of what is going on here are outside the scope of this blog post. Essentially, though, we can use values of this structure as a compile-time binding that will act just like the identifier provided for &lt;code&gt;runtime-binding&lt;/code&gt;, but we can also include a value of our choosing for &lt;code&gt;fixity&lt;/code&gt;. Here’s an example:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;right&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This new &lt;code&gt;::&lt;/code&gt; binding will act, in every way, just like &lt;code&gt;cons&lt;/code&gt;. If we use it in the REPL, you can see that it acts exactly the same:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, we can also use &lt;code&gt;syntax-local-value&lt;/code&gt; to extract this binding’s fixity at compile-time, and that’s what makes it interesting:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;::&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; &amp;#39;right&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using this extra compile-time information, we can adjust our &lt;code&gt;#%infix&lt;/code&gt; macro to inspect bindings and determine their fixity, then use that to make decisions about parsing. Just like we used &lt;code&gt;syntax/parse/class/paren-shape&lt;/code&gt; to make decisions based on the &lt;code&gt;'paren-shape&lt;/code&gt; syntax property, we can use &lt;a href="http://docs.racket-lang.org/syntax-classes/index.html#%28mod-path._syntax%2Fparse%2Fclass%2Flocal-value%29"&gt;&lt;code&gt;syntax/parse/class/local-value&lt;/code&gt;&lt;/a&gt; to pattern-match on bindings with a particular compile-time value. We’ll wrap this in a syntax class of our own to make the code easier to read:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;infix-op&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"infix operator"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-value&lt;/span&gt; &lt;span class="n"&gt;infix-operator?&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.local-value&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, we can update &lt;code&gt;#%infix&lt;/code&gt; to use our new &lt;code&gt;infix-op&lt;/code&gt; syntax class:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notably, we now require all operators to be bound to compile-time infix operator values, and we include two conditions via &lt;code&gt;#:when&lt;/code&gt; clauses. These clauses check to ensure that the operator in question has the expected fixity before committing to that clause; if the condition fails, then parsing backtracks. Using this new definition of &lt;code&gt;#%infix&lt;/code&gt;, we can successfully use &lt;code&gt;::&lt;/code&gt; in an infix expression, and it will be parsed with the associativity that we expect:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Exciting!&lt;/p&gt;&lt;h3&gt;&lt;a name="a-nicer-interface-for-defining-infix-operators"&gt;&lt;/a&gt;A nicer interface for defining infix operators&lt;/h3&gt;&lt;p&gt;We currently have to define infix operators by explicitly using &lt;code&gt;define-syntax&lt;/code&gt;, but this is not a very good interface. Users of infix syntax probably don’t want to have to understand the internal workings of the infix operator implementation, so we just need to define one final macro to consider this done: the &lt;code&gt;define-infix-operator&lt;/code&gt; form from the example at the very beginning of this blog post.&lt;/p&gt;&lt;p&gt;Fortunately, this macro is absolutely trivial to write. In fact, we can do it in a mere three lines of code, since it’s very minor sugar over the &lt;code&gt;define-syntax&lt;/code&gt; definitions we were already writing:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;op:id&lt;/span&gt; &lt;span class="n"&gt;value:id&lt;/span&gt;
                       &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;}}})&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this in hand, we can define some infix operators with a much nicer syntax:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;racket/base/+&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;racket/base/-&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;racket/base/*&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="n"&gt;racket/base//&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="nb"&gt;expt&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With these simple definitions, we can write some very nice mathematical expressions that use infix syntax, in ordinary &lt;code&gt;#lang racket&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;-1&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;256&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;64&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And you know what’s most amazing about this? The entire thing is &lt;strong&gt;only 50 lines of code&lt;/strong&gt;. Here is the entire implementation of infix operators from this blog post in a single code block, with absolutely nothing hidden or omitted:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for-syntax&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/class/local-value&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/parse/class/paren-shape&lt;/span&gt;
                     &lt;span class="n"&gt;syntax/transformer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-in&lt;/span&gt; &lt;span class="n"&gt;racket/base/&lt;/span&gt; &lt;span class="n"&gt;racket/base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runtime-binding&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:property&lt;/span&gt; &lt;span class="nb"&gt;prop:procedure&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;set!-transformer-procedure&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-variable-like-transformer&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-runtime-binding&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;infix-op&lt;/span&gt;
    &lt;span class="kd"&gt;#:description&lt;/span&gt; &lt;span class="s2"&gt;"infix operator"&lt;/span&gt;
    &lt;span class="kd"&gt;#:attributes&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~var&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;local-value&lt;/span&gt; &lt;span class="n"&gt;infix-operator?&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator-fixity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.local-value&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="k"&gt;#%app&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="n"&gt;~braces&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-parser&lt;/span&gt; &lt;span class="n"&gt;#%infix&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;racket/base/#%app&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
  &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op:infix-op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="kd"&gt;#:when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eq?&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;op.fixity&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;#%infix&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;op:id&lt;/span&gt; &lt;span class="n"&gt;value:id&lt;/span&gt;
                       &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;}}})&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;racket/base/+&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;racket/base/-&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;racket/base/*&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="n"&gt;racket/base//&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;^&lt;/span&gt; &lt;span class="nb"&gt;expt&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-infix-operator&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="nb"&gt;cons&lt;/span&gt; &lt;span class="kd"&gt;#:fixity&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Racket is a hell of a programming language.&lt;/p&gt;&lt;h2&gt;&lt;a name="applications-limitations-and-implications"&gt;&lt;/a&gt;Applications, limitations, and implications&lt;/h2&gt;&lt;p&gt;This blog post has outlined a complete, useful model for infix operators, and it is now hopefully clear how they work, but many of the most interesting properties of this implementation are probably not obvious. As far as I can make out, this embedding of infix operators into a macro system is novel, and I am &lt;em&gt;almost certain&lt;/em&gt; that the way this implementation tracks fixity information is unique. One of the most interesting capabilities gained from this choice of implementation is the ability for macros to define infix operators and control their fixity, even &lt;em&gt;locally&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;What does this mean? Well, remember that infix operators are just special syntax bindings. Racket includes a variety of forms for binding or adjusting macros locally, such as &lt;code&gt;let-syntax&lt;/code&gt; and &lt;code&gt;syntax-parameterize&lt;/code&gt;. Using these tools, it would be entirely possible to implement a &lt;code&gt;with-fixity&lt;/code&gt; macro, that could adjust the fixity of an operator within a syntactic block. This could be used, for example, to make &lt;code&gt;/&lt;/code&gt; right associative within a block of code:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="m"&gt;1/6&lt;/span&gt;
&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;with-fixity&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="m"&gt;1/2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In fact, this macro is hardly theoretical, since it could be implemented in a trivial 7 lines, simply expanding to uses of &lt;code&gt;splicing-let&lt;/code&gt; and &lt;code&gt;splicing-let-syntax&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;with-fixity&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;op:id&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~and&lt;/span&gt; &lt;span class="n"&gt;fixity&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~or&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;~datum&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;}}}]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;op-tmp&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;generate-temporaries&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;splicing-let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;op-tmp&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;splicing-let-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;infix-operator&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;op-tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;fixity&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is not especially useful given the current set of infix operator features, but it’s easy to imagine how useful it could be in a system that also supported a notion of precedence. It is not entirely uncommon to encounter certain expressions that could be more cleanly expressed with a local set of operator precedence rules, perhaps described as a set of relations &lt;em&gt;between&lt;/em&gt; operators rather than a global table of magic precedence numbers. With traditional approaches to infix operators, parsing such code would be difficult without a very rigid syntactic structure, but this technique makes it easy.&lt;/p&gt;&lt;p&gt;As mentioned at the beginning of this blog post, this technique is also not merely a novelty—as of now, I am actively using this in &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Hackett&lt;/a&gt; to support infix operators with all of the features outlined here. The Hackett implementation is a little bit fancier than the one in this blog post, since it works harder to produce better error messages. It explicitly disallows mixing left associative and right associative operators in the same expression, so it does some additional validation as part of expansion, and it arranges for source location information to be copied onto the result. It also make a different design decision to allow &lt;em&gt;any&lt;/em&gt; expression to serve as an infix operator, assuming left associativity if no fixity annotation is available.&lt;/p&gt;&lt;p&gt;If you’re interested in the code behind the additional steps Hackett takes to make infix operators more usable and complete, take a look at &lt;a href="https://github.com/lexi-lambda/hackett/blob/0d177d00a9ee96f30dd76761f1cb86f15830779f/hackett-lib/hackett/private/infix.rkt"&gt;this file for the definition of infix bindings&lt;/a&gt;, as well as &lt;a href="https://github.com/lexi-lambda/hackett/blob/0d177d00a9ee96f30dd76761f1cb86f15830779f/hackett-lib/hackett/private/kernel.rkt#L80-L101"&gt;this file for the defintion of infix application&lt;/a&gt;. My hope is to eventually add support for some sort of precedence information, though who knows—maybe infix operators will be easier to reason about if the rules are kept extremely simple. I am also considering adding support for so-called “operator sections” at some point, which would allow things like &lt;code&gt;{_ - 1}&lt;/code&gt; to serve as a shorthand for &lt;code&gt;(lambda [x] {x - 1})&lt;/code&gt;, but I haven’t yet decided if I like the tradeoffs involved.&lt;/p&gt;&lt;p&gt;It’s possible that this implementation of infix operators might also be useful in languages in the Racket ecosystem besides Hackett. However, I’m not sure it makes a ton of sense in &lt;code&gt;#lang racket&lt;/code&gt; without modifications, as variadic functions subsume many of the cases where infix operators are needed in Haskell. If there is a clamoring for this capability, I would be happy to consider extracting the functionality into a library, but as of right now, I don’t have any plans to do so.&lt;/p&gt;&lt;p&gt;Finally, the main point of this blog post is to showcase how easy it is to do things in Racket that would be impossible in most languages and difficult even in most Lisps. It also helps to show off how Hackett is already benefitting from those capabilities: while this particular feature is built-in to &lt;code&gt;#lang hackett&lt;/code&gt;, there’s no reason something similar but more powerful couldn’t be built as a separate library by a &lt;em&gt;user&lt;/em&gt; of Hackett. Even as Hackett’s author, I think that’s exciting, since makes it possible for users to experiment with improvements to the language on their own. Some of those improvements may eventually be rolled into the core language or standard library, but many of them can likely live effectively in separate libraries, accessible on-demand to those who need them. After all, that’s one of Racket’s most important promises—languages as libraries—and it’s why Hackett is a part of the Racket ecosystem.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Unit testing effectful Haskell with monad-mock</title><link>https://lexi-lambda.github.io/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/</guid><pubDate>29 Jun 2017</pubDate><description>&lt;article&gt;&lt;p&gt;Nearly eight months ago, &lt;a href="/blog/2016/10/03/using-types-to-unit-test-in-haskell/"&gt;I wrote a blog post about unit testing effectful Haskell code&lt;/a&gt; using a library called test-fixture. That library has served us well, but it wasn’t as easy to use as I would have liked, and it worked better with certain patterns than others. Since then, I’ve learned more about Haskell and more about testing, and I’m pleased to announce that I am releasing an entirely new testing library, &lt;a href="https://hackage.haskell.org/package/monad-mock"&gt;monad-mock&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name="a-first-glance-at-monad-mock"&gt;&lt;/a&gt;A first glance at monad-mock&lt;/h2&gt;&lt;p&gt;The monad-mock library is, first and foremost, designed to be &lt;em&gt;easy&lt;/em&gt;. It doesn’t ask much from you, and it requires almost zero boilerplate.&lt;/p&gt;&lt;p&gt;The first step is to write an mtl-style interface that encodes an effect you want to mock. For example, you might want to test some code that interacts with the filesystem:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you just have to write your code as normal. For demonstration purposes, here’s a function that defines copying a file in terms of &lt;code&gt;readFile&lt;/code&gt; and &lt;code&gt;writeFile&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;copyFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;copyFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Making this function work on the real filesystem is trivial, since we just need to define an instance of &lt;code&gt;MonadFileSystem&lt;/code&gt; for &lt;code&gt;IO&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Prelude&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readFile&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Prelude&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;writeFile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But how do we test this? Well, we &lt;em&gt;could&lt;/em&gt; run some real code in &lt;code&gt;IO&lt;/code&gt;, which might not be so bad for such a simple function, but this seems like a bad idea. For one thing, a bad implementation of &lt;code&gt;copyFile&lt;/code&gt; could do some pretty horrible things if it misbehaved and decided to overwrite important files, and if you’re constantly running a test suite whenever a file changes, it’s easy to imagine causing a lot of damage. Running tests against the real filesystem also makes tests slower and harder to parallelize, and it only gets much worse once you are doing more complex effects than interacting with the filesystem.&lt;/p&gt;&lt;p&gt;Using monad-mock, we can test this function in just a couple of lines of code:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Control.Exception&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Control.Monad.Mock&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Control.Monad.Mock.TH&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Data.Function&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Test.Hspec&lt;/span&gt;

&lt;span class="nf"&gt;makeMock&lt;/span&gt; &lt;span class="s"&gt;"FileSystemAction"&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ts&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="nf"&gt;spec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="s"&gt;"copyFile"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"reads a file and writes its contents to another file"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
    &lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;copyFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt; &lt;span class="s"&gt;"bar.txt"&lt;/span&gt;
      &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;runMock&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="kt"&gt;ReadFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt; &lt;span class="kt"&gt;:-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"contents"&lt;/span&gt;
                &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;WriteFile&lt;/span&gt; &lt;span class="s"&gt;"bar.txt"&lt;/span&gt; &lt;span class="s"&gt;"contents"&lt;/span&gt; &lt;span class="kt"&gt;:-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That’s it!&lt;/p&gt;&lt;p&gt;The last two lines of the above snippet are the real interesting bits, which specify the actions that are expected to be executed, and it couples them with their results. You will find that if you tweak the list in any way, such as reordering the actions, eliminating one or both of them, or adding an additional action to the end, the test will fail. We could even turn this into a property-based test that generated arbitrary file paths and file contents.&lt;/p&gt;&lt;p&gt;Admittedly, in this trivial example, the mock is a little silly, since converting this into a property-based test would demonstrate how much we’ve basically just reimplemented the function in our test. However, once our function starts to do somewhat more complicated things, then our tests become more meaningful. Here’s a similar function that only copies a file if it is nonempty:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;copyNonemptyFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;copyNonemptyFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
    &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function has some logic which is very clearly &lt;em&gt;not&lt;/em&gt; expressed in its type, and it would be difficult to encode that information into the type in a safe way. Fortunately, we can guarantee that it works by writing some tests:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;describe&lt;/span&gt; &lt;span class="s"&gt;"copyNonemptyFile"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"copies a file with contents"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
    &lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;copyNonemptyFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt; &lt;span class="s"&gt;"bar.txt"&lt;/span&gt;
      &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;runMock&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="kt"&gt;ReadFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt; &lt;span class="kt"&gt;:-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"contents"&lt;/span&gt;
                &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;WriteFile&lt;/span&gt; &lt;span class="s"&gt;"bar.txt"&lt;/span&gt; &lt;span class="s"&gt;"contents"&lt;/span&gt; &lt;span class="kt"&gt;:-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;

  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"does nothing with an empty file"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
    &lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;copyNonemptyFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt; &lt;span class="s"&gt;"bar.txt"&lt;/span&gt;
      &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;runMock&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="kt"&gt;ReadFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt; &lt;span class="kt"&gt;:-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These tests are much more useful, and they have some actual value to them. Imagine we had accidentally written &lt;code&gt;when&lt;/code&gt; instead of &lt;code&gt;unless&lt;/code&gt;, an easy typo to make. Our tests would fail with some useful error messages:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1) copyNonemptyFile copies a file with contents
     uncaught exception: runMockT: expected the following unexecuted actions to be run:
       WriteFile "bar.txt" "contents"

2) copyNonemptyFile does nothing with an empty file
     uncaught exception: runMockT: expected end of program, called writeFile
       given action: WriteFile "bar.txt" ""
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You now know enough to write tests with monad-mock.&lt;/p&gt;&lt;h2&gt;&lt;a name="why-unit-test"&gt;&lt;/a&gt;Why unit test?&lt;/h2&gt;&lt;p&gt;When the issue of testing is brought up in Haskell, it is often treated with a certain distaste by a portion of the community. There are some points I’ve seen a number of times, and though they take different forms, they boil down to two ideas:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;“Haskell code does not need tests because the type system can prove correctness.”&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;“Testing in Haskell is trivial because it is a pure language, and testing pure functions is easy.”&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I’ve been writing Haskell professionally for over a year now, and I can happily say that there &lt;em&gt;is&lt;/em&gt; some truth to both of those things! When my Haskell code typechecks, I feel a confidence in it that I would not feel were I using a language with a less powerful type system. Furthermore, Haskell encourages a “pure core, impure shell” approach to system design that makes testing many things pleasant and straightforward, and it completely eliminates the worry of subtle nondeterminism leaking into tests.&lt;/p&gt;&lt;p&gt;That said, Haskell is not a proof assistant, and its type system cannot guarantee everything, especially for code that operates on the boundaries of what Haskell can control. For much the same reason, I find that my pure code is the code I am &lt;em&gt;least&lt;/em&gt; likely to need to test, since it is also the code with the strongest type safety guarantees, operating on types in my application’s domain. In contrast, the effectful code is often what I find the most value in extensively testing, since it often contains the most subtle complexity, and it is frequently difficult or even impossible to encode into types.&lt;/p&gt;&lt;p&gt;Haskell has the power to provide remarkably strong correctness guarantees with a surprisingly small amount of effort by using a combination of tests and types, using each to accommodate for the other’s weaknesses and playing to each technique’s strengths. Some code is test-driven, other code is type-driven. Most code ends up being a mix of both. Testing is just a tool like any other, and it’s nice to feel confident in one’s ability to effectively structure code in a decoupled, testable manner.&lt;/p&gt;&lt;h2&gt;&lt;a name="why-mock"&gt;&lt;/a&gt;Why mock?&lt;/h2&gt;&lt;p&gt;Even if you accept that testing is good, the question of whether or not to &lt;em&gt;mock&lt;/em&gt; is a subtler issue. To some people, “unit testing” is synonymous with mocks. This is emphatically not true, and in fact, overly aggressive mocking is one of the best ways to make your test suite completely worthless. The monad-mock approach to mocking is a bit more principled than mocking in many dynamic, object-oriented languages, but it comes with many of the same drawbacks: mocks couple your tests to your implementation in ways that make them less valuable and less meaningful.&lt;/p&gt;&lt;p&gt;For the &lt;code&gt;MonadFileSystem&lt;/code&gt; example above, I would actually probably &lt;em&gt;not&lt;/em&gt; use a mock. Instead, I would use a &lt;strong&gt;fake&lt;/strong&gt;, in-memory filesystem implementation:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;FakeFileSystemT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;FakeFileSystemT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;fakeFileSystemT&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FakeFileSystemT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;span class="nf"&gt;fakeFileSystemT&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FakeFileSystemT&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="n"&gt;sort&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;runStateT&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FakeFileSystemT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;FakeFileSystemT&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;lookup&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
    &lt;span class="n"&gt;maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"readFile: no such file ‘"&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;"’"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;FakeFileSystemT&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;modify&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;filter&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;fst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above snippet demonstrates how easy it is to define a &lt;code&gt;MonadFileSystem&lt;/code&gt; implementation in terms of &lt;code&gt;StateT&lt;/code&gt;, and while this may seem like a lot of boilerplate, it really isn’t. You have to write a fake &lt;em&gt;once&lt;/em&gt; per interface, and the above block is a minuscule twelve lines of code. With this technique, you are still able to write tests that depend on the state of the filesystem before and after running the implementation, but you decouple yourself from the precise process of getting there:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;describe&lt;/span&gt; &lt;span class="s"&gt;"copyNonemptyFile"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"copies a file with contents"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;runIdentity&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;copyNonemptyFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt; &lt;span class="s"&gt;"bar.txt"&lt;/span&gt;
          &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;fakeFileSystemT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"contents"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"bar.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"contents"&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"contents"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;

  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"does nothing with an empty file"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;runIdentity&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;copyNonemptyFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt; &lt;span class="s"&gt;"bar.txt"&lt;/span&gt;
          &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;fakeFileSystemT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is better than using a mock, and I would highly recommend doing it if you can! However, a lot of real applications have to interact with services of much greater complexity than an idealized filesystem, and creating that sort of in-memory fake is not always practical. One such situation might be interacting with AWS CloudFormation, for example:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadAWS&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;createStack&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;StackName&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;StackTemplate&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;AWSError&lt;/span&gt; &lt;span class="kt"&gt;StackId&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;listStacks&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;AWSError&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;StackSummaries&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="n"&gt;describeStack&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;StackId&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;AWSError&lt;/span&gt; &lt;span class="kt"&gt;StackInfo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="c1"&gt;-- and so on...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AWS is a very complex system, and it can do dozens of different things (and fail in dozens of different ways) based on an equally complex set of inputs. For example, in the above API, &lt;code&gt;createStack&lt;/code&gt; needs to parse its template, which can be YAML or JSON, in order to determine which of many possible errors and behaviors can be produced, both on the initial call and on subsequent ones.&lt;/p&gt;&lt;p&gt;Creating a fake implementation of &lt;em&gt;AWS&lt;/em&gt; is hardly feasible, and this is where a mock can be useful. By simply writing &lt;code&gt;makeMock "AWSAction" [ts| MonadAWS |]&lt;/code&gt;, we can test functions that interact with AWS in a pure way without necessarily needing to replicate all of its complexity.&lt;/p&gt;&lt;h3&gt;&lt;a name="isolating-mocks"&gt;&lt;/a&gt;Isolating mocks&lt;/h3&gt;&lt;p&gt;Of course, tests that use mocks provide less value than tests that use “smarter” fakes, since they are far more tightly coupled to the implementation, and it’s dramatically more likely that you will need to change the tests when you change the logic. To avoid this, it can be helpful to create multiple interfaces to the same thing: a high-level interface and a low-level one. If our above &lt;code&gt;MonadAWS&lt;/code&gt; is a low-level interface, we could create a high-level counterpart that does precisely what our application needs:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadDeploy&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;executeDeployment&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Deployment&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;DeployError&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When running our application “for real”, we would use &lt;code&gt;MonadAWS&lt;/code&gt; to implement &lt;code&gt;MonadDeploy&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;executeDeploymentImpl&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadAWS&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Deployment&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;DeployError&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;executeDeploymentImpl&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The nice thing about this is we can actually test &lt;code&gt;executeDeploymentImpl&lt;/code&gt; using a &lt;code&gt;MonadAWS&lt;/code&gt; mock, so we can still have unit test coverage of the code on the boundaries of our system! Additionally, by containing the mock to a single place, we can test the rest of our code using a smarter fake implementation of &lt;code&gt;MonadDeploy&lt;/code&gt;, helping to decouple our code from AWS’s complex API and improve the reliability and usefulness of our test suite.&lt;/p&gt;&lt;p&gt;They key point here is that mocking is just a small piece of the larger testing puzzle in &lt;em&gt;any&lt;/em&gt; language, and that is just as true in Haskell. An overemphasis on mocking is an easy way to end up with a test suite that feels useless, probably because it is. Use mocks as a technique to insulate your application from the complexity in others’ APIs, then use more domain-specific testing techniques and type-level assertions to ensure the correctness of your logic.&lt;/p&gt;&lt;h2&gt;&lt;a name="how-monad-mock-works"&gt;&lt;/a&gt;How monad-mock works&lt;/h2&gt;&lt;p&gt;If you’ve read this far and are convinced that monad-mock is useful, you may safely stop reading now. However, if you are interested in the details of what it actually does and what makes it tick, the rest of this blog post is going to focus on how the implementation works and how it compares to other techniques.&lt;/p&gt;&lt;p&gt;The centerpiece of monad-mock’s API is its monad transformer, &lt;code&gt;MockT&lt;/code&gt;, which is a type constructor that accepts three types:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;MockT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; type variables obviously correspond to the usual monad transformer arguments, which represent the underlying monad and the result of the monadic computation, respectively. The &lt;code&gt;f&lt;/code&gt; variable is more interesting, since it’s what makes &lt;code&gt;MockT&lt;/code&gt; work at all, and it isn’t even a type: it’s a type constructor with kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. What does it mean?&lt;/p&gt;&lt;p&gt;Looking at the type signature of &lt;code&gt;runMockT&lt;/code&gt; gives us a little bit more information about what that &lt;code&gt;f&lt;/code&gt; actually represents:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;runMockT&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;WithResult&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MockT&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This type signature provides two pieces of key information:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;The &lt;code&gt;f&lt;/code&gt; parameter is constrained by the &lt;code&gt;Action f&lt;/code&gt; constraint.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Running a mocked computation requires supplying a list of &lt;code&gt;WithResult f&lt;/code&gt; values. This list corresponds to the list of expectations provided to &lt;code&gt;runMock&lt;/code&gt; in earlier examples.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;To understand both of these things, it helps to examine the definition of an actual datatype that can have an &lt;code&gt;Action&lt;/code&gt; instance. For the filesystem example, the action datatype looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;FileSystemAction&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="kt"&gt;ReadFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FileSystemAction&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
  &lt;span class="kt"&gt;WriteFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FileSystemAction&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice how each constructor clearly corresponds to one of the methods of &lt;code&gt;MonadFileSystem&lt;/code&gt;, with a type to match. Now the purpose of the type provided to the &lt;code&gt;FileSystemAction&lt;/code&gt; constructor (in this case &lt;code&gt;r&lt;/code&gt;) should hopefully become clear: it represents the type of the value &lt;em&gt;produced&lt;/em&gt; by each method. Also note that the type is completely phantom—it does not appear in negative position in any of the constructors.&lt;/p&gt;&lt;p&gt;With this in mind, we can take a look at the definition of &lt;code&gt;WithResult&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;WithResult&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;:-&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;WithResult&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is what defines the &lt;code&gt;(:-&amp;gt;)&lt;/code&gt; constructor from earlier in the blog post, and you can see that it effectively just represents a tuple of an action and a value of its associated result. It’s completely type-safe, since it ensures the result matches the type argument to the action.&lt;/p&gt;&lt;p&gt;Finally, this brings us to the &lt;code&gt;Action&lt;/code&gt; class, which is not complex, but is unfortunately necessary:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;eqAction&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:~:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;showAction&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice that these methods are effectively just &lt;code&gt;(==)&lt;/code&gt; and &lt;code&gt;show&lt;/code&gt;, lifted to type constructors of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. One significant difference is that &lt;code&gt;eqAction&lt;/code&gt; produces &lt;code&gt;Maybe (a :~: b)&lt;/code&gt; instead of &lt;code&gt;Bool&lt;/code&gt;, where &lt;code&gt;(:~:)&lt;/code&gt; is from &lt;code&gt;Data.Type.Equality&lt;/code&gt;. This is a type equality witness, which means a successful equality between two values allows the compiler to be sure that the two &lt;em&gt;types&lt;/em&gt; are equal. This is necessary for the implementation of &lt;code&gt;runMockT&lt;/code&gt; due to the phantom type in actions—in order to convince GHC that we can properly return the result of a mocked action, we need to assure it that the value we’re going to return is actually of the proper type.&lt;/p&gt;&lt;p&gt;Implementing this typeclass is not particularly burdensome, but it’s entirely boilerplate, so even if you want to define your own action type (that is, you don’t want to use &lt;code&gt;makeMock&lt;/code&gt;), you can use the &lt;code&gt;deriveAction&lt;/code&gt; function from &lt;code&gt;Control.Monad.Mock.TH&lt;/code&gt; to derive an &lt;code&gt;Action&lt;/code&gt; instance on an existing datatype.&lt;/p&gt;&lt;h3&gt;&lt;a name="connecting-the-mock-to-its-class"&gt;&lt;/a&gt;Connecting the mock to its class&lt;/h3&gt;&lt;p&gt;Now that we have an action with which to mock a class, we need to actually define an instance of that class for &lt;code&gt;MockT&lt;/code&gt;. For this process, monad-mock provides a &lt;code&gt;mockAction&lt;/code&gt; function with the following type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;mockAction&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MockT&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function accepts two arguments: the name of the method being mocked and the action that represents the current call. This is easier to illustrate with an actual instance of &lt;code&gt;MonadFileSystem&lt;/code&gt; using &lt;code&gt;MockT&lt;/code&gt; and our &lt;code&gt;FileSystemAction&lt;/code&gt; type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFileSystem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MockT&lt;/span&gt; &lt;span class="kt"&gt;FileSystemAction&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mockAction&lt;/span&gt; &lt;span class="s"&gt;"readFile"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReadFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mockAction&lt;/span&gt; &lt;span class="s"&gt;"writeFile"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriteFile&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This allows &lt;code&gt;readFile&lt;/code&gt; and &lt;code&gt;writeFile&lt;/code&gt; to defer to the mock, and providing the names of the functions as strings helps monad-mock to produce useful error messages upon failure. Internally, &lt;code&gt;MockT&lt;/code&gt; is a &lt;code&gt;StateT&lt;/code&gt; that keeps track of a list of &lt;code&gt;WithResult f&lt;/code&gt; values as its state. Each call to the mock checks the action against the internal list of calls, and if they match, it returns the associated result. Otherwise, it throws an exception.&lt;/p&gt;&lt;p&gt;This scheme is simple, but it seems to work remarkably well. There are some obvious enhancements that will probably be eventually necessary, like allowing action results that run in the underlying monad &lt;code&gt;m&lt;/code&gt; in order to support things like &lt;code&gt;throwError&lt;/code&gt; from &lt;code&gt;MonadError&lt;/code&gt;, but so far, it hasn’t been necessary for what we’ve been using it for. Certain tricky signatures defy this simple technique, such as signatures where a monadic action appears in a negative position (that is, the signatures you need things like &lt;a href="https://hackage.haskell.org/package/monad-control"&gt;monad-control&lt;/a&gt; or &lt;a href="https://hackage.haskell.org/package/monad-unlift"&gt;monad-unlift&lt;/a&gt; for), but we’ve found that most of our effects don’t have any reason to include such signatures.&lt;/p&gt;&lt;h2&gt;&lt;a name="a-brief-comparison-with-free-r-monads"&gt;&lt;/a&gt;A brief comparison with free(r) monads&lt;/h2&gt;&lt;p&gt;At this point, astute readers will likely be thinking about free monads, which parts of this technique greatly resemble. The representation of actions as GADTs is especially similar to &lt;a href="https://hackage.haskell.org/package/freer"&gt;freer&lt;/a&gt;, which does something extremely similar. Indeed, you can think of this technique as something that combines a freer-style representation with mtl-style classes. Given that freer already does this, you might ask yourself what the point is.&lt;/p&gt;&lt;p&gt;If you are already sold on free monads, monad-mock may very well be uninteresting to you. From the perspective of theoretical novelty, monad-mock is not anything new or different. However, there are a variety of practical reasons to prefer mtl over free, and it’s nice to see how easy it is to enjoy the testing benefits of free without too much extra effort.&lt;/p&gt;&lt;p&gt;An in-depth comparison between mtl and free is well outside the scope of this blog post. However, the key point is that this technique &lt;em&gt;only&lt;/em&gt; affects test code, so the real runtime implementation will not be affected in any way. This means you can take advantage of the performance benefits and ecosystem support of mtl without sacrificing simple, expressive testing.&lt;/p&gt;&lt;h2&gt;&lt;a name="conclusion"&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;To cap things off, I want to emphasize monad-mock’s role as a single part of a larger initiative we’ve been making for the better part of the past eighteen months. Haskell is a language with ever-evolving techniques and style, and it’s sometimes dizzying to figure out how to use all the pieces together to develop robust, maintainable applications. While monad-mock might not be anything drastically different from existing testing techniques, my hope is that it can provide an opinionated mechanism to make testing easy and accessible, even for complex interactions with other services and systems.&lt;/p&gt;&lt;p&gt;I’ve made an effort to make it abundantly clear in this blog post that monad-mock is &lt;em&gt;not&lt;/em&gt; a silver bullet to testing, and in fact, I would prefer other techniques for ensuring correctness whenever possible. Even so, mocking is a nice tool to have in your toolbox, and it’s a good fallback to get even the worst APIs under test coverage.&lt;/p&gt;&lt;p&gt;If you want to try out monad-mock for yourself, &lt;a href="https://hackage.haskell.org/package/monad-mock"&gt;take a look at the documentation on Hackage&lt;/a&gt; and start playing around! It’s still early software, so it’s not the most proven or featureful, but we’ve managed to get mileage out of it already, all the same. If you find any problems, have a use case it does not support, or just find something about it unclear, please do not hesitate to &lt;a href="https://github.com/cjdev/monad-mock"&gt;open an issue on the GitHub repository&lt;/a&gt;—we obviously can’t fix issues we don’t know about.&lt;/p&gt;&lt;p&gt;Thanks as always to the many people who have contributed ideas that have shaped my philosophy and approach to testing and have helped provide the tools that make this library work. Happy testing!&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Realizing Hackett, a metaprogrammable Haskell</title><link>https://lexi-lambda.github.io/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/</guid><pubDate>27 May 2017</pubDate><description>&lt;article&gt;&lt;p&gt;&lt;a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"&gt;Almost five months ago, I wrote a blog post about my new programming language, Hackett&lt;/a&gt;, a fanciful sketch of a programming language from a far-off land with Haskell’s type system and Racket’s macros. At that point in time, I had a little prototype that barely worked, that I barely understood, and was a little bit of a technical dead-end. People saw the post, they got excited, but development sort of stopped.&lt;/p&gt;&lt;p&gt;Then, almost two months ago, I took a second stab at the problem in earnest. I read a lot, I asked a lot of people for help, and eventually I got something sort of working. Suddenly, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Hackett is not only real, it’s working, and you can try it out yourself&lt;/a&gt;!&lt;/p&gt;&lt;h2&gt;&lt;a name="a-first-look-at-hackett"&gt;&lt;/a&gt;A first look at Hackett&lt;/h2&gt;&lt;p&gt;Hackett is still very new, very experimental, and an enormous work in progress. However, that doesn’t mean it’s useless! Hackett is already a remarkably capable programming language. Let’s take a quick tour.&lt;/p&gt;&lt;p&gt;As Racket law decrees it, every Hackett program must begin with &lt;code&gt;#lang&lt;/code&gt;. We can start with the appropriate incantation:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you’re using DrRacket or racket-mode with background expansion enabled, then congratulations: the typechecker is online. We can begin by writing a well-typed, albeit boring program:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="s2"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In Hackett, a use of &lt;code&gt;main&lt;/code&gt; at the top level indicates that running the module as a program should execute some &lt;code&gt;IO&lt;/code&gt; action. In this case, &lt;code&gt;println&lt;/code&gt; is a function of type &lt;code&gt;{String -&amp;gt; (IO Unit)}&lt;/code&gt;. Just like Haskell, Hackett is pure, and the runtime will figure out how to actually run an &lt;code&gt;IO&lt;/code&gt; value. If you run the above program, you will notice that it really does print out &lt;code&gt;Hello, world!&lt;/code&gt;, exactly as we would like.&lt;/p&gt;&lt;p&gt;Of course, hello world programs are boring—so imperative! We are functional programmers, and we have our &lt;em&gt;own&lt;/em&gt; class of equally boring programs we must write when learning a new language. How about some Fibonacci numbers?&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zip-with&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail!&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;))})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, Hackett is just like Haskell in that it is &lt;em&gt;lazy&lt;/em&gt;, so we can construct an infinite list of Fibonacci numbers, and the runtime will happily do nothing at all. When we call &lt;code&gt;take&lt;/code&gt;, we realize the first ten numbers in the list, and when you run the program, you should see them printed out, clear as day!&lt;/p&gt;&lt;p&gt;But these programs are boring. Printing strings and laziness may have been novel when you first learned about them, but if you’re reading this blog post, my bet is that you probably &lt;em&gt;aren’t&lt;/em&gt; new to programming. How about something more interesting, &lt;strong&gt;like a web server&lt;/strong&gt;?&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;hackett/demo/web-server&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Greeting&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greeting&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;-&amp;gt;Body&lt;/span&gt; &lt;span class="n"&gt;Greeting&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;-&amp;gt;body&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;greeting&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;"Hello, "&lt;/span&gt; &lt;span class="n"&gt;++&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;++&lt;/span&gt; &lt;span class="s2"&gt;"!"&lt;/span&gt;&lt;span class="p"&gt;})])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defserver&lt;/span&gt; &lt;span class="n"&gt;run-server&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GET&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;               &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;   &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s2"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GET&lt;/span&gt; &lt;span class="s2"&gt;"greet"&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Greeting&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="s2"&gt;"Running server on port 8080."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;run-server&lt;/span&gt; &lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ racket my-server.rkt
Running server on port &lt;span class="m"&gt;8080&lt;/span&gt;.
^Z
$ &lt;span class="nb"&gt;bg&lt;/span&gt;
$ curl &lt;span class="s1"&gt;&amp;#39;http://localhost:8080/greet/Alexis&amp;#39;&lt;/span&gt;
Hello, Alexis!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Welcome to Hackett.&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name="what-is-hackett"&gt;&lt;/a&gt;What is Hackett?&lt;/h2&gt;&lt;p&gt;Excited yet? I hope so. I certainly am.&lt;/p&gt;&lt;p&gt;Before you get a little &lt;em&gt;too&lt;/em&gt; excited, however, let me make a small disclaimer: the above program, while quite real, is a demo. It is certainly not a production web framework, and it actually just uses the Racket web server under the hood. It does not handle very many things right now. You cannot use it to build your super awesome webapp, and even if you could, I would not recommend attempting to do so.&lt;/p&gt;&lt;p&gt;All that said, it is a &lt;em&gt;real&lt;/em&gt; tech demo, and it shows off the potential for Hackett to do some pretty cool things. While the server implementation is just reusing Racket’s dynamically typed web server, the Hackett interface to it is 100% statically typed, and the above example shows off a host of features:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Algebraic datatypes.&lt;/strong&gt; Hackett has support for basic ADTs, including recursive datatypes (though not yet mutually recursive datatypes).&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Typeclasses.&lt;/strong&gt; The demo web server uses a &lt;code&gt;-&amp;gt;Body&lt;/code&gt; typeclass to render server responses, and this module implements a &lt;code&gt;-&amp;gt;Body&lt;/code&gt; instance for the custom &lt;code&gt;Greeting&lt;/code&gt; datatype.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Macros.&lt;/strong&gt; The &lt;code&gt;defserver&lt;/code&gt; macro provides a concise, readable, &lt;em&gt;type safe&lt;/em&gt; way to define a simple, RESTful web server. It defines two endpoints, a homepage and a greeting, and the latter parses a segment from the URL.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Static typechecking.&lt;/strong&gt; Obviously. If you try and change the homepage endpoint to produce a number instead of a string, you will get a type error! Alternatively, try removing the &lt;code&gt;-&amp;gt;Body&lt;/code&gt; instance and see what happens.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Infix operators.&lt;/strong&gt; In Hackett, &lt;code&gt;{&lt;/code&gt; curly braces &lt;code&gt;}&lt;/code&gt; enter &lt;em&gt;infix mode&lt;/em&gt;, which permits arbitrary infix operators. Most Lisps have variadic functions, so infix operators are not strictly necessary, but Hackett only supports curried, single-argument functions, so infix operators are some especially sweet sugar.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Pure, monadic I/O.&lt;/strong&gt; The &lt;code&gt;println&lt;/code&gt; and &lt;code&gt;run-server&lt;/code&gt; functions both produce &lt;code&gt;(IO Unit)&lt;/code&gt;, and &lt;code&gt;IO&lt;/code&gt; is a monad. &lt;code&gt;do&lt;/code&gt; notation is provided as a macro, and it works with any type that implements the &lt;code&gt;Monad&lt;/code&gt; typeclass.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;All these features are already implemented, and they really work! Of course, you might look at this list and be a little confused: sure, there are macros, but all these other things are firmly Haskellisms. If you thought that, you’d be quite right! &lt;strong&gt;Hackett is much closer to Haskell than Racket, even though it is syntactically a Lisp.&lt;/strong&gt; Keep this guiding principal in mind as you read this blog post or explore Hackett. Where Haskell and Racket conflict, Hackett usually prefers Haskell.&lt;/p&gt;&lt;p&gt;For a bit more information about what Hackett is and what it aims to be, &lt;a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"&gt;check out my blog post from a few months ago&lt;/a&gt; from back when Hackett was called Rascal. I won’t reiterate everything I said there, but I do want to give a bit of a status update, explain what I’ve been working on, and hopefully give you some idea about where Hackett is going.&lt;/p&gt;&lt;h2&gt;&lt;a name="the-story-so-far-and-getting-to-hackett-0-1"&gt;&lt;/a&gt;The story so far, and getting to Hackett 0.1&lt;/h2&gt;&lt;p&gt;In September of 2016, I attended &lt;a href="http://con.racket-lang.org/2016/"&gt;(sixth RacketCon)&lt;/a&gt;, where I saw a &lt;a href="https://www.youtube.com/watch?v=j5Hauz6cewM"&gt;pretty incredible and extremely exciting talk&lt;/a&gt; about implementing type systems as macros. Finally, I could realize my dream of having an elegant Lisp with a safe, reliable macro system and a powerful, expressive type system! Unfortunately, reality ensued, and I remembered I didn’t actually know any type theory.&lt;/p&gt;&lt;p&gt;Therefore, in October, I started to learn about type systems, and I began to read through Pierce’s Types and Programming Languages, then tried to learn the things I would need to understand Haskell’s type system. I learned about Hindley-Milner and basic typeclasses, and I tried to apply these things to the Type Systems as Macros approach. Throughout October, I hacked and I hacked, and by the end of the month, I stood back and admired my handiwork!&lt;/p&gt;&lt;p&gt;…it &lt;em&gt;sort of&lt;/em&gt; worked?&lt;/p&gt;&lt;p&gt;The trouble was that I found myself stuck. I wasn’t sure how to proceed. My language had bugs, programs sometimes did things I didn’t understand, the typechecker was clearly unsound, and there didn’t seem to be an obvious path forward. Other things in my life became distracting or difficult, and I didn’t have the energy to work on it anymore, so I stopped. I put Hackett (then Rascal) on the shelf for a couple months, only to finally return to it in late December.&lt;/p&gt;&lt;p&gt;At the beginning of January, I decided it would be helpful to be public about what I was working on, so I wrote a blog post! Feedback was positive, overwhelmingly so, and while it was certainly encouraging, I suddenly felt nervous about expectations I had not realized I was setting. Could I really build this? Did I have the knowledge or the time? At that point, I didn’t really, so work stalled.&lt;/p&gt;&lt;p&gt;Fortunately, in early April, some things started to become clear. I took another look at Hackett, and I knew I needed to reimplement it from the ground up. I also knew that I needed a different technique, but this time, I knew a bit more about where to find it. I got some help from &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt; and put together &lt;a href="https://gist.github.com/lexi-lambda/045ba782c8a0d915bd8abf97167d3bb5"&gt;an implementation of Pierce and Turner’s Local Type Inference&lt;/a&gt;. Unfortunately, it didn’t really provide the amount of type inference I was looking for, but fortunately, implementing it helped me figure out how to understand the rather more complicated (though very impressive) &lt;a href="http://www.cs.cmu.edu/~joshuad/papers/bidir/"&gt;Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism&lt;/a&gt;. After that, things just sort of started falling into place:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;First, I &lt;a href="https://github.com/lexi-lambda/higher-rank"&gt;implemented the Complete and Easy paper in Haskell&lt;/a&gt;, including building a little parser and interpreter. That helped me actually understand the paper, and Haskell really is a rather wonderful language for doing such a thing.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Three days later, I &lt;a href="https://github.com/lexi-lambda/racket-higher-rank"&gt;ported the Haskell implementation to Racket&lt;/a&gt;, using (and somewhat abusing) the Type Systems as Macros techniques. It wasn’t the prettiest, but it seemed to work, and that was rather encouraging.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;After that, however, I got a little stuck again, as I wasn’t sure how to generalize what I had. I was also incredibly busy with my day job, and I wasn’t able to really make progress for a few weeks. In early May, however, I decided to &lt;a href="https://twitter.com/lexi_lambda/status/865026650487967744"&gt;take a vacation&lt;/a&gt; for a week, and with some time to focus, I &lt;a href="https://github.com/lexi-lambda/higher-rank/tree/algebraic"&gt;souped up the Haskell implementation with products and sums&lt;/a&gt;. This was progress!&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The &lt;em&gt;following day&lt;/em&gt; I managed to make &lt;a href="https://github.com/lexi-lambda/racket-higher-rank/tree/type-constructors"&gt;similar changes to the Racket implementation&lt;/a&gt;, but rather than add anonymous products and sums, I added arbitrary type constructors.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A couple days later and with more than a bit of help from &lt;a href="http://functorial.com"&gt;Phil Freeman&lt;/a&gt;, I &lt;a href="https://github.com/lexi-lambda/hackett/commit/1fd7fc905b93f68e39b9d01fedc4fb52aa44c4c4"&gt;rebranded the Racket implementation as Hackett, Mk II&lt;/a&gt;, and I started working towards turning it into a real programming language.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;em&gt;Less than three weeks later&lt;/em&gt;, and I have a programming language with everything from laziness and typeclasses to a tiny, proof-of-concept web server with &lt;a href="https://twitter.com/lexi_lambda/status/867617563206758400"&gt;editor support&lt;/a&gt;. The future of Hackett looks bright, and though there’s a &lt;em&gt;lot&lt;/em&gt; of work left before I will be even remotely satisfied with it, I am excited and reassured that it already seems to be bearing some fruit.&lt;/p&gt;&lt;p&gt;So what’s left? Is Hackett ready for an initial release? Can you start writing programs in it today? Well, unfortunately, the answer is mostly &lt;strong&gt;no&lt;/strong&gt;, at least if you want those programs to be at all reliable in a day or two. If everything looks so cheery, though, what’s left? What is Hackett still missing?&lt;/p&gt;&lt;h3&gt;&lt;a name="what-hackett-still-isn-t"&gt;&lt;/a&gt;What Hackett still &lt;em&gt;isn’t&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;I have a laundry list of features I want for Hackett. I want GADTs, indexed type families, newtype deriving, and a compiler that can target multiple backends. These things, however, are not essential. You can probably imagine writing useful software without any of them. Before I can try to tackle those, I first need to tackle some of the bits of the foundation that simply don’t exist yet (or have at least been badly neglected).&lt;/p&gt;&lt;p&gt;Fortunately, these things are not insurmountable, nor are they necessarily especially hard. They’re things like default class methods, static detection and prevention of orphan instances, exhaustiveness checking for pattern-matching, and a real kind system. That’s right—right now, Hackett’s type system is effectively dynamically typed, and even though you can write a higher-kinded type, there is no such thing as a “kind error”.&lt;/p&gt;&lt;p&gt;Other things are simply necessary quality of life improvements before Hackett can become truly usable. Type errors are currently rather atrocious, though they could certainly be worse. Additionally, typechecking currently just halts whenever it encounters a type error, and it makes no attempt to generate more than one type error at a time. Derivation of simple instances like &lt;code&gt;Show&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; is important, and it will also likely pave the way for a more general form of typeclass deriving (since it can most certainly be implemented via macros), so it’s uncharted territory that still needs to be explored.&lt;/p&gt;&lt;p&gt;Bits of plumbing are still exposed in places, whether it’s unexpected behavior when interoperating with Racket or errors sometimes reported in terms of internal forms. Local bindings are, if you can believe it, still entirely unimplemented, so &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;letrec&lt;/code&gt; need to be written up. The standard library needs fleshing out, and certain bits of code need to be cleaned up and slotted into the right place.&lt;/p&gt;&lt;p&gt;Oh, and of course, &lt;strong&gt;the whole thing needs to be documented&lt;/strong&gt;. That in and of itself is probably a pretty significant project, especially since there’s a good chance I’ll want to figure out how to best make use of Scribble for a language that’s a little bit different from Racket.&lt;/p&gt;&lt;p&gt;All in all, there’s a lot of work to be done! I am eager to make it happen, but I also work a full-time job, and I don’t have it in me to continue at the pace I’ve been working at for the past couple of weeks. Still, if you’re interested in the project, stay tuned and keep an eye on it—if all goes as planned, I hope to make it truly useful before too long.&lt;/p&gt;&lt;h2&gt;&lt;a name="answering-some-questions"&gt;&lt;/a&gt;Answering some questions&lt;/h2&gt;&lt;p&gt;It’s possible that this blog post does not seem like much; after all, it’s not terribly long. However, if you’re anything like me, there’s a good chance you are interested enough to have some questions! Obviously, I cannot anticipate all your questions and answer them here in advance, but I will try my best.&lt;/p&gt;&lt;h3&gt;&lt;a name="can-i-try-hackett"&gt;&lt;/a&gt;Can I try Hackett?&lt;/h3&gt;&lt;p&gt;Yes! With the caveat that it’s alpha software in every sense of the word: undocumented, not especially user friendly, and completely unstable. However, if you &lt;em&gt;do&lt;/em&gt; want to give it a try, it isn’t difficult: just install Racket, then run &lt;code&gt;raco pkg install hackett&lt;/code&gt;. Open DrRacket and write &lt;code&gt;#lang hackett&lt;/code&gt; at the top of the module, then start playing around.&lt;/p&gt;&lt;p&gt;Also, note that the demo web server used in the example at the top of this blog post is &lt;em&gt;not&lt;/em&gt; included when you install the &lt;code&gt;hackett&lt;/code&gt; package. If you want to try that out, you’ll have to run &lt;code&gt;raco pkg install hackett-demo&lt;/code&gt; to install the demo package as well.&lt;/p&gt;&lt;h3&gt;&lt;a name="are-there-any-examples-of-hackett-code"&gt;&lt;/a&gt;Are there any examples of Hackett code?&lt;/h3&gt;&lt;p&gt;Unfortunately, not a lot right now, aside from the tiny examples in this blog post. However, if you are already familiar with Haskell, the syntax likely won’t be hard to pick up. Reading the Hackett source code is not especially recommended, given that it is filled with implementation details. However, if you are interested, reading the module where most of the prelude is defined isn’t so bad. You can &lt;a href="https://github.com/lexi-lambda/hackett/blob/6ceeac05e3d2a4b2dacd39163744baf239cf65a4/hackett-lib/hackett/private/prim/base.rkt"&gt;find it on GitHub here&lt;/a&gt;, or you can open the &lt;code&gt;hackett/private/prim/base&lt;/code&gt; module on a local installation.&lt;/p&gt;&lt;h3&gt;&lt;a name="how-can-i-learn-more-ask-questions-about-hackett"&gt;&lt;/a&gt;How can I learn more / ask questions about Hackett?&lt;/h3&gt;&lt;p&gt;Feel free to ping me and ask me questions! I may not always be able to get back to you immediately, but if you hang around, I will eventually send you a response. The best ways to contact me are via the #racket IRC channel on Freenode, the snek Slack community (&lt;a href="http://snek.jneen.net"&gt;which you can sign up for here&lt;/a&gt;), sending me &lt;a href="https://twitter.com/lexi_lambda"&gt;a DM on Twitter&lt;/a&gt;, opening &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;an issue on the GitHub repo&lt;/a&gt;, or even just &lt;a href="mailto:lexi.lambda@gmail.com"&gt;sending me an email&lt;/a&gt; (though I’m usually a bit slower to respond to the latter).&lt;/p&gt;&lt;h3&gt;&lt;a name="how-can-i-help"&gt;&lt;/a&gt;How can I help?&lt;/h3&gt;&lt;p&gt;Probably the easiest way to help out is to try Hackett for yourself and &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;report any bugs or infelicities you run into&lt;/a&gt;. Of course, many issues right now are known, there’s just so much to do that I haven’t had the chance to clean everything up. For that reason, the most effective way to contribute is probably to pick an existing issue and try and implement it yourself, but I wouldn’t be surprised if most people found the existing implementation a little intimidating.&lt;/p&gt;&lt;p&gt;If you &lt;em&gt;are&lt;/em&gt; interested in helping out, I’d be happy to give you some pointers and answer some questions, since it would be extremely nice to have some help. Please feel free to contact me using any of the methods mentioned in the previous section, and I’ll try and help you find something you could work on.&lt;/p&gt;&lt;h3&gt;&lt;a name="how-does-hackett-compare-to-x-why-doesn-t-hackett-support-y"&gt;&lt;/a&gt;How does Hackett compare to &lt;em&gt;X&lt;/em&gt; / why doesn’t Hackett support &lt;em&gt;Y&lt;/em&gt;?&lt;/h3&gt;&lt;p&gt;These tend to be complex questions, and I don’t always have comprehensive answers for them, especially since the language is evolving so quickly. Still, if you want to ask me about this, feel free to just send the question to me directly. In my experience, it’s usually better to have a conversation about this sort of thing rather than just answering in one big comparison, since there’s usually a fair amount of nuance.&lt;/p&gt;&lt;h3&gt;&lt;a name="when-will-hackett-be-ready-for-me-to-use"&gt;&lt;/a&gt;When will Hackett be ready for me to use?&lt;/h3&gt;&lt;p&gt;I don’t know.&lt;/p&gt;&lt;p&gt;Obviously, there is a lot left to implement, that is certainly true, but there’s more to it than that. If all goes well, I don’t see any reason why Hackett can’t be early beta quality by the end of this year, even if it doesn’t support all of the goodies necessary to achieve perfection (which, of course, it never really can).&lt;/p&gt;&lt;p&gt;However, there are other things to consider, too. The Racket package system is currently flawed in ways that make rapidly iterating on Hackett hard, since it is extremely difficult (if not impossible) to make backwards-incompatible changes without potentially breaking someone’s program (even if they don’t update anything about their dependencies)! This is a solvable problem, but it would take some work modifying various elements of the package system and build tools, so that might need to get done before I can recommend Hackett in good faith.&lt;/p&gt;&lt;h2&gt;&lt;a name="appendix"&gt;&lt;/a&gt;Appendix&lt;/h2&gt;&lt;p&gt;It would be unfair not to mention all the people that have made Hackett possible. I cannot list them all here, but I want to give special thanks to &lt;a href="http://www.ccs.neu.edu/home/stchang/"&gt;Stephen Chang&lt;/a&gt;, &lt;a href="http://www.cs.ubc.ca/~joshdunf/"&gt;Joshua Dunfield&lt;/a&gt;, &lt;a href="http://eecs.northwestern.edu/~robby/"&gt;Robby Findler&lt;/a&gt;, &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, &lt;a href="http://functorial.com"&gt;Phil Freeman&lt;/a&gt;, &lt;a href="http://www.ccs.neu.edu/home/types/"&gt;Ben Greenman&lt;/a&gt;, &lt;a href="https://github.com/AlexKnauth"&gt;Alex Knauth&lt;/a&gt;, &lt;a href="http://www.cl.cam.ac.uk/~nk480/"&gt;Neelakantan Krishnaswami&lt;/a&gt;, and &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt;. I’d also like to thank everyone involved in the Racket and Haskell projects as a whole, as well as everyone who has expressed interest and encouragement about what I’ve been working on.&lt;/p&gt;&lt;p&gt;As a final point, just for fun, I thought I’d keep track of all the albums I’ve been listening to while working on Hackett, just in the past few weeks. It is &lt;a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/#whats-in-a-name"&gt;on theme with the name&lt;/a&gt;, after all. This list is not completely exhaustive, as I’m sure some slipped through the cracks, but you can thank the following artists for helping me power through a few of the hills in Hackett’s implementation:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The Beach Boys — Pet Sounds&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Boards of Canada — Music Has The Right To Children, Geogaddi&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Bruce Springsteen — Born to Run&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;King Crimson — In the Court of the Crimson King, Larks’ Tongues in Aspic, Starless and Bible Black, Red, Discipline&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Genesis — Nursery Cryme, Foxtrot, Selling England by the Pound, The Lamb Lies Down on Broadway, A Trick of the Tail&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Mahavishnu Orchestra — Birds of Fire&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Metric — Fantasies, Synthetica, Pagans in Vegas&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Muse — Origin of Symmetry, Absolution, The Resistance&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Peter Gabriel — Peter Gabriel I, II, III, IV / Security, Us, Up&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Pink Floyd — Wish You Were Here&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Supertramp — Breakfast In America&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The Protomen — The Protomen, Act II: The Father of Death&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Talking Heads — Talking Heads: 77, More Songs About Buildings and Food, Fear of Music, Remain in Light&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Yes — Fragile, Relayer, Going For The One&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;And of course, &lt;em&gt;Voyage of the Acolyte&lt;/em&gt;, by &lt;strong&gt;Steve Hackett&lt;/strong&gt;.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Lifts for free: making mtl typeclasses derivable</title><link>https://lexi-lambda.github.io/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/</guid><pubDate>28 Apr 2017</pubDate><description>&lt;article&gt;&lt;p&gt;Perhaps the most important abstraction a Haskell programmer must understand to effectively write modern Haskell code, beyond the level of the monad, is the &lt;em&gt;monad transformer&lt;/em&gt;, a way to compose monads together in a limited fashion. One frustrating downside to monad transformers is a proliferation of &lt;code&gt;lift&lt;/code&gt;s, which explicitly indicate which monad in a transformer “stack” a particular computation should run in. Fortunately, the venerable &lt;a href="https://hackage.haskell.org/package/mtl"&gt;mtl&lt;/a&gt; provides typeclasses that make this lifting mostly automatic, using typeclass machinery to insert &lt;code&gt;lift&lt;/code&gt; where appropriate.&lt;/p&gt;&lt;p&gt;Less fortunately, the mtl approach does not actually eliminate &lt;code&gt;lift&lt;/code&gt; entirely, it simply moves it from use sites to instances. This requires a small zoo of extraordinarily boilerplate-y instances, most of which simply implement each typeclass method using &lt;code&gt;lift&lt;/code&gt;. While we cannot eliminate the instances entirely without somewhat dangerous techniques like &lt;a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#overlapping-instances"&gt;overlapping instances&lt;/a&gt;, we &lt;em&gt;can&lt;/em&gt; automatically derive them using features of modern GHC, eliminating the truly unnecessary boilerplate.&lt;/p&gt;&lt;h2&gt;&lt;a name="the-problem-with-mtl-style-typeclasses"&gt;&lt;/a&gt;The problem with mtl-style typeclasses&lt;/h2&gt;&lt;p&gt;To understand what problem it is exactly that we’re trying to solve, we first need to take a look at an actual mtl-style typeclass. I am going to start with an mtl-&lt;em&gt;style&lt;/em&gt; typeclass, rather than an actual typeclass in the mtl, due to slight complications with mtl’s actual typeclasses that we’ll get into later. Instead, let’s start with a somewhat boring typeclass, which we’ll call &lt;code&gt;MonadExit&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;System.Exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitCode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a simple typeclass that abstracts over the concept of early exit, given an exit code. The most obvious implementation of this typeclass is over &lt;code&gt;IO&lt;/code&gt;, which will actually exit the program:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="k"&gt;qualified&lt;/span&gt; &lt;span class="nn"&gt;System.Exit&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exitWith&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exitWith&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One of the cool things about these typeclasses, though, is that we don’t have to have just one implementation. We could also write a pure implementation of &lt;code&gt;MonadExit&lt;/code&gt;, which would simply short-circuit the current computation and return the &lt;code&gt;ExitCode&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead of simply having an instance on a concrete monad, though, we probably want to be able to use this in a larger monad stack, so we can define an &lt;code&gt;ExitT&lt;/code&gt; monad transformer that can be inserted into any monad transformer stack:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="cm"&gt;{-# LANGUAGE GeneralizedNewtypeDeriving #-}&lt;/span&gt;

&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Control.Monad.Except&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;runExceptT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;throwError&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Control.Monad.Trans&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadTrans&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;runExitT&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;runExitT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;runExceptT&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;throwError&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this in place, we can write actual programs using our &lt;code&gt;ExitT&lt;/code&gt; monad transformer:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;runExitT&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
        &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;putStrLn&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;
        &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitFailure&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;putStrLn&lt;/span&gt; &lt;span class="s"&gt;"world"&lt;/span&gt;
&lt;span class="nf"&gt;hello&lt;/span&gt;
&lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitFailure&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is pretty cool! Unfortunately, experienced readers will see the rather large problem with what we have so far. Specifically, it won’t actually work if we try and wrap &lt;code&gt;ExitT&lt;/code&gt; in another monad transformer:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;logIn&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;runExitT&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="n"&gt;runReaderT&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
        &lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt;
        &lt;span class="n"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;"password1234"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="c1"&gt;-- super secure password&lt;/span&gt;
          &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitFailure&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="s"&gt;"access granted"&lt;/span&gt;

&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;logIn&lt;/span&gt; &lt;span class="s"&gt;"not the right password"&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;interactive&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;
    &lt;span class="err"&gt;•&lt;/span&gt; &lt;span class="kt"&gt;No&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="n"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="n"&gt;m0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;arising&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt; &lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;
    &lt;span class="err"&gt;•&lt;/span&gt; &lt;span class="kt"&gt;In&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;stmt&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;interactive&lt;/span&gt; &lt;span class="kt"&gt;GHCi&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The error message is relatively self-explanatory if you are familiar with mtl error messages: there is no &lt;code&gt;MonadExit&lt;/code&gt; instance for &lt;code&gt;ReaderT&lt;/code&gt;. This makes sense, since we only defined a &lt;code&gt;MonadExit&lt;/code&gt; instance for &lt;em&gt;&lt;code&gt;ExitT&lt;/code&gt;&lt;/em&gt;, nothing else. Fortunately, the instance for &lt;code&gt;ReaderT&lt;/code&gt; is completely trivial, since we just need to use &lt;code&gt;lift&lt;/code&gt; to delegate to the next monad in the stack:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that the delegating instance is set up, we can actually use our &lt;code&gt;logIn&lt;/code&gt; function:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;logIn&lt;/span&gt; &lt;span class="s"&gt;"not the right password"&lt;/span&gt;
&lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitFailure&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;logIn&lt;/span&gt; &lt;span class="s"&gt;"password1234"&lt;/span&gt;
&lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="s"&gt;"access granted"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name="an-embarrassment-of-instances"&gt;&lt;/a&gt;An embarrassment of instances&lt;/h3&gt;&lt;p&gt;We’ve managed to make our program work properly now, but we’ve still only defined the delegating instance for &lt;code&gt;ReaderT&lt;/code&gt;. What if someone wants to use &lt;code&gt;ExitT&lt;/code&gt; with &lt;code&gt;WriterT&lt;/code&gt;? Or &lt;code&gt;StateT&lt;/code&gt;? Or any of &lt;code&gt;ExceptT&lt;/code&gt;, &lt;code&gt;RWST&lt;/code&gt;, or &lt;code&gt;ContT&lt;/code&gt;? Well, we have to define instances for each and every one of them, and as it turns out, the instances are all identical!&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;RWST&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ContT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is bad enough on its own, but this is actually the &lt;em&gt;simplest&lt;/em&gt; case: a typeclass with a single method which is trivially lifted through any other monad transformer. Another thing we’ve glossed over is actually defining all the delegating instances for the &lt;em&gt;other&lt;/em&gt; mtl typeclasses on &lt;code&gt;ExitT&lt;/code&gt; itself. Fortunately, we can derive these ones with &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;, since &lt;code&gt;ExceptT&lt;/code&gt; has already done most of the work for us:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadIO&lt;/span&gt; &lt;span class="c1"&gt;-- base&lt;/span&gt;
           &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadBase&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="c1"&gt;-- transformers-base&lt;/span&gt;
           &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadTrans&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="c1"&gt;-- mtl&lt;/span&gt;
           &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadThrow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadCatch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadMask&lt;/span&gt; &lt;span class="c1"&gt;-- exceptions&lt;/span&gt;
           &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadTransControl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadBaseControl&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="c1"&gt;-- monad-control&lt;/span&gt;
           &lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unfortunately, we have to write the &lt;code&gt;MonadError&lt;/code&gt; instance manually if we want it, since we don’t want to pick up the instance from &lt;code&gt;ExceptT&lt;/code&gt;, but rather wish to defer to the underlying monad. This means writing some truly horrid delegation code:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;throwError&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;throwError&lt;/span&gt;

  &lt;span class="n"&gt;catchError&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;catchError&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runExceptT&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExitT&lt;/span&gt; &lt;span class="n"&gt;x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="kr"&gt;in&lt;/span&gt; &lt;span class="n"&gt;runExceptT&lt;/span&gt; &lt;span class="n"&gt;x&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(Notably, this is so awful because &lt;code&gt;catchError&lt;/code&gt; is more complex than the simple &lt;code&gt;exitWith&lt;/code&gt; method we’ve studied so far, which is why we’re starting with a simpler typeclass. We’ll get more into this later, as promised.)&lt;/p&gt;&lt;p&gt;This huge number of instances is sometimes referred to as the “n&lt;sup&gt;2&lt;/sup&gt; instances” problem, since it requires every monad transformer have an instance of every single mtl-style typeclass. Fortunately, in practice, this proliferation is often less horrible than it might seem, mostly because deriving helps a lot. However, remember that if &lt;code&gt;ExitT&lt;/code&gt; &lt;em&gt;weren’t&lt;/em&gt; a simple wrapper around an existing monad transformer, we wouldn’t be able to derive the instances at all! Instead, we’d have to write them all out by hand, just like we did with all the &lt;code&gt;MonadExit&lt;/code&gt; instances.&lt;/p&gt;&lt;p&gt;It’s a shame that these typeclass instances can’t be derived in a more general way, allowing derivation for arbitrary monad transformers instead of simply requiring the newtype deriving machinery. As it turns out, with clever use of modern GHC features, we actually &lt;strong&gt;can&lt;/strong&gt;. It’s not even all that hard.&lt;/p&gt;&lt;h2&gt;&lt;a name="default-instances-with-default-signatures"&gt;&lt;/a&gt;Default instances with default signatures&lt;/h2&gt;&lt;p&gt;It’s not hard to see that our &lt;code&gt;MonadExit&lt;/code&gt; instances are all exactly the same: just &lt;code&gt;lift . exitWith&lt;/code&gt;. Why is that, though? Well, every instance is an instance on a monad transformer over a monad that is already an instance of &lt;code&gt;MonadExit&lt;/code&gt;. In fact, we can express this in a type signature, and we can extract &lt;code&gt;lift . exitWith&lt;/code&gt; into a separate function:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;defaultExitWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;defaultExitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, writing &lt;code&gt;defaultExitWith&lt;/code&gt; really isn’t any easier than writing &lt;code&gt;lift . exitWith&lt;/code&gt;, so this deduplication doesn’t really buy us anything. However, it &lt;em&gt;does&lt;/em&gt; indicate that we could write a default implementation of &lt;code&gt;exitWith&lt;/code&gt; if we could require just a little bit more from the implementing type. With &lt;a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#default-method-signatures"&gt;GHC’s &lt;code&gt;DefaultSignatures&lt;/code&gt; extension&lt;/a&gt;, we can do precisely that.&lt;/p&gt;&lt;p&gt;The idea is that we can write a separate type signature for a default implementation of &lt;code&gt;exitWith&lt;/code&gt;, which can be more specific than the type signature for &lt;code&gt;exitWith&lt;/code&gt; in general. This allows us to use our &lt;code&gt;defaultExitWith&lt;/code&gt; implementation more or less directly:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="cm"&gt;{-# LANGUAGE DefaultSignatures #-}&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;

  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have to use &lt;code&gt;m1&lt;/code&gt; instead of &lt;code&gt;m&lt;/code&gt;, since type variables in the instance head are always scoped, and the names would conflict. However, this creates another problem, since our specialized type signature replaces &lt;code&gt;m&lt;/code&gt; with &lt;code&gt;t m1&lt;/code&gt;, which won’t quite work (as GHC can’t automatically figure out they should be the same). Instead, we can use &lt;code&gt;m&lt;/code&gt; in the type signature, then just add a type equality constraint ensuring that &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;t m1&lt;/code&gt; must be the same type:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;

  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;exitWith&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can write all of our simple instances without even needing to write a real implementation! All of the instance bodies can be empty:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;RWST&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ContT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;While this doesn’t completely alleviate the pain of writing instances, it’s definitely an improvement over what we had before. With &lt;a href="https://downloads.haskell.org/~ghc/8.2.1-rc1/docs/html/users_guide/glasgow_exts.html#deriving-strategies"&gt;GHC 8.2’s new &lt;code&gt;DerivingStrategies&lt;/code&gt; extension&lt;/a&gt;, it becomes especially beneficial when defining entirely new transformers that should also have &lt;code&gt;ExitT&lt;/code&gt; instances, since they can be derived with &lt;code&gt;DeriveAnyClass&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;ParserT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ParserT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="n"&gt;anyclass&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadExit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is pretty wonderful.&lt;/p&gt;&lt;p&gt;Given that only &lt;code&gt;MonadExit&lt;/code&gt; supports being derived in this way, we sadly still need to implement the other, more standard mtl-style typeclasses ourselves, like &lt;code&gt;MonadIO&lt;/code&gt;, &lt;code&gt;MonadBase&lt;/code&gt;, &lt;code&gt;MonadReader&lt;/code&gt;, &lt;code&gt;MonadWriter&lt;/code&gt;, etc. However, what if all of those classes provided the same convenient default signatures that our &lt;code&gt;MonadExit&lt;/code&gt; does? If that were the case, then we could write something like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;ParserT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ParserT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="n"&gt;anyclass&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;MonadIO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadBase&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
                    &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
                    &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadThrow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadCatch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadMask&lt;/span&gt;
                    &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt;
                    &lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Compared to having to write all those instances by hand, this would be a pretty enormous difference. Unfortunately, many of these typeclasses are not quite as simple as our &lt;code&gt;MonadExit&lt;/code&gt;, and we’d have to be a bit more clever to make them derivable.&lt;/p&gt;&lt;h2&gt;&lt;a name="making-mtl-s-classes-derivable"&gt;&lt;/a&gt;Making mtl’s classes derivable&lt;/h2&gt;&lt;p&gt;Our &lt;code&gt;MonadExit&lt;/code&gt; class was extremely simple, since it only had a single method with a particularly simple type signature. For reference, this was the type of our generic &lt;code&gt;exitWith&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;exitWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadExit&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ExitCode&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let’s now turn our attention to &lt;code&gt;MonadReader&lt;/code&gt;. At first blush, this typeclass should not be any trickier to implement than &lt;code&gt;MonadExit&lt;/code&gt;, since the types of &lt;code&gt;ask&lt;/code&gt; and &lt;code&gt;reader&lt;/code&gt; are both quite simple:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;ask&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;
&lt;span class="nf"&gt;reader&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, the type of the other method, &lt;code&gt;local&lt;/code&gt;, throws a bit of a wrench in our plans. It has the following type signature:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;local&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Why is this so much more complicated? Well, the key is in the second argument, which has the type &lt;code&gt;m a&lt;/code&gt;. That’s not something that can be simply &lt;code&gt;lift&lt;/code&gt;ed away! Try it yourself: try to write a &lt;code&gt;MonadReader&lt;/code&gt; instance for some monad transformer. It’s not as easy as it looks!&lt;/p&gt;&lt;p&gt;We can illustrate the problem by creating our own version of &lt;code&gt;MonadReader&lt;/code&gt; and implementing it for something like &lt;code&gt;ExceptT&lt;/code&gt; ourselves. We can start with the trivial methods first:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;ask&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;
  &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;ask&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt;
  &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, implementing &lt;code&gt;local&lt;/code&gt; is harder. Let’s specialize the type signature to &lt;code&gt;ExceptT&lt;/code&gt; to make it more clear why:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;local&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Our base monad, &lt;code&gt;m&lt;/code&gt;, implements &lt;code&gt;local&lt;/code&gt;, but we have to convert the first argument from &lt;code&gt;ExceptT e m a&lt;/code&gt; into &lt;code&gt;m (Either e a)&lt;/code&gt; first, run it through &lt;code&gt;local&lt;/code&gt; in &lt;code&gt;m&lt;/code&gt;, then wrap it back up in &lt;code&gt;ExceptT&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;ask&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt;
  &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt;
  &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runExceptT&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This operation is actually a mapping operation of sorts, since we’re mapping &lt;code&gt;local f&lt;/code&gt; over &lt;code&gt;x&lt;/code&gt;. For that reason, this can be rewritten using the &lt;code&gt;mapExceptT&lt;/code&gt; function provided from &lt;code&gt;Control.Monad.Except&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;ask&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt;
  &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt;
  &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mapExceptT&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you implement &lt;code&gt;MonadReader&lt;/code&gt; instances for other transformers, like &lt;code&gt;StateT&lt;/code&gt; and &lt;code&gt;WriterT&lt;/code&gt;, you’ll find that the instances are exactly the same &lt;em&gt;except&lt;/em&gt; for &lt;code&gt;mapExceptT&lt;/code&gt;, which is replaced with &lt;code&gt;mapStateT&lt;/code&gt; and &lt;code&gt;mapWriterT&lt;/code&gt;, respectively. This is sort of obnoxious, given that we want to figure out how to create a generic version of &lt;code&gt;local&lt;/code&gt; that works with any monad transformer, but this requires concrete information about which monad we’re in. Obviously, the power &lt;code&gt;MonadTrans&lt;/code&gt; gives us is not enough to make this generic. Fortunately, there is a typeclass which does: &lt;a href="http://hackage.haskell.org/package/monad-control-1.0.1.0/docs/Control-Monad-Trans-Control.html#t:MonadTransControl"&gt;&lt;code&gt;MonadTransControl&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;monad-control&lt;/code&gt; package.&lt;/p&gt;&lt;p&gt;Using &lt;code&gt;MonadTransControl&lt;/code&gt;, we can write a generic &lt;code&gt;mapT&lt;/code&gt; function that maps over an arbitrary monad transformer with a &lt;code&gt;MonadTransControl&lt;/code&gt; instance:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;mapT&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="kt"&gt;MonadTransControl&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StT&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StT&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
     &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="nf"&gt;mapT&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftWith&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;restoreT&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This type signature may look complicated (and, well, it is), but the idea is that the &lt;code&gt;StT&lt;/code&gt; associated type family encapsulates the monadic state that &lt;code&gt;t&lt;/code&gt; introduces. For example, for &lt;code&gt;ExceptT&lt;/code&gt;, &lt;code&gt;StT (ExceptT e) a&lt;/code&gt; is &lt;code&gt;Either e a&lt;/code&gt;. For &lt;code&gt;StateT&lt;/code&gt;, &lt;code&gt;StT (StateT s) a&lt;/code&gt; is &lt;code&gt;(a, s)&lt;/code&gt;. Some transformers, like &lt;code&gt;ReaderT&lt;/code&gt;, have no state, so &lt;code&gt;StT (ReaderT r) a&lt;/code&gt; is just &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;I will not go into the precise mechanics of how &lt;code&gt;MonadTransControl&lt;/code&gt; works in this blog post, but it doesn’t matter significantly; the point is that we can now use &lt;code&gt;mapT&lt;/code&gt; to create a generic implementation of &lt;code&gt;local&lt;/code&gt; for use with &lt;code&gt;DefaultSignatures&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;ask&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;
  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;
  &lt;span class="n"&gt;ask&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt;

  &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTransControl&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mapT&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt;

  &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;reader&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ask&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Once more, we now get instances of our typeclass, in this case &lt;code&gt;MonadReader&lt;/code&gt;, &lt;strong&gt;for free&lt;/strong&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It’s also worth noting that we &lt;em&gt;don’t&lt;/em&gt; get a &lt;code&gt;ContT&lt;/code&gt; instance for free, even though &lt;code&gt;ContT&lt;/code&gt; has a &lt;code&gt;MonadReader&lt;/code&gt; instance in mtl. Unlike the other monad transformers mtl provides, &lt;code&gt;ContT&lt;/code&gt; does not have a &lt;code&gt;MonadTransControl&lt;/code&gt; instance because it cannot be generally mapped over. While a &lt;code&gt;mapContT&lt;/code&gt; function does exist, its signature is more restricted:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;mapContT&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ContT&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ContT&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It happens that &lt;code&gt;local&lt;/code&gt; can still be implemented for &lt;code&gt;ContT&lt;/code&gt;, so it can still have a &lt;code&gt;MonadReader&lt;/code&gt; instance, but it cannot be derived in the same way as it can for the other transformers. Still, in practice, I’ve found that most user-defined transformers do not have such complex control flow, so they can safely be instances of &lt;code&gt;MonadTransControl&lt;/code&gt;, and they get this deriving for free.&lt;/p&gt;&lt;h3&gt;&lt;a name="extending-this-technique-to-other-mtl-typeclasses"&gt;&lt;/a&gt;Extending this technique to other mtl typeclasses&lt;/h3&gt;&lt;p&gt;The default instances for the other mtl typeclasses are slightly different from the one for &lt;code&gt;MonadReader&lt;/code&gt;, but for the most part, the same general technique applies. Here’s a derivable &lt;code&gt;MonadError&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;throwError&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;throwError&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;throwError&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;throwError&lt;/span&gt;

  &lt;span class="n"&gt;catchError&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;catchError&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTransControl&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;catchError&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftWith&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;catchError&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;restoreT&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;RWST&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;MonadState&lt;/code&gt; interface turns out to be extremely simple, so it doesn’t even need &lt;code&gt;MonadTransControl&lt;/code&gt; at all:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
  &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;

  &lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt;

  &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
    &lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="n"&gt;s&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;WriterT&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Everything seems to be going well! However, not everything is quite so simple.&lt;/p&gt;&lt;h3&gt;&lt;a name="a-monadwriter-diversion"&gt;&lt;/a&gt;A &lt;code&gt;MonadWriter&lt;/code&gt; diversion&lt;/h3&gt;&lt;p&gt;Unexpectedly, &lt;code&gt;MonadWriter&lt;/code&gt; turns out to be by far the trickiest of the bunch. It’s not too hard to create default implementations for most of the methods of the typeclass:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt;

  &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTrans&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lift&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt;

  &lt;span class="n"&gt;listen&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;listen&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTransControl&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;listen&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftWith&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;listen&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;y&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;restoreT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, &lt;code&gt;MonadWriter&lt;/code&gt; has a fourth method, &lt;code&gt;pass&lt;/code&gt;, which has a particularly tricky type signature:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;pass&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As far as I can tell, this is not possible to generalize using &lt;code&gt;MonadTransControl&lt;/code&gt; alone, since it would require inspection of the result of the monadic argument (that is, it would require a function from &lt;code&gt;StT t (a, b) -&amp;gt; (StT t a, b)&lt;/code&gt;), which is not possible in general. My gut is that this could likely also be generalized with a slightly more powerful abstraction than &lt;code&gt;MonadTransControl&lt;/code&gt;, but it is not immediately obvious to me what that abstraction should be.&lt;/p&gt;&lt;p&gt;One extremely simple way to make this possible would be to design something to serve this specific use case:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;RunSplit&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StT&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;MonadTransControl&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadTransSplit&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;liftWithSplit&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;RunSplit&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instances of &lt;code&gt;MonadTransSplit&lt;/code&gt; would basically just provide a way to pull out bits of the result, if possible:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadTransSplit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;liftWithSplit&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmap&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadTransSplit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ExceptT&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;liftWithSplit&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmap&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadTransSplit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;StateT&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;liftWithSplit&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftWith&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmap&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then, using this, it would be possible to write a generic version of &lt;code&gt;pass&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;default&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadTransSplit&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;pass&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftWithSplit&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;case&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;restoreT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, this seems pretty overkill for just one particular method, given that I have no idea if &lt;code&gt;MonadTransSplit&lt;/code&gt; would be useful &lt;em&gt;anywhere&lt;/em&gt; else. One interesting thing about going down this rabbit hole, though, is that I learned that &lt;code&gt;pass&lt;/code&gt; has some somewhat surprising behavior when mixed with transformers like &lt;code&gt;ExceptT&lt;/code&gt; or &lt;code&gt;MaybeT&lt;/code&gt;, if you don’t carefully consider how it works. It’s a strange method with a somewhat strange interface, so I don’t think I have a satisfactory conclusion about &lt;code&gt;MonadWriter&lt;/code&gt; yet.&lt;/p&gt;&lt;h2&gt;&lt;a name="regrouping-and-stepping-back"&gt;&lt;/a&gt;Regrouping and stepping back&lt;/h2&gt;&lt;p&gt;Alright, that was a lot of fairly intense, potentially confusing code. What the heck did we actually accomplish? Well, we got a couple of things:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;First, we developed a technique for writing simple mtl-style typeclasses that are derivable using &lt;code&gt;DeriveAnyClass&lt;/code&gt; (or simply writing an empty instance declaration). We used a &lt;code&gt;MonadExit&lt;/code&gt; class as a proof of concept, but really, the technique is applicable to most mtl-style typeclasses that represent simple effects (including, for example, &lt;code&gt;MonadIO&lt;/code&gt;).&lt;/p&gt;&lt;p&gt;This technique is useful in isolation, even if you completely disregard the rest of the blog post. For an example where I recently applied it in real code, see &lt;a href="https://github.com/cjdev/monad-persist/blob/1ce8568d881da3171f8689dd65f4f2df5f6dd313/library/Control/Monad/Persist.hs#L226-L271"&gt;the default signatures provided with &lt;code&gt;MonadPersist&lt;/code&gt; from the &lt;code&gt;monad-persist&lt;/code&gt; library&lt;/a&gt;, which make &lt;a href="https://github.com/cjdev/monad-persist/blob/1ce8568d881da3171f8689dd65f4f2df5f6dd313/library/Control/Monad/Persist.hs#L506-L513"&gt;defining instances completely trivial&lt;/a&gt;. If you use mtl-style typeclasses in your own application to model effects, I don’t see much of a reason &lt;em&gt;not&lt;/em&gt; to use this technique.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;After &lt;code&gt;MonadExit&lt;/code&gt;, we applied the same technique to the mtl-provided typeclasses &lt;code&gt;MonadReader&lt;/code&gt;, &lt;code&gt;MonadError&lt;/code&gt;, and &lt;code&gt;MonadState&lt;/code&gt;. These are a bit trickier, since the first two need &lt;code&gt;MonadTransControl&lt;/code&gt; in addition to the  usual &lt;code&gt;MonadTrans&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Whether or not this sort of thing should actually be added to mtl itself probably remains to be seen. For the simplest typeclass, &lt;code&gt;MonadState&lt;/code&gt;, it seems like there probably aren’t many downsides, but given the difficulty implementing it for &lt;code&gt;MonadWriter&lt;/code&gt; (or, heaven forbid, &lt;code&gt;MonadCont&lt;/code&gt;, which I didn’t even seriously take a look at for this blog post), it doesn’t seem like an obvious win. Consistency is important.&lt;/p&gt;&lt;p&gt;Another downside that I sort of glossed over is possibly even more significant from a practical point of view: adding default signatures to &lt;code&gt;MonadReader&lt;/code&gt; would require the removal of the default implementation of &lt;code&gt;ask&lt;/code&gt; that is provided by the existing library (which implements &lt;code&gt;ask&lt;/code&gt; in terms of &lt;code&gt;reader&lt;/code&gt;). This would be backwards-incompatible, so it’d be difficult to change, even if people wanted to do it. Still, it’s interesting to consider what these typeclasses might look like if they were designed today.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Overall, these techniques are not a silver bullet for deriving mtl-style typeclasses, nor do they eliminate the n&lt;sup&gt;2&lt;/sup&gt; instances problem that mtl style suffers from. That said, they &lt;em&gt;do&lt;/em&gt; significantly reduce boilerplate and clutter in the simplest cases, and they demonstrate how modern Haskell’s hierarchy of typeclasses provides a lot of power, both to describe quite abstract concepts and to alleviate the need to write code by hand.&lt;/p&gt;&lt;p&gt;I will continue to experiment with the ideas described in this blog post, and I’m sure some more pros and cons will surface as I explore the design space. If you have any suggestions for how to deal with “the &lt;code&gt;MonadWriter&lt;/code&gt; problem”, I’d be very interested to hear them! In the meantime, consider using the technique in your application code when writing effectful, monadic typeclasses.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Rascal is now Hackett, plus some answers to questions</title><link>https://lexi-lambda.github.io/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/</guid><pubDate>05 Jan 2017</pubDate><description>&lt;article&gt;&lt;p&gt;Since I published &lt;a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"&gt;my blog post introducing Rascal&lt;/a&gt;, I’ve gotten some &lt;em&gt;amazing&lt;/em&gt; feedback, more than I had ever anticipated! One of the things that was pointed out, though, is that &lt;a href="http://www.rascal-mpl.org"&gt;Rascal is a language that already exists&lt;/a&gt;. Given that the name “Rascal” came from a mixture of “Racket” and “Haskell”, I always had an alternative named planned, and that’s “Hackett”. So, to avoid confusion as much as possible, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;&lt;strong&gt;Rascal is now known as Hackett&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;With that out of the way, I also want to answer some of the other questions I received, both to hopefully clear up some confusion and to have something I can point to if I get the same questions in the future.&lt;/p&gt;&lt;h2&gt;&lt;a name="what-s-in-a-name"&gt;&lt;/a&gt;What’s in a name?&lt;/h2&gt;&lt;p&gt;First, a little trivia.&lt;/p&gt;&lt;p&gt;I’ve already mentioned that the old “Rascal” name was based on the names “Racket” and “Haskell”, which is true. However, it had a slightly deeper meaning, too: the name fit a tradition of naming languages in the Scheme family after somewhat nefarious things, such as “Gambit”, “Guile”, “Larceny”, and “Racket” itself. The name goes back a little bit further to the Planner programming language; Scheme was originally called Schemer, but it was (no joke) shorted due to filename length restrictions.&lt;/p&gt;&lt;p&gt;Still, my language isn’t really a Scheme, so the weak connection wasn’t terribly relevant. Curious readers might be wondering if there’s any deeper meaning to the name “Hackett” than a mixture of the two language names. In fact, there is. Hackett is affectionately named after the &lt;a href="https://en.wikipedia.org/wiki/Steve_Hackett"&gt;Genesis progressive rock guitarist, Steve Hackett&lt;/a&gt;, one of my favorite musicians. The fact that the name is a homophone with “hack-it” is another convenient coincidence.&lt;/p&gt;&lt;p&gt;Perhaps not the most interesting thing in this blog post, but there it is.&lt;/p&gt;&lt;h2&gt;&lt;a name="why-racket-why-not-haskell"&gt;&lt;/a&gt;Why Racket? Why &lt;em&gt;not&lt;/em&gt; Haskell?&lt;/h2&gt;&lt;p&gt;One of the most common questions I received is why I used Racket as the implementation language instead of Haskell. This is a decent question, and I think it likely stems at least in part from an item of common confusion: &lt;strong&gt;Racket is actually two things, a programming language and a programming language platform&lt;/strong&gt;. The fact that the two things have the same name is probably not ideal, but it’s what we’ve got.&lt;/p&gt;&lt;p&gt;Racket-the-language is obviously the primary language used on the Racket platform, but there’s actually surprisingly little need for that to be the case; it’s simply the language that is worked on the most. Much of the Racket tooling, including the compiler, macroexpander, and IDE, are actually totally language agnostic. If someone came along and wrote a language that got more popular than &lt;code&gt;#lang racket&lt;/code&gt;, then there wouldn’t really be anything hardcoded into any existing tooling that would give the impression that &lt;code&gt;#lang racket&lt;/code&gt; was ever the more “dominant” language, aside from the name.&lt;/p&gt;&lt;p&gt;For this reason, Racket is ideal for implementing new programming languages, moreso than pretty much any other platform out there. The talk I linked to in the previous blog post, &lt;a href="https://www.youtube.com/watch?v=TfehOLha-18"&gt;Languages in an Afternoon&lt;/a&gt;, describes this unique capability. It’s short, only ~15 minutes, but if you’re not into videos, I can try and explain why Racket is so brilliant for this sort of thing.&lt;/p&gt;&lt;p&gt;By leveraging the Racket platform instead of implementing my language from scratch, I get the following things pretty much for free:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;I get a JIT compiler for my code, and I don’t have to implement a compiler myself.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I also get a package manager that can cooperate with Hackett code to deliver Hackett modules.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I get a documentation system that is fully indexed and automatically locally installed when you install Hackett or any package written in Hackett, and that documentation is automatically integrated with the editor.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The DrRacket IDE can be used out of the box with Hackett code, it automatically does syntax highlighting and indenting, and it even provides interactive tools for inspecting bindings (something that I demo in my aforementioned talk).&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If you don’t want to use DrRacket, you can use the &lt;a href="https://github.com/greghendershott/racket-mode"&gt;racket-mode&lt;/a&gt; major mode for Emacs, which uses the same sets of tools that DrRacket uses under the hood, so you get most of the same DrRacket goodies without sacrificing Emacs’s power of customization.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Reimplementing all of that in another language would take years of work, and I haven’t even mentioned Racket’s module system and macroexpander, which are the underpinnings of Hackett. GHC’s typechecker is likely roughly as complex as Racket’s macroexpander combined with its module system, but I am not currently implementing GHC’s typechecker, since I do not need all of OutsideIn(X)’s features, just Haskell 98 + some extensions.&lt;/p&gt;&lt;p&gt;In contrast, I truly do need all of the Racket macroexpander to implement Hackett, since the &lt;em&gt;Type Systems as Macros&lt;/em&gt; paper uses pretty much every trick the Racket macro system has to offer to implement typechecking as macroexpansion. For those reasons, implementing the Racket macroexpander &lt;strong&gt;alone&lt;/strong&gt; in Haskell would likely be monumentally more work than implementing a Hindley-Milner typechecker in Racket, so it doesn’t really make sense to use Haskell for that job.&lt;/p&gt;&lt;h3&gt;&lt;a name="actually-running-hackett-code"&gt;&lt;/a&gt;Actually running Hackett code&lt;/h3&gt;&lt;p&gt;Now, it’s worth noting that GHC is much more efficient as a compiler than Racket is, for a whole host of reasons. However, since typechecking and macroexpansion are inherently strictly compile-time phases, it turns out to be totally feasible to run the typechecker/macroexpander in Racket (since in Hackett, the two things are one and the same), then compile the resulting fully-expanded, well-typed code to GHC Core. That could then be handed off to GHC itself and compiled using the full power of the GHC optimizer and compiler toolchain.&lt;/p&gt;&lt;p&gt;This would be no small amount of work, but it seems theoretically possible, so eventually it’s something I’d love to look into. There are various complexities to making it work, but I think it would let me get the best of both worlds without reinventing the wheel, so it’s something I want long-term.&lt;/p&gt;&lt;p&gt;There’s also the question of how “native” Hackett code would be, were it compiled to GHC Core. Would Hackett code be able to use Haskell libraries, and vice versa? My guess is that the answer is “yes, with some glue”. It probably wouldn’t be possible to do it completely seamlessly, because Hackett provides type information at macroexpansion time that likely wouldn’t exist in the same form in GHC. It might be possible to do some incredibly clever bridging to be able to use Haskell libraries in Hackett almost directly, but the inverse might not be true if a library’s interface depends on macros.&lt;/p&gt;&lt;h2&gt;&lt;a name="how-do-template-haskell-quasiquoters-compete-with-macros"&gt;&lt;/a&gt;How do Template Haskell quasiquoters compete with macros?&lt;/h2&gt;&lt;p&gt;Quasiquoters have a number of drawbacks, but the two main ones are complexity and lack of composition.&lt;/p&gt;&lt;p&gt;S-expressions happen to be simple, and this means s-expression macros have two lovely properties: they’re easy to write, given good libraries (Racket has &lt;a href="http://docs.racket-lang.org/syntax/stxparse.html"&gt;&lt;code&gt;syntax/parse&lt;/code&gt;&lt;/a&gt;), and they’re easy for tools to understand. Quasiquoters force implementors to write their own parsers from raw strings of characters, which is quite a heavy burden, and it usually means those syntaxes are confusing and brittle. To give a good example, consider &lt;a href="http://www.yesodweb.com/book/persistent#persistent_code_generation"&gt;persistent’s quasiquoters&lt;/a&gt;: they look &lt;em&gt;sort of&lt;/em&gt; like Haskell data declarations, but they’re not really, and I honestly have no idea what their actual syntax really is. It feels pretty finicky, though. In contrast, an s-expression based version of the same syntax would basically look just like the usual datatype declaration form, plus perhaps some extra goodies.&lt;/p&gt;&lt;p&gt;Additionally, s-expression macros &lt;em&gt;compose&lt;/em&gt;, and this should probably be valued more than anything else. If you’re writing code that doesn’t compose, it’s usually a bad sign. So much of functional programming is about writing small, reusable pieces of code that can be composed together, and macros are no different. Racket’s &lt;code&gt;match&lt;/code&gt;, for example, is an expression, and it contains expressions, so &lt;code&gt;match&lt;/code&gt; can be nested within itself, as well as other arbitrary macros that produce expressions. Similarly, many Racket macros can be extended, which is possible due to having such uniform syntax.&lt;/p&gt;&lt;p&gt;Making macros “stand out” is an issue of some subjectivity, but in my experience such a fear of macros tends to stem from a familiarity with bad macro systems (which, to be fair, is almost all of them) and poor tooling. I’ve found that, in practice, most of the reasons people want to know “is this a macro??” is because macros are scary black boxes and people want to know which things to be suspicious of.&lt;/p&gt;&lt;p&gt;Really, though, one of the reasons macros are complicated isn’t knowing which things are macros, but it’s knowing &lt;em&gt;which identifiers are uses and which identifiers are bindings&lt;/em&gt;, and things like that. Just knowing that something is a macro use doesn’t actually help at all there—the syntax won’t tell you. &lt;a href="http://i.imgur.com/HvYee19.png"&gt;Solve that problem with tools that address the problem head on, not by making a syntax that makes macros second-class citizens.&lt;/a&gt; One of the reasons I used the phrase “syntactic abstractions” in my previous blog post is because you specifically want them to be &lt;strong&gt;abstractions&lt;/strong&gt;. If you have to think of a macro in terms of the thing it expands to then it isn’t a very watertight abstraction. You don’t think about Haskell pattern-matching in terms of what the patterns compile to, you just use them. Macros should be (and can be) just as fluid.&lt;/p&gt;&lt;h2&gt;&lt;a name="how-can-i-help"&gt;&lt;/a&gt;How can I help?&lt;/h2&gt;&lt;p&gt;Right now, what I really need is someone who understands type system implementation. You don’t need to be up to date on what’s cutting edge—I’m not implementing anything nearly as complicated as GADTs or dependent types yet—you just need to understand how to implement Haskell 98. If you have that knowledge and you’re interested in helping, even if it just means answering some of my questions, please contact me via email, IRC (the #racket channel on Freenode is a good place for now), or Slack (I’m active in the snek Slack community, &lt;a href="http://snek.jneen.net"&gt;which you can sign up for here&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;If you aren’t familiar with those things, but you’re still interested in helping out, there’s definitely plenty of work that needs doing. If you want to find somewhere you can pitch in, contacting me via any of the above means is totally fine, and I can point you in the right direction. Even if you just want to be a guinea pig, that’s useful.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Rascal: a Haskell with more parentheses</title><link>https://lexi-lambda.github.io/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/</guid><pubDate>02 Jan 2017</pubDate><description>&lt;article&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: since the writing of this blog post, Rascal has been renamed to Hackett. You can read about why in &lt;a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/"&gt;the followup blog post&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;“Hey! You got your Haskell in my Racket!”&lt;/p&gt;&lt;p&gt;“No, you got &lt;em&gt;your&lt;/em&gt; Racket in &lt;em&gt;my&lt;/em&gt; Haskell!”&lt;/p&gt;&lt;p&gt;Welcome to the &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Rascal&lt;/a&gt; programming language.&lt;/p&gt;&lt;h2&gt;&lt;a name="why-rascal"&gt;&lt;/a&gt;Why Rascal?&lt;/h2&gt;&lt;p&gt;Why yet &lt;em&gt;another&lt;/em&gt; programming language? Anyone who knows me knows that I already have two programming languages that I &lt;em&gt;really&lt;/em&gt; like: Haskell and Racket. Really, I think they’re both great! Each brings some things to the table that aren’t really available in any other programming language I’ve ever used.&lt;/p&gt;&lt;p&gt;Haskell, in many ways, is a programming language that fits my mental model of how to structure programs better than any other programming language I’ve used. Some people would vehemently disagree, and it seems that there is almost certainly some heavy subjectivity in how people think about programming. I think Haskell’s model is awesome once you get used to it, though, but this blog post is not really going to try and convince you why you should care about Haskell (though that &lt;em&gt;is&lt;/em&gt; something I want to write at some point). What you &lt;em&gt;should&lt;/em&gt; understand, though, is that to me, Haskell is pretty close to what I want in a programming language.&lt;/p&gt;&lt;p&gt;At the same time, though, Haskell has problems, and a lot of that revolves around its story for metaprogramming. “Metaprogramming” is another M word that people seem to be very afraid of, and for good reason: most metaprogramming systems are ad-hoc, unsafe, unpredictable footguns that require delicate care to use properly, and &lt;em&gt;even then&lt;/em&gt; the resulting code is brittle and difficult to understand. Haskell doesn’t suffer from this problem as much as some languages, but it isn’t perfect by any means: Haskell has at least two different metaprogramming systems (generics and Template Haskell) that are designed for different tasks, but they’re both limited in scope and both tend to be pretty complicated to use.&lt;/p&gt;&lt;p&gt;Discussing the merits and drawbacks of Haskell’s various metaprogramming capabilities is also outside the scope of this blog post, but there’s one &lt;em&gt;fact&lt;/em&gt; that I want to bring up, which is that &lt;strong&gt;Haskell does not provide any mechanism for adding syntactic abstractions to the language&lt;/strong&gt;. What do I mean by this? Well, in order to understand what a “syntactic abstraction” is and why you should care about it, I want to shift gears a little and take a look at why Racket is so amazing.&lt;/p&gt;&lt;h3&gt;&lt;a name="a-programmable-programming-language-theory-and-practice"&gt;&lt;/a&gt;A programmable programming language: theory and practice&lt;/h3&gt;&lt;p&gt;I feel confident in saying that Racket has &lt;em&gt;the&lt;/em&gt; most advanced macro system in the world, and it is pretty much unparalleled in that space. There are many languages with powerful type systems, but Racket is more or less alone in many of the niches it occupies. Racket has a large number of innovations that I don’t know of in any other programming language, and a significant portion of them focus on making Racket a &lt;a href="http://www.ccs.neu.edu/home/matthias/manifesto/"&gt;programmable programming language, a language for building languages&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This lofty goal is backed up by decades of research, providing Racket with an unparalleled toolkit for creating languages that can communicate, be extended, and even cooperate with tooling to provide introspection and error diagnostics. Working in Haskell feels like carefully designing a mould that cleanly and precisely fits your domain, carefully carving, cutting, and whittling. In contrast, working with Racket feels like moulding your domain until it looks the way &lt;em&gt;you&lt;/em&gt; want it to look, poking and prodding at a pliable substrate. The sheer &lt;em&gt;ease&lt;/em&gt; of it all is impossible for me to convey in words, so &lt;a href="https://twitter.com/andmkent_/status/724036694773628930"&gt;you will have to see it for yourself&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;All this stuff is super abstract, though. What does it mean for practical programming, and why should you care? Well, I’m not going to try and sell you if you’re extremely skeptical, but if you’re interested, &lt;a href="https://www.youtube.com/watch?v=TfehOLha-18"&gt;I gave a talk on some of Racket’s linguistic capabilities last year called &lt;em&gt;Languages in an Afternoon&lt;/em&gt;&lt;/a&gt;. If you’re curious, give it a watch, and you might find yourself (hopefully) a little impressed. If you prefer reading, well, I have some &lt;a href="/blog/2015/12/21/adts-in-typed-racket-with-macros/"&gt;blog posts&lt;/a&gt; on this very blog that &lt;a href="/blog/2015/08/30/managing-application-configuration-with-envy/"&gt;demonstrate what Racket can do&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The basic idea, though, is that by having a simple syntax and a powerful macro system with a formalization of lexical scope, users can effectively invent entirely new language constructs as ordinary libraries, constructs that would have to be core forms in other programming languages. For example, Racket supports pattern-matching, but it isn’t built into the compiler: it’s simply implemented in the &lt;code&gt;racket/match&lt;/code&gt; module distributed with Racket. Not only is it defined in ordinary Racket code, it’s actually &lt;em&gt;extensible&lt;/em&gt;, so users can add their own pattern-matching forms that cooperate with &lt;code&gt;match&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;This is the power of a macro system to produce “syntactic abstractions”, things that can transform the way a user thinks of the code they’re writing. Racket has the unique capability of making these abstractions both easy to write and watertight, so instead of being a scary tool you have to handle with extreme care, you can easily whip up a powerful, user-friendly embedded domain specific language in a matter of &lt;em&gt;minutes&lt;/em&gt;, and it’ll be safe, provide error reporting for misuse, and cooperate with existing tooling pretty much out of the box.&lt;/p&gt;&lt;h3&gt;&lt;a name="fusing-haskell-and-racket"&gt;&lt;/a&gt;Fusing Haskell and Racket&lt;/h3&gt;&lt;p&gt;So, let’s assume that we &lt;em&gt;do&lt;/em&gt; want Haskell’s strong type system and that we &lt;em&gt;also&lt;/em&gt; want a powerful metaprogramming model that permits syntactic extensions. What would that look like? Well, one way we could do it is to put one in front of the other: macro expansion is, by nature, a compile-time pass, so we could stick a macroexpander in front of the typechecker. This leads to a simple technique: first, macroexpand the program to erase the macros, then typecheck it and erase the types, then send the resulting code off to be compiled. This technique has the following properties:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;First of all, &lt;strong&gt;it’s easy to implement&lt;/strong&gt;. Racket’s macroexpander, while complex, is well-documented in academic literature and works extremely well in practice. In fact, this strategy has already been implemented! Typed Racket, the gradually-typed sister language of Racket, expands every program before typechecking. It would be possible to effectively create a “Lisp-flavored Haskell” by using this technique, and it might not even be that hard.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Unfortunately, there’s a huge problem with this approach: &lt;strong&gt;type information is not available at macroexpansion time&lt;/strong&gt;. This is the real dealbreaker with the “expand, then typecheck” model, since static type information is some of the most useful information possibly available to a macro writer. In an ideal world, macros should not only have access to type information, they should be able to manipulate it and metaprogram the typechecker as necessary, but if macroexpansion is a separate phase from typechecking, then that information simply doesn’t exist yet.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;For me, the second option is unacceptable. I am &lt;em&gt;not&lt;/em&gt; satisfied by a “Lisp-flavored Haskell”; I want my types and macros to be able to cooperate and communicate with each other. The trouble, though, is that solving that problem is really, really hard! For a couple years now, I’ve been wishing this ideal language existed, but I’ve had no idea how to make it actually work. Template Haskell implements a highly restricted system of interweaving typechecking and splice evaluation, but it effectively does it by running the typechecker and the splice expander alternately, splitting the source into chunks and typechecking them one at a time. This works okay for Template Haskell, but for the more powerful macro system I am looking for, it wouldn’t scale.&lt;/p&gt;&lt;p&gt;There’s something a little bit curious, though, about the problem as I just described it. The processes of “macroexpanding the program to erase the macros” and “typechecking the program to erase the types” sound awfully similar. It seems like maybe these are two sides of the same coin, and it would be wonderful if we could encode one in terms of the other, effectively turning the two passes into a single, unified pass. Unfortunately, while this sounds great, I had no idea how to do this (and it didn’t help that I really had no idea how existing type systems were actually implemented).&lt;/p&gt;&lt;p&gt;Fortunately, last year, Stephen Chang, Alex Knauth, and Ben Greenman put together a rather exciting paper called &lt;a href="http://www.ccs.neu.edu/home/stchang/popl2017/"&gt;&lt;em&gt;Type Systems as Macros&lt;/em&gt;&lt;/a&gt;, which does precisely what I just described, and it delivers it all in a remarkably simple and elegant presentation. The idea is to “distribute” the task of typechecking over the individual forms of the language, leveraging existing macro communication facilities avaiable in the Racket macroexpander to propagate type information as macros are expanded. To me, it was exactly what I was looking for, and I almost immediately started playing with it and seeing what I could do with it.&lt;/p&gt;&lt;p&gt;The result is &lt;a href="https://github.com/lexi-lambda/hackett"&gt;&lt;em&gt;Rascal&lt;/em&gt;&lt;/a&gt;, a programming language built in the Racket ecosystem that attempts to implement a Haskell-like type system.&lt;/p&gt;&lt;h2&gt;&lt;a name="a-first-peek-at-rascal"&gt;&lt;/a&gt;A first peek at Rascal&lt;/h2&gt;&lt;p&gt;Rascal is a very new programming language I’ve only been working on over the past few months. It is extremely experimental, riddled with bugs, half-baked, and may turn your computer into scrambled eggs. Still, while I might not recommend that you actually &lt;em&gt;use&lt;/em&gt; it just yet, I want to try and share what it is I’m working on, since I’d bet at least a few other people will find it interesting, too.&lt;/p&gt;&lt;p&gt;First, let me say this up front: &lt;strong&gt;Rascal is probably a lot closer to Haskell than Racket&lt;/strong&gt;. That might come as a surprise, given that Rascal has very Lisp-y syntax, it’s written in Racket, and it runs on the Racket platform, but semantically, Rascal is mostly just Haskell 98. This is important, because it may come as a surprise, given that there are so few statically typed Lisps, but there’s obviously no inherent reason that Lisps need to be dynamically typed. They just seem to have mostly evolved that way.&lt;/p&gt;&lt;p&gt;Taking a look at a snippet of Rascal code, it’s easy to see that the language doesn’t work quite like a traditional Lisp, though:&lt;sup&gt;&lt;a href="#footnote-1" id="footnote-ref-1-1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(def+ map-every-other : (forall [a] {{a -&amp;gt; a} -&amp;gt; (List a) -&amp;gt; (List a)})
  [_ nil            -&amp;gt; nil]
  [_ {x :: nil}     -&amp;gt; {x :: nil}]
  [f {x :: y :: ys} -&amp;gt; {x :: (f y) :: (map-every-other f ys)}])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a Lisp with all the goodies you would expect out of Haskell: static types, parametric polymorphism, automatically curried functions, algebraic datatypes, pattern-matching, infix operators, and of course, &lt;em&gt;typeclasses&lt;/em&gt;. Yes, with Rascal you can have your monads in all their statically dispatched glory:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(data (Maybe a)
  (just a)
  nothing)

(instance (Monad Maybe)
  [join (case-lambda
          [(just (just x)) (just x)]
          [_               nothing])])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So far, though, this really &lt;em&gt;is&lt;/em&gt; just “Haskell with parentheses”. As alluded to above, however, Rascal is a bit more than that.&lt;/p&gt;&lt;h3&gt;&lt;a name="core-forms-can-be-implemented-as-derived-concepts"&gt;&lt;/a&gt;Core forms can be implemented as derived concepts&lt;/h3&gt;&lt;p&gt;Rascal’s type system is currently very simple, being nothing more than Hindley-Milner plus ad-hoc polymorphism in the form of typeclasses. Something interesting to note about it is that it does not implement ADTs or pattern-matching anywhere in the core! In fact, ADTs are defined as two macros &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt;, in an entirely separate module, which can be imported just like any other library.&lt;/p&gt;&lt;p&gt;The main &lt;code&gt;rascal&lt;/code&gt; language provides ADTs by default, of course, but it would be perfectly possible to produce a &lt;code&gt;rascal/kernel&lt;/code&gt; language which does not include them at all. In this particular case, it seems unlikely that Rascal programmers would want their own implementation of ADTs, but it’s an interesting proof of concept, and it hints at other “core” features that could be implemented using macros.&lt;/p&gt;&lt;p&gt;Simple syntactic transformations are, of course, trivially defined as macros. Haskell &lt;code&gt;do&lt;/code&gt; notation is defined as &lt;a href="https://github.com/lexi-lambda/hackett/blob/87d001a82c86fb66544d25c37ffba9be1ac63464/rascal-lib/rascal/monad.rkt#L48-L58"&gt;an eleven-line macro in &lt;code&gt;rascal/monad&lt;/code&gt;&lt;/a&gt;, and GHC’s useful &lt;code&gt;LambdaCase&lt;/code&gt; extension is also possible to implement without modifying Rascal at all. This is useful, because there are many syntactic shorthands that are extremely useful to implement, but don’t make any sense to be in GHC because they are specific to certain libraries or applications. Racket’s macro system makes those not only possible, but actually pretty easy.&lt;/p&gt;&lt;p&gt;While the extent of what is possible to implement as derived forms remains to be seen, many useful GHC features seem quite possible to implement without touching the core language, including things like &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; and other generic deriving mechanisms like &lt;code&gt;GHC.Generics&lt;/code&gt;, &lt;code&gt;DeriveGeneric&lt;/code&gt;, and &lt;code&gt;DeriveAnyClass&lt;/code&gt;.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-language-is-not-enough"&gt;&lt;/a&gt;The language is not enough&lt;/h3&gt;&lt;p&gt;No language is perfect. Most people would agree with this, but I would take it a step further: no language is even sufficient! This makes a lot of sense, given that general-purpose programming languages are designed to do &lt;em&gt;everything&lt;/em&gt;, and it’s impossible to do everything well.&lt;/p&gt;&lt;p&gt;Haskell programmers know this, and they happily endorse the creation of embedded domain specific languages. These are fantastic, and we need more of them. Things like &lt;a href="http://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; let me write a third of the code I might otherwise need to, and the most readable code is the code you didn’t have to write in the first place. DSLs are good.&lt;/p&gt;&lt;p&gt;Unfortunately, building DSLs is traditionally difficult, largely in part because building embedded DSLs means figuring out a way to encode your domain into your host language of choice. Sometimes, your domain simply does not elegantly map to your host language’s syntax or semantics, and you have to come up with a compromise. This is easy to see with servant, which, while it does a remarkably good job, still has to resort to some very clever type magic to create some semblance of an API description in Haskell types:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;type UserAPI = "users" :&amp;gt; Get '[JSON] [User]
          :&amp;lt;|&amp;gt; "users" :&amp;gt; ReqBody '[JSON] User :&amp;gt; Post '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; Get '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; ReqBody '[JSON] User
                       :&amp;gt; Put '[JSON] User
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above code is &lt;em&gt;remarkably&lt;/em&gt; readable for what it is, but what if we didn’t have to worry about working within the constraints of Haskell’s syntax? What if we could design a syntax that was truly the best for the job? Perhaps we would come up with something like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(define-api User-API
  #:content-types [JSON]
  [GET  "users"                    =&amp;gt; (List User)]
  [POST "users"                    =&amp;gt; User -&amp;gt; User]
  [GET  "users" [userid : Integer] =&amp;gt; User]
  [PUT  "users" [userid : Integer] =&amp;gt; User -&amp;gt; User])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This would be extremely easy to write with Racket’s macro-writing utilities, and it could even be made extensible. This could also avoid having to do the complicated typeclass trickery servant has to perform to then generate code from the above specification, since it would be much easier to just generate the necessary code directly (which still maintaining type safety).&lt;/p&gt;&lt;p&gt;In addition to the type-level hacks that Haskell programmers often have to pull in order to make these kinds of fancy DSLs work, free monads tend to be used to create domain-specific languages. This works okay for some DSLs, but remember that when you use a free monad, you are effectively writing a &lt;em&gt;runtime interpreter&lt;/em&gt; for your language! Macros, on the other hand, are compiled, and you get ability to &lt;em&gt;compile&lt;/em&gt; your DSL to code that can be optimized by all the existing facilities of the compiler toolchain.&lt;/p&gt;&lt;h2&gt;&lt;a name="rascal-is-embryonic"&gt;&lt;/a&gt;Rascal is embryonic&lt;/h2&gt;&lt;p&gt;I’m pretty excited about Rascal. I think that it could have the potential to do some pretty interesting things, and I have some ideas in my head for how having macros in a Haskell-like language could change things. I also think that, based on what I’ve seen so far, having both macros and a Haskell-like type system could give rise to &lt;em&gt;completely&lt;/em&gt; different programming paradigms than exist in either Haskell or Racket today. My gut tells me that this is a case where the whole might actually be greater than the sum of its parts.&lt;/p&gt;&lt;p&gt;That said, Rascal doesn’t really exist yet. Yes, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;there is a GitHub repository&lt;/a&gt;, and it has some code in it that does… something. Unfortunately, the code is also currently extremely buggy, to the point of being borderline broken, and it’s also in such early stages that you can’t really do &lt;em&gt;anything&lt;/em&gt; interesting with it, aside from some tiny toy programs.&lt;/p&gt;&lt;p&gt;As I have worked on Rascal, I’ve come to a somewhat unfortunate conclusion, which is that I really have almost zero interest in implementing type systems. I felt that way before I started the project, but I was hoping that maybe once I got into them, I would find them more interesting. Unfortunately, as much as I love working with powerful type systems (and really, I adore working with Haskell and using all the fancy features GHC provides), I find implementing the software that makes them tick completely dull.&lt;/p&gt;&lt;p&gt;Still, I’m willing to invest the time to get something that I can use. Even so, resources for practical type system implementation are scarce. I want to thank &lt;a href="https://web.cecs.pdx.edu/~mpj/"&gt;Mark P Jones&lt;/a&gt; for his wonderful resource &lt;a href="https://web.cecs.pdx.edu/~mpj/thih/"&gt;Typing Haskell in Haskell&lt;/a&gt;, without which getting to where I am now would likely have been impossible. I also want to thank &lt;a href="http://www.stephendiehl.com"&gt;Stephen Diehl&lt;/a&gt; for his wonderful &lt;a href="http://dev.stephendiehl.com/fun/"&gt;Write You a Haskell&lt;/a&gt; series, which was also wonderfully useful to study, even if it is unfinished and doesn’t cover anything beyond ML just yet.&lt;/p&gt;&lt;p&gt;Even with these wonderful resources, I’ve come to the realization that &lt;strong&gt;I probably can’t do all of this on my own&lt;/strong&gt;. I consider myself pretty familiar with macros and macro expanders at this point, but I don’t know much about type systems (at least not their implementation), and I could absolutely use some help. So if you’re interested in Rascal and think you might be able to pitch in, please: I would appreciate even the littlest bits of help or guidance!&lt;/p&gt;&lt;p&gt;In the meantime, I will try to keep picking away at Rascal in the small amount of free time I currently have. Thanks, as always, to all the amazing people who have contributed to the tools I’ve been using for this project: special thanks to the authors of &lt;em&gt;Type Systems as Macros&lt;/em&gt; for their help as well as the people I mentioned just above, and also to all of the people who have built Racket and Haskell and made them what they are today. Without them, Rascal would most definitely not exist.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;li id="footnote-1"&gt;&lt;p&gt;Note that most of the Rascal code in this blog post probably doesn’t actually work on the current Rascal implementation. Pretty much all of it can be implemented in the current implementation, the syntax just isn’t quite as nice yet. &lt;a href="#footnote-ref-1-1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Using types to unit-test in Haskell</title><link>https://lexi-lambda.github.io/blog/2016/10/03/using-types-to-unit-test-in-haskell/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2016/10/03/using-types-to-unit-test-in-haskell/</guid><pubDate>03 Oct 2016</pubDate><description>&lt;article&gt;&lt;p&gt;Object-oriented programming languages make unit testing easy by providing obvious boundaries between units of code in the form of classes and interfaces. These boundaries make it easy to stub out parts of a system to test functionality in isolation, which makes it possible to write fast, deterministic test suites that are robust in the face of change. When writing Haskell, it can be unclear how to accomplish the same goals: even inside pure code, it can become difficult to test a particular code path without also testing all its collaborators.&lt;/p&gt;&lt;p&gt;Fortunately, by taking advantage of Haskell’s expressive type system, it’s possible to not only achieve parity with object-oriented testing techniques, but also to provide stronger static guarantees as well. Furthermore, it’s all possible without resorting to extra-linguistic hacks that static object-oriented languages sometimes use for mocking, such as dynamic bytecode generation.&lt;/p&gt;&lt;h2&gt;&lt;a name="first-an-aside-on-testing-philosophy"&gt;&lt;/a&gt;First, an aside on testing philosophy&lt;/h2&gt;&lt;p&gt;Testing methodology is a controversial topic within the larger programming community, and there are a multitude of different approaches. This blog post is about &lt;em&gt;unit testing&lt;/em&gt;, an already nebulous term with a number of different definitions. For the purposes of this post, I will define a unit test as a test that stubs out collaborators of the code under test in some way. Accomplishing that in Haskell is what this is primarily about.&lt;/p&gt;&lt;p&gt;I want to be clear that I do not think that unit tests are the only way to write tests, nor the best way, nor even always an applicable way. Depending on your domain, rigorous unit testing might not even make sense, and other forms of tests (end-to-end, integration, benchmarks, etc.) might fulfill your needs.&lt;/p&gt;&lt;p&gt;In practice, though, implementing those other kinds of tests seems to be well-documented in Haskell compared to pure, object-oriented style unit testing. As my Haskell applications have grown, I have found myself wanting a more fine-grained testing tool that allows me to both test a piece of my codebase in isolation and also use my domain-specific types. This blog post is about that.&lt;/p&gt;&lt;p&gt;With that disclaimer out of the way, let’s talk about testing in Haskell.&lt;/p&gt;&lt;h2&gt;&lt;a name="drawing-seams-using-types"&gt;&lt;/a&gt;Drawing seams using types&lt;/h2&gt;&lt;p&gt;One of the primary attributes of unit tests in object-oriented languages, especially statically-typed ones, is the concept of “seams” within a codebase. These are internal boundaries between components of a system. Some boundaries are obvious—interactions with a database, manipulation of the file system, and performing I/O over the network, to name a few examples—but others are more subtle. Especially in larger codebases, it can be helpful to isolate two related but distinct pieces of functionality as much as possible, which makes them easier to reason about, even if they’re actually part of the same codebase.&lt;/p&gt;&lt;p&gt;In OO languages, these seams are often marked using interfaces, whether explicitly (in the case of static languages) or implicitly (in the case of dynamic ones). By programming to an interface, it’s possible to create “fake” implementations of that interface for use in unit tests, effectively making it possible to stub out code that isn’t directly relevant to the code being tested.&lt;/p&gt;&lt;p&gt;In Haskell, representing these seams is a lot less obvious. Consider a fairly trivial function that reverses a file’s contents on the file system:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;reverseFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;reverseFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function is impossible to test without testing against a real file system. It simply performs I/O directly, and there’s no way to “mock out” the file system for testing purposes. Now, admittedly, this function is so trivial that a unit test might not seem worth the cost, but consider a slightly more complicated function that interacts with a database:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;renderUserProfile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;HTML&lt;/span&gt;
&lt;span class="nf"&gt;renderUserProfile&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fetchUser&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt;
  &lt;span class="n"&gt;posts&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fetchRecentPosts&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt;

  &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"’s Profile"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h2&lt;/span&gt; &lt;span class="s"&gt;"Recent Posts"&lt;/span&gt;
    &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ul&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;postTitle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;posts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It might now be a bit more clear that it could be useful to test the above function without running a real database and doing all the necessary context setup before each test case. Indeed, it would be nice if a test could just provide stubbed implementations for &lt;code&gt;fetchUser&lt;/code&gt; and &lt;code&gt;fetchRecentPosts&lt;/code&gt;, then make assertions about the output.&lt;/p&gt;&lt;p&gt;One way to solve this problem is to pass the results of those two functions to &lt;code&gt;renderUserProfile&lt;/code&gt; as arguments, turning it into a pure function that could be easily tested. This becomes obnoxious for functions of even just slightly more complexity, though (it is not unreasonable to imagine needing a handful of different queries to render a user’s profile page), and it requires significantly restructuring code simply because the tests need it.&lt;/p&gt;&lt;p&gt;The above code is not only difficult to test, however—it has another problem, too. Specifically, both functions return &lt;code&gt;IO&lt;/code&gt; values, which means they can effectively do &lt;em&gt;anything&lt;/em&gt;. Haskell has a very strong type system for typing terms, but it doesn’t provide any guarantees about effects beyond a simple yes/no answer about function purity. Even though the &lt;code&gt;renderUserProfile&lt;/code&gt; function should really only need to interact with the database, it could theoretically delete files, send emails, make HTTP requests, or do any number of other things.&lt;/p&gt;&lt;p&gt;Fortunately, it’s possible to solve &lt;em&gt;both&lt;/em&gt; problems—a lack of testability and a lack of type safety—using the same general technique. This approach is reminiscent of the interface-based seams of object-oriented languages, but unlike most object-oriented approaches, it provides additional type safety guarantees without the need to explicitly modify the code to support some kind of dependency injection.&lt;/p&gt;&lt;h3&gt;&lt;a name="making-implicit-interfaces-explicit"&gt;&lt;/a&gt;Making implicit interfaces explicit&lt;/h3&gt;&lt;p&gt;Statically typed, object-oriented languages provide interfaces as a language construct to encode certain kinds of contracts into the type system, and Haskell has something similar. Typeclasses are, in many ways, an analog to OO interfaces, and they can be used in a similar way. In the above case, let’s write down interfaces that the &lt;code&gt;reverseFile&lt;/code&gt; and &lt;code&gt;renderUserProfile&lt;/code&gt; functions can use:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFS&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadDB&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;fetchUser&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;
  &lt;span class="n"&gt;fetchRecentPosts&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The really nice thing about these interfaces is that our function implementations don’t have to change &lt;em&gt;at all&lt;/em&gt; to take advantage of them. In fact, all we have to change is their types:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;reverseFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadFS&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;reverseFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;renderUserProfile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadDB&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;HTML&lt;/span&gt;
&lt;span class="nf"&gt;renderUserProfile&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fetchUser&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt;
  &lt;span class="n"&gt;posts&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fetchRecentPosts&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt;

  &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"’s Profile"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;h2&lt;/span&gt; &lt;span class="s"&gt;"Recent Posts"&lt;/span&gt;
    &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ul&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;postTitle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;posts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is pretty neat, since we haven’t had to alter our code at all, but we’ve managed to completely decouple ourselves from &lt;code&gt;IO&lt;/code&gt;. This has the direct effect of both making our code more abstract (we no longer rely on the “real” file system or a “real” database, which makes our code easier to test) and restricting what our functions can do (just from looking at the type signatures, we know what side-effects they can perform).&lt;/p&gt;&lt;p&gt;Of course, since we’re now coding against an interface, our code doesn’t actually do much of anything. If we want to actually use the functions we’ve written, we’ll have to define instances of &lt;code&gt;MonadFS&lt;/code&gt; and &lt;code&gt;MonadDB&lt;/code&gt;. When actually running our code, we’ll probably still use &lt;code&gt;IO&lt;/code&gt; (or some monad transformer stack with &lt;code&gt;IO&lt;/code&gt; at the bottom), so we can define trivial instances for that existing use case:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFS&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Prelude&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readFile&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Prelude&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;writeFile&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadDB&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;fetchUser&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;SQL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetchUser&lt;/span&gt;
  &lt;span class="n"&gt;fetchRecentPosts&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;SQL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetchRecentPosts&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Even if we go no further, &lt;strong&gt;this is already incredibly useful&lt;/strong&gt;. By restricting the sorts of effects our functions can perform at the type level, it becomes a lot easier to see which code is interacting with what. This can be invaluable when working in a part of a moderately large codebase that you are unfamiliar with. Even if the only instance of these typeclasses is &lt;code&gt;IO&lt;/code&gt;, the benefits are immediately apparent.&lt;/p&gt;&lt;p&gt;Of course, this blog post is about testing, so we’re going to go further and take advantage of these seams we’ve now drawn. The question is: how?&lt;/p&gt;&lt;h2&gt;&lt;a name="testing-with-typeclasses-an-initial-attempt"&gt;&lt;/a&gt;Testing with typeclasses: an initial attempt&lt;/h2&gt;&lt;p&gt;Given that we now have functions depending on an interface instead of &lt;code&gt;IO&lt;/code&gt;, we can create separate instances of our typeclasses for use in tests. Let’s start with the &lt;code&gt;renderUserProfile&lt;/code&gt; function. We’ll create a simple wrapper around the &lt;code&gt;Identity&lt;/code&gt; type, since we don’t actually care much about the “effects” of our &lt;code&gt;MonadDB&lt;/code&gt; methods:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Data.Functor.Identity&lt;/span&gt;

&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Identity&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;unTestM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;unTestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Identity&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, we’ll create a trivial instance of &lt;code&gt;MonadDB&lt;/code&gt; for &lt;code&gt;TestM&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadDB&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;fetchUser&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Alyssa"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;fetchRecentPosts&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="kt"&gt;Post&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;postTitle&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Metacircular Evaluator"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this instance, it’s now possible to write a simple unit test of the &lt;code&gt;renderUserProfile&lt;/code&gt; function that doesn’t need a real database running at all:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;spec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="s"&gt;"renderUserProfile"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"shows the user’s name"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;unTestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;renderUserProfile&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;intToId&lt;/span&gt; &lt;span class="mi"&gt;1234&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldContainElement&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="s"&gt;"Alyssa’s Profile"&lt;/span&gt;

  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"shows a list of the user’s posts"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;unTestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;renderUserProfile&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;intToId&lt;/span&gt; &lt;span class="mi"&gt;1234&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldContainElement&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;ul&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;li&lt;/span&gt; &lt;span class="s"&gt;"Metacircular Evaluator"&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is pretty nice, and running the above tests reveals a nice property of these kinds of isolated test cases: the test suite runs &lt;em&gt;really, really fast&lt;/em&gt;. Communicating with a database, even in extremely simple ways, takes a measurable amount of time, especially with dozens of tests. In contrast, even with hundreds of tests, our unit test suite runs in less than a tenth of a second.&lt;/p&gt;&lt;p&gt;This all seems to be successful, so let’s try and apply the same testing technique to &lt;code&gt;reverseFile&lt;/code&gt;.&lt;/p&gt;&lt;h3&gt;&lt;a name="testing-side-effectful-code"&gt;&lt;/a&gt;Testing side-effectful code&lt;/h3&gt;&lt;p&gt;Looking at the type signature for &lt;code&gt;reverseFile&lt;/code&gt;, we have a small problem:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;reverseFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadFS&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Specifically, the return type is &lt;code&gt;()&lt;/code&gt;. Making any assertions against the result of this function would be completely worthless, given that it’s guaranteed to be the same exact thing each time. Instead, &lt;code&gt;reverseFile&lt;/code&gt; is inherently side-effectful, so we want to be able to test that it properly interacts with the file system in the correct way.&lt;/p&gt;&lt;p&gt;In order to do this, a simple wrapper around &lt;code&gt;Identity&lt;/code&gt; won’t be enough, but we can replace it with something more powerful: &lt;code&gt;Writer&lt;/code&gt;. Specifically, we can use a writer monad to “log” what gets called in order to test side-effects. We’ll start by creating a new &lt;code&gt;TestM&lt;/code&gt; type, just like last time:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Writer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="nf"&gt;logTestM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;logTestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;execWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using this slightly more powerful type, we can write a useful instance of &lt;code&gt;MonadFS&lt;/code&gt; that will track the argument given to &lt;code&gt;writeFile&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFS&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, the instance is quite simple, but it now enables us to write a straightforward unit test for &lt;code&gt;reverseFile&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;spec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="s"&gt;"reverseFile"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"reverses a file’s contents on the filesystem"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logTestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverseFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"olleh"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, quite simple to both implement and use, and the test itself is blindingly fast. There’s another problem, though, which is that we have technically left part of &lt;code&gt;reverseFile&lt;/code&gt; untested: we’ve completely ignored the &lt;code&gt;path&lt;/code&gt; argument.&lt;/p&gt;&lt;p&gt;In this contrived example, it may seem silly to test something so trivial, but in real code, it’s quite possible that one would care very much about testing multiple different aspects about a single function. When testing &lt;code&gt;renderUserProfile&lt;/code&gt;, this was not hard, since we could reuse the same &lt;code&gt;TestM&lt;/code&gt; type and &lt;code&gt;MonadDB&lt;/code&gt; instance for both test cases, but in the &lt;code&gt;reverseFile&lt;/code&gt; example, we’ve ignored the path entirely.&lt;/p&gt;&lt;p&gt;We &lt;em&gt;could&lt;/em&gt; adjust our &lt;code&gt;MonadFS&lt;/code&gt; instance to also track the path provided to each method, but this has a few problems. First, it means every test case would depend on all the various properties we are testing, which would mean updating every test case when we add a new one. It would also be simply impossible if we needed to track multiple types—in this particular case, it turns out that &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;FilePath&lt;/code&gt; are actually the same type, but in practice, there may be a handful of disparate, incompatible types.&lt;/p&gt;&lt;p&gt;Both of the above issues could be fixed by creating a sum type and manually filtering out the relevant elements in each test case, but a much more intuitive approach would be to simply have a separate instance for each case. Unfortunately, in Haskell, creating a new instance means creating an entirely new type. To illustrate how much duplication that would entail, we could create the following type and instance for testing proper propagation of the &lt;code&gt;path&lt;/code&gt; argument:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;TestM&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;TestM&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Writer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="nf"&gt;logTestM&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;TestM&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;logTestM&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;execWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;MonadFS&lt;/span&gt; &lt;span class="kt"&gt;TestM&amp;#39;&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now it’s possible to add an extra test case that asserts that the proper path is provided to the two filesystem functions:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;spec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="s"&gt;"reverseFile"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"reverses a file’s contents on the filesystem"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logTestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverseFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"olleh"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"operates on the file at the provided path"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logTestM&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverseFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This works, but it’s ultimately unacceptably complicated. Our test harness code is now significantly larger than the actual tests themselves, and the amount of boilerplate is frustrating. Verbose test suites are especially bad, since forcing programmers to jump through hoops just to implement a single test reduces the likelihood that people will actually write good tests, if they write tests at all. In contrast, if writing tests is easy, then people will naturally write more of them.&lt;/p&gt;&lt;p&gt;The above strategy to writing tests is not good enough, but it does reveal a particular problem: in Haskell, typeclass instances are not first-class values that can be manipulated and abstracted over, they are static constructs that can only be managed by the compiler, and users do not have a direct way to modify them. With some cleverness, however, we can actually create an approximation of first-class typeclass dictionaries, which will allow us to dramatically simplify the above testing mechanism.&lt;/p&gt;&lt;h2&gt;&lt;a name="creating-first-class-typeclass-instances"&gt;&lt;/a&gt;Creating first-class typeclass instances&lt;/h2&gt;&lt;p&gt;In order to provide an easy way to construct instances, we need a way to represent instances as ordinary Haskell values. This is not terribly difficult, given that instances are conceptually just records containing a collection of functions. For example, we could create a datatype that represents an instance of the &lt;code&gt;MonadFS&lt;/code&gt; typeclass:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To avoid namespace clashes with the actual method identifiers, the record fields are prefixed with an underscore, but otherwise, the translation is remarkably straightforward. Using this record type, we can easily create values that represent the two instances we defined above:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;contentInst&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
&lt;span class="nf"&gt;contentInst&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;pathInst&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
&lt;span class="nf"&gt;pathInst&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These two values represent two different implementations of &lt;code&gt;MonadFS&lt;/code&gt;, but since they’re ordinary Haskell values, they can be manipulated and even &lt;em&gt;extended&lt;/em&gt; like any other records. This can be extremely useful, since it makes it possible to create a sort of “base” instance, then have individual test cases override individual pieces of functionality piecemeal.&lt;/p&gt;&lt;p&gt;Of course, although we’ve written these two instances, we have no way to actually use them. After all, Haskell does not provide a way to explicitly provide typeclass dictionaries. Fortunately, we can create a sort of “proxy” type that will use a reader to thread the dictionary around explicitly, and the instance can defer to the dictionary’s implementation.&lt;/p&gt;&lt;h3&gt;&lt;a name="creating-an-instance-proxy"&gt;&lt;/a&gt;Creating an instance proxy&lt;/h3&gt;&lt;p&gt;To represent our proxy type, we’ll use a combination of a &lt;code&gt;Writer&lt;/code&gt; and a &lt;code&gt;ReaderT&lt;/code&gt;; the former to implement the logging used by instances, and the latter to actually thread around the dictionary. Our type will look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
    &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;ReaderT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadFSInst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Writer&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;
           &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadReader&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadFSInst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadWriter&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;
           &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;logTestM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;
&lt;span class="nf"&gt;logTestM&lt;/span&gt; &lt;span class="n"&gt;inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;execWriter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runReaderT&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;inst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This might look rather complicated, and it is, but let’s break down exactly what it’s doing.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;The &lt;code&gt;TestM&lt;/code&gt; type includes two type parameters. The first is the type of value that will be logged (hence the name &lt;code&gt;log&lt;/code&gt;), which corresponds to the argument to &lt;code&gt;Writer&lt;/code&gt; from previous incarnations of &lt;code&gt;TestM&lt;/code&gt;. Unlike those types, though, we want this version to work with any &lt;code&gt;Monoid&lt;/code&gt;, so we’ll make it a type parameter. The second parameter is simply the type of the current monadic value, as before.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The type itself is defined as a wrapper around a small monad transformer stack, the first of which is &lt;code&gt;ReaderT&lt;/code&gt;. The state threaded around by the reader is, in this case, the instance dictionary, which is &lt;code&gt;MonadFSInst&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;However, recall that &lt;code&gt;MonadFSInst&lt;/code&gt; accepts a type variable—the type of a monad itself—so we must provide &lt;code&gt;TestM log&lt;/code&gt; as an argument to &lt;code&gt;MonadFSInst&lt;/code&gt;. This slight bit of indirection allows us to tie the knot between the mutually dependent instances and proxy type.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The base monad in the transformer stack is &lt;code&gt;Writer&lt;/code&gt;, which is used to actually implement the logging functionality, just like in prior cases. The only difference now is that the &lt;code&gt;log&lt;/code&gt; type parameter now determines what the writer actually produces.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, as before, we use &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; to derive all the relevant &lt;code&gt;mtl&lt;/code&gt; classes, adding the somewhat wordy &lt;code&gt;MonadReader&lt;/code&gt; constraint to the list.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Using this single type, we can now implement a &lt;code&gt;MonadFS&lt;/code&gt; instance that defers to the dictionary carried around within &lt;code&gt;TestM&lt;/code&gt;’s reader state:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Monoid&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MonadFS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;asks&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
  &lt;span class="n"&gt;writeFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;asks&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This may seem somewhat boilerplate-y, and it is to some extent, but the important consideration is that this boilerplate only needs to be written &lt;em&gt;once&lt;/em&gt;. With this in place, it’s now possible to write an arbitrary number of first-class instances that use the above mechanism without extending the mechanism at all.&lt;/p&gt;&lt;p&gt;To see what actually using this code would look like, let’s update the &lt;code&gt;reverseFile&lt;/code&gt; tests to use the new &lt;code&gt;TestM&lt;/code&gt; implementation, as well as the &lt;code&gt;contentInst&lt;/code&gt; and &lt;code&gt;pathInst&lt;/code&gt; dictionaries from earlier:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;spec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="s"&gt;"reverseFile"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"reverses a file’s contents on the filesystem"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logTestM&lt;/span&gt; &lt;span class="n"&gt;contentInst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverseFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"olleh"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"operates on the file at the provided path"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logTestM&lt;/span&gt; &lt;span class="n"&gt;pathInst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverseFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can do a little bit better, though. Really, the definitions of &lt;code&gt;contentInst&lt;/code&gt; and &lt;code&gt;pathInst&lt;/code&gt; are specific to each test case. With ordinary typeclass instances, we cannot scope them to any particular block, but since &lt;code&gt;MonadFSInst&lt;/code&gt; is just an ordinary Haskell datatype, we can manipulate them just like any other Haskell values. Therefore, we can just inline those instances’ definitions into the test cases themselves to keep them closer to the actual tests.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;spec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="s"&gt;"reverseFile"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"reverses a file’s contents on the filesystem"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;contentInst&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;
          &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logTestM&lt;/span&gt; &lt;span class="n"&gt;contentInst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverseFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"olleh"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"operates on the file at the provided path"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;pathInst&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;
          &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tell&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logTestM&lt;/span&gt; &lt;span class="n"&gt;pathInst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverseFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is pretty good. We’re now able to create inline instances of our &lt;code&gt;MonadFS&lt;/code&gt; typeclass, which allows us to write extremely concise unit tests using ordinary Haskell typeclasses as system seams. We’ve managed to cut down on the boilerplate considerably, though we still have a couple problems. For one, this example only uses a single typeclass containing only two methods. A real &lt;code&gt;MonadFS&lt;/code&gt; typeclass would likely have at least a dozen methods for performing various filesystem operations, and writing out the instance dictionaries for every single method, even the ones that aren’t used within the code under test, would be pretty frustratingly verbose.&lt;/p&gt;&lt;p&gt;This problem is solvable, though. Since instances are just ordinary Haskell records, we can create a “base” instance that just throws an exception whenever the method is called:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;baseInst&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
&lt;span class="nf"&gt;baseInst&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;MonadFSInst&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"unimplemented instance method ‘_readFile’"&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"unimplemented instance method ‘_writeFile’"&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then code that only uses &lt;code&gt;readFile&lt;/code&gt; could only override that particular method, for example:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;myInst&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;baseInst&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Normally, of course, this would be a terrible idea. However, since this is all just test code, it can be extremely useful in quickly figuring out what methods need to be stubbed out for a particular test case. Since all the code actually gets run at test time, attempts to use unimplemented instance methods will immediately raise an error, informing the programmer which methods need to be implemented to make the test pass. This can also help to significantly cut down on the amount of effort it takes to implement each test.&lt;/p&gt;&lt;p&gt;Another problem is that our approach is specialized exclusively to &lt;code&gt;MonadFS&lt;/code&gt;. What about functions that use both &lt;code&gt;MonadFS&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;MonadDB&lt;/code&gt;, for example? Fortunately, that is not hard to solve, either. We can adapt the &lt;code&gt;MonadFSInst&lt;/code&gt; type to include fields for all of the typeclasses relevant to our system, turning it into a generic test fixture of sorts:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;FixtureInst&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;FixtureInst&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;-- MonadFS&lt;/span&gt;
    &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;

    &lt;span class="c1"&gt;-- MonadDB&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_fetchUser&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_fetchRecentPosts&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Updating &lt;code&gt;TestM&lt;/code&gt; to use &lt;code&gt;FixtureInst&lt;/code&gt; instead of &lt;code&gt;MonadFSInst&lt;/code&gt; is trivial, and all the rest of the infrastructure still works. However, this means that every time a new typeclass is added, three things need to be updated:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Its methods need to be added to the &lt;code&gt;FixtureInst&lt;/code&gt; record.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Those methods need to be given error-raising defaults in the &lt;code&gt;baseInst&lt;/code&gt; value.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;An actual instance of the typeclass needs to be written for &lt;code&gt;TestM&lt;/code&gt; that defers to the &lt;code&gt;FixtureInst&lt;/code&gt; value.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Furthermore, most of this manual manipulation of methods is required every time a particular typeclass changes, whether that means adding a method, removing a method, renaming a method, or changing a method’s type. This is especially frustrating given that all this code is really just mechanical boilerplate that could all be derived by the set of typeclasses being tested.&lt;/p&gt;&lt;p&gt;That last point is especially important: aside from the instances themselves, every piece of boilerplate above is obviously possible to generate from existing types alone. With that piece of information in mind, we can do even better: we can use Template Haskell.&lt;/p&gt;&lt;h2&gt;&lt;a name="removing-the-boilerplate-using-test-fixture"&gt;&lt;/a&gt;Removing the boilerplate using &lt;code&gt;test-fixture&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;The above code was not only rather boilerplate-heavy, it was pretty complicated. Fortunately, you don’t actually have to write it. Enter the library &lt;a href="http://hackage.haskell.org/package/test-fixture"&gt;&lt;code&gt;test-fixture&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Control.Monad.TestFixture&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Control.Monad.TestFixture.TH&lt;/span&gt;

&lt;span class="nf"&gt;mkFixture&lt;/span&gt; &lt;span class="s"&gt;"FixtureInst"&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;&amp;#39;&amp;#39;MonadFS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;&amp;#39;&amp;#39;MonadDB&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="nf"&gt;spec&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt; &lt;span class="s"&gt;"reverseFile"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"reverses a file’s contents on the filesystem"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;contentInst&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;
          &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logTestFixture&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverseFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;contentInst&lt;/span&gt;
    &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"olleh"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

  &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s"&gt;"operates on the file at the provided path"&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;pathInst&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;def&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;_readFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;
          &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_writeFile&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logTestFixture&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;reverseFile&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pathInst&lt;/span&gt;
    &lt;span class="n"&gt;paths&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;shouldBe&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"foo.txt"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;That’s it.&lt;/strong&gt; The above code automatically generates everything you need to write fast, simple, deterministic unit tests in Haskell. The &lt;code&gt;mkFixture&lt;/code&gt; function is a Template Haskell macro that expands into a definition quite similar to the &lt;code&gt;FixtureInst&lt;/code&gt; type we wrote by hand, but since it’s automatically generated from the typeclass definitions, it never needs to be updated.&lt;/p&gt;&lt;p&gt;The &lt;code&gt;logTestFixture&lt;/code&gt; function replaces the &lt;code&gt;logTestM&lt;/code&gt; function we wrote by hand, but it works exactly the same. The &lt;code&gt;Control.Monad.TestFixture&lt;/code&gt; library also exports a &lt;code&gt;log&lt;/code&gt; function that is a synonym for &lt;code&gt;tell . singleton&lt;/code&gt;, but using &lt;code&gt;tell&lt;/code&gt; directly still works if you prefer.&lt;/p&gt;&lt;p&gt;The &lt;code&gt;mkFixture&lt;/code&gt; function also generates a &lt;code&gt;Default&lt;/code&gt; instance, which replaces the &lt;code&gt;baseInst&lt;/code&gt; value defined earlier. It functions the same way, though, producing useful error messages that refer to the names of unimplemented typeclass methods that have not been stubbed out.&lt;/p&gt;&lt;p&gt;This blog post is not a &lt;code&gt;test-fixture&lt;/code&gt; tutorial—indeed, it is much more complicated than a &lt;code&gt;test-fixture&lt;/code&gt; tutorial would be, since it covers what the library is really doing under the hood—but if you’re interested, I would highly recommend you take a look at the &lt;a href="http://hackage.haskell.org/package/test-fixture"&gt;&lt;code&gt;test-fixture&lt;/code&gt; documentation on Hackage&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name="conclusion-credits-and-similar-techniques"&gt;&lt;/a&gt;Conclusion, credits, and similar techniques&lt;/h2&gt;&lt;p&gt;This blog post came about as the result of a need my coworkers and I found when writing Haskell code; we wanted a way to write unit tests quickly and easily, but we didn’t find much advice from the rest of the Haskell ecosystem. The &lt;code&gt;test-fixture&lt;/code&gt; library is the result of that exploratory work, and we currently use it to test a significant portion of our Haskell code.&lt;/p&gt;&lt;p&gt;It would be extremely unfair to suggest that I was the inventor of this technique or the inventor of the library. Two of my coworkers, &lt;a href="https://github.com/jxv"&gt;Joe Vargas&lt;/a&gt; and &lt;a href="https://github.com/aztecrex"&gt;Greg Wiley&lt;/a&gt;, came up with the general approach and wrote &lt;code&gt;Control.Monad.TestFixture&lt;/code&gt;, and I simply wrote the Template Haskell macro to eliminate the boilerplate. With that in mind, I think I can say with some fairness that I think this technique is a joy to use when unit testing is a desirable goal, and I would definitely recommend it if you are interested in doing isolated testing in Haskell.&lt;/p&gt;&lt;p&gt;The general technique of using typeclasses to emulate effects was in part inspired by the well-known &lt;code&gt;mtl&lt;/code&gt; library. An alternate approach to writing unit-testable Haskell code is using free monads, but overall, I prefer this approach over free monads because the typeclass constraints add type safety in ways that free monads do not (at least not without additional boilerplate), and this approach also lends itself well to static analysis-based boilerplate reduction techniques. It has its own tradeoffs, though, so if you’ve had success with free monads, then I certainly make no claim this is a superior approach, just one that I’ve personally found pleasant.&lt;/p&gt;&lt;p&gt;As a final note, if you &lt;em&gt;do&lt;/em&gt; check out &lt;code&gt;test-fixture&lt;/code&gt;, feel free to leave feedback by opening issues on &lt;a href="https://github.com/cjdev/test-fixture/issues"&gt;the GitHub issue tracker&lt;/a&gt;—even things like confusing documentation are worth a bug report.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Understanding the npm dependency model</title><link>https://lexi-lambda.github.io/blog/2016/08/24/understanding-the-npm-dependency-model/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2016/08/24/understanding-the-npm-dependency-model/</guid><pubDate>24 Aug 2016</pubDate><description>&lt;article&gt;&lt;p&gt;Currently, &lt;a href="https://www.npmjs.com"&gt;npm&lt;/a&gt; is &lt;em&gt;the&lt;/em&gt; package manager for the frontend world. Sure, there are alternatives, but for the time being, npm seems to have won. Even tools like &lt;a href="https://bower.io"&gt;Bower&lt;/a&gt; are being pushed to the wayside in favor of the One True Package Manager, but what’s most interesting to me is npm’s relatively novel approach to dependency management. Unfortunately, in my experience, it is actually not particularly well understood, so consider this an attempt to clarify how exactly it works and how it affects &lt;strong&gt;you&lt;/strong&gt; as a user or package developer.&lt;/p&gt;&lt;h2&gt;&lt;a name="first-the-basics"&gt;&lt;/a&gt;First, the basics&lt;/h2&gt;&lt;p&gt;At a high level, npm is not too dissimilar from other package managers for programming languages: packages depend on other packages, and they express those dependencies with &lt;em&gt;version ranges&lt;/em&gt;. npm happens to use the &lt;a href="http://semver.org"&gt;semver&lt;/a&gt; versioning scheme to express those ranges, but the way it performs version resolution is mostly immaterial; what matters is that packages can depend on ranges rather than specific versions of packages.&lt;/p&gt;&lt;p&gt;This is rather important in any ecosystem, since locking a library to a specific set of dependencies could cause significant problems, but it’s actually much less of a problem in npm’s case compared to other, similar package systems. Indeed, it is often safe for a library author to pin a dependency to a specific version without affecting dependent packages or applications. The tricky bit is determining &lt;em&gt;when&lt;/em&gt; this is safe and when it’s not, and this is what I so frequently find that people get wrong.&lt;/p&gt;&lt;h2&gt;&lt;a name="dependency-duplication-and-the-dependency-tree"&gt;&lt;/a&gt;Dependency duplication and the dependency tree&lt;/h2&gt;&lt;p&gt;Most users of npm (or at least most package authors) eventually learn that, unlike other package managers, npm installs a &lt;em&gt;tree&lt;/em&gt; of dependencies. That is, every package installed gets its own set of dependencies rather than forcing every package to share the same canonical set of packages. Obviously, virtually every single package manager in existence has to model a dependency tree at some point, since that’s how dependencies are expressed by programmers.&lt;/p&gt;&lt;p&gt;For example, consider two packages, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. Each of them have their own set of dependencies, which can be represented as a tree:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;foo
├── hello ^0.1.2
└── world ^1.0.7

bar
├── hello ^0.2.8
└── goodbye ^3.4.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Imagine an application that depends on &lt;em&gt;both&lt;/em&gt; &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. Obviously, the &lt;code&gt;world&lt;/code&gt; and &lt;code&gt;goodbye&lt;/code&gt; dependencies are totally unrelated, so how npm handles them is relatively uninteresting. However, consider the case of &lt;code&gt;hello&lt;/code&gt;: both packages require conflicting versions.&lt;/p&gt;&lt;p&gt;Most package managers (including RubyGems/Bundler, pip, and Cabal) would simply barf here, reporting a version conflict. This is because, in most package management models, &lt;strong&gt;only one version of any particular package can be installed at a time&lt;/strong&gt;. In that sense, one of the package manager’s primary responsibilities is to figure out a set of package versions that will satisfy every version constraint simultaneously.&lt;/p&gt;&lt;p&gt;In contrast, npm has a somewhat easier job: it’s totally okay with installing different versions of the same package because each package gets its own set of dependencies. In the aforementioned example, the resulting directory structure would look something like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;node_modules/
├── foo/
│   └── node_modules/
│       ├── hello/
│       └── world/
└── bar/
    └── node_modules/
        ├── hello/
        └── goodbye/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notably, the directory structure very closely mirrors the actual dependency tree. The above diagram is something of a simplification: in practice, each transitive dependency would have its own &lt;code&gt;node_modules&lt;/code&gt; directory and so on, but the directory structure can get pretty messy pretty quickly. (Furthermore, npm 3 performs some optimizations to attempt to share dependencies when it can, but those are ultimately unnecessary to actually understanding the model.)&lt;/p&gt;&lt;p&gt;This model is, of course, extremely simple. The obvious effect is that every package gets its own little sandbox, which works absolutely marvelously for utility libraries like &lt;code&gt;ramda&lt;/code&gt;, &lt;code&gt;lodash&lt;/code&gt;, or &lt;code&gt;underscore&lt;/code&gt;. If &lt;code&gt;foo&lt;/code&gt; depends on &lt;code&gt;ramda@^0.19.0&lt;/code&gt; but &lt;code&gt;bar&lt;/code&gt; depends on &lt;code&gt;ramda@^0.22.0&lt;/code&gt;, they can both coexist completely peacefully without any problems.&lt;/p&gt;&lt;p&gt;At first blush, this system is &lt;em&gt;obviously&lt;/em&gt; better than the alternative, flat model, so long as the underlying runtime supports the required module loading scheme. However, it is not without drawbacks.&lt;/p&gt;&lt;p&gt;The most apparent downside is a significant increase in code size, given the potential for many, many copies of the same package, all with different versions. An increase in code size can often mean more than just a larger program—it can have a significant impact on performance. Larger programs just don’t fit into CPU caches as easily, and merely having to page a program in and out can significantly slow things down. That’s mostly just a tradeoff, though, since you’re sacrificing performance, not program correctness.&lt;/p&gt;&lt;p&gt;The more insidious problem (and the one that I see crop up quite a lot in the npm ecosystem without much thought) is how dependency isolation can affect cross-package communication.&lt;/p&gt;&lt;h2&gt;&lt;a name="dependency-isolation-and-values-that-pass-package-boundaries"&gt;&lt;/a&gt;Dependency isolation and values that pass package boundaries&lt;/h2&gt;&lt;p&gt;The earlier example of using &lt;code&gt;ramda&lt;/code&gt; is a place where npm’s default dependency management scheme really shines, given that Ramda just provides a bunch of plain ol’ functions. Passing these around is totally harmless. In fact, mixing functions from two different versions of Ramda would be totally okay! Unfortunately, not all cases are nearly that simple.&lt;/p&gt;&lt;p&gt;Consider, for a moment, &lt;code&gt;react&lt;/code&gt;. React components are very much &lt;em&gt;not&lt;/em&gt; plain old data; they are complex values that can be extended, instantiated, and rendered in a variety of ways. React represents component structure and state using an internal, private format, using a mixture of carefully arranged keys and values and some of the more powerful features of JavaScript’s object system. This internal structure might very well change between React versions, so a React component defined with &lt;code&gt;react@0.3.0&lt;/code&gt; likely won’t work quite right with &lt;code&gt;react@15.3.1&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;With that in mind, consider two packages that define their own React components and export them for consumers to use. Looking at their dependency tree, we might see something like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;awesome-button
└── react ^0.3.0

amazing-modal
└── react ^15.3.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Given that these two packages use wildly different versions of React, npm would give each of them their own copy of React, as requested, and packages would happily install. However, if you tried to use these components together, they wouldn’t work at all! A newer version of React simply cannot understand an old version’s component, so you would get a (likely confusing) runtime error.&lt;/p&gt;&lt;p&gt;What went wrong? Well, dependency isolation works great when a package’s dependencies are purely implementation details, never observable from outside of a package. However, as soon as a package’s dependency becomes exposed as part of its &lt;em&gt;interface&lt;/em&gt;, dependency isolation is not only subtly wrong, it can cause complete failure at runtime. These are cases when traditional dependency management are much better—they will tell you as soon as you attempt to install two packages that they just don’t work together, rather than waiting for you to figure that out for yourself.&lt;/p&gt;&lt;p&gt;This might not sound &lt;em&gt;too&lt;/em&gt; bad—after all, JavaScript is a very dynamic language, so static guarantees are mostly few and far between, and your tests should catch these problems should they arise—but it can cause unnecessary issues when two packages &lt;em&gt;can&lt;/em&gt; theoretically work together fine, but because npm assigned each one its own copy of a particular package (that is, it wasn’t quite smart enough to figure out it could give them both the same copy), things break down.&lt;/p&gt;&lt;p&gt;Looking outside of npm specifically and considering this model when applied to other languages, it becomes increasingly clear that this won’t do. This blog post was inspired by &lt;a href="https://www.reddit.com/r/haskell/comments/4zc6y3/why_doesnt_cabal_use_a_model_like_that_of_npm/?ref=share&amp;amp;ref_source=link"&gt;a Reddit thread discussing the npm model applied to Haskell&lt;/a&gt;, and this flaw was touted as a reason why it couldn’t possibly work for such a static language.&lt;/p&gt;&lt;p&gt;Due to the way the JavaScript ecosystem has evolved, it’s true that most people can often get away with this subtle potential for incorrect behavior without any problems. Specifically, JavaScript tends to rely on duck typing rather than more restrictive checks like &lt;code&gt;instanceof&lt;/code&gt;, so objects that satisfy the same protocol will still be compatible, even if their implementations aren’t &lt;em&gt;quite&lt;/em&gt; the same. However, npm actually provides a robust solution to this problem that allows package authors to explicitly express these “cross-interface” dependencies.&lt;/p&gt;&lt;h3&gt;&lt;a name="peer-dependencies"&gt;&lt;/a&gt;Peer dependencies&lt;/h3&gt;&lt;p&gt;Normally, npm package dependencies are listed under a &lt;code&gt;"dependencies"&lt;/code&gt; key in the package’s &lt;code&gt;package.json&lt;/code&gt; file. There is, however, another, less-used key called &lt;code&gt;"peerDependencies"&lt;/code&gt;, which has the same format as the ordinary dependencies list. The difference shows up in how npm performs dependency resolution: rather than getting its own copy of a peer dependency, a package expects that dependency to be provided by its dependent.&lt;/p&gt;&lt;p&gt;This effectively means that peer dependencies are effectively resolved using the “traditional” dependency resolution mechanism that tools like Bundler and Cabal use: there must be one canonical version that satisfies everyone’s constraint. Since npm 3, things are a little bit less straightforward (specifically, peer dependencies are not automatically installed unless a dependent package explicitly depends on the peer package itself), but the basic idea is the same. This means that package authors must make a choice for each dependency they install: should it be a normal dependency or a peer dependency?&lt;/p&gt;&lt;p&gt;This is where I think people tend to get a little lost, even those familiar with the peer dependency mechanism. Fortunately, the answer is relatively simple: is the dependency in question visible in &lt;em&gt;any place&lt;/em&gt; in the package’s interface?&lt;/p&gt;&lt;p&gt;This is sometimes hard to see in JavaScript because the “types” are invisible; that is, they are dynamic and rarely explicitly written out. However, just because the types are dynamic does not mean they are not there at runtime (and in the heads of various programmers), so the rule still holds: if the type of a function in a package’s public interface somehow depends on a dependency, it should be a peer dependency.&lt;/p&gt;&lt;p&gt;To make this a little more concrete, let’s look at a couple of examples. First off, let’s take a look at some simple cases, starting with some uses of &lt;code&gt;ramda&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;add&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nx"&gt;from&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ramda&amp;#39;&lt;/span&gt;

&lt;span class="kr"&gt;export&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;withDefaultConfig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;config&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class="nx"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="nx"&gt;path&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="nx"&gt;config&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;export&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;add5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first example here is pretty obvious: in &lt;code&gt;withDefaultConfig&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt; is used purely as an implementation detail, so it’s safe, and it’s not part of the module’s interface. In &lt;code&gt;add5&lt;/code&gt;, the example is a little trickier: the result of &lt;code&gt;add(5)&lt;/code&gt; is a partially-applied function created by Ramda, so technically, a Ramda-created value is a part of this module’s interface. However, the contract &lt;code&gt;add5&lt;/code&gt; has with the outside world is simply that it is a JavaScript function that adds five to its argument, and it doesn’t depend on any Ramda-specific functionality, so &lt;code&gt;ramda&lt;/code&gt; can safely be a non-peer dependency.&lt;/p&gt;&lt;p&gt;Now let’s look at another example using the &lt;code&gt;jpeg&lt;/code&gt; image library:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;Jpeg&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nx"&gt;from&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;jpeg&amp;#39;&lt;/span&gt;

&lt;span class="kr"&gt;export&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;createSquareBuffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;cb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class="nx"&gt;createSquareJpeg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;export&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;createSquareJpeg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Jpeg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, the &lt;code&gt;createSquareBuffer&lt;/code&gt; function invokes a callback with an ordinary Node.js &lt;code&gt;Buffer&lt;/code&gt; object, so the &lt;code&gt;jpeg&lt;/code&gt; library is an implementation detail. If that were the only function exposed by this module, &lt;code&gt;jpeg&lt;/code&gt; could safely be a non-peer dependency. However, the &lt;code&gt;createSquareJpeg&lt;/code&gt; function violates that rule: it returns a &lt;code&gt;Jpeg&lt;/code&gt; object, which is an opaque value with a structure defined exclusively by the &lt;code&gt;jpeg&lt;/code&gt; library. Therefore, a package with the above module &lt;em&gt;must&lt;/em&gt; list &lt;code&gt;jpeg&lt;/code&gt; as a peer dependency.&lt;/p&gt;&lt;p&gt;This sort of restriction works in reverse, too. For example, consider the following module:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;writeFile&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nx"&gt;from&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;fs&amp;#39;&lt;/span&gt;

&lt;span class="kr"&gt;export&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;writeJpeg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;jpeg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;cb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class="nx"&gt;jpeg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;image&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;writeFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;image&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;cb&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above module does not even &lt;em&gt;import&lt;/em&gt; the &lt;code&gt;jpeg&lt;/code&gt; package, yet it implicitly depends on the &lt;code&gt;encode&lt;/code&gt; method of the &lt;code&gt;Jpeg&lt;/code&gt; interface. Therefore, despite not even explicitly using it anywhere in the code, a package containing the above module should include &lt;code&gt;jpeg&lt;/code&gt; as a peer dependency.&lt;/p&gt;&lt;p&gt;They key is to carefully consider what contract your modules have with their dependents. If those contracts involve other packages in any way, they should be peer dependencies. If they don’t, they should be ordinary dependencies.&lt;/p&gt;&lt;h2&gt;&lt;a name="applying-the-npm-model-to-other-programming-languages"&gt;&lt;/a&gt;Applying the npm model to other programming languages&lt;/h2&gt;&lt;p&gt;The npm model of package management is more complicated than that of other languages, but it provides a real advantage: implementation details are kept as implementation details. In other systems, it’s quite possible to find yourself in “dependency hell”, when you personally know that the version conflict reported by your package manager is not a real problem, but because the package system must pick a single canonical version, there’s no way to make progress without adjusting code in your dependencies. This is extremely frustrating.&lt;/p&gt;&lt;p&gt;This sort of dependency isolation is not the most advanced form of package management in existence—indeed, far from it—but it’s definitely more powerful than most other mainstream systems out there. Of course, most other languages could not adopt the npm model simply by changing the package manager: having a global package namespace can prevent multiple versions of the same package being installed at a &lt;em&gt;runtime&lt;/em&gt; level. The reason npm is able to do what it does is because Node itself supports it.&lt;/p&gt;&lt;p&gt;That said, the dichotomy between peer and non-peer dependencies is a little confusing, especially to people who aren’t package authors. Figuring out which packages need to go in which group is not always obvious or trivial. Fortunately, other languages might be able to help.&lt;/p&gt;&lt;p&gt;Returning to Haskell, its strong static type system would potentially allow this distinction to be detected entirely automatically, and Cabal could actually report an error when a package used in an exposed interface was not listed as a peer dependency (much like how it currently prevents importing a transitive dependency without explicitly depending on it). This would allow helper function packages to keep on being implementation details while still maintaining strong interface safety. This would likely take a lot of work to get just right—managing the global nature of typeclass instances would likely make this much more complicated than a naïve approach would accommodate—but it would add a nice layer of flexibility that does not currently exist.&lt;/p&gt;&lt;p&gt;From the perspective of JavaScript, npm has demonstrated that it can be a capable package manager, despite the monumental burden placed upon it by the ever-growing, ever-changing JS ecosystem. As a package author myself, I would implore other users to carefully consider the peer dependencies feature and work hard to encode their interfaces’ contracts using it—it’s a commonly misunderstood gem of the npm model, and I hope this blog post helped to shed at least a little more light upon it.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Climbing the infinite ladder of abstraction</title><link>https://lexi-lambda.github.io/blog/2016/08/11/climbing-the-infinite-ladder-of-abstraction/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2016/08/11/climbing-the-infinite-ladder-of-abstraction/</guid><pubDate>11 Aug 2016</pubDate><description>&lt;article&gt;&lt;p&gt;I started programming in elementary school.&lt;/p&gt;&lt;p&gt;When I was young, I was fascinated by the idea of automation. I loathed doing the same repetitive task over and over again, and I always yearned for a way to &lt;a href="https://xkcd.com/974/"&gt;solve the general problem&lt;/a&gt;. When I learned about programming, I was immediately hooked: it was &lt;em&gt;so easy&lt;/em&gt; to turn repetitive tasks into automated pipelines that would free me from ever having to do the same dull, frustrating exercise ever again.&lt;/p&gt;&lt;p&gt;Of course, one of the first things I found out once I’d started was that nothing is ever quite so simple. Before long, my solutions to eliminate repetition grew repetitive, and it became clear I spent a lot of time typing out the same things, over and over again, creating the very problem I had initially set out to destroy. It was through this that I grew interested in functions, classes, and other repetition-reducing aids, and soon enough, I discovered the wonderful world of &lt;strong&gt;abstraction&lt;/strong&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name="the-brick-wall-of-inexpressiveness"&gt;&lt;/a&gt;The brick wall of inexpressiveness&lt;/h2&gt;&lt;p&gt;When I started programming, I was mostly playing with ActionScript and Java, just tinkering with things and seeing what I could come up with. I had quite a lot of fun, and the joy of solving problems hooked me almost immediately, but I also ran into frustrations pretty quickly. Specifically, I started writing a lot of code that looked like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a bit of a cheap example, given that Java getters and setters are something of a programming language punching bag at this point, but I really did write them, and I really did get frustrated by them! I learned object-oriented design patterns, and I pored over books, forum threads, blog posts, and Stack Overflow questions about how to structure code to prevent spaghetti, but no matter how hard I tried, I kept having to type things that looked suspiciously similar to each other.&lt;/p&gt;&lt;p&gt;It was really quite frustrating, because no matter how I approached the problem, I ended up with a boilerplate-heavy mess. The &lt;em&gt;whole reason&lt;/em&gt; I got started programming was to avoid this sort of thing, so what could I do? Well, it became increasingly obvious to me that Java had to go, and I needed to try something else. I started learning two very different programming languages, JavaScript and Objective-C, and I liked them both, for different reasons.&lt;/p&gt;&lt;p&gt;When I learned JavaScript, I discovered the closure, the first-class function, and I was entranced by it. Through jQuery, I learned of its power to design APIs that could be fun to use, dropping the boring, “heavy” feeling that Java carried around everywhere. With Objective-C, on the other hand, I learned about the power of a more dynamic object system, something with interesting syntax and the ability to handle “message passing” at a far higher level than Java ever could.&lt;/p&gt;&lt;p&gt;Both of these languages were flawed, as all languages are, but they opened my mind to the idea that &lt;em&gt;programming languages&lt;/em&gt; could drastically influence the way I thought about problem solving, and they set me on a quest to find the programming language that would eliminate boilerplate once and for all.&lt;/p&gt;&lt;h2&gt;&lt;a name="discovering-lisp"&gt;&lt;/a&gt;Discovering Lisp&lt;/h2&gt;&lt;p&gt;Over the next few years, I grew to appreciate JavaScript’s small, simple core, despite rather disliking its object system and poor faculties for user-friendly data modeling. I pored over its history, and I found out that its design was heavily influenced by an obscure little language called Scheme, as well as an even more obscure language called Self, and a part of me started to wonder what it would be like to incorporate those languages’ ideas without some of the compromises JavaScript had made.&lt;/p&gt;&lt;p&gt;This idea lingered in the back of my head for a couple years, and while I tried to play with Scheme a couple times, it was simply too inaccessible for me. I was used to languages with powerful, easy to use IDEs, and when I found myself with nothing more than a command-line executable and rather scarce documentation, I was at a loss for how to begin. Even if I could do math in the REPL, where could I go from there? I’d started programming by building games, then websites. What could I possibly do with Scheme?&lt;/p&gt;&lt;p&gt;The language (or rather, its lack of an ecosystem) proved too intimidating for me at that young age, but the idea of Lisp’s homoiconicity stuck with me. Eventually, I started to design my very own programming language, a &lt;a href="https://github.com/lexi-lambda/libsol"&gt;highly dynamic Lisp with a prototypal object system called Sol&lt;/a&gt;. I worked on it for about a year, and when I was done with it, it had a not-too-shabby complement of features: it had lambdas, macros, a fully-featured object model, and a CommonJS-esque module system, complete with the ability to dynamically import arbitrary C extensions. It was by far the largest project I’d ever worked on, and when I was done, I was pretty pleased.&lt;/p&gt;&lt;p&gt;Unfortunately, it was also abysmally slow.&lt;/p&gt;&lt;p&gt;I turned to a local college to find some people who could give me feedback and maybe point me in the right direction, and someone told me about another obscure programming language called &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;. At about the same time, someone pointed me to a totally different language called &lt;a href="https://www.haskell.org"&gt;Haskell&lt;/a&gt;. This was uncharted territory for me, and for a while, I didn’t really explore either of those languages further. Eventually, though, I dove into them in earnest, and what I found has dramatically altered my perspective on programming since then.&lt;/p&gt;&lt;h2&gt;&lt;a name="a-journey-into-complexity"&gt;&lt;/a&gt;A journey into complexity&lt;/h2&gt;&lt;p&gt;Fast forward about three years, and today, I am employed writing Haskell, and I spend most of my free time writing Racket. These languages left a mark on me, and while I’ve learned &lt;em&gt;so much more&lt;/em&gt; since then, I find myself continually bucking the mainstream and coming back to functional programming, hygienic macros, and possibly the most powerful type system in existence in a production-ready programming language.&lt;/p&gt;&lt;p&gt;I’ve also started realizing something else, though: &lt;strong&gt;the languages I’ve settled into are &lt;em&gt;really complicated&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;When I started programming, I thought about things like numbers, text, and shapes on a screen. Before long, I learned about functions, then classes, then message-passing and lambdas. I dove into macros and typeclasses, and now I speak in functors and monads, sets of scopes and internal definition contexts, and parser combinators and domain specific languages.&lt;/p&gt;&lt;p&gt;Why?&lt;/p&gt;&lt;p&gt;Sometimes I talk to fellow programmers, and they are horrified by the types of terms I fling around. “Why would you ever need something called a ‘monad’?” they ask, completely perplexed. “Macros are confusing,” they argue. “Being explicit is better.”&lt;/p&gt;&lt;p&gt;Obviously, I disagree, but why? What have I given up? If my fellow programmers cannot understand what I’m writing, is it actually worth it?&lt;/p&gt;&lt;p&gt;I’ve searched for years to find a programming language that will eliminate boilerplate, that will allow me to express my ideas succinctly and cleanly, that will let me turn hard problems into trivial ones, and I’ve discovered two completely different approaches to tackling those issues. Racket has macros, and Haskell has its fancy type system. Both of these things are lightyears ahead of where I was nearly a decade ago, writing dozens of lines of repetitive Java that ultimately did very little, but I’m still dealing with the same problems.&lt;/p&gt;&lt;p&gt;Racket knows too little about my program—it can’t figure out what I mean based on the type of thing I’m operating on because it is (mostly) dynamically typed. I &lt;em&gt;still&lt;/em&gt; have to clarify myself and write things that feel redundant because the computer isn’t smart enough to figure out the “obvious”. Similarly, Haskell is too limiting—the compiler cannot deduce constraints I can solve in my head in seconds, and its syntax is not extensible like Racket’s is. Every day, I peer into piles upon piles of monadic computation, and really, what have I gained?&lt;/p&gt;&lt;h3&gt;&lt;a name="improvement-but-never-mastery"&gt;&lt;/a&gt;Improvement, but never mastery&lt;/h3&gt;&lt;p&gt;Like almost anything in life, programming is not really a perfectable art. There’s always some unlearned skill or undiscovered technique, and part of this potential for perpetual self-improvement is one of the things that I find so attractive about the field. That said, I this it is reasonable to say that certain languages have higher ceilings than others.&lt;/p&gt;&lt;p&gt;For example I am pretty confident that I &lt;em&gt;get&lt;/em&gt; JavaScript. The language has lots of nooks and crannies that I don’t completely understand, but I feel pretty confident that I understand its semantics well enough to be able to grasp any piece of JavaScript code without too much incredulity. Now, that’s not to say that JavaScript is a simplistic language—far from it—but most of the ways I improve my JavaScripting abilities are learning new techniques &lt;em&gt;within&lt;/em&gt; the language, not entirely new linguistic constructs.&lt;/p&gt;&lt;p&gt;On the other hand, languages like Haskell and Racket tend to blur the line. I feel like I have a good grasp of Haskell’s core, but do I have a good intuition for laziness? Do I completely grok type families? What about &lt;code&gt;TypeInType&lt;/code&gt;? Ultimately, I have to come to the conclusion that I do not fully understand Haskell, much less a lot of the advanced category theory that composes some of its most powerful libraries. Racket manages to blur the line between language and library even further, and while I consider myself a decent Racketeer, I absolutely do &lt;em&gt;not&lt;/em&gt; have a good grasp on all the intricacies of Racket’s macro system.&lt;/p&gt;&lt;p&gt;This is especially obvious to me at work, given that I write Haskell in a team setting. Just like back when I was writing Java, I end up with solutions that don’t satisfy me, and I reach for increasingly powerful constructs to help alleviate my qualms. Sometimes, I find myself cracking out &lt;code&gt;DataKinds&lt;/code&gt;, and it might even help my problem, but there’s a cost: my coworkers are sometimes confused.&lt;/p&gt;&lt;p&gt;Every time I climb to the next rung on the ladder of abstraction, those only a couple rungs below me (even if we’re all hundreds of rungs up!) find themselves perplexed. In the worst case, people may even blame their confusion on their own inadequacy or lack of skill. This is &lt;em&gt;terrible&lt;/em&gt;, especially when I know that, by the time they’ve caught up, I’ll be off playing with some new toy: comonads or type families or classy lenses. The cycle continues, and nobody is ever truly satisfied—I always want to find a new abstraction that will make things simpler, and those just a couple steps behind me struggle to keep up.&lt;/p&gt;&lt;p&gt;Of course, I experience it from the opposite perspective just as often: I delve into Edward Kmett’s fancier libraries or Phil Freeman’s blog posts about category theory, and I recognize that I am rather lost. Sometimes, I find myself understanding things, but just as often, I cannot wrap my head around the concepts being discussed. I may figure them out eventually, sure, but by then everyone else has moved on to even &lt;em&gt;more&lt;/em&gt; advanced things, and still, none of them truly solve my problems.&lt;/p&gt;&lt;h2&gt;&lt;a name="ultimately-it-all-has-at-least-a-little-value"&gt;&lt;/a&gt;Ultimately, it all has (at least a little) value&lt;/h2&gt;&lt;p&gt;It would be nice to think about all that and say, well, “Let’s finally break the cycle. Let’s stop deluding ourselves into thinking our solutions to our self-made problems are actually solving anything.” It would be great if I could tell myself that, but I unfortunately really can’t.&lt;/p&gt;&lt;p&gt;The scariest part of all is that I think it’s completely worthwhile.&lt;/p&gt;&lt;p&gt;So much of these more and more complicated abstractions are trying to do the same basic thing: come up with a better way of modeling the problem. In some sense, that’s all programming really is, modeling a domain in a way that can be leveraged by a digital computer. Our increasingly complicated DSLs &lt;em&gt;seem&lt;/em&gt; unnecessarily complicated, they &lt;em&gt;seem&lt;/em&gt; increasingly removed from reality, but that’s only because we’re getting better at creating languages that are closer to our domains without the baggage of preconceptions that came before us.&lt;/p&gt;&lt;p&gt;The downside is that, without an understanding of those preconceptions, a lot of what we come up with seems like patent gibberish to those unaware of our languages’ history.&lt;/p&gt;&lt;p&gt;Most programmers, even those who have never seen BASIC before, can figure out what this snippet does:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nl"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;INPUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"What is your name: "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;U$&lt;/span&gt;
&lt;span class="nl"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;PRINT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"Hello "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;U$&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On the other hand, very few would probably understand this one:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;-- | A class for categories.&lt;/span&gt;
&lt;span class="c1"&gt;--   id and (.) must form a monoid.&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Category&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
    &lt;span class="c1"&gt;-- | the identity morphism&lt;/span&gt;
    &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

    &lt;span class="c1"&gt;-- | morphism composition&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Yet very few new programs are being written in BASIC, and lots are being written in Haskell.&lt;/p&gt;&lt;p&gt;Even one of the most popular, fastest-growing programming languages in the world, JavaScript, a language considered relatively accessible compared to things like Haskell, would likely be incomprehensible to a programmer not familiar with its syntax:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;export&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;composeWithProps&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;curry&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parentProps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;composed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;childProps&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="nx"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parentProps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;omit&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;children&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nx"&gt;childProps&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;childProps&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;children&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="c1"&gt;// give the composed component a pretty display name for debugging&lt;/span&gt;
  &lt;span class="nx"&gt;composed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;displayName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sb"&gt;`Composed(&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;getDisplayName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;, &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;getDisplayName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;)`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;composed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Moving towards increasingly specialized syntaxes is not inherently bad—it can often be indicative of a more streamlined, domain-specific way of thinking—but while it may dramatically increase the productivity of a seasoned programmer, it can be nothing short of baffling to a newcomer.&lt;/p&gt;&lt;p&gt;That, specifically, is the crux of my fear: are we always aware of who we are optimizing for? I do not have a moral problem with writing code to optimize concision for seasoned programmers; after all, brevity is one of the primary ways code is made more readable (verbosity is the enemy of understanding). However, when that concision comes at the cost of beginners’ understanding, the picture becomes a bit more grey. It is not wrong to write things that are highly optimized for one’s own knowledge and understanding, and establishing a group of such people can make for an &lt;em&gt;extremely&lt;/em&gt; productive team. It’s just also important to understand that others will likely be confused, and without being willing to invest the time and money into education, smart, diligent people will still fail to grasp the concepts, and they will likely be wholly uninterested in them.&lt;/p&gt;&lt;h3&gt;&lt;a name="reactionary-anti-intellectualism-and-the-search-for-moderation"&gt;&lt;/a&gt;Reactionary anti-intellectualism and the search for moderation&lt;/h3&gt;&lt;p&gt;I have noticed lately that people close to my circles have started regularly slinging insults at people who work in highly specialized notation. Math, including things like category and type theory, has become an especially acceptable punching bag. &lt;a href="https://twitter.com/lexi_lambda/status/763111451691134976"&gt;I recently tweeted a picture of some rather dense mathematics from a paper I’d read&lt;/a&gt;, and I was frankly disturbed at some of the vitriolic responses. Academia is sometimes described as “masturbatory”, and honestly, that is both offensive and hypocritical.&lt;/p&gt;&lt;p&gt;Mathematical notation is not perfect, no more than dense Haskell, heavily metaprogrammed Ruby, or IIFE-packed JavaScript. Still, it serves a purpose, and sometimes spelling things out is neither practically feasible nor a theoretical improvement. Programmers would not take kindly to being asked to write all their code out as prose, nor would they like being told that using higher-order functions like &lt;code&gt;map&lt;/code&gt; should be banned because they are too confusing and not immediately self-explanatory.&lt;/p&gt;&lt;p&gt;I am glad that people are focusing on usability and accessibility more than ever, and I think that’s one of the areas I’m the most interested in. I want to get the best of both worlds: I aim to write code in a highly concise, precise style, but I try and produce intuitive interfaces with human-readable errors upon failure. To me, a user-hostile yet technically functional library is a buggy one, and I would happily file a bug report about a confusing API or error message.&lt;/p&gt;&lt;p&gt;Abstraction is what seems to make programming possible, and indeed, it’s what makes most modern &lt;em&gt;technology&lt;/em&gt; possible. It’s what allows people to drive a car without knowing how an internal combustion engine works, and it’s what allows people to browse the web without having a deep understanding of internet protocol. In programming, abstraction serves a similar purpose. Of course, just like all tools, abstractions can have rather different goals: the average user will not pick up Photoshop in a day, but a power user is not going to be satisfied with Paint.&lt;/p&gt;&lt;p&gt;Programmers are professionals, and we work in a technical domain. I am absolutely of the belief that programming, like any other field, is not always about what comes easiest: sometimes it’s important to sit down and study for a while to grok a particularly complicated concept, and other times, it’s simply important to learn by trying, failing, and asking questions. I strive to find that blend of accessible, concise, and robust, and just like everything else, that target shifts depending on the situation and people I’m working with.&lt;/p&gt;&lt;p&gt;I honestly don’t know if Racket and Haskell are worth their costs in complexity. At the end of the day, maybe what really matters is writing simple, consistent things that other people can understand. I really hope that there is a place for more powerful languages within a team, but there’s something to be said about which languages tend to get the most popular.&lt;/p&gt;&lt;p&gt;Ultimately, though, I am just trying to be aware of the tradeoffs I’m making, the benefits I’m getting, and the impact on those I’m working with. I will continue to search for abstractions that can better fit my needs, and I am sure I will keep on climbing the ladder of abstraction for years to come—I just really hope I’m not wasting my time.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Four months with Haskell</title><link>https://lexi-lambda.github.io/blog/2016/06/12/four-months-with-haskell/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2016/06/12/four-months-with-haskell/</guid><pubDate>12 Jun 2016</pubDate><description>&lt;article&gt;&lt;p&gt;At the end of January of this year, I switched to a new job, almost exclusively because I was enticed by the idea of being able to write Haskell. The concept of using such an interesting programming language every day instead of what I’d been doing before (mostly Rails and JavaScript) was very exciting, and I’m pleased to say that the switch seems to have been well worth it.&lt;/p&gt;&lt;p&gt;Haskell was a language I had played with in the past but never really used for anything terribly practical, but lately I think I can confidently say that it really is an &lt;em&gt;incredible&lt;/em&gt; programming language. At the same time, it has some significant drawbacks, too, though probably not the ones people expect. I certainly wasn’t prepared for some of the areas where Haskell would blow me away, nor was I capable of realizing which parts would leave me hopelessly frustrated until I actually sat down and started writing lots and lots of code.&lt;/p&gt;&lt;h2&gt;&lt;a name="dispelling-some-myths"&gt;&lt;/a&gt;Dispelling some myths&lt;/h2&gt;&lt;p&gt;Before moving on and discussing my experiences in depth, I want to take a quick detour to dispel some frequent rumors I hear about why Haskell is at least potentially problematic. These are things I hear a &lt;em&gt;lot&lt;/em&gt;, and nothing in my experience so far would lead me to believe these are actually true. Ultimately, I don’t want to spend too much time on these—I think that, for the most part, they are nitpicks that people complain about to avoid understanding the deeper and more insidious problems with the language—but I think it’s important to at least mention them.&lt;/p&gt;&lt;h3&gt;&lt;a name="hiring-haskell-developers-is-not-hard"&gt;&lt;/a&gt;Hiring Haskell developers is not hard&lt;/h3&gt;&lt;p&gt;I am on the first Haskell team in my company, and I am among the first Haskell developers we ever hired. Not only were we hiring without much experience with Haskell at all, we explicitly &lt;em&gt;did not&lt;/em&gt; want to hire remote. Debate all you like about whether or not permitting remote work is a good idea, but I don’t think anyone would dispute that this constraint makes hiring much harder. We didn’t have any trouble finding a very large stream of qualified applicants, and it definitely seems to have dispelled any fears that we would have trouble finding new candidates in the future.&lt;/p&gt;&lt;h3&gt;&lt;a name="performing-i-o-in-haskell-is-easy"&gt;&lt;/a&gt;Performing I/O in Haskell is easy&lt;/h3&gt;&lt;p&gt;Haskell’s purity is a point of real contention, and it’s one of the most frustrating complaints I often hear about Haskell. It is surprisingly common to hear concerns along the lines of “I don’t want to use Haskell because its academic devotion to purity sounds like it would make it very hard to get anything done”. There are very valid reasons to avoid Haskell, but in practice, I/O is not one of them. In fact, I found that isolating I/O in Haskell was much the same as isolating I/O in every other language, which I need to do anyway to permit unit testing.&lt;/p&gt;&lt;p&gt;...you &lt;em&gt;do&lt;/em&gt; write deterministic unit tests for your impure logic, right?&lt;/p&gt;&lt;h3&gt;&lt;a name="working-with-lots-of-monads-is-not-very-difficult"&gt;&lt;/a&gt;Working with lots of monads is not very difficult&lt;/h3&gt;&lt;p&gt;The “M word” has ended up being a running joke &lt;em&gt;about&lt;/em&gt; Haskell that actually ends up coming up fairly rarely &lt;em&gt;within&lt;/em&gt; the Haskell community. To be clear, there is &lt;em&gt;no doubt&lt;/em&gt; in my mind that monads make Haskell intimidating and provide a steep learning curve for new users. The proliferation of the joke that monads are impossible to explain, to the point of becoming mythologized, is absolutely indicative of a deeper problem about Haskell’s accessibility. However, once people learn the basics about monads, I’ve found that applying them is just as natural as applying any other programming pattern.&lt;/p&gt;&lt;p&gt;Monads are used to assist the programmer, not impede them, and they really do pay off in practice. When something has a monadic interface, there’s a decent chance I already know what that interface is going to do, and that makes working with lots of different monads surprisingly easy. Admittedly, I do rely very, very heavily on tooling to help me out here, but with things like mouseover type tooltips, I’ve actually found that working with a variety of different monads and monad transformers is actually quite pleasant, and it makes things very readable!&lt;/p&gt;&lt;h2&gt;&lt;a name="haskell-the-good-parts"&gt;&lt;/a&gt;Haskell: the good parts&lt;/h2&gt;&lt;p&gt;With the disclaimers out of the way, I really just want to gush for a little bit. This is not going to be an objective, reasoned survey of why Haskell is good. I am not even really going to touch upon why types are so great and why purity is so wonderful—I’d love to discuss those in depth, but that’s for a different blog post. For now, I just want to touch upon the real surprises, the real things that made me &lt;em&gt;excited&lt;/em&gt; about Haskell in ways I didn’t expect. These are the things that my subjective little experience has found fun.&lt;/p&gt;&lt;h3&gt;&lt;a name="language-extensions-are-haskell"&gt;&lt;/a&gt;Language extensions &lt;em&gt;are&lt;/em&gt; Haskell&lt;/h3&gt;&lt;p&gt;There was a time in my life when I spent a lot of time writing C. There are a lot of compilers for C, and they all implement the language in subtly different but often incompatible ways, especially on different platforms. The only way to maintain a modicum of predictability was to adhere to the standards &lt;em&gt;religiously&lt;/em&gt;, even when certain GCC or MSVC extensions seem tantalizingly useful. I was actually bitten a few times by real instances where I figured I’d just use a harmless extension that was implemented everywhere, then found out it worked slightly differently across different compilers in a particular edge case. It was a learning experience.&lt;/p&gt;&lt;p&gt;It seems that this fear provides a very real distrust for using GHC’s numerous &lt;em&gt;language extensions&lt;/em&gt;, and indeed, for a long time, I felt that it was probably an admirable goal to stick to Haskell 98 or Haskell 2010 as closely as possible. Sometimes I chose a slightly more verbose solution that was standard Haskell to avoid turning on a trivial extension that would make the code look a little bit cleaner.&lt;/p&gt;&lt;p&gt;About a year later, I’m finding that attitude was not only a mistake, but it forced me to often completely miss out on a lot of Haskell’s core value. GHC &lt;em&gt;won&lt;/em&gt;, and now GHC and Haskell are basically synonymous. With that in mind, the portability concerns of language extensions are a bit of a non-issue, and turning them on is a very good idea! Some extensions are more than a little dangerous, so they cannot all be turned on without thinking, but the question is absolutely not “Is using language extensions a good idea?” and more “Is using &lt;em&gt;this&lt;/em&gt; language extension a good idea?”&lt;/p&gt;&lt;p&gt;This is important, and I bring it up for a reason: so much of the awesomeness of Haskell is locked behind language extensions. Turning a lot of these on is one of the main things that made me really start to see how incredibly powerful Haskell actually is.&lt;/p&gt;&lt;h3&gt;&lt;a name="phantom-types"&gt;&lt;/a&gt;Phantom types&lt;/h3&gt;&lt;p&gt;I’m going to start out by talking about &lt;em&gt;phantom types&lt;/em&gt;, which are a pretty simple concept but a powerful one, and they serve as the foundation for a lot of other cool type-level tricks that can make Haskell extremely interesting. The basic idea of a phantom type is simple; it’s a type parameter that isn’t actually used to represent any particular runtime value:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This type represents an id for some kind of value, but although the kind of value is specified in the type as the &lt;code&gt;a&lt;/code&gt; type parameter, it isn’t actually used anywhere on the data definition—no matter what &lt;code&gt;a&lt;/code&gt; is, an &lt;code&gt;Id&lt;/code&gt; is just a piece of text. This makes it possible to write functions that operate on specific kinds of ids, and those invariants will be statically checked by the compiler, even though the runtime representation is entirely identical:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;fetchUser&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;MonadDB&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using &lt;code&gt;FlexibleInstances&lt;/code&gt;, it’s also possible to create different instances for different kinds of ids. For example, it would be possible to have different &lt;code&gt;Show&lt;/code&gt; instances depending on the type of id in question.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"user #"&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;unpack&lt;/span&gt; &lt;span class="n"&gt;txt&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"post #"&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;unpack&lt;/span&gt; &lt;span class="n"&gt;txt&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This provides a simple framework for encoding entirely arbitrary information into the type system, then asking the compiler to actually check assertions about that information. This is made even more powerful with some other extensions, which I’ll talk about shortly.&lt;/p&gt;&lt;h3&gt;&lt;a name="letting-the-compiler-write-code"&gt;&lt;/a&gt;Letting the compiler write code&lt;/h3&gt;&lt;p&gt;One of the things I really dislike, more than most things, is boilerplate. A little bit of boilerplate is fine—even necessary at times—but as soon as I start wondering if a code generator would improve things, I think the programming language has pretty much failed me.&lt;/p&gt;&lt;p&gt;I write a lot of Racket because, in a sense, Racket is the ultimate boilerplate killer: the macro system is a first-class code generator integrated with the rest of the language, and it means that boilerplate is almost never an issue. Of course, that’s not always true: sometimes a bit of boilerplate &lt;em&gt;is&lt;/em&gt; still necessary because macros cannot deduce enough information about the program to generate the code entirely on their own, and in Haskell, some of that information is actually present in the type system.&lt;/p&gt;&lt;p&gt;This leads to two absolutely incredible extensions, both of which are simple and related, but which actually &lt;em&gt;completely change&lt;/em&gt; how I approach problems when programming. These two extensions are &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; and &lt;code&gt;StandaloneDeriving&lt;/code&gt;.&lt;/p&gt;&lt;h4&gt;&lt;a name="newtypes-and-type-safety"&gt;&lt;/a&gt;Newtypes and type safety&lt;/h4&gt;&lt;p&gt;The basic idea is that “newtypes” are just simple wrapper types in Haskell. This turns out to be extremely important when trying to find the value of Haskell because they allow you to harden type safety by specializing types to &lt;em&gt;your&lt;/em&gt; domain. For example, consider a type representing a user’s name:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This type is extremely simple, and in fact isn’t even at all different from a simple &lt;code&gt;Text&lt;/code&gt; value with respect to its representation, since all combinations of unicode characters are allowed in a name. Therefore, what’s the point of a separate type? Well, this allows Haskell to introduce actual compilation failures when two different kinds of textual data are mixed. This is not a new idea, and even in languages that don’t support this sort of thing, Joel Spolsky’s old blog post &lt;a href="http://www.joelonsoftware.com/articles/Wrong.html"&gt;Making Wrong Code Look Wrong&lt;/a&gt; describes how it can be done by convention. Still, almost every modern language makes this possible: in C, it would be a single-member &lt;code&gt;struct&lt;/code&gt;, in class-based OO languages, it would be a single-member class... this is not a complicated idea.&lt;/p&gt;&lt;p&gt;The difference lies in its usage. In other languages, this strategy is actually not very frequently employed for the simple reason that it is almost always extremely annoying. You are forced to do tons of wrapping/unwrapping, and at that point it isn’t really clear if you’re even getting all that much value out of the distinction when your first solution to a type mismatch is wrapping or unwrapping the value without a second thought. In Haskell, however, this can be heavily mitigated by asking the compiler to &lt;em&gt;automatically derive typeclass implementations&lt;/em&gt;, which allow the unwrapping/wrapping to effectively happen implicitly for a constrained set of operations.&lt;/p&gt;&lt;h4&gt;&lt;a name="using-generalizednewtypederiving"&gt;&lt;/a&gt;Using &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;Consider the &lt;code&gt;Name&lt;/code&gt; type once again, but this time, let’s derive a class:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IsString&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;IsString&lt;/code&gt; typeclass in Haskell allows custom types to automatically be created from string literals. It is &lt;em&gt;not&lt;/em&gt; handled specially by Haskell’s &lt;code&gt;deriving&lt;/code&gt; mechanism. Since &lt;code&gt;Text&lt;/code&gt; implements &lt;code&gt;IsString&lt;/code&gt;, an instance will be generated that simply defers to the underlying type, automatically generating the code to wrap the result up in a &lt;code&gt;Name&lt;/code&gt; box at the end. This means that code like this will now just magically work:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Name&lt;/span&gt;
&lt;span class="nf"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Alyssa P. Hacker"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;No boilerplate needs to be written! This is a neat trick, but it actually turns out to be far more useful than that simple example in practice. What really makes this functionality shine is when you want to derive &lt;em&gt;some&lt;/em&gt; kinds of functionality but disallow some others. For example, using the &lt;a href="https://hackage.haskell.org/package/text-conversions"&gt;&lt;code&gt;text-conversions&lt;/code&gt;&lt;/a&gt; package, it’s possible to do something like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToText&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This creates an opaque &lt;code&gt;Id&lt;/code&gt; type, but it automatically generates conversions &lt;em&gt;to&lt;/em&gt; textual formats. However, it does &lt;em&gt;not&lt;/em&gt; automatically create &lt;code&gt;FromText&lt;/code&gt; or &lt;code&gt;FromJSON&lt;/code&gt; instances, which would be dangerous because decoding &lt;code&gt;Id&lt;/code&gt;s can potentially fail. It’s then possible to write out those instances manually to preserve a type safety:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromText&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;fromText&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="n"&gt;isValidId&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="kr"&gt;then&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;else&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;parseJSON&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="s"&gt;"invalid id"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fromText&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;parseJSON&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt;            &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="s"&gt;"invalid id"&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name="using-standalonederiving"&gt;&lt;/a&gt;Using &lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;The ordinary &lt;code&gt;deriving&lt;/code&gt; mechanism is extremely useful, especially when paired with the above, but sometimes it is desirable to have a little bit more flexibility. In these cases, &lt;code&gt;StandaloneDeriving&lt;/code&gt; can help.&lt;/p&gt;&lt;p&gt;Take the &lt;code&gt;Id&lt;/code&gt; example again: it has a phantom type, and simply adding something like &lt;code&gt;deriving (ToText)&lt;/code&gt; with derive &lt;code&gt;ToText&lt;/code&gt; instances for &lt;em&gt;all&lt;/em&gt; kinds of ids. It is potentially useful, however, to derive instances for more specific id types. Using standalone &lt;code&gt;deriving&lt;/code&gt; constructs permits this sort of flexibility.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ToText&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;ToText&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;toText&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;postIdToText&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is an example where GHC language extensions end up becoming significantly more than the sum of their parts, which seems to be a fairly frequent realization. The &lt;code&gt;StandaloneDeriving&lt;/code&gt; mechanism is a little bit useful without &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;, but when combined, they are incredibly powerful tools for getting a very fine-grained kind of type safety &lt;em&gt;without&lt;/em&gt; writing any boilerplate.&lt;/p&gt;&lt;h3&gt;&lt;a name="datakinds-are-super-cool-with-caveats"&gt;&lt;/a&gt;DataKinds are super cool, with caveats&lt;/h3&gt;&lt;p&gt;Phantom types are quite wonderful, but they can only encode &lt;em&gt;types&lt;/em&gt;, not arbitrary data. That’s where &lt;code&gt;DataKinds&lt;/code&gt; and &lt;code&gt;KindSignatures&lt;/code&gt; come in: they allow lifting arbitrary datatypes to the type level so that things that would normally be purely runtime values can be used at compile-time as well.&lt;/p&gt;&lt;p&gt;The way this works is pretty simple—when you define a datatype, you also define a “datakind”:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;RegistrationStatus&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Registered&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Anonymous&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Normally, the above declaration declares a &lt;em&gt;type&lt;/em&gt;, &lt;code&gt;RegistrationStatus&lt;/code&gt;, and two &lt;em&gt;data constructors&lt;/em&gt;, &lt;code&gt;Registered&lt;/code&gt; and &lt;code&gt;Anonymous&lt;/code&gt;. With &lt;code&gt;DataKinds&lt;/code&gt;, it also defines a &lt;em&gt;kind&lt;/em&gt;, &lt;code&gt;RegistrationStatus&lt;/code&gt;, and two &lt;em&gt;type constructors&lt;/em&gt;, &lt;code&gt;Registered&lt;/code&gt; and &lt;code&gt;Anonymous.&lt;/code&gt;&lt;/p&gt;&lt;p&gt;If that’s confusing, the way to understand that is to realize there is a sort of natural ordering here: types describe values, and kinds describe types. Therefore, turning on &lt;code&gt;DataKinds&lt;/code&gt; “lifts” each definition by a single level, so types become kinds and values become types. This permits using these things at the type level:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;RegistrationStatus&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example, &lt;code&gt;UserId&lt;/code&gt; still has a single phantom type variable, &lt;code&gt;s&lt;/code&gt;, but this time it is constrained to the &lt;code&gt;RegistrationStatus&lt;/code&gt; kind. Therefore, it can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;Registered&lt;/code&gt; or &lt;code&gt;Anonymous&lt;/code&gt;. This cooperates well with the aforementioned &lt;code&gt;StandaloneDeriving&lt;/code&gt; mechanism, and it mostly provides a convenient way to constrain type variables to custom kinds.&lt;/p&gt;&lt;p&gt;In general, &lt;code&gt;DataKinds&lt;/code&gt; is a much more powerful extension, allowing things like type-level natural numbers or strings, which can be used to perform actual type-level computation (especially in combination with &lt;code&gt;TypeFamilies&lt;/code&gt;) or a sort of metaprogramming. In some cases, they can even be used to implement things emulating things you can do with dependent types.&lt;/p&gt;&lt;p&gt;I think &lt;code&gt;DataKinds&lt;/code&gt; are a very cool Haskell extension, but there are a couple caveats. One of the main ones is how new kinds are defined: &lt;code&gt;DataKinds&lt;/code&gt; “hijacks” the existing datatype declaration syntax by making every single datatype declaration define a type &lt;em&gt;and&lt;/em&gt; a kind. This is a little confusing, and it would be nice if a different syntax was used so that each could be defined independently.&lt;/p&gt;&lt;p&gt;Similarly, it seems that a lot of work is being done to allow using runtime values at the type level, but I wonder if people will ever need to use, say, runtime values at the &lt;em&gt;kind&lt;/em&gt; level. This immediately evokes thoughts of Racket’s phase-based macro system, and I wonder if some of this duplication would be unnecessary with something similar.&lt;/p&gt;&lt;p&gt;Food for thought, but overall, &lt;code&gt;DataKinds&lt;/code&gt; are a very nice addition to help with precisely and specifically typing particular problems.&lt;/p&gt;&lt;h3&gt;&lt;a name="typeclasses-can-emulate-effects"&gt;&lt;/a&gt;Typeclasses can emulate effects&lt;/h3&gt;&lt;p&gt;This is something that I’ve found interesting in my time writing Haskell because I have &lt;em&gt;no idea&lt;/em&gt; if it’s idiomatic or not, but it seems pretty powerful. The initial motivator for this idea was figuring out how to test our code without constantly dropping into &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;More generally, we wanted to be able to unit test by “mocking” out collaborators, as it would be described in object oriented programming. I was always semi-distrustful of mocking, and indeed, it seems likely that it is heavily abused in certain circles, but I’ve come to appreciate the need that sometimes it is important to stub things out, &lt;em&gt;even in pure code&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;As an example, consider some code that needs access to the current time. This is something that would normally require &lt;code&gt;IO&lt;/code&gt;, but we likely want to be able to use the value in a pure context without “infecting” the entire program with &lt;code&gt;IO&lt;/code&gt; types. In Haskell, I have generally seen three ways of handling this sort of thing:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Just inject the required values into the function and produce them “higher up” where I/O is okay. If threading the value around becomes too burdensome, use a Reader monad.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Use a free monad or similar to create a pure DSL of sorts, then write interpreters for various implementations, one of which uses &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Create custom monadic typeclasses that provide interfaces to the functionality you want to perform, then create instances, one of which is an instance over &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;This last approach seems to be less common in Haskell, but it’s the approach we took, and it seems to work out remarkably well. Returning to the need to get the current time, we could pretty easily write such a typeclass to encode that need:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;getCurrentTime&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;UTCTime&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can write functions that use the current time:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;validateToken&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Token&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="nf"&gt;validateToken&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;currentTime&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getCurrentTime&lt;/span&gt;
  &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tokenExpirationDate&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentTime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, we can write instances for &lt;code&gt;CurrentTime&lt;/code&gt; that will allow us to run the same code in different contexts:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;AppM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;AppM&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;runAppM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;MonadIO&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Identity&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Functor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Applicative&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;runTestM&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;runTestM&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;runIdentity&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="kt"&gt;AppM&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;getCurrentTime&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;liftIO&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Clock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getCurrentTime&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="kt"&gt;TestM&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;getCurrentTime&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;posixSecondsToUTCTime&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where this really starts to shine is when adding additional effects. For example, the above token validation function might also need information about some kind of secret used for signing. Under this model, it’s just another typeclass:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TokenSecret&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;getTokenSecret&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Secret&lt;/span&gt;

&lt;span class="nf"&gt;validateToken&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;TokenSecret&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Token&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="nf"&gt;validateToken&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;currentTime&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getCurrentTime&lt;/span&gt;
  &lt;span class="n"&gt;secret&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getTokenSecret&lt;/span&gt;
  &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tokenExpirationDate&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;currentTime&lt;/span&gt;
       &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;verifySignature&lt;/span&gt; &lt;span class="n"&gt;tok&lt;/span&gt; &lt;span class="n"&gt;secret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course, so far all of these functions have been extremely simple, and we’ve basically been using them as a glorified reader monad. In practice, though, we use this pattern for lots more than just retrieving values. For example, we might have a typeclass for database interactions:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Monad&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Persistence&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;fetchUser&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;insertUser&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;PersistenceError&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Id&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With all of this done, it becomes incredibly easy to see which functions are using which effects:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;postUsers&lt;/span&gt;
  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Persistence&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;TokenSecret&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Response&lt;/span&gt;
&lt;span class="nf"&gt;postUsers&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="nf"&gt;getHealthcheck&lt;/span&gt;
  &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;CurrentTime&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
  &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="kt"&gt;Response&lt;/span&gt;
&lt;span class="nf"&gt;getHealthcheck&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There’s no need to perform any lifting, and this all seems to scale quite nicely. We’ve written some additional utilities to help write tests against functions using these kinds of monadic interfaces, and even though there’s a little bit of annoying boilerplate in a few spots, overall it seems to work quite elegantly.&lt;/p&gt;&lt;p&gt;I’m not entirely sure how common this is in the Haskell community, but it’s certainly pretty neat how easy it is to get nearly all of the benefits of effect types in other languages simply by composing some of Haskell’s simplest features.&lt;/p&gt;&lt;h3&gt;&lt;a name="atom-s-ide-haskell-tooling-is-invaluable"&gt;&lt;/a&gt;Atom’s ide-haskell tooling is invaluable&lt;/h3&gt;&lt;p&gt;Alright, so, confession time: I don’t use Emacs.&lt;/p&gt;&lt;p&gt;I know, I know, how is that possible? I write Lisp, after all. Well, honestly, I tried picking it up a number of times, but none of those times did I get far enough to ditch my other tools. For Racket work, I use DrRacket, but for almost everything else, I use Atom.&lt;/p&gt;&lt;p&gt;Atom has a lot of flaws, but it’s also pretty amazing in places, and I absolutely &lt;em&gt;love&lt;/em&gt; the Haskell tooling written by the wonderful &lt;a href="https://github.com/atom-haskell"&gt;atom-haskell&lt;/a&gt; folks. I use it constantly, and even though it doesn’t always work perfectly, it works pretty well. When it has problems, I’ve at least figured out how to get it working correctly.&lt;/p&gt;&lt;p&gt;This is probably hard to really explain without seeing it for yourself, but I’ve found that I basically &lt;em&gt;depend&lt;/em&gt; on this sort of tooling to be fully productive in Haskell, and I have no problem admitting that. The ability to get instant feedback about type errors tied to visual source locations, to be able to directly manipulate the source by selecting expressions and getting type information, and even the option to get inline linter suggestions means I spend a lot less time glancing at the terminal, and even less time in the REPL.&lt;/p&gt;&lt;p&gt;The tooling is far from perfect, and it leaves a lot to be desired in places (the idea of using that static information for automated, project-wide refactoring &lt;em&gt;a la&lt;/em&gt; Java is tantalizing), but most of those things are ideas of what amazing things could be, not broken or missing essentials. I am pretty satisfied with ide-haskell right now, and I can only hope it continues to get better and better.&lt;/p&gt;&lt;h2&gt;&lt;a name="frustrations-drawbacks-and-pain-points"&gt;&lt;/a&gt;Frustrations, drawbacks, and pain points&lt;/h2&gt;&lt;p&gt;Haskell is not perfect. In fact, far from it. There is a vast array of little annoyances that I have with the language, as is the case with any language. Still, there are a few overarching problems that I would really like to at least mention. These are the biggest sources of frustration for me so far.&lt;/p&gt;&lt;h3&gt;&lt;a name="purity-failure-and-exception-handling"&gt;&lt;/a&gt;Purity, failure, and exception-handling&lt;/h3&gt;&lt;p&gt;One of Haskell’s defining features is its purity—I don’t think many would disagree with that. Some people consider it a drawback, others consider it one of its greatest boons. Personally, I like it a lot, and I think one of the best parts about it is how it requires the programmer to be incredibly deliberate about failure.&lt;/p&gt;&lt;p&gt;In many languages, when looking up a value from a container where the key doesn’t exist, there are really two ways to go about expressing this failure:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Throw an exception.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The former is scary because it means &lt;em&gt;any&lt;/em&gt; call to any function can make the entire program blow up, and it’s often impossible to know which functions even have the potential to throw. This creates a certain kind of non-local control flow that can sometimes cause a lot of unpredictability. The second option is much the same, especially when any value in a program might be &lt;code&gt;null&lt;/code&gt;; it just defers the failure.&lt;/p&gt;&lt;p&gt;In languages with option types, this is somewhat mitigated. Java now has option types, too, but they are still frequently cumbersome to use because there is nothing like monads to use to simply chain operations together. Haskell, in comparison, has an incredible complement of tools to simply handle errors without a whole lot of burden on the programmer, and I have found that, in practice, this is &lt;em&gt;actually helpful&lt;/em&gt; and I really do write better error-handling code.&lt;/p&gt;&lt;h4&gt;&lt;a name="first-the-good-parts"&gt;&lt;/a&gt;First, the good parts&lt;/h4&gt;&lt;p&gt;I have seen a comparison drawn between throwing checked exceptions and returning &lt;code&gt;Maybe&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt; types, but in practice the difference is massive. Handling checked exceptions is a monotonous chore because they are not first-class values, they are actually entirely separate linguistic constructs. Consider a library that throws a &lt;code&gt;LibraryException&lt;/code&gt;, and you want to wrap that library and convert those exceptions to &lt;code&gt;ApplicationException&lt;/code&gt;s. Well, have fun writing this code dozens of times:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LibraryException&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;ApplicationException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fromLibraryException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// ...&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;doSomethingElse&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LibraryException&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;ApplicationException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fromLibraryException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In Haskell, failure is just represented by first-class values, and it’s totally possible to write helper functions to abstract over that kind of boilerplate:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;libraryToApplication&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;LibraryError&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;ApplicationError&lt;/span&gt;
&lt;span class="nf"&gt;libraryToApplication&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="nf"&gt;liftLibrary&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;LibraryError&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="kt"&gt;ApplicationError&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;liftLibrary&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mapLeft&lt;/span&gt; &lt;span class="n"&gt;libraryToApplication&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, that same boilerplate-y code becomes nearly invisible:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftLibrary&lt;/span&gt; &lt;span class="n"&gt;doSomething&lt;/span&gt;

&lt;span class="c1"&gt;-- ...&lt;/span&gt;

&lt;span class="nf"&gt;y&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;liftLibrary&lt;/span&gt; &lt;span class="n"&gt;doSomethingElse&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This might not &lt;em&gt;seem&lt;/em&gt; like much, but it really cuts down on the amount of visual noise, which ends up making all the difference. Boilerplate incurs a cost much bigger than simply taking the time to type it all out (though that’s important, too): the cognitive overhead of parsing which parts of a program are boilerplate has a significant impact on readability.&lt;/p&gt;&lt;h4&gt;&lt;a name="so-what-s-the-problem"&gt;&lt;/a&gt;So what’s the problem?&lt;/h4&gt;&lt;p&gt;If error handling is so great in Haskell, then why am I putting it under the complaints section? Well, it turns out that not everyone seems to think it’s as great as I make it out to be because people seem to keep writing Haskell APIs that throw exceptions!&lt;/p&gt;&lt;p&gt;Despite what some purists would have you believe, Haskell has exceptions, and they are not uncommon. Lots of things can throw exceptions, some of which are probably reasonable. Failing to connect to a database is a pretty catastrophic error, so it seems fair that it would throw. On the other hand, inserting a duplicate record is pretty normal operation, so it seems like that should &lt;em&gt;not&lt;/em&gt; throw.&lt;/p&gt;&lt;p&gt;I mostly treat exceptions in Haskell as unrecoverable catastrophes. If I throw an error in &lt;em&gt;my&lt;/em&gt; code, I do not intend to catch it. That means something horrible happened, and I just want that horribleness to show up in a log somewhere so I can fix the problem. If I care about failure, there are better ways to handle that failure gracefully.&lt;/p&gt;&lt;p&gt;It’s also probably worth noting that exceptions in Haskell can be thrown from anywhere, even pure code, but can only be &lt;em&gt;caught&lt;/em&gt; within the &lt;code&gt;IO&lt;/code&gt; monad. This is especially scary, but I’ve seen it happen in actual libraries out in the wild, even ones that the entire Haskell ecosystem is built on. One of the crowning examples of this is the &lt;code&gt;text&lt;/code&gt; package, which provides a function called &lt;code&gt;decodeUtf8&lt;/code&gt; to convert bytestrings into text. Its type is very simple:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nf"&gt;decodeUtf8&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;ByteString&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But wait, what if the bytestring is not actually a valid UTF-8 string?&lt;/p&gt;&lt;p&gt;Boom. There goes the application.&lt;/p&gt;&lt;p&gt;Okay, okay, well, at least the &lt;code&gt;text&lt;/code&gt; package provides another function, this one called &lt;code&gt;decodeUtf8'&lt;/code&gt;, which returns an &lt;code&gt;Either&lt;/code&gt;. This is good, and I’ve trained myself to only ever use &lt;code&gt;decodeUtf8'&lt;/code&gt;, but it still has some pretty significant problems:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The &lt;em&gt;safe&lt;/em&gt; version of this function is the “prime” version, rather than the other way around, which encourages people to use the unsafe one. Ideally, the unsafe one should be explicitly labeled as such... maybe call it &lt;code&gt;unsafeDecodeUtf8&lt;/code&gt;?&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;This is not a hypothetical problem. When using a Haskell JWT library, we found a function that converts a string into a JWT. Since not all strings are JWTs, the library intelligently returns a &lt;code&gt;Maybe&lt;/code&gt;. Therefore, we figured we were safe.&lt;/p&gt;&lt;p&gt;A couple weeks later, we found that providing this function with invalid data was returning HTTP 500 errors. Why? Our error handling was meticulous! Well, the answer was a &lt;code&gt;decodeUtf8&lt;/code&gt; call, hidden inside of the JWT library. This is especially egregious, given that the API it exposed returned a &lt;code&gt;Maybe&lt;/code&gt; anyway! It would have been trivial to use the safe version there, instead, but the poor, misleading name led the library developer to overlook the bug lurking in the otherwise innocuous function.&lt;/p&gt;&lt;p&gt;Even worse, this function was totally pure, and we used it in pure code, so we could not simply wrap the function and catch the exception. We had two options: use &lt;code&gt;unsafePerformIO&lt;/code&gt; (yuck!) or perform a check before handing the data to the buggy function. We chose the latter, but in some cases, I imagine that could be too difficult to do in order to make it feasible.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The point I’m trying to make is that this is a real problem, and it seems to me that throwing exceptions invalidates one of the primary advantages of Haskell. It disappointed me to realize that a significant amount of code written by FP Complete, one of the primary authors of some of the most important “modern Haskell” code in existence (including Stack), seem to very frequently expose APIs that will throw.&lt;/p&gt;&lt;p&gt;I’m not sure how much of this stems from a fundamental divide in the Haskell ecosystem and how much it is simply due to Michael Snoyman’s coding style, given that he is the primary author of a number of these tools and libraries that seem very eager to throw exceptions. As just one example of a real situation in which we were surprised by this behavior, we used Snoyman’s http-client library and found that it mysteriously throws upon nearly &lt;em&gt;any&lt;/em&gt; failure state:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;A note on exceptions: for the most part, all actions that perform I/O should be assumed to throw an &lt;code&gt;HttpException&lt;/code&gt; in the event of some problem, and all pure functions will be total. For example, &lt;code&gt;withResponse&lt;/code&gt;, &lt;code&gt;httpLbs&lt;/code&gt;, and &lt;code&gt;BodyReader&lt;/code&gt; can all throw exceptions.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;This doesn’t seem entirely unreasonable—after all, isn’t a failure to negotiate TLS fairly catastrophic?—until you consider our use case. We needed to make a subrequest during the extent of another HTTP request to our server, and if that subrequest fails, we absolutely need to handle that failure gracefully. Of course, this is not &lt;em&gt;terrible&lt;/em&gt; given that we are in &lt;code&gt;IO&lt;/code&gt; so we can actually catch these exceptions, but since this behavior was only noted in a single aside at the top of the documentation, we didn’t realize we were forgetting error handling until far too late and requests were silently failing.&lt;/p&gt;&lt;p&gt;Exceptions seem to devalue one of the most powerful concepts in Haskell: if I don’t consider all the possibilities, my code &lt;em&gt;does not compile&lt;/em&gt;. In practice, when working with APIs that properly encode these possibilities into the type system, this value proposition seems to be real. I really do find myself writing code that works correctly as soon as it compiles. It’s almost magical.&lt;/p&gt;&lt;p&gt;Using exceptions throws that all out the window, and I wish the Haskell ecosystem was generally more cautious about when to use them.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-string-problem"&gt;&lt;/a&gt;The String problem&lt;/h3&gt;&lt;p&gt;I sort of alluded to this a tiny bit in the last section, and that is probably indicative of how bad this issue is. I’m just going to be blunt: &lt;strong&gt;In Haskell, strings suck.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;This is always a bit of an amusing point whenever it is discussed because of how silly it seems. Haskell is a research language with a cutting-edge type system and some of the fanciest features of any language in existence. When everyday programming might use things like “profunctors”, “injective type families”, and “generalized algebraic datatypes”, you would think that dealing with &lt;em&gt;strings&lt;/em&gt; would be a well-solved problem.&lt;/p&gt;&lt;p&gt;But it isn’t. Haskell libraries frequently use not one, not two, but &lt;em&gt;&lt;strong&gt;five&lt;/strong&gt;&lt;/em&gt; kinds of strings. Let’s list them off, shall we?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;First off, there’s the built-in &lt;code&gt;String&lt;/code&gt; type, which is actually an alias for the &lt;code&gt;[Char]&lt;/code&gt; type. For those not intimately familiar with Haskell, that’s a &lt;em&gt;linked list of characters&lt;/em&gt;. As &lt;a href="http://www.stephendiehl.com/"&gt;Stephen Diehl&lt;/a&gt; recently put it in &lt;a href="http://www.stephendiehl.com/posts/strings.html"&gt;a blog post describing the disaster that is Haskell string types&lt;/a&gt;:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;This is not only a bad representation, it’s quite possibly the least efficient (non-contrived) representation of text data possible and has horrible performance in both time and space. &lt;em&gt;And it’s used everywhere in Haskell.&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The point is, it’s really bad. This type is not a useful representation for textual data in practical applications.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Moving on, we have a fairly decent type, &lt;code&gt;Text&lt;/code&gt;, which comes from &lt;code&gt;Data.Text&lt;/code&gt; in the &lt;code&gt;text&lt;/code&gt; package. This is a decent representation of text, and it’s probably the one that everything should use. Well, maybe. Because &lt;code&gt;Text&lt;/code&gt; comes in two varieties: lazy and strict. Nobody seems to agree on which of those two should be used, though, and they are totally incompatible types: functions that work with one kind of text won’t work with the other. You have to manually convert between them.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, we have &lt;code&gt;ByteString&lt;/code&gt;, which is horribly misnamed because it really isn’t a string at all, at least not in the textual sense. A better name for this type would have simply been &lt;code&gt;Bytes&lt;/code&gt;, which sounds a lot scarier. And that would be good, because data typed as a &lt;code&gt;ByteString&lt;/code&gt; is as close as you can get in Haskell to not assigning a type at all: a bytestring holds arbitrary bytes without assigning them any meaning whatsoever!&lt;/p&gt;&lt;p&gt;Or at least, that’s the intention. The trouble is that people &lt;em&gt;don’t&lt;/em&gt; treat bytestrings like that—they just use them to toss pieces of text around, even when those pieces of text have a well-defined encoding and represent textual data. This leads to the &lt;code&gt;decodeUtf8&lt;/code&gt; problem mentioned above, but it’s bigger than that because it often ends up with some poor APIs that assign some interpretation to &lt;code&gt;ByteString&lt;/code&gt; data without assigning it a different type.&lt;/p&gt;&lt;p&gt;Again, this is throwing away so much of Haskell’s safety. It would be like using &lt;code&gt;Int&lt;/code&gt; to keep track of boolean data (“just use 0 and 1!”) or using empty and singleton lists instead of using &lt;code&gt;Maybe&lt;/code&gt;. When you use the precise type, you encode invariants and contracts into statically-checked assertions, but when you use general types like &lt;code&gt;ByteString&lt;/code&gt;, you give that up.&lt;/p&gt;&lt;p&gt;Oh, and did I mention that &lt;code&gt;ByteString&lt;/code&gt;s also come in incompatible lazy and strict versions, too?&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So, obviously, the answer is to just stop using the bad types and to just use (one kind of) &lt;code&gt;Text&lt;/code&gt; everywhere. Great! Except that the other types are totally inescapable. The entire standard library uses &lt;code&gt;String&lt;/code&gt; exclusively—after all, &lt;code&gt;text&lt;/code&gt; is a separate package—and small libraries often use &lt;code&gt;String&lt;/code&gt; instead of &lt;code&gt;text&lt;/code&gt; because they have no need to bring in the dependency. Of course, this just means every real application pays the performance hit of converting between all these different kinds of strings.&lt;/p&gt;&lt;p&gt;Similarly, those that &lt;em&gt;do&lt;/em&gt; use &lt;code&gt;Text&lt;/code&gt; often use different kinds of text, so code ends up littered with &lt;code&gt;fromStrict&lt;/code&gt; or &lt;code&gt;toStrict&lt;/code&gt; coercions, which (again) have a cost. I’ve already ranted enough about &lt;code&gt;ByteString&lt;/code&gt;, but basically, if you’re using &lt;code&gt;ByteString&lt;/code&gt; in your API to pass around data that is semantically text, you are causing me pain. Please stop.&lt;/p&gt;&lt;p&gt;It seems that the way &lt;code&gt;Data.Text&lt;/code&gt; probably &lt;em&gt;should&lt;/em&gt; have been designed was by making &lt;code&gt;Text&lt;/code&gt; a typeclass, then making the lazy and strict implementations instances of that typeclass. Still, the fact that both of them exist would always cause problems. I’m actually unsure which one is the “correct” choice—I don’t know enough about how the two perform in practice—but it seems likely that picking &lt;em&gt;either&lt;/em&gt; one would be a performance improvement over the current system, which is constantly spending time converting between the two.&lt;/p&gt;&lt;p&gt;This issue has been ranted about plenty, so I won’t ramble on, but if you’re designing new libraries, please, &lt;em&gt;please&lt;/em&gt; use &lt;code&gt;Text&lt;/code&gt;. Your users will thank you.&lt;/p&gt;&lt;h3&gt;&lt;a name="documentation-is-nearly-worthless"&gt;&lt;/a&gt;Documentation is nearly worthless&lt;/h3&gt;&lt;p&gt;Finally, let’s talk about documentation.&lt;/p&gt;&lt;p&gt;One of my favorite programming languages is Racket. Racket has a documentation tool called Scribble. Scribble is special because it is a totally separate domain-specific language for writing documentation, and it makes it fun and easy to write good explanations. There are even forms for typesetting automatically-rendered examples that look like a REPL. If the examples ever break or become incorrect, the docs don’t even compile.&lt;/p&gt;&lt;p&gt;All of the Racket core library documentation makes sure to set a good example about what good documentation should look like. The vast majority of the documentation is paragraphs of prose and simple but practical examples. There are also type signatures (in the form of contracts), and those are super important, but they are so effective because of how the prose explains what each function does, when to use it, &lt;em&gt;why&lt;/em&gt; you’d use it, and &lt;em&gt;why you wouldn’t use it&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Everything is cross-referenced automatically. The documentation is completely searchable locally out of the box. As soon as you install a package, its docs are automatically indexed. User-written libraries tend to have pretty good docs, too, because the standard libraries set such a good example &lt;em&gt;and&lt;/em&gt; because the tools are so fantastic. Racket docs are really nice, and they’re so good they actually make things like Stack Overflow or even Google mostly irrelevant. It’s all there in the manual.&lt;/p&gt;&lt;p&gt;Haskell documentation is the opposite of everything I just said.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The core libraries are poorly documented. Most functions include a sentence of description, and almost none include examples. At their worst, the descriptions simply restate the type signature.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Third-party libraries’ documentation is even worse, going frequently completely undocumented and actually only including type signatures and nothing else.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Haddock is an incredibly user-hostile tool for writing anything other than tiny snippets of documentation and is not very good at supporting prose. Notably, Haddock’s documentation is not generated using Haddock (and it still manages to be almost unusable). Forcing all documentation into inline comments makes users unlikely to write much explanation, and there is no ability for abstraction.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Reading documentation locally is very difficult because there is no easy way to open documentation for a particular package in a web browser, and it’s &lt;em&gt;certainly&lt;/em&gt; not searchable. This is especially ridiculous given that Hoogle exists, which is one of best ways to search API docs in existence. There should be a &lt;code&gt;stack hoogle&lt;/code&gt; command that just opens a Hoogle page for all locally-installed packages and Just Works, but there isn’t.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Most valuable information exists outside of documentation, so Google becomes a go-to immediately after a quick glance at the docs, and information is spread across blog posts, mailing lists, and obscure reddit posts.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This is a problem that cannot be fixed by just making Haddock better, nor can it be fixed simply by improving the existing standard library documentation. There is a fundamental problem with Haskell documentation (which, to be completely fair, is not unique to Haskell), which is that its tools do not support anything more than API docs.&lt;/p&gt;&lt;p&gt;Good documentation is so much more than “here’s what this function does”; it’s about guides and tutorials and case studies and common pitfalls. &lt;a href="http://docs.racket-lang.org/lens/lens-guide.html"&gt;This is documentation for someone new to lenses.&lt;/a&gt; &lt;a href="https://hackage.haskell.org/package/lens#readme"&gt;This is not.&lt;/a&gt; Take note of the difference.&lt;/p&gt;&lt;h2&gt;&lt;a name="conclusion-and-other-thoughts"&gt;&lt;/a&gt;Conclusion and other thoughts&lt;/h2&gt;&lt;p&gt;Haskell is an incredible programming platform, and indeed, it is sometimes mind-boggling how complete it is. It also has a lot of rough edges, sometimes in places that feel like they need a lot more care, or perhaps they’re even simply unfinished.&lt;/p&gt;&lt;p&gt;I could spend weeks writing about all the things I really like or dislike about the language, discussing in fine detail all the things that have made me excited or all the little bits that have made me want to tear my hair out. Heck, I could probably spend a month writing about strings alone. That’s not the point, though... I took a risk with Haskell, and it’s paid off. I’m not yet sure exactly how I feel about it, or when I would chose it relative to other tools, but it is currently very high on my list of favorite technologies.&lt;/p&gt;&lt;p&gt;I did not come to Haskell with a distaste for static typing, despite the fact that I write so much Racket, a dynamically typed language (by default, at least). I don’t really use Typed Racket, and despite my love for Haskell and its type system, I am not sure I will use much more of it than I did before. Haskell and Racket are very different languages, which is justified in some places and probably sort of circumstantial in others.&lt;/p&gt;&lt;p&gt;The future of Haskell seems bright, and a lot of the changes in the just-released GHC 8 are extremely exciting. I did not list records as a pain point because the changes in GHC 8 appear to make them a &lt;em&gt;lot&lt;/em&gt; more palatable, although whether or not they solve that problem completely remains to be seen. I will absolutely continue to write Haskell and push it to its limits where I can, and hopefully try and take as much as I can from it along the way.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Simple, safe multimethods in Racket</title><link>https://lexi-lambda.github.io/blog/2016/02/18/simple-safe-multimethods-in-racket/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2016/02/18/simple-safe-multimethods-in-racket/</guid><pubDate>18 Feb 2016</pubDate><description>&lt;article&gt;&lt;p&gt;Racket ships with &lt;code&gt;racket/generic&lt;/code&gt;, a system for defining &lt;em&gt;generic methods&lt;/em&gt;, functions that work differently depending on what sort of value they are supplied. I have made heavy use of this feature in my collections library, and it has worked well for my needs, but that system does have a bit of a limitation: it only supports &lt;em&gt;single dispatch&lt;/em&gt;. Method implementations may only be chosen based on a single argument, so multiple dispatch is impossible.&lt;/p&gt;&lt;h2&gt;&lt;a name="motivating-multiple-dispatch"&gt;&lt;/a&gt;Motivating multiple dispatch&lt;/h2&gt;&lt;p&gt;What is multiple dispatch and why is it necessary? Well, in most cases, it &lt;em&gt;isn’t&lt;/em&gt; necessary at all. &lt;a href="http://dl.acm.org/citation.cfm?doid=1449764.1449808"&gt;It has been shown that multiple dispatch is much rarer than single dispatch in practice.&lt;/a&gt; However, when actually needed, having multiple dispatch in the toolbox is a valuable asset.&lt;/p&gt;&lt;p&gt;A classic example of multiple dispatch is multiplication over both scalars and vectors. Ideally, all of the following operations should work:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2 × 3 = 6
2 × ⟨3, 4⟩ = ⟨6, 8⟩
⟨3, 4⟩ × 2 = ⟨6, 8⟩
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In practice, most languages do not support such flexible dispatch rules without fairly complicated branching constructs to handle each permutation of input types. Furthermore, since most languages only support single dispatch (such as most object-oriented languages), it is nearly impossible to add support for a new combination of types to an existing method.&lt;/p&gt;&lt;p&gt;To illustrate the above, even if a language supported operator overloading &lt;em&gt;and&lt;/em&gt; it included a &lt;code&gt;Vector&lt;/code&gt; class that overloaded multiplication to properly work with numbers and vectors, it might not implement matrix multiplication. If a user defines a &lt;code&gt;Matrix&lt;/code&gt; class, they may overload &lt;em&gt;its&lt;/em&gt; multiplication to support numbers, vectors, and matrices, but it is impossible to extend the multiplication implementation for the &lt;code&gt;Vector&lt;/code&gt; class. That method is now completely set in stone, unless it is edited directly (and the programmer may not have access to &lt;code&gt;Vector&lt;/code&gt;’s implementation).&lt;/p&gt;&lt;p&gt;Multiple dispatch solves all of these problems. Rather than specify implementations of functions for singular types, it is possible to specify implementations for sets of types. In the above example, a programmer would be able to define a new function that operates on &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Matrix&lt;/code&gt; arguments. Since each definition does not “belong” to any given type, extending this set of operations is trivial.&lt;/p&gt;&lt;h2&gt;&lt;a name="multiple-dispatch-in-racket"&gt;&lt;/a&gt;Multiple dispatch in Racket&lt;/h2&gt;&lt;p&gt;This blog post is somewhat long and technical, so before proceeding any further, I want to show some real code that actually works so you can get a feel for what I’m talking about. As a proof-of-concept, I have created &lt;a href="https://github.com/lexi-lambda/racket-multimethod"&gt;a very simple implementation of multiple dispatch in Racket&lt;/a&gt;. The above example would look like this in Racket using my module:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;multimethod&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct-out&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct-out&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-generic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;curry&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pardon the somewhat clunky syntax, but the functionality is there. Using the above code works as expected:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt; (mul (num 2) (num 3))
(num 6)
&amp;gt; (mul (num 2) (vec '(3 4)))
(vec '(6 8))
&amp;gt; (mul (vec '(3 4)) (num 2))
(vec '(6 8))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Making the above snippet work is not particularly hard. In fact, it’s likely that most competent Racketeers could do it without much thought. However, there’s a tiny bit more going on behind the scenes than it may seem.&lt;/p&gt;&lt;h2&gt;&lt;a name="the-problem-with-multiple-dispatch"&gt;&lt;/a&gt;The problem with multiple dispatch&lt;/h2&gt;&lt;p&gt;The single-dispatch design limitation of &lt;code&gt;racket/generic&lt;/code&gt; comes directly from a desire to avoid what has been described as “spooky action at a distance”, a problem that is prevalent in many systems that support methods with multiple dispatch (aka &lt;em&gt;multimethods&lt;/em&gt;). Specifically, the issue arises when new method implementations are defined for existing datatypes, which can have far-reaching effects throughout a program because the method table is global state. Both CLOS and Clojure suffer from this shortcoming.&lt;/p&gt;&lt;p&gt;Interestingly, Haskell with multi-parameter typeclasses (a nonstandard but highly useful extension) makes it quite trivial to create constructs similar to multiple dispatch (though the overload resolution is done at compile-time). The similarities are significant: Haskell &lt;em&gt;also&lt;/em&gt; suffers from the possibility of a certain sort of “spooky action”. However, Haskell’s static typing and resolution allows the compiler to catch these potential issues, known as “orphan instances”, at compile time. Even though Racket does not support the same sort of static typing, the same idea can be used to keep multiple dispatch safe using the macro system.&lt;/p&gt;&lt;h2&gt;&lt;a name="safe-dynamically-typed-multiple-dispatch"&gt;&lt;/a&gt;Safe, dynamically-typed multiple dispatch&lt;/h2&gt;&lt;p&gt;In order to make multiple dispatch safe, we first need to determine exactly what is unsafe. Haskell has rules for determining what constitutes an “orphan instance”, and these rules are equally applicable for determining dangerous multimethod implementations. Specifically, a definition can be considered unsafe if &lt;em&gt;both&lt;/em&gt; of the following conditions are true:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;The multimethod that is being implemented was declared in a different module from the implementation.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;All&lt;/em&gt; of the types used for dispatch in the multimethod instance were declared in a different module from the implementation.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Conversely, a multimethod implementation is safe if &lt;em&gt;either&lt;/em&gt; of the following conditions are true:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;The multimethod that is being implemented is declared in the same module as the implementation.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;Any&lt;/em&gt; of the types used for dispatch in the multimethod instance are declared in the same module as the implementation.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Why do these two rules provide a strong enough guarantee to eliminate the dangers created by global state? Well, to understand that, we need to understand what can go wrong if these rules are ignored.&lt;/p&gt;&lt;h3&gt;&lt;a name="multimethods-and-dangerous-instances"&gt;&lt;/a&gt;Multimethods and dangerous instances&lt;/h3&gt;&lt;p&gt;What exactly is this dangerous-sounding “spooky action”, and what causes it? Well, the trouble stems from the side-effectful nature of multimethod instance definitions. Consider the Racket module from earlier, which defines multiplication instances for scalars and vectors:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct-out&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct-out&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-generic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;curry&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that there is not actually a &lt;code&gt;(mul vec vec)&lt;/code&gt; implementation. This is intentional: there are &lt;em&gt;two&lt;/em&gt; ways to take the product of two vectors, so no default implementation is provided. However, it is possible that another module might desire an instance for &lt;code&gt;mul&lt;/code&gt; that takes the dot product, and the programmer might write the following definition:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;foldl&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, there is something fishy about the above definition: it doesn’t need to be exported with &lt;code&gt;provide&lt;/code&gt; to work! Since instances don’t create new bindings, they only add dispatch options, they don’t ever need to &lt;code&gt;provide&lt;/code&gt; anything. This is problematic, though: it means that a program could continue to happily compile &lt;em&gt;even if&lt;/em&gt; the module containing the dot product instance was never loaded with &lt;code&gt;require&lt;/code&gt;, but an attempt to multiply two vectors would fail at runtime, claiming that there was no &lt;code&gt;(mul vec vec)&lt;/code&gt; implementation. This drastic change of behavior violates Racket programmers’ assumptions about the guarantees made by modules (&lt;code&gt;require&lt;/code&gt; should not cause any side-effects if the module’s bindings are not used).&lt;/p&gt;&lt;p&gt;Of course, while this seems potentially unexpected, it is workable: just be careful to &lt;code&gt;require&lt;/code&gt; modules containing instances. Unfortunately, it gets much worse—what if a different library defines &lt;em&gt;its own&lt;/em&gt; &lt;code&gt;(mul vec vec)&lt;/code&gt; instance? What if that instance takes the cross product instead? That library may function entirely properly on its own, but when loaded alongside the program that defines a dot product instance, it is impossible to determine which instance should be used where. Because &lt;code&gt;define-instance&lt;/code&gt; operates by modifying the aforementioned global state, the implementations clash, and the two systems &lt;em&gt;cannot&lt;/em&gt; continue to operate together as written.&lt;/p&gt;&lt;p&gt;This is pretty bad. Defining extra instances is a reasonable use-case for multiple dispatch, but if these instances can break &lt;em&gt;third-party code&lt;/em&gt;, how can they be trusted? This sort of problem can make multiple dispatch difficult to reason about and even more difficult to trust.&lt;/p&gt;&lt;h3&gt;&lt;a name="what-determines-safety"&gt;&lt;/a&gt;What determines safety?&lt;/h3&gt;&lt;p&gt;With those problems in mind, we can turn back to the two rules for &lt;em&gt;safe&lt;/em&gt; multiple dispatch. How do they prevent the above issues? Well, let’s take them one at a time.&lt;/p&gt;&lt;p&gt;Remember that an instance can be unequivocally determined to be safe if either of the two conditions are true, so we can consider them entirely independently. The first one is simple—an instance is safe if the following condition holds:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The multimethod that is being implemented is declared in the same module as the implementation.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;This one is pretty obvious. It is impossible to create a “bad” instance of a method declared in the same module because it is impossible to import the method without also bringing in the instance. Furthermore, a conflicting instance cannot be defined at the place where the types themselves are defined because that would require a circular module dependency, which Racket does not permit.&lt;/p&gt;&lt;p&gt;With the above explanation in mind, the second condition should make sense, too:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;Any&lt;/em&gt; of the types used for dispatch in the multimethod instance are declared in the same module as the implementation.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The same argument for the first point holds for the second, but with the parties swapped. Again, it is impossible to use the instance without somehow requiring the module that defines the datatype itself, so the instance would always be required, anyway. The most interesting aspect of this condition is that it demonstrates that instances can be defined for existing datatypes (that are defined in other modules) just so long as &lt;em&gt;at least one&lt;/em&gt; of the datatypes is defined in the same module. This continues to permit the important use-case of extending the interfaces of existing types.&lt;/p&gt;&lt;h3&gt;&lt;a name="encoding-the-safety-rules-into-racket-s-macro-system"&gt;&lt;/a&gt;Encoding the safety rules into Racket’s macro system&lt;/h3&gt;&lt;p&gt;In order to keep track of which methods and instances are defined where, I leveraged a technique based on the one &lt;a href="http://www.ccs.neu.edu/racket/pubs/scheme2007-ctf.pdf"&gt;used by Typed Racket to keep track of whether or not a typed identifier is used in a typed or untyped context&lt;/a&gt;. However, instead of using a simple mutable boolean flag, I used a mutable &lt;a href="http://docs.racket-lang.org/syntax/syntax-helpers.html#%28tech._identifier._set%29"&gt;free identifier set&lt;/a&gt;, which keeps track of the identifiers within a given module that should be considered “privileged”.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket/base&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;syntax/id-set&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;mark-id-as-privileged!&lt;/span&gt;
         &lt;span class="n"&gt;id-privileged?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;privileged-ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutable-free-id-set&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mark-id-as-privileged!&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;free-id-set-add!&lt;/span&gt; &lt;span class="n"&gt;privileged-ids&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;free-id-set-member?&lt;/span&gt; &lt;span class="n"&gt;privileged-ids&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Making this work with &lt;code&gt;define-generic&lt;/code&gt; is obvious: just invoke &lt;code&gt;mark-id-as-privileged!&lt;/code&gt; on the method name to note that the method is “privileged” in the scope of the current module. Keeping track of privileged structs is similarly straightforward, though it is a little more devious: the &lt;code&gt;multimethod&lt;/code&gt; module provides a custom &lt;code&gt;struct&lt;/code&gt; macro that just expands to &lt;code&gt;struct&lt;/code&gt; from &lt;code&gt;racket/base&lt;/code&gt;, but adds privilege information.&lt;/p&gt;&lt;p&gt;The &lt;code&gt;define-instance&lt;/code&gt; macro does all the heavy lifting to ensure that only privileged identifiers can be used in instance definitions. A simple check for the identifier annotations is performed before proceeding with macro expansion:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ormap&lt;/span&gt; &lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When the privilege checks fail, an error is raised:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;define-instance&lt;/span&gt;
                        &lt;span class="s2"&gt;"expected name of struct defined in current module"&lt;/span&gt;
                        &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With the above safeguards in place, the dangerous dot product implementation from above &lt;strong&gt;would not be allowed&lt;/strong&gt;. The checks manage to encode both of the safety rules into the macro system such that invalid instances will fail &lt;em&gt;at compile time&lt;/em&gt;, preventing dangerous uses of multimethods from ever slipping by unnoticed.&lt;/p&gt;&lt;h3&gt;&lt;a name="actually-implementing-multiple-dispatch"&gt;&lt;/a&gt;Actually implementing multiple dispatch&lt;/h3&gt;&lt;p&gt;The rest of the multimethod implementation is relatively straightforward and is not even particularly robust. If anything, it is the bare minimum of what would be needed to allow the safety mechanisms above to work. Lots of features that would likely be needed in a real implementation are not included, and graceful error handling is largely ignored.&lt;/p&gt;&lt;p&gt;Multimethods themselves are implemented as Racket &lt;a href="http://docs.racket-lang.org/guide/proc-macros.html#%28tech._transformer._binding%29"&gt;transformer bindings&lt;/a&gt; containing custom data, including a reference to the multimethod’s arity and dispatch table. The custom datatype includes a &lt;code&gt;prop:procedure&lt;/code&gt; structure type property, which allows such bindings to also function as macros. The macro procedure expands to an operation that looks up the proper instance to use in the multimethod’s dispatch table and invokes it with the supplied arguments.&lt;/p&gt;&lt;p&gt;The relevant code for defining multimethods is reproduced below:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;multimethod&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arity&lt;/span&gt; &lt;span class="n"&gt;dispatch-table&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:property&lt;/span&gt; &lt;span class="nb"&gt;prop:procedure&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
        &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apply-multimethod&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;
         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apply-multimethod&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;))]))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-generic&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method:id&lt;/span&gt; &lt;span class="n"&gt;arg:id&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;with-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;arity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;length&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generate-temporary&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mark-id-as-privileged!&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-hash&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;multimethod&lt;/span&gt; &lt;span class="n"&gt;arity&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;dispatch-table&lt;/span&gt;&lt;span class="p"&gt;))))]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The dispatch tables are implemented entirely in terms of Racket’s structure types, so while they can be defined on arbitrary structure types (including ones defined in the Racket standard library), they &lt;em&gt;cannot&lt;/em&gt; be defined on primitives such as pairs or vectors. Implementations are registered in the dispatch table using the compile-time information associated with structs’ transformer bindings, and the same information is retrieved from struct instances at runtime to look up the proper implementation to call. Notably, this only works if the struct is &lt;code&gt;#:transparent&lt;/code&gt;, or more generally and accurately, if the calling code has access to the struct’s inspector. All structs defined by the &lt;code&gt;struct&lt;/code&gt; form from the &lt;code&gt;multimethod&lt;/code&gt; module are automatically marked as &lt;code&gt;#:transparent&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;The following code implements defining multimethod instances:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raise-syntax-error&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;define-instance&lt;/span&gt;
                          &lt;span class="s2"&gt;"expected name of struct defined in current module"&lt;/span&gt;
                          &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-instance&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="c1"&gt;; standard (define (proc ...) ...) shorthand&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;type:id&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body:expr&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="c1"&gt;; full (define proc lambda-expr) notation&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;type:id&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;proc:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;multimethod&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-local-value&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;ormap&lt;/span&gt; &lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;with-syntax&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;multimethod-dispatch-table&lt;/span&gt; &lt;span class="n"&gt;multimethod&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                     &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;struct-type-id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;compose1&lt;/span&gt; &lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="n"&gt;extract-struct-info&lt;/span&gt; &lt;span class="nb"&gt;syntax-local-value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
         &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;struct-types&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="n"&gt;struct-type-id&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-set!&lt;/span&gt; &lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="n"&gt;struct-types&lt;/span&gt; &lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="p"&gt;))))]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The resulting implementation is a useful, if certainly incomplete implementation of multimethods in Racket that does not sacrifice the safety provided by &lt;code&gt;racket/generic&lt;/code&gt;’s single-dispatch approach.&lt;/p&gt;&lt;h2&gt;&lt;a name="related-work-advantages-and-disadvantages-and-areas-for-future-improvement"&gt;&lt;/a&gt;Related work, advantages and disadvantages, and areas for future improvement&lt;/h2&gt;&lt;p&gt;As previously mentioned, this implementation of multiple dispatch was inspired by the types of APIs offered by CLOS and Clojure while also maintaining the safety of &lt;code&gt;racket/generic&lt;/code&gt;. The inspiration for the safety rules came from GHC’s detection of orphan instances. Although most of the ideas presented above exist in other places, I am unsure if the concept of safety checking has been used before in any dynamically-typed programming languages.&lt;/p&gt;&lt;p&gt;The primary advantage offered over Racket’s existing generics system is obvious: multiple dispatch. Furthermore, this system can supersede many uses of &lt;code&gt;racket/generic&lt;/code&gt; simply by dispatching on a single type. However, the current implementation does &lt;em&gt;not&lt;/em&gt; support all of the features of &lt;code&gt;racket/generic&lt;/code&gt;, such as supporting non-structure types and allowing fallback implementations. While those are well within the realm of possibility, other things like attaching structure type properties are probably not possible with this approach, so it is unlikely that the existing system could be subsumed by one like this one.&lt;/p&gt;&lt;p&gt;Additionally, this implementation would almost certainly need numerous improvements before being useful to most programmers:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Good error reporting for failure cases.&lt;/strong&gt; Right now, even something obvious like calling a method on values that do not implement it simply fails with an error produced by &lt;code&gt;hash-ref&lt;/code&gt;. In a more interesting sense, using the arity to generate compile-time error messages for &lt;code&gt;define-instance&lt;/code&gt; would be a nice improvement.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Support for Racket primitive data types.&lt;/strong&gt; This might require some cooperation from Racket itself to permit an elegant implementation, but they could also just be special-cased. So long as lookup for primitives was done &lt;em&gt;after&lt;/em&gt; consulting the main dispatch table, there wouldn’t be any performance hit for non-primitive types.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Option to supply fallback implementations.&lt;/strong&gt; This wouldn’t be too hard at all, though it’s questionable whether or not it would be useful without method groupings like &lt;code&gt;define/generic&lt;/code&gt; provides. There would likely also need to be some sort of way to check if a set of values implements a particular method.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Better cooperation with structure inspectors to alleviate the need for all structures to be transparent.&lt;/strong&gt; It’s currently unclear to me how exactly this works and how it &lt;em&gt;should&lt;/em&gt; work. There might be a better way to do this without mucking with inspectors.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Much more flexible argument lists, including the ability to specify arguments that are not used for dispatch.&lt;/strong&gt; This is really a pretty fundamental requirement, but the parsing required was significant enough for me to put it off for this initial prototype.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Scribble forms to document generic methods and their instances.&lt;/strong&gt; This is something &lt;code&gt;racket/generic&lt;/code&gt; &lt;em&gt;doesn’t&lt;/em&gt; have, and it has suffered for it. It would be very nice to have easy documentation forms for multimethods.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Proper consideration of struct subtyping.&lt;/strong&gt; Racket structs support subtyping, which I have not given much thought for this prototype. It is possible that subtyping violates constraints I had assumed would hold, so reviewing the existing code with that context would be useful.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I’m not sure how much effort is involved in most of the above ideas, and in fact I’m not even completely sure how useful this system is to begin with. I have not found myself reaching much for multiple dispatch in my time as a Racket programmer, but that could simply be because it was previously unavailable. It will be interesting to see if that changes now that I have built this system, even if it is a bit rough around the edges.&lt;/p&gt;&lt;h2&gt;&lt;a name="conclusion"&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Despite the lack of need for multiple dispatch to solve most problems, as indicated by its general lack of support in mainstream programming languages, it’s a nice tool to have in the toolbox, and it &lt;em&gt;is&lt;/em&gt; asked for in the Racket community from time to time (perhaps due to its familiarity in other parts of the Lisp world). Time will tell if pointing people to something like this will create or stifle interest in multiple dispatch for Racket.&lt;/p&gt;&lt;p&gt;The source for the &lt;a href="https://github.com/lexi-lambda/racket-multimethod"&gt;&lt;code&gt;multimethod&lt;/code&gt; package can be found here&lt;/a&gt; if you are at all interested in playing with it yourself.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>ADTs in Typed Racket with macros</title><link>https://lexi-lambda.github.io/blog/2015/12/21/adts-in-typed-racket-with-macros/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2015/12/21/adts-in-typed-racket-with-macros/</guid><pubDate>21 Dec 2015</pubDate><description>&lt;article&gt;&lt;p&gt;Macros are one of Racket's flagship features, and its macro system really is state of the art. Of course, it can sometimes be difficult to demonstrate &lt;em&gt;why&lt;/em&gt; macros are so highly esteemed, in part because it can be hard to find self-contained examples of using macros in practice. Of course, one thing that macros are perfect for is filling a "hole" in the language by introducing a feature a language lacks, and one of those features in Typed Racket is &lt;strong&gt;ADTs&lt;/strong&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name="warning-this-is-not-a-macro-tutorial"&gt;&lt;/a&gt;Warning: this is not a macro tutorial&lt;/h2&gt;&lt;p&gt;First, a disclaimer: this post assumes at least some knowledge of Scheme/Racket macros. Ideally, you would be familiar with Racket itself. But if you aren't, fear not: if you get lost, don't worry. Hold on to the bigger picture, and you'll likely learn more than someone who knows enough to follow all the way through. If you &lt;em&gt;are&lt;/em&gt; interested in learning about macros, I must recommend Greg Hendershott's &lt;a href="http://www.greghendershott.com/fear-of-macros/"&gt;Fear of Macros&lt;/a&gt;. It is good. This is not that.&lt;/p&gt;&lt;p&gt;Now, with that out of the way, let's get started.&lt;/p&gt;&lt;h2&gt;&lt;a name="what-we-re-building"&gt;&lt;/a&gt;What we&amp;rsquo;re building&lt;/h2&gt;&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Algebraic_data_type"&gt;Algebraic data types&lt;/a&gt;, or &lt;em&gt;ADTs&lt;/em&gt;, are a staple of the ML family of functional programming languages. I won't go into detail here—I want to focus on the implementation—but they're a very descriptive way of modeling data that encourages designing functions in terms of pattern-matching, something that Racket is already good at.&lt;/p&gt;&lt;p&gt;Racket also already has a facility for creating custom data structures in the form of &lt;em&gt;structs&lt;/em&gt;, which are extremely flexible, but also a little verbose. Racket structs are more powerful than we need, but that means we can implement our ADTs in terms of Racket's struct system.&lt;/p&gt;&lt;p&gt;With that in mind, what should our syntax look like? Well, let's consider a quintessential example of ADTs: modeling a simple tree. For now, let's just consider a tree of integers. For reference, the Haskell syntax for such a data structure would look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Empty&lt;/span&gt;
          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Node&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This already demonstrates a few of the core things we'll need to build:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Each ADT has a &lt;em&gt;data type&lt;/em&gt;, in this case &lt;code&gt;Tree&lt;/code&gt;. This name only exists in the world of types, it isn't a value.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Each ADT has various &lt;em&gt;data constructors&lt;/em&gt;, in this case &lt;code&gt;Leaf&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Each data constructor may accept any number of arguments, each of which have a specific type.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The types that data constructors may accept include the ADT's datatype itself—that is, definitions can be recursive.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Of course, there's one more important feature we're missing: polymorphism. Our definition of a tree is overly-specific, and really, it should be able to hold any kind of data, not just integers. In Haskell, we can do that by adding a type parameter:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Empty&lt;/span&gt;
            &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
            &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this in mind, we can add a fifth and final point to our list:&lt;/p&gt;&lt;ol start="5"&gt;&lt;li&gt;&lt;p&gt;ADTs must be able to be parametrically polymorphic.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;That covers all of our requirements for basic ADTs. Now we're ready to port this idea to Racket.&lt;/p&gt;&lt;h3&gt;&lt;a name="describing-adts-in-racket"&gt;&lt;/a&gt;Describing ADTs in Racket&lt;/h3&gt;&lt;p&gt;How should we take the Haskell syntax for an ADT definition and adapt it to Racket's parenthetical s-expressions? By taking some cues from the Haskell implementation, Typed Racket's type syntax, and Racket's naming conventions, a fairly logical syntax emerges:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;Empty&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This looks pretty good. Just like with the Haskell implementation, &lt;code&gt;Tree&lt;/code&gt; should only exist at the type level, and &lt;code&gt;Empty&lt;/code&gt;, &lt;code&gt;Leaf&lt;/code&gt;, and &lt;code&gt;Node&lt;/code&gt; should be constructor functions. Our syntax mirrors Racket function application, too—the proper way to create a leaf would be &lt;code&gt;(Leaf 7)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Now that we can create ADT values, how should we extract the values from them? Well, just like in ML-likes, we can use pattern-matching. We don't need to reinvent the wheel for this one; we should be able to just use Racket's &lt;code&gt;match&lt;/code&gt;[racket] with our datatypes. For example, a function that sums all the values in a tree might look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;               &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="n"&gt;n&lt;/span&gt;               &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Given that Racket's &lt;code&gt;struct&lt;/code&gt; form automatically produces identifiers that cooperate with &lt;code&gt;match&lt;/code&gt;, this shouldn't be hard at all. And with our syntax settled, we're ready to begin implementation.&lt;/p&gt;&lt;h2&gt;&lt;a name="implementing-adts-as-syntax"&gt;&lt;/a&gt;Implementing ADTs as syntax&lt;/h2&gt;&lt;p&gt;Now for the fun part. To implement our ADT syntax, we'll employ Racket's industrial-strength macro DSL, &lt;a href="http://docs.racket-lang.org/syntax/stxparse.html"&gt;&lt;code&gt;syntax/parse&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;syntax/parse&lt;/code&gt; library works like the traditional Scheme &lt;code&gt;syntax-case&lt;/code&gt; on steroids, and one of the most useful features is the ability to define "syntax classes" that encapsulate reusable parsing rules into declarative components.&lt;/p&gt;&lt;p&gt;Since this is not a macro tutorial, the following implementation assumes you already know how to use &lt;code&gt;syntax/parse&lt;/code&gt;. However, all of the concepts here are well within the reaches of any intermediate macrologist, so don't be intimidated by some of the more complex topics at play.&lt;/p&gt;&lt;h3&gt;&lt;a name="parsing-types-with-a-syntax-class"&gt;&lt;/a&gt;Parsing types with a syntax class&lt;/h3&gt;&lt;p&gt;To implement ADTs, we're going to want to define exactly one syntax class, a class that describes the grammar for a type. As we've seen, types can be bare identifiers, like &lt;code&gt;Tree&lt;/code&gt;, or they can be identifiers with parameters, like &lt;code&gt;(Tree a)&lt;/code&gt;. We'll want to cover both cases.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This syntax class has two rules, one that's a bare identifier, and one that's a list. The ellipsis followed by a plus (&lt;code&gt;...+&lt;/code&gt;) in the second example means "one or more", so parsing those parameters will automatically be handled for us. In the bare identifier example, we use &lt;code&gt;#:attr&lt;/code&gt; to give the &lt;code&gt;param&lt;/code&gt; attribute the default value of an empty list, so this syntax class will actually &lt;em&gt;normalize&lt;/em&gt; the input we get in addition to actually parsing it.&lt;/p&gt;&lt;h3&gt;&lt;a name="a-first-attempt-at-define-datatype"&gt;&lt;/a&gt;A first attempt at &lt;code&gt;define-datatype&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Now we can move on to actually implementing &lt;code&gt;define-datatype&lt;/code&gt;. The rules are simple: we need to generate a structure type for each one of the data constructors, and we need to generate a type definition for the parent type itself. This is pretty simple to implement using &lt;code&gt;syntax-parser&lt;/code&gt;, which actually does the parsing for our macro.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-datatype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;type-name:type&lt;/span&gt; &lt;span class="n"&gt;data-constructor:type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This definition will do all the parsing we need. It parses the entire macro "invocation", ignoring the first datum with &lt;code&gt;_&lt;/code&gt; (which will just be the identifier &lt;code&gt;define-datatype&lt;/code&gt;), then expecting a &lt;code&gt;type-name&lt;/code&gt;, which uses the &lt;code&gt;type&lt;/code&gt; syntax class we defined above. Next, we expect zero or more &lt;code&gt;data-constructor&lt;/code&gt;s, which also use the &lt;code&gt;type&lt;/code&gt; syntax class. That's all we have to do for parsing. We now have all the information we need to actually output the expansion for the macro.&lt;/p&gt;&lt;p&gt;Of course, it won't be that easy: this is the difficult part. The first step is to generate a Racket struct for each data constructor. We can do this pretty easily with some simple use of Racket's syntax templating facility. A naïve attempt would look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-datatype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;type-name:type&lt;/span&gt; &lt;span class="n"&gt;data-constructor:type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is actually really close to being correct. This will generate a struct definition for each &lt;code&gt;data-constructor&lt;/code&gt;, where each struct has the name of the data constructor and the same number of fields as arguments provided. The trouble is that in Racket structs, all of the fields have &lt;em&gt;names&lt;/em&gt;, but in our ADTs, all the fields are anonymous and by-position. Currently, we're just using the same name for &lt;em&gt;all&lt;/em&gt; the fields, &lt;code&gt;f&lt;/code&gt;, so if any data constructor has two or more fields, we'll get an error.&lt;/p&gt;&lt;p&gt;Since we don't care about the field names, what we want to do is just generate random names for every field. To do this, we can use a Racket function called &lt;code&gt;generate-temporary&lt;/code&gt;, which generates random identifiers. Our next attempt might look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt;
      &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generate-temporary&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;#,&lt;/code&gt; lets us "escape" from the template to execute &lt;code&gt;(generate-temporary)&lt;/code&gt; and interpolate its result into the syntax. Unfortunately, this doesn't work. We &lt;em&gt;do&lt;/em&gt; generate a random field name, but the ellipsis will re-use the same generated value when it repeats the fields, rendering our whole effort pointless. We need to generate the field names once per type.&lt;/p&gt;&lt;h3&gt;&lt;a name="more-leveraging-syntax-classes"&gt;&lt;/a&gt;More leveraging syntax classes&lt;/h3&gt;&lt;p&gt;As it turns out, this is &lt;em&gt;also&lt;/em&gt; easy to do with syntax classes. We can add an extra attribute to our &lt;code&gt;type&lt;/code&gt; syntax class to generate a random identifier with each one. Again, we can use &lt;code&gt;#:attr&lt;/code&gt; to do that automatically. Our new definition for &lt;code&gt;type&lt;/code&gt; will look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="n"&gt;name:id&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;generate-temporaries&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we're using &lt;code&gt;generate-temporaries&lt;/code&gt; instead of &lt;code&gt;generate-temporary&lt;/code&gt;, which will conveniently generate a new identifier for each of the elements in the list we provide it. This way, we'll get a fresh identifier for each &lt;code&gt;param&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;We can now fix our macro to use this &lt;code&gt;field-id&lt;/code&gt; attribute instead of the static field name:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt;
      &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;data-constructor.field-id&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name="creating-the-supertype"&gt;&lt;/a&gt;Creating the supertype&lt;/h3&gt;&lt;p&gt;We're almost done—now we just need to implement our overall type, the one defined by &lt;code&gt;type-name&lt;/code&gt;. This is implemented as a trivial type alias, but we need to ensure that polymorphic types are properly handled. For example, a non-polymorphic type would need to be handled like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-type&lt;/span&gt; &lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, a polymorphic type alias would need to include the type parameters in each subtype, like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;How can we do this? Well, so far, we've been very declarative by using syntax patterns, templates, and classes. However, this is a more pernicious problem to solve with our declarative tools. Fortunately, it's very easy to fall back to using &lt;strong&gt;procedural macros&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;To build each properly-instantiated type, we'll use a combination of &lt;code&gt;define/with-syntax&lt;/code&gt; and Racket's list comprehensions, &lt;code&gt;for/list&lt;/code&gt;. The &lt;code&gt;define/with-syntax&lt;/code&gt; form binds values to pattern identifiers, which can be used within syntax patterns just like the ones bound by &lt;code&gt;syntax-parser&lt;/code&gt;. This will allow us to break up our result into multiple steps. Technically, &lt;code&gt;define/with-syntax&lt;/code&gt; is not strictly necessary—we could just use &lt;code&gt;#`&lt;/code&gt; and &lt;code&gt;#,&lt;/code&gt;—but it's cleaner to work with.&lt;/p&gt;&lt;p&gt;We'll start by defining a set of instantiated data constructor types, one per &lt;code&gt;data-constructor&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/with-syntax&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can fill in the body with any code we'd like, so long as each body returns a syntax object. We can use some trivial branching logic to determine which form we need:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/with-syntax&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx-null?&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now with our definition for &lt;code&gt;data-type&lt;/code&gt;, we can implement our type alias for the supertype extremely easily:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-type&lt;/span&gt; &lt;span class="n"&gt;type-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name="putting-it-all-together"&gt;&lt;/a&gt;Putting it all together&lt;/h3&gt;&lt;p&gt;There's just one more thing to do before we can call this macro finished: we need to ensure that all the type parameters defined by &lt;code&gt;type-name&lt;/code&gt; are in scope for each data constructor's structure definition. We can do this by making use of &lt;code&gt;type-name.param&lt;/code&gt; within each produced struct definition, resulting in this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;data-constructor.field-id&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And we're done! The final macro, now completed, looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-syntax-class&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="n"&gt;name:id&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="n"&gt;...+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;generate-temporaries&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;define-datatype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;type-name:type&lt;/span&gt; &lt;span class="n"&gt;data-constructor:type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/with-syntax&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;for/list&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;in-syntax&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx-null?&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
             &lt;span class="n"&gt;name&lt;/span&gt;
             &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

     &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt;
           &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;data-constructor.field-id&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-type&lt;/span&gt; &lt;span class="n"&gt;type-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It's a little bit dense, certainly, but it is not as complicated or scary as it might seem. It's a simple, mostly declarative, powerful way to transform a DSL into ordinary Typed Racket syntax, and now all we have to do is put it to use.&lt;/p&gt;&lt;h2&gt;&lt;a name="using-our-adts"&gt;&lt;/a&gt;Using our ADTs&lt;/h2&gt;&lt;p&gt;With the macro built, we can now actually use our ADTs using the syntax we described! The following is now &lt;em&gt;valid code&lt;/em&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;Empty&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;Positive-Byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can use this to define common data types, such as Haskell's &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;maybe-default&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;All&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maybe-default&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;maybe-then&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;All&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maybe-then&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And of course, we can also use it to define ADTs that use concrete types rather that type parameters, if we so desire. This implements a small mathematical language, along with a trivial interpreter:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Subtract&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Multiply&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Divide&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="n"&gt;x&lt;/span&gt;                            &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Subtract&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Multiply&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Divide&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;

&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Multiply&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Divide&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="m"&gt;1/2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There's all the power of ADTs, right in Racket, all implemented in 22 lines of code. If you'd like to see all the code together in a runnable form, &lt;a href="https://gist.github.com/lexi-lambda/18cf7a9156f743a1317e"&gt;I've put together a gist here&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name="conclusions-and-credit"&gt;&lt;/a&gt;Conclusions and credit&lt;/h2&gt;&lt;p&gt;This isn't the simplest macro to create, nor is it the most complex. The code examples might not even make much sense until you try it out yourself. Macros, like any difficult concept, are not always easy to pick up, but they certainly &lt;em&gt;are&lt;/em&gt; powerful. The ability to extend the language in such a way, in the matter of minutes, is unparalleled in languages other than Lisp.&lt;/p&gt;&lt;p&gt;This is, of course, a blessing and a curse. Lisps reject some of the syntactic landmarks that often aid in readability for the power to abstract programs into their bare components. In the end, is this uniform conciseness more or less readable? That's an incredibly subjective question, one that has prompted powerfully impassioned discussions, and I will not attempt to argue one way or the other here.&lt;/p&gt;&lt;p&gt;That said, I think it's pretty cool.&lt;/p&gt;&lt;p&gt;Finally, I must give credit where credit is due. Thanks to &lt;a href="http://andmkent.com"&gt;Andrew M. Kent&lt;/a&gt; for the creation of the &lt;a href="https://github.com/andmkent/datatype"&gt;datatype&lt;/a&gt; package, which served as the inspiration for this blog post. Many thanks to &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt; for his work creating Typed Racket, as well as helping me dramatically simplify the implementation used in this blog post. Also thanks to &lt;a href="http://www.ccs.neu.edu/home/ryanc/"&gt;Ryan Culpepper&lt;/a&gt; and &lt;a href="http://www.ccs.neu.edu/home/matthias/"&gt;Matthias Felleisen&lt;/a&gt; for their work on creating &lt;code&gt;syntax/parse&lt;/code&gt;, which is truly a marvelous tool for exploring the world of macros, and, of course, a big thanks to &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt; for his implementation of hygiene in Racket, as well as much of the rest of Racket itself. Not to mention the entire legacy of those who formulated the foundations of the Scheme macro system and created the framework for all of this to be possible so many decades later.&lt;/p&gt;&lt;p&gt;Truly, working in Racket feels like standing on the shoulders of giants. If you're intrigued, give it a shot. It's a fun feeling.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Functionally updating record types in Elm</title><link>https://lexi-lambda.github.io/blog/2015/11/06/functionally-updating-record-types-in-elm/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2015/11/06/functionally-updating-record-types-in-elm/</guid><pubDate>06 Nov 2015</pubDate><description>&lt;article&gt;&lt;p&gt;&lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt; is a wonderful language for building web apps, and I love so much of its approach to language design. Elm does so many things &lt;em&gt;right&lt;/em&gt; straight out of the box, and that's a real breath of fresh air in the intersection of functional programming and web development. Still, it gets one thing wrong, and unfortunately, that one thing is incredibly important. Elm took the "functions" out of "functional record types".&lt;/p&gt;&lt;p&gt;Almost any software program, at its core, is all about data. Maybe it's about computing data, maybe it's about manipulating data, or maybe it's about displaying data, but at the end of the day, some sort of data model is going to be needed. The functional model is a breathtakingly elegant system for handling data and shuttling it around throughout a program, and &lt;a href="https://en.wikipedia.org/wiki/Functional_reactive_programming"&gt;functional reactive programming&lt;/a&gt;, which Elm uses to model event-like interactions, makes this model work even better. The really important thing, though, is what tools Elm actually gives you to model your data.&lt;/p&gt;&lt;h2&gt;&lt;a name="a-brief-primer-on-elm-records"&gt;&lt;/a&gt;A brief primer on Elm records&lt;/h2&gt;&lt;p&gt;Elm supports all the core datatypes one would expect—numbers, strings, booleans, optionals, etc.—and it allows users to define their own types with ADTs. However, Elm also provides another datatype, which it calls "records". Records are similar to objects in JavaScript: they're effectively key-value mappings. They're cool data structures, and they work well. Here's an example of creating a &lt;code&gt;Point&lt;/code&gt; datatype in Elm:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;alias&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Float&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Float&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice that &lt;code&gt;Point&lt;/code&gt; is declared as a type &lt;em&gt;alias&lt;/em&gt;, not as a separate type like an ADT. This is because record types are truly encoded in the type system as values with named fields, not as disparate types. This allows for some fun tricks, but that's outside the scope of this blog post.&lt;/p&gt;&lt;h2&gt;&lt;a name="the-good"&gt;&lt;/a&gt;The good&lt;/h2&gt;&lt;p&gt;What I'd like to discuss is what it looks like to &lt;em&gt;manipulate&lt;/em&gt; these data structures. Constructing them is completely painless, and reading from them is super simple. This is where the record system gets everything very &lt;em&gt;right&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;origin&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;origin&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;distanceBetween&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Float&lt;/span&gt;
&lt;span class="nv"&gt;distanceBetween&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;dx&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;
      &lt;span class="nv"&gt;dy&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt;
  &lt;span class="kr"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;sqrt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;dx&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;&lt;span class="nv"&gt;dx&lt;/span&gt; &lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;dy&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;&lt;span class="nv"&gt;dy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The syntax is clean and simple. Most importantly, however, the record system is functional (in the "functional programming" sense). In a functional system, it's useful to express concepts in terms of function composition, and this is very easy to do in Elm. Creating a function to access a field would normally be clunky if you always needed to do &lt;code&gt;record.field&lt;/code&gt; to access the value. Fortunately, Elm provides some sugar:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;-- These two expressions are equivalent:&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;record&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;record&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;field&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;field&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using the &lt;code&gt;.field&lt;/code&gt; shorthand allows writing some other functions in terms of composition, as most functional programmers would desire:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;doubledX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Float&lt;/span&gt;
&lt;span class="nv"&gt;doubledX&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;(*)&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This satisfies me.&lt;/p&gt;&lt;h2&gt;&lt;a name="the-bad"&gt;&lt;/a&gt;The bad&lt;/h2&gt;&lt;p&gt;So if everything in Elm is so great, what am I complaining about? Well, while the syntax to access fields is convenient, the syntax to &lt;em&gt;functionally set&lt;/em&gt; fields is questionably clunky. Consider a function that accepts a point and returns a new point with its &lt;code&gt;x&lt;/code&gt; field set to &lt;code&gt;0&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;zeroedX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;zeroedX&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This doesn't look too bad, does it? It's clear and concise. To me, though, there's something deeply wrong here... this function has a lot of redundancy! It seems to me like we should be able to write this function more clearly in a point-free style. The &lt;code&gt;.field&lt;/code&gt; shorthand "functionalizes" the record getter syntax, so there must be a function version of the update syntax, right? Maybe it would look something like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;zeroedX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;zeroedX&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But alas, there is no such syntax.&lt;/p&gt;&lt;p&gt;Now you may ask... why does it matter? This seems trivial, and in fact, the explicit updater syntax may actually be more readable by virtue of how explicit it is. You'd be right, because so far, these examples have been horribly contrived. But let's consider a slightly more useful example: &lt;em&gt;functionally updating&lt;/em&gt; a record.&lt;/p&gt;&lt;p&gt;What's the difference? Well, say I wanted to take a point and increment its &lt;code&gt;x&lt;/code&gt; field by one. Well, I can easily write a function for that:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;incrementX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;incrementX&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Not terrible, though a &lt;em&gt;little&lt;/em&gt; verbose. Still, what if we want to also add a function that &lt;em&gt;decrements&lt;/em&gt; &lt;code&gt;x&lt;/code&gt;?&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;decrementX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;decrementX&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Oh, gosh. That's basically the exact same definition but with the operation flipped. Plus we probably want these operations for &lt;code&gt;y&lt;/code&gt;, too. Fortunately, there's an easy solution: just pass a function in to &lt;em&gt;transform&lt;/em&gt; the value! We can define an &lt;code&gt;updateX&lt;/code&gt; function that allows us to do that easily, then we can define our derived operations in terms of that:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;updateX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Float&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;updateX&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;incrementX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;incrementX&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;updateX&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;(+)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;decrementX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;decrementX&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;updateX&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Not only is that much cleaner, but we can now use it to implement all sorts of other operations that allow us to add, subtract, multiply, or divide the &lt;code&gt;x&lt;/code&gt; field. Now we just need to generalize our solution to work with the &lt;code&gt;x&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;y&lt;/code&gt; fields!&lt;/p&gt;&lt;p&gt;Oh, wait. &lt;strong&gt;We can't.&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name="the-ugly"&gt;&lt;/a&gt;The ugly&lt;/h2&gt;&lt;p&gt;This is where everything breaks down completely. Elm does not offer enough abstraction to reduce this level of crazy duplication:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;updateX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Float&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;updateX&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;incrementX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;incrementX&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;updateX&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;(+)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;decrementX&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;decrementX&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;updateX&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;updateY&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Float&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;updateY&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;point&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;incrementY&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;incrementY&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;updateY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;(+)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;decrementY&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Point&lt;/span&gt;
&lt;span class="nv"&gt;decrementY&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;updateY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We sure can give it a shot, though. At the very least, we &lt;em&gt;can&lt;/em&gt; implement the increment and decrement functions in a more general way by passing in an updater function:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;increment&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;Float&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;
&lt;span class="nv"&gt;increment&lt;/span&gt; &lt;span class="nv"&gt;update&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;update&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;(+)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, with &lt;code&gt;updateX&lt;/code&gt; and &lt;code&gt;updateY&lt;/code&gt;, we can increment either field very clearly and expressively. If we shorten the names to &lt;code&gt;uX&lt;/code&gt; and &lt;code&gt;uY&lt;/code&gt;, then the resulting code is actually very readable:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;pointAbove&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;uY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;pointBelow&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;uY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It's almost like English now: "update Y using this transformation". This is actually pretty satisfactory. The trouble arises when you have a struct with many fields:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kr"&gt;alias&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;health&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;strength&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;charisma&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;intellect&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;
  &lt;span class="c1"&gt;-- etc.&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It might be very convenient to have generic functional updaters in this case. One could imagine a game that has &lt;code&gt;Potion&lt;/code&gt; items:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Potion&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Potion&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;PlayerStats&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then some different kinds of potions:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;potions&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Potion&lt;/span&gt; &lt;span class="s"&gt;"Health Potion"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;uHealth&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;(+)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))),&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Potion&lt;/span&gt; &lt;span class="s"&gt;"Greater Intellect Potion"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;uIntellect&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;(+)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Potion&lt;/span&gt; &lt;span class="s"&gt;"Potion of Weakness"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;uStrength&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;//&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a really elegant way to think about items that can affect a player's stats! Unfortunately, it also means you have to define updater functions for &lt;em&gt;every single field in the record&lt;/em&gt;. This can get tedious rather quickly:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;uHealth&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt;
&lt;span class="nv"&gt;uHealth&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;health&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;health&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;uStrength&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt;
&lt;span class="nv"&gt;uStrength&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;strength&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;strength&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;uCharisma&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt;
&lt;span class="nv"&gt;uCharisma&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;charisma&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt;&lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;charisma&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;-- etc.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is pretty icky. Could there be a better way?&lt;/p&gt;&lt;h2&gt;&lt;a name="trying-to-create-a-more-general-abstraction"&gt;&lt;/a&gt;Trying to create a more general abstraction&lt;/h2&gt;&lt;p&gt;Interestingly, this pattern doesn't &lt;em&gt;need&lt;/em&gt; to be this bad. There are better ways to do this. Let's revisit our updater functions.&lt;/p&gt;&lt;p&gt;Really, &lt;code&gt;update&lt;/code&gt; can be defined in terms of two other primitive operations: a read and a (functional) write. What would it look like if we implemented it that way instead of requiring special updater functions to be defined? Well, it would look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;update&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;
&lt;span class="nv"&gt;update&lt;/span&gt; &lt;span class="nv"&gt;get&lt;/span&gt; &lt;span class="nv"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;set&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;get&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The type definition is a little long, but it's really pretty simple. We just supply a getter and a setter, then a function to do the transformation, and finally a record to actually transform. Of course, as you can see from the type, this function isn't actually specific to records: it can be used with any value for which a getter and setter can be provided.&lt;/p&gt;&lt;p&gt;The trouble here is that writing field setters isn't any easier in Elm than writing field updaters. They still look pretty verbose:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;sHealth&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt;
&lt;span class="nv"&gt;sHealth&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;stats&lt;/span&gt; &lt;span class="nf"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;health&lt;/span&gt; &lt;span class="nf"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;uHealth&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt;
&lt;span class="nv"&gt;uHealth&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;update&lt;/span&gt; &lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;health&lt;/span&gt; &lt;span class="nv"&gt;sHealth&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, at the end of it all, this isn't really a better abstraction. Still remember my fantasy &lt;code&gt;!field&lt;/code&gt; setter shorthand half a blog post ago? Now perhaps it makes a little more sense. &lt;em&gt;If&lt;/em&gt; such a syntax existed, then defining the updater would be incredibly simple:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nv"&gt;uHealth&lt;/span&gt; &lt;span class="nf"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt; &lt;span class="nf"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;PlayerStats&lt;/span&gt;
&lt;span class="nv"&gt;uHealth&lt;/span&gt; &lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;update&lt;/span&gt; &lt;span class="nf"&gt;.&lt;/span&gt;&lt;span class="nv"&gt;health&lt;/span&gt; &lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="nv"&gt;health&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Still, no syntax, no easy updaters, and by extension, no easy, declarative description of behavior without quite a bit of boilerplate.&lt;/p&gt;&lt;h2&gt;&lt;a name="conclusions-and-related-work"&gt;&lt;/a&gt;Conclusions and related work&lt;/h2&gt;&lt;p&gt;Elm is a very promising language, and it seems to be in fairly rapid development. So far, its author, &lt;a href="https://twitter.com/czaplic"&gt;Evan Czaplicki&lt;/a&gt;, has taken a very cautious approach to implementing language features, especially potentially redundant ones. This caution is why things like operator slicing, "where" clauses, and special updater syntax have not yet made it into the language. Maybe at some point these will be deemed important enough to include, but for the time being, they've been excluded.&lt;/p&gt;&lt;p&gt;I obviously think that having this sort of thing is incredibly important to being able to write expressive code without a huge amount of overhead. However, I also do &lt;em&gt;not&lt;/em&gt; want to give the impression that I think adding special setter syntax is the only way to do it.&lt;/p&gt;&lt;p&gt;Seasoned functional programmers will surely have noticed that many of these concepts sound a lot like lenses, and Elm actually already has a lens-like library authored by Evan himself, called &lt;a href="https://github.com/evancz/focus"&gt;Focus&lt;/a&gt;. This, however, does not actually solve the problem: it requires manual description of setters just like the purely function based approach does. Really, lenses are just the logical next step in the line of abstraction I've already laid out above.&lt;/p&gt;&lt;p&gt;Interestingly, PureScript and Elm, the two Haskell-likes-on-the-frontend that I've paid attention to (though PureScript is much closer to Haskell than Elm), both have this very same problem. Haskell itself solves it with macros via Template Haskell. My favorite language, Racket, solves it with its own macro system. Is there another way to do these things that doesn't involve introducing a heavyweight macro system? Definitely. But I think this is a &lt;em&gt;necessary feature&lt;/em&gt;, not a "nice to have", so if a macro system is out of the picture, then a simpler, less flexible solution is the obvious logical alternative.&lt;/p&gt;&lt;p&gt;I really like Elm, and most of my experiences with it have been more than enough to convince me that it is a fantastic language for the job. Unfortunately, the issue of functional record updaters has been quite the frustrating obstacle in my otherwise frictionless ride. I will continue to happily use Elm over other, far less accommodating tools, but I hope that issues like these will be smoothed out as the language and its ecosystem matures.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Canonical factories for testing with factory_girl_api</title><link>https://lexi-lambda.github.io/blog/2015/09/23/canonical-factories-for-testing-with-factory-girl-api/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2015/09/23/canonical-factories-for-testing-with-factory-girl-api/</guid><pubDate>23 Sep 2015</pubDate><description>&lt;article&gt;&lt;p&gt;Modern web applications are often built as &lt;em&gt;single-page apps&lt;/em&gt;, which are great for keeping concerns separated, but problematic when tested. Logic needs to be duplicated in front- and back-end test suites, and if the two apps diverge, the tests won't catch the failure. I haven't found a very good solution to this problem aside from brittle, end-to-end integration tests.&lt;/p&gt;&lt;p&gt;To attempt to address a fraction of this problem, I built &lt;a href="https://github.com/lexi-lambda/factory_girl_api"&gt;factory_girl_api&lt;/a&gt;, a way to share context setup between both sides of the application.&lt;/p&gt;&lt;h2&gt;&lt;a name="a-brief-overview-of-factory-girl"&gt;&lt;/a&gt;A brief overview of factory_girl&lt;/h2&gt;&lt;p&gt;In the land of Ruby and Rails, &lt;a href="https://github.com/thoughtbot/factory_girl"&gt;factory_girl&lt;/a&gt; is a convenient gem for managing factories for models. Out of the box, it integrates with Rails' default ORM, ActiveRecord, and provides declarative syntax for describing what attributes factories should initialize. For example, a factory declaration used to create a widget might look like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="no"&gt;FactoryGirl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;factory&lt;/span&gt; &lt;span class="ss"&gt;:widget&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;sequence&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Widget #&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;price&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;

    &lt;span class="n"&gt;trait&lt;/span&gt; &lt;span class="ss"&gt;:expensive&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="n"&gt;price&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This makes it easy to create new instances of &lt;code&gt;Widget&lt;/code&gt; and use them for unit tests. For example, this would create and persist a widget with a unique name and a price of 10 units:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="n"&gt;widget&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;FactoryGirl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="ss"&gt;:widget&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also create more expensive widgets by using the &lt;code&gt;:expensive&lt;/code&gt; trait.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="n"&gt;expensive_widget&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;FactoryGirl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="ss"&gt;:widget&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:expensive&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Any number of traits can be specified at once. Additionally, it is possible to override individual attributes manually.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="n"&gt;fancy_widget&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;FactoryGirl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="ss"&gt;:widget&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:expensive&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Fancy Widget&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It works well, and it keeps initialization boilerplate out of individual tests.&lt;/p&gt;&lt;h2&gt;&lt;a name="testing-on-the-front-end"&gt;&lt;/a&gt;Testing on the front-end&lt;/h2&gt;&lt;p&gt;Trouble arises when we need to write tests for the JavaScript application that use the same models. Suddenly, we need to duplicate the same kind of logic in our front-end tests. We might start out by setting up object state manually:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;fancyWidget&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
  &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Fancy Widget&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Things can quickly get out of hand when models grow complex. Even if we use a factory library in JavaScript, it's possible for our front-end factories to diverge from their back-end counterparts. This means our integration tests will fail, but our unit tests will still blindly pass. Having to duplicate all that logic in two places is dangerous. It would be nice to have a &lt;em&gt;single, canonical source&lt;/em&gt; for all of our factories.&lt;/p&gt;&lt;h3&gt;&lt;a name="reusing-server-side-factories-with-factory-girl-api"&gt;&lt;/a&gt;Reusing server-side factories with factory_girl_api&lt;/h3&gt;&lt;p&gt;To help alleviate this problem, I created the &lt;a href="https://github.com/lexi-lambda/factory_girl_api"&gt;factory_girl_api&lt;/a&gt; gem for Rails and the &lt;a href="https://github.com/lexi-lambda/angular-factory-girl-api"&gt;angular-factory-girl-api&lt;/a&gt; Bower package for Angular. These packages cooperate with each other to allow server-side factories to be used in JavaScript tests.&lt;/p&gt;&lt;p&gt;The Angular module provides a service with syntax comparable to factory_girl itself. Both traits and custom attributes are supported:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nx"&gt;FactoryGirl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;widget&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;expensive&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Fancy Widget&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, however, a round-trip API call must be made to the server in order to call the factory and return the result. Because of this, the Angular version of FactoryGirl returns a promise that is resolved with the serialized version of the model, which can then be used as sample data in unit tests.&lt;/p&gt;&lt;h3&gt;&lt;a name="the-problems-with-relying-on-the-server-for-data"&gt;&lt;/a&gt;The problems with relying on the server for data&lt;/h3&gt;&lt;p&gt;In my preliminary use of this tool, it works. In many ways, it's much nicer than duplicating logic in both places. However, I'm not &lt;em&gt;completely&lt;/em&gt; convinced it's the right solution yet.&lt;/p&gt;&lt;p&gt;First of all, it couples the front-end to the back-end, even during unit testing, which is disappointing. It means that a server needs to be running (in test mode) in order for the tests to run at all. For the kinds of projects I work on, this isn't really a bad thing, and the benefits of the reduced duplication far outweigh the downsides.&lt;/p&gt;&lt;p&gt;My real concern is that this solves a very small facet of the general problem with fragile front-end test suites. Single-page applications usually depend wholly on their integration with back-end APIs. If those APIs change, the tests will continue to happily pass as long as the API is simply mocked, which seems to be the usual solution in the front-end universe. This is, frankly, unacceptable in real application development.&lt;/p&gt;&lt;h3&gt;&lt;a name="potential-improvements-and-other-paths-to-success"&gt;&lt;/a&gt;Potential improvements and other paths to success&lt;/h3&gt;&lt;p&gt;I am ultimately unsatisfied with this approach, but writing brittle end-to-end integration tests is not the solution. This &lt;em&gt;kind&lt;/em&gt; of thing may be a step in the right direction: writing tests that aren't really pure unit tests, but also aren't fragile full-stack integration tests. This is a middle-ground that seems infrequently traveled, perhaps due to a lack of tooling (or perhaps because it just doesn't work). I don't know.&lt;/p&gt;&lt;p&gt;Either way, I'm interested in where this is headed, and I'll be curious to see if I run into any roadblocks using the workflow I've created. If anyone else is interested in playing with these two libraries, the READMEs are much more comprehensive than what I've covered here. Take a look, and give them a spin!&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lexi-lambda/factory_girl_api"&gt;factory_girl_api&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lexi-lambda/angular-factory-girl-api"&gt;angular-factory-girl-api&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Managing application configuration with Envy</title><link>https://lexi-lambda.github.io/blog/2015/08/30/managing-application-configuration-with-envy/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2015/08/30/managing-application-configuration-with-envy/</guid><pubDate>30 Aug 2015</pubDate><description>&lt;article&gt;&lt;p&gt;Application configuration can be a pain. Modern web apps don't live on dedicated boxes, they run on VPSes somewhere in the amorphous "cloud", and keeping configuration out of your application's repository can seem like more trouble than it's worth. Fortunately, &lt;a href="http://12factor.net"&gt;The Twelve-Factor App&lt;/a&gt; provides a set of standards for keeping web apps sane, and &lt;a href="http://12factor.net/config"&gt;one of those guidelines advises keeping configuration in the environment&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/lexi-lambda/envy"&gt;Envy&lt;/a&gt; is the declarative bridge between Racket code and the outside world of the environment.&lt;/p&gt;&lt;h2&gt;&lt;a name="introducing-envy"&gt;&lt;/a&gt;Introducing Envy&lt;/h2&gt;&lt;p&gt;I built Envy to distill the common tasks needed when working with environment variables into a single, declarative interface that eliminates boilerplate and makes it easy to see which environment variables an application depends on (instead of having them littered throughout the codebase). Using it is simple. Just require &lt;code&gt;envy&lt;/code&gt; and you're good to go.&lt;/p&gt;&lt;p&gt;The best way to use Envy is to create a "manifest" module that declares all the environment variables your application might use. For example, the following module is a manifest that describes an application that uses three environment variables:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="c1"&gt;; environment.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;typed/racket/base&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;envy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/provide-environment&lt;/span&gt;
  &lt;span class="n"&gt;api-token&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;log-level&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Symbol&lt;/span&gt; &lt;span class="kd"&gt;#:default&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;info&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;parallel?&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Boolean&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When this module is required, Envy will automatically do the following:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Envy will check the values of three environment variables: &lt;code&gt;API_TOKEN&lt;/code&gt;, &lt;code&gt;LOG_LEVEL&lt;/code&gt;, and &lt;code&gt;PARALLEL&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If either &lt;code&gt;API_TOKEN&lt;/code&gt; or &lt;code&gt;PARALLEL&lt;/code&gt; is not set, an error will be raised:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;envy: The required environment variable "API_TOKEN" is not defined.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The values for &lt;code&gt;LOG_LEVEL&lt;/code&gt; and &lt;code&gt;PARALLEL&lt;/code&gt; will be parsed to match their type annotations.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If &lt;code&gt;LOG_LEVEL&lt;/code&gt; is not set, it will use the default value, &lt;code&gt;'info&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The values will be stored in &lt;code&gt;api-token&lt;/code&gt;, &lt;code&gt;log-level&lt;/code&gt;, and &lt;code&gt;parallel?&lt;/code&gt;, all of which will be provided by the enclosing module.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Now just &lt;code&gt;(require (prefix-in env: "environment.rkt"))&lt;/code&gt;, and the environment variables are guaranteed to be available in your application's code.&lt;/p&gt;&lt;h2&gt;&lt;a name="working-with-typed-racket"&gt;&lt;/a&gt;Working with Typed Racket&lt;/h2&gt;&lt;p&gt;As you may have noticed by the example above, Envy is built with Typed Racket in mind. In fact, &lt;code&gt;define/provide-environment&lt;/code&gt; will &lt;em&gt;only&lt;/em&gt; work within a Typed Racket module, but that doesn't mean Envy can't be used with plain Racket—the manifest module can always be required by any kind of Racket module.&lt;/p&gt;&lt;p&gt;However, when using Typed Racket, Envy provides additional bonuses. Environment variables are inherently untyped—they're all just strings—but Envy assigns the proper type to each environment variable automatically, so no casting is necessary.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt; parallel?
- : Boolean
#t
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Envy really shines when using optional environment variables with the &lt;code&gt;#:default&lt;/code&gt; option. The type of the value given to &lt;code&gt;#:default&lt;/code&gt; doesn't need to be the same type of the environment variable itself, and if it isn't, Envy will assign the value a union type.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt; (define-environment
    [num-threads : Positive-Integer #:default #f])
&amp;gt; num-threads
- : (U Positive-Integer #f)
#f
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This added level of type-safety means it's easy to manage optional variables that don't have reasonable defaults: the type system will enforce that all code considers the possibility that such variables do not exist.&lt;/p&gt;&lt;h2&gt;&lt;a name="and-more"&gt;&lt;/a&gt;And more...&lt;/h2&gt;&lt;p&gt;To see the full set of features that Envy already provides, &lt;a href="https://lexi-lambda.github.io/envy/envy.html"&gt;take a look at the documentation&lt;/a&gt;. That said, this is just the first release based on my initial use-cases, but I'm sure there are more features Envy could have to accommodate common application configuration patterns. If you have an idea that could make Envy better, &lt;a href="https://github.com/lexi-lambda/envy/issues"&gt;open an issue and make a suggestion&lt;/a&gt;! I already have plans for a &lt;code&gt;#lang envy&lt;/code&gt; DSL, which will hopefully cut the boilerplate out in its entirety.&lt;/p&gt;&lt;p&gt;And finally, to give credit where credit is due, Envy is heavily inspired by &lt;a href="https://github.com/eval/envied"&gt;Envied&lt;/a&gt; (both in name and function), an environment variable manager for Ruby, which I've used to great effect.&lt;/p&gt;&lt;p&gt;Try it out!&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;raco pkg install envy&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lexi-lambda/envy"&gt;Envy on GitHub&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href="https://lexi-lambda.github.io/envy/envy.html"&gt;Envy documentation&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Deploying Racket applications on Heroku</title><link>https://lexi-lambda.github.io/blog/2015/08/22/deploying-racket-applications-on-heroku/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2015/08/22/deploying-racket-applications-on-heroku/</guid><pubDate>22 Aug 2015</pubDate><description>&lt;article&gt;&lt;p&gt;&lt;a href="https://www.heroku.com"&gt;Heroku&lt;/a&gt; is a "platform as a service" that provides an incredibly simple way to deploy simple internet applications, and I take liberal advantage of its free tier for testing out simple applications. It has support for a variety of languages built-in, but Racket is not currently among them. Fortunately, Heroku provides an interface for adding custom build processes for arbitrary types of applications, called “buildpacks”. I've built one for Racket apps, and with just a little bit of configuration, it’s possible to get a Racket webserver running on Heroku.&lt;/p&gt;&lt;h2&gt;&lt;a name="building-the-server"&gt;&lt;/a&gt;Building the server&lt;/h2&gt;&lt;p&gt;Racket's &lt;a href="http://docs.racket-lang.org/web-server/index.html"&gt;web-server&lt;/a&gt; package makes building and running a simple server incredibly easy. Here's all the code we'll need to get going:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;web-server/servlet&lt;/span&gt;
         &lt;span class="n"&gt;web-server/servlet-env&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response/xexpr&lt;/span&gt;
   &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;html&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;title&lt;/span&gt; &lt;span class="s2"&gt;"Racket Heroku App"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;body&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;h1&lt;/span&gt; &lt;span class="s2"&gt;"It works!"&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serve/servlet&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="kd"&gt;#:servlet-path&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Running the above file will start up the server on the default port, 8080. When running on Heroku, however, we're required to bind to the port that Heroku provides via the &lt;code&gt;PORT&lt;/code&gt; environment variable. We can access this using the Racket &lt;code&gt;getenv&lt;/code&gt;[racket] function.&lt;/p&gt;&lt;p&gt;Additionally, the Racket web server specifically binds to localhost, but Heroku doesn't allow that restriction, so we need to pass &lt;code&gt;#f&lt;/code&gt; for the &lt;code&gt;#:listen-ip&lt;/code&gt; argument.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;getenv&lt;/span&gt; &lt;span class="s2"&gt;"PORT"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;string-&amp;gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;getenv&lt;/span&gt; &lt;span class="s2"&gt;"PORT"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serve/servlet&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
               &lt;span class="kd"&gt;#:servlet-path&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;
               &lt;span class="kd"&gt;#:listen-ip&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
               &lt;span class="kd"&gt;#:port&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, by default, &lt;code&gt;serve/servlet&lt;/code&gt;[racket] will open a web browser automatically when the program is run, which is very useful for rapid prototyping within something like DrRacket, but we'll want to turn that off.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serve/servlet&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
               &lt;span class="kd"&gt;#:servlet-path&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;
               &lt;span class="kd"&gt;#:listen-ip&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
               &lt;span class="kd"&gt;#:port&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;
               &lt;span class="kd"&gt;#:command-line?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That's it! Now we have a Racket web server that can run on Heroku. Obviously it's not a very interesting application right now, but that's fine for our purposes.&lt;/p&gt;&lt;h2&gt;&lt;a name="setting-up-our-app-for-heroku"&gt;&lt;/a&gt;Setting up our app for Heroku&lt;/h2&gt;&lt;p&gt;The next step is to actually create an app on Heroku. Don't worry—it's free! That said, explaining precisely how Heroku works is outside the scope of this article. Just make an account, then create an app. I called mine "racket-heroku-sample". Once you've created an app and set up Heroku's command-line tool, you can specify the proper buildpack:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ git init
$ heroku git:remote -a racket-heroku-sample
$ heroku buildpacks:set https://github.com/lexi-lambda/heroku-buildpack-racket&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We'll also need to pick a particular Racket version before we deploy our app. At the time of this writing, Racket 6.2.1 is the latest version, so I just set the &lt;code&gt;RACKET_VERSION&lt;/code&gt; environment variable as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;$ heroku config:set &lt;span class="nv"&gt;RACKET_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt;.2.1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now there's just one thing left to do before we can push to Heroku: we need to tell Heroku what command to use to run our application. To do this, we use something called a "Procfile" that contains information about the process types for our app. Heroku supports multiple processes of different types, but we're just going to have a single web process.&lt;/p&gt;&lt;p&gt;Specifically, we just want to run our &lt;code&gt;serve.rkt&lt;/code&gt; module. The Racket buildpack installs the repository as a package, so we can run &lt;code&gt;racket&lt;/code&gt; with the &lt;code&gt;-l&lt;/code&gt; flag to specify a module path, which will be more robust than specifying a filesystem path directly. Therefore, our Procfile will look like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;web: racket -l sample-heroku-app/server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now all that's left to do is push our repository to Heroku's git remote. Once the build completes, we can &lt;a href="https://racket-heroku-sample.herokuapp.com"&gt;navigate to our app's URL and actually see it running live&lt;/a&gt;!&lt;/p&gt;&lt;h2&gt;&lt;a name="conclusion"&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;That's all that's needed to get a Racket app up and running on Heroku, but it probably isn't the best way to manage a real application. Usually it's best to use a continuous integration service to automatically deploy certain GitHub branches to Heroku, after running the tests, of course. Also, a real application would obviously be a little more complicated.&lt;/p&gt;&lt;p&gt;That said, this provides the foundation and shell. If you'd like to see the sample app used in this post, you can &lt;a href="https://github.com/lexi-lambda/racket-sample-heroku-app"&gt;find it on GitHub here&lt;/a&gt;. For more details on the buildpack itself, &lt;a href="https://github.com/lexi-lambda/heroku-buildpack-racket"&gt;it's also available on GitHub here&lt;/a&gt;.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item><item><title>Automatically deploying a Frog-powered blog to GitHub pages</title><link>https://lexi-lambda.github.io/blog/2015/07/18/automatically-deploying-a-frog-powered-blog-to-github-pages/</link><guid isPermaLink="true">https://lexi-lambda.github.io/blog/2015/07/18/automatically-deploying-a-frog-powered-blog-to-github-pages/</guid><pubDate>18 Jul 2015</pubDate><description>&lt;article&gt;&lt;p&gt;So, I have a blog now. It's a simple static blog, but what's unique about it is that it's powered by Racket; specifically, it uses &lt;a href="http://www.greghendershott.com"&gt;Greg Hendershott&lt;/a&gt;'s fantastic &lt;a href="https://github.com/greghendershott/frog"&gt;Frog&lt;/a&gt; tool. I've taken this and moulded it to my tastes to build my blog, including configuring automatic deployment via &lt;a href="https://travis-ci.org"&gt;Travis CI&lt;/a&gt;, so my blog is always up-to-date.&lt;/p&gt;&lt;h2&gt;&lt;a name="setting-up-frog"&gt;&lt;/a&gt;Setting up Frog&lt;/h2&gt;&lt;p&gt;I should note that Frog itself was wonderfully easy to drop in and get running. Just following the readme, a simple &lt;code&gt;raco pkg install frog&lt;/code&gt; followed by &lt;code&gt;raco frog --init&lt;/code&gt; and &lt;code&gt;raco frog -bp&lt;/code&gt; created a running blog and opened it in my web browser. There was nothing more to it. Once that's done, all it takes to write a blog post is &lt;code&gt;raco frog -n "Post Title"&lt;/code&gt;, and you're good to go.&lt;/p&gt;&lt;p&gt;By default, Frog uses Bootstrap, which provides a lot of the necessary scaffolding for you, but I opted to roll my own layout using flexbox. I also decided to use &lt;a href="http://sass-lang.com"&gt;Sass&lt;/a&gt; for my stylesheets, potentially with support for &lt;a href="http://coffeescript.org"&gt;CoffeeScript&lt;/a&gt; later, so I wanted to have a good flow for compiling all the resources for deployment. To do that, I used &lt;a href="http://gulpjs.com"&gt;Gulp&lt;/a&gt; in conjunction with &lt;a href="https://www.npmjs.com"&gt;NPM&lt;/a&gt; for build and dependency management.&lt;/p&gt;&lt;p&gt;Going this route has a few advantages, primarily the fact that updating dependencies becomes much easier, and I can build and deploy my blog with just a couple of commands without needing to commit compiled or minified versions of my sources to version control.&lt;/p&gt;&lt;h2&gt;&lt;a name="configuring-automatic-deployment-with-travis"&gt;&lt;/a&gt;Configuring automatic deployment with Travis&lt;/h2&gt;&lt;p&gt;Once Frog itself was configured and my styling was finished, I started looking into how to deploy my blog to a GitHub page without needing to check in any of the generated files to source control. I found a couple of resources, the most useful one being &lt;a href="https://gist.github.com/domenic/ec8b0fc8ab45f39403dd"&gt;this Gist&lt;/a&gt;, which describes how to set up deployment for any project. The basic idea is to create a deployment script which will automatically generate your project, initialize a git repository with the generated files, and push to GitHub's special &lt;code&gt;gh-pages&lt;/code&gt; branch.&lt;/p&gt;&lt;p&gt;To make this easy, Frog can be configured to output to a separate directory via the &lt;code&gt;.frogrc&lt;/code&gt; configuration file. I chose to output to the &lt;code&gt;out&lt;/code&gt; directory:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;output-dir = out
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I also configured my Gulp build to output my CSS into the same output directory. Now, all that's necessary in order to deploy the blog to GitHub is to initialize a Git repository in the output directory, and push the files to the remote branch.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ cd out
$ git init
$ git add .
$ git commit -m "Deploy to GitHub Pages"
$ git push --force "$REMOTE_URL" master:gh-pages
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The next step is to configure Travis so that it can securely push to the GitHub repository with the required credentials. This can be done with Travis's &lt;a href="http://docs.travis-ci.com/user/encryption-keys/"&gt;encryption keys&lt;/a&gt; along with a GitHub &lt;a href="https://github.com/settings/tokens"&gt;personal access token&lt;/a&gt;. Just install the Travis CLI client, copy the access token, and run a command:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ gem install travis
$ travis encrypt GH_TOKEN=&amp;lt;access token...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The output of that command is an encrypted value to be placed in an environment variable in the project's &lt;code&gt;.travis.yml&lt;/code&gt; configuration file. The URL for the repository on GitHub will also need to be specified as well:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nt"&gt;env&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;global&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;GH_REF&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;github.com/&amp;lt;gh-username&amp;gt;/&amp;lt;gh-repo&amp;gt;.git&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;secure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;&amp;lt;encrypted data...&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now all that's left is configuring the &lt;code&gt;.travis.yml&lt;/code&gt; to run Frog. Since Travis doesn't natively support Racket at the time of this writing, the choice of "language" is somewhat arbitrary, but since I want Pygments installed for syntax highlighting, I set my project type to &lt;code&gt;python&lt;/code&gt;, then installed Racket and Frog as pre-installation steps.&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nt"&gt;env&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;global&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;GH_REF&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;github.com/&amp;lt;gh-username&amp;gt;/&amp;lt;gh-repo&amp;gt;.git&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;secure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;&amp;lt;encrypted data...&amp;gt;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;RACKET_DIR&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;~/racket&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;RACKET_VERSION&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;6.2&amp;#39;&lt;/span&gt;

&lt;span class="nt"&gt;before_install&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone https://github.com/greghendershott/travis-racket.git&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;cat travis-racket/install-racket.sh | bash&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;export PATH="${RACKET_DIR}/bin:${PATH}"&lt;/span&gt;

&lt;span class="nt"&gt;install&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;raco pkg install --deps search-auto frog&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(It might be worth noting that Greg Hendershott &lt;em&gt;also&lt;/em&gt; maintains the repository that contains the above Travis build script!)&lt;/p&gt;&lt;p&gt;Finally, in my case, I wasn't deploying to a project-specific GitHub page. Instead, I wanted to deploy to my user page, which uses &lt;code&gt;master&lt;/code&gt;, not &lt;code&gt;gh-pages&lt;/code&gt;. Obviously, I didn't want Travis running on my &lt;code&gt;master&lt;/code&gt; branch, since it would be deploying to that, so I added a branch whitelist:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nt"&gt;branches&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;only&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;source&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All that was left to do was to write up the actual deployment script to be used by Travis. Based on the one provided in the above Gist, mine looked like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; -ev &lt;span class="c1"&gt;# exit with nonzero exit code if anything fails&lt;/span&gt;

&lt;span class="c1"&gt;# clear the output directory&lt;/span&gt;
rm -rf out &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;# build the blog files + install pygments for highlighting support&lt;/span&gt;
npm install
npm run build
pip install pygments
raco frog --build

&lt;span class="c1"&gt;# go to the out directory and create a *new* Git repo&lt;/span&gt;
&lt;span class="nb"&gt;cd&lt;/span&gt; out
git init

&lt;span class="c1"&gt;# inside this git repo we&amp;#39;ll pretend to be a new user&lt;/span&gt;
git config user.name &lt;span class="s2"&gt;"Travis CI"&lt;/span&gt;
git config user.email &lt;span class="s2"&gt;"&amp;lt;your@email.here&amp;gt;"&lt;/span&gt;

&lt;span class="c1"&gt;# The first and only commit to this new Git repo contains all the&lt;/span&gt;
&lt;span class="c1"&gt;# files present with the commit message "Deploy to GitHub Pages".&lt;/span&gt;
git add .
git commit -m &lt;span class="s2"&gt;"Deploy to GitHub Pages"&lt;/span&gt;

&lt;span class="c1"&gt;# Force push from the current repo&amp;#39;s master branch to the remote&lt;/span&gt;
&lt;span class="c1"&gt;# repo. (All previous history on the branch will be lost, since we are&lt;/span&gt;
&lt;span class="c1"&gt;# overwriting it.) We redirect any output to /dev/null to hide any sensitive&lt;/span&gt;
&lt;span class="c1"&gt;# credential data that might otherwise be exposed.&lt;/span&gt;
git push --force --quiet &lt;span class="s2"&gt;"https://&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;GH_TOKEN&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;@&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;GH_REF&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; master &amp;gt; /dev/null &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For reference, my final &lt;code&gt;.travis.yml&lt;/code&gt; looked like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="pygments"&gt;&lt;span class="nt"&gt;language&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;python&lt;/span&gt;
&lt;span class="nt"&gt;python&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3.4&amp;#39;&lt;/span&gt;

&lt;span class="nt"&gt;branches&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;only&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;source&lt;/span&gt;

&lt;span class="nt"&gt;env&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;global&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;GH_REF&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;github.com/lexi-lambda/lexi-lambda.github.io.git&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;secure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;&amp;lt;long secure token...&amp;gt;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;RACKET_DIR&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;~/racket&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;RACKET_VERSION&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;6.2&amp;#39;&lt;/span&gt;

&lt;span class="nt"&gt;before_install&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone https://github.com/greghendershott/travis-racket.git&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;cat travis-racket/install-racket.sh | bash&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;export PATH="${RACKET_DIR}/bin:${PATH}"&lt;/span&gt;

&lt;span class="nt"&gt;install&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;raco pkg install --deps search-auto frog&lt;/span&gt;

&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;bash ./deploy.sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That's it! Now I have a working blog that I can publish just by pushing to the &lt;code&gt;source&lt;/code&gt; branch on GitHub.&lt;/p&gt;&lt;ol class="footnotes"&gt;&lt;/ol&gt;&lt;/article&gt;</description></item></channel></rss>