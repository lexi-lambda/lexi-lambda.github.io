<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Alexis King's Blog: Posts tagged 'programming languages'</title>
  <description>Alexis King's Blog: Posts tagged 'programming languages'</description>
  <link>http://lexi-lambda.github.io/tags/programming-languages.html</link>
  <lastBuildDate>Sun, 19 Jan 2020 00:00:00 UT</lastBuildDate>
  <pubDate>Sun, 19 Jan 2020 00:00:00 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>No, dynamic type systems are not inherently more open</title>
   <link>http://lexi-lambda.github.io/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/?utm_source=programming-languages&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open</guid>
   <pubDate>Sun, 19 Jan 2020 00:00:00 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Internet debates about typing disciplines continue to be plagued by a pervasive myth that dynamic type systems are inherently better at modeling “open world” domains. The argument usually goes like this: the goal of static typing is to pin everything down as much as possible, but in the real world, that just isn’t practical. Real systems should be loosely coupled and worry about data representation as little as possible, so dynamic types lead to a more robust system in the large.&lt;/p&gt;

&lt;p&gt;This story sounds compelling, but it isn’t true. The flaw is in the premise: static types are &lt;em&gt;not&lt;/em&gt; about “classifying the world” or pinning down the structure of every value in a system. The reality is that static type systems allow specifying exactly how much a component needs to know about the structure of its inputs, and conversely, how much it doesn’t. Indeed, in practice static type systems excel at processing data with only a partially-known structure, as they can be used to ensure application logic doesn’t accidentally assume too much.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="two-typing-fallacies"&gt;Two typing fallacies&lt;/h1&gt;

&lt;p&gt;I’ve wanted to write this blog post for a while, but what finally made me decide to do it were misinformed comments responding to &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;my previous blog post&lt;/a&gt;. Two comments in particular caught my eye, &lt;a href="https://www.reddit.com/r/programming/comments/dt0w63/parse_dont_validate/f6ulpsy/"&gt;the first of which was posted on /r/programming&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Strongly disagree with the post […] it promotes a fundamentally entangled and static view of the world. It assumes that we can or should theorize about what is &amp;ldquo;valid&amp;rdquo; input at the edge between the program and the world, thus introducing a strong sense of coupling through the entire software, where failure to conform to some schema will automatically crash the program.&lt;/p&gt;
 &lt;p&gt;This is touted as a feature here but imagine if the internet worked like this. A server changes their JSON output, and we need to recompile and reprogram the entire internet. This is the static view that is promoted as a feature here. […] The &amp;ldquo;parser mentality&amp;rdquo; is fundamentally rigid and global, whereas robust system design should be decentralised and leave interpretation of data to the receiver.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Given the argument being made in the blog post—that you should use precise types whenever possible—one can see where this misinterpretation comes from. How could a proxy server possibly be written in such a style, since it cannot anticipate the structure of its payloads? The commenter’s conclusion is that strict static typing is at odds with programs that don’t know the structure of their inputs ahead of time.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://news.ycombinator.com/item?id=21479933"&gt;The second comment was left on Hacker News&lt;/a&gt;, and it is significantly shorter than the first one:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;What would be the type signature of, say, Python&amp;rsquo;s &lt;code&gt;pickle.load()&lt;/code&gt;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is a different kind of argument, one that relies on the fact that the types of reflective operations may depend on runtime values, which makes them challenging to capture with static types. This argument suggests that static types limit expressiveness because they forbid such operations outright.&lt;/p&gt;

&lt;p&gt;Both these arguments are fallacious, but in order to show why, we have to make explicit an implicit claim. The two comments focus primarily on illustrating how static type systems can’t process data of an unknown shape, but they simultaneously advance an implicit belief: that dynamically typed languages &lt;em&gt;can&lt;/em&gt; process data of an unknown shape. As we’ll see, this belief is misguided; programs are not capable of processing data of a truly unknown shape regardless of typing discipline, and static type systems only make already-present assumptions explicit.&lt;/p&gt;

&lt;h1 id="you-cant-process-what-you-dont-know"&gt;You can’t process what you don’t know&lt;/h1&gt;

&lt;p&gt;The claim is simple: in a static type system, you must declare the shape of data ahead of time, but in a dynamic type system, the type can be, well, dynamic! It sounds self-evident, so much so that Rich Hickey has practically built a speaking career upon its emotional appeal. The only problem is it isn’t true.&lt;/p&gt;

&lt;p&gt;The hypothetical scenario usually goes like this. Say you have a distributed system, and services in the system emit events that can be consumed by any other service that might need them. Each event is accompanied by a payload, which listening services can use to inform further action. The payload itself is minimally-structured, schemaless data encoded using a generic interchange format such as JSON or &lt;a href="https://github.com/edn-format/edn"&gt;EDN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a simple example, a login service might emit an event like this one whenever a new user signs up:&lt;/p&gt;

&lt;div class="brush: json"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;"event_type"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"signup"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;"timestamp"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"2020-01-19T05:37:09Z"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;"data"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;"user"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;"id"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;"name"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Alyssa"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;"email"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"alyssa@example.com"&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Some downstream services might listen for these &lt;code&gt;signup&lt;/code&gt; events and take further action whenever they are emitted. For example, a transactional email service might send a welcome email whenever a new user signs up. If the service were written in JavaScript, the handler might look something like this:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;login&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="cm"&gt;/* ... */&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;signup&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="nx"&gt;sendEmail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;email&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sb"&gt;`Welcome to Blockchain Emporium, &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;!`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But what if this service were written in Haskell instead? Being good, reality-fearing Haskell programmers who &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;parse, not validate&lt;/a&gt;, the Haskell code might look something like this, instead:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Event&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;Event&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;parseJSON&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;withObject&lt;/span&gt; &lt;span class="s"&gt;"Event"&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;eventType&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"event_type"&lt;/span&gt;
    &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;eventType&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
      &lt;span class="s"&gt;"login"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"data"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="s"&gt;"signup"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"signup"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"unknown event_type: "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;eventType&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromJSON&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Success&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="cm"&gt;{- ... -}&lt;/span&gt;
  &lt;span class="kt"&gt;Success&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;sendEmail&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"Welcome to Blockchain Emporium, "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"!"&lt;/span&gt;
  &lt;span class="kt"&gt;Error&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"could not parse event: "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It’s definitely more boilerplate, but some extra overhead for type definitions is to be expected (and is greatly exaggerated in such tiny examples), and the arguments we’re discussing aren’t about boilerplate, anyway. The &lt;em&gt;real&lt;/em&gt; problem with this version of the code, according to the Reddit comment from earlier, is that the Haskell code has to be updated whenever a service adds a new event type! A new case has to be added to the &lt;code&gt;Event&lt;/code&gt; datatype, and it must be given new parsing logic. And what about when new fields get added to the payload? What a maintenance nightmare.&lt;/p&gt;

&lt;p&gt;In comparison, the JavaScript code is much more permissive. If a new event type is added, it will just fall through the &lt;code&gt;switch&lt;/code&gt; and do nothing. If extra fields are added to the payload, the JavaScript code will just ignore them. Seems like a win for dynamic typing.&lt;/p&gt;

&lt;p&gt;Except that no, it isn’t. The only reason the statically typed program fails if we don’t update the &lt;code&gt;Event&lt;/code&gt; type is that we wrote &lt;code&gt;handleEvent&lt;/code&gt; that way. We could just have easily done the same thing in the JavaScript code, adding a default case that rejects unknown event types:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* ... */&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sb"&gt;`unknown event_type: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We didn’t do that, since in this case it would clearly be silly. If a service receives an event it doesn’t know about, it should just ignore it. This is a case where being permissive is clearly the correct behavior, and we can easily implement that in the Haskell code too:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromJSON&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="cm"&gt;{- ... -}&lt;/span&gt;
  &lt;span class="kt"&gt;Error&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is still in the spirit of “parse, don’t validate” because we’re still parsing the values we &lt;em&gt;do&lt;/em&gt; care about as early as possible, so we don’t fall into the double-validation trap. At no point do we take a code path that depends on a value being well-formed without first ensuring (with the help of the type system) that it is, in fact, actually well-formed. We don’t have to respond to an ill-formed value by raising an error! We just have to be explicit about ignoring it.&lt;/p&gt;

&lt;p&gt;This illustrates an important point: the &lt;code&gt;Event&lt;/code&gt; type in this Haskell code doesn’t describe “all possible events,” it describes all the events that the application cares about. Likewise, the code that parses those events’ payloads only worries about the fields the application needs, and it ignores extraneous ones. A static type system doesn’t require you eagerly write a schema for the whole universe, it simply requires you to be up front about the things you need.&lt;/p&gt;

&lt;p&gt;This turns out to have a lot of pleasant benefits even though knowledge about inputs is limited:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;It’s easy to discover the assumptions of the Haskell program just by looking at the type definitions. We know, for example, that this application doesn’t care about the &lt;code&gt;timestamp&lt;/code&gt; field, since it never appears in any of the payload types. In the dynamically-typed program, we’d have to audit every code path to see whether or not it inspects that field, which would be a lot of error-prone work!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;What’s more, it turns out the Haskell code doesn’t actually &lt;em&gt;use&lt;/em&gt; the &lt;code&gt;userId&lt;/code&gt; field inside the &lt;code&gt;SignupPayload&lt;/code&gt; type, so that type is overly conservative. If we want to ensure it isn’t actually needed (since, for example, maybe we’re phasing out providing the user ID in that payload entirely), we need only delete that record field; if the code typechecks, we can be confident it really doesn’t depend on that field.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, we neatly avoid all the gotchas related to shotgun parsing &lt;a href="/blog/2019/11/05/parse-don-t-validate/#the-danger-of-validation"&gt;mentioned in the previous blog post&lt;/a&gt;, since we still haven’t compromised on any of those principles.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;We’ve already invalidated the first half of the claim: that statically typed languages can’t deal with data where the structure isn’t completely known. Let’s now look at the other half, which states that dynamically typed languages can process data where the structure isn’t known at all. Maybe that still sounds right, but if you slow down and think about it more carefully, you’ll find it can’t be.&lt;/p&gt;

&lt;p&gt;The above JavaScript code makes all the same assumptions our Haskell code does: it assumes event payloads are JSON objects with an &lt;code&gt;event_type&lt;/code&gt; field, and it assumes &lt;code&gt;signup&lt;/code&gt; payloads include &lt;code&gt;data.user.name&lt;/code&gt; and &lt;code&gt;data.user.email&lt;/code&gt; fields. It certainly can’t do anything useful with truly unknown input! If a new event payload is added, our JavaScript code can’t magically adapt to handle it simply because it is dynamically typed. Dynamic typing just means the types of values are carried alongside them at runtime and checked as the program executes; the types are still there, and this program still implicitly relies on them being particular things.&lt;/p&gt;

&lt;h1 id="keeping-opaque-data-opaque"&gt;Keeping opaque data opaque&lt;/h1&gt;

&lt;p&gt;In the previous section, we debunked the idea that statically typed systems can’t process partially-known data, but if you have been paying close attention, you may have noticed it did not fully refute the original claim.&lt;/p&gt;

&lt;p&gt;Although we were able to handle unknown data, we always simply discarded it, which would not fly if we were trying to implement some sort of proxying. For example, suppose we have a forwarding service that broadcasts events over a public network, attaching a signature to each payload to ensure it can’t be spoofed. We might implement this in JavaScript this way:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;signedPayload&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="nx"&gt;retransmitEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;signedPayload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this case, we don’t care about the structure of the payload at all (the &lt;code&gt;signature&lt;/code&gt; function just works on any valid JSON object), but we still have to preserve all the information. How could we do that in a statically typed language, since a statically-typed language would have to assign the payload a precise type?&lt;/p&gt;

&lt;p&gt;Once again, the answer involves rejecting the premise: there’s no need to give data a type that’s any more precise than the application needs. The same logic could be written in a straightforward way in Haskell:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;signedPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"signature"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;
  &lt;span class="n"&gt;retransmitEvent&lt;/span&gt; &lt;span class="n"&gt;signedPayload&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"event payload was not an object "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this case, since we don’t care about the structure of the payload, we manipulate a value of type &lt;code&gt;JSON.Value&lt;/code&gt; directly. This type is extremely imprecise compared to our &lt;code&gt;Event&lt;/code&gt; type from earlier—it can hold any legal JSON value, of any shape—but in this case, we &lt;em&gt;want&lt;/em&gt; it to be imprecise.&lt;/p&gt;

&lt;p&gt;Thanks to that imprecision, the type system helped us here: it caught the fact that we’re assuming the payload is a JSON object, not some other JSON value, and it made us handle the non-object cases explicitly. In this case we chose to raise an error, but of course, as before, you could choose some other form of recovery if you wanted to. You just have to be explicit about it.&lt;/p&gt;

&lt;p&gt;Once more, note that the assumption we were forced to make explicit in Haskell is &lt;em&gt;also&lt;/em&gt; made by the JavaScript code! If our JavaScript &lt;code&gt;handleEvent&lt;/code&gt; function were called with a string rather than an object, it’s unlikely the behavior would be desirable, since an object spread on a string results in the following surprise:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="s2"&gt;"payload"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"sig"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"y"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"l"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"o"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"d"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"sig"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Oops. Once again, the parsing style of programming has helped us out, since if we didn’t “parse” the JSON value into an object by matching on the &lt;code&gt;Object&lt;/code&gt; case explicitly, our code would not compile, and if we left off the fallthrough case, we’d get a warning about inexhaustive patterns.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let’s look at one more example of this phenomenon before moving on. Suppose we’re consuming an API that returns user IDs, and suppose those IDs happen to be UUIDs. A straightforward interpretation of “parse, don’t validate” might suggest we represent user IDs in our Haskell API client using a &lt;code&gt;UUID&lt;/code&gt; type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UUID&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, our Reddit commenter would likely take umbrage with this! Unless the API contract explicitly states that all user IDs will be UUIDs, this representation is overstepping our bounds. Although user IDs might be UUIDs today, perhaps they won’t be tomorrow, and then our code would break for no reason! Is this the fault of static type systems?&lt;/p&gt;

&lt;p&gt;Again, the answer is no. This is a case of improper data modeling, but the static type system is not at fault—it has simply been misused. The appropriate way to represent a &lt;code&gt;UserId&lt;/code&gt; is to define a new, opaque type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Unlike the type alias defined above which simply creates a new name for the existing &lt;code&gt;UUID&lt;/code&gt; type, this declaration creates a totally new &lt;code&gt;UserId&lt;/code&gt; type that is distinct from all other types, including &lt;code&gt;Text&lt;/code&gt;. If we keep the datatype’s constructor private (that is, we don’t export it from the module that defines this type), then the &lt;em&gt;only&lt;/em&gt; way to produce a &lt;code&gt;UserId&lt;/code&gt; will be to go through its &lt;code&gt;FromJSON&lt;/code&gt; parser. Dually, the only things you can do with a &lt;code&gt;UserId&lt;/code&gt; are compare it with other &lt;code&gt;UserId&lt;/code&gt;s for equality or serialize it using the &lt;code&gt;ToJSON&lt;/code&gt; instance. Nothing else is permitted: the type system will prevent you from depending on the remote service’s internal representation of user IDs.&lt;/p&gt;

&lt;p&gt;This illustrates another way that static type systems can provide strong, useful guarantees when manipulating completely opaque data. The runtime representation of a &lt;code&gt;UserId&lt;/code&gt; is really just a string, but the type system does not allow you to accidentally use it like it’s a string, nor does it allow you to forge a new &lt;code&gt;UserId&lt;/code&gt; out of thin air from an arbitrary string.&lt;sup&gt;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-definition" name="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The type system is not a ball and chain forcing you to describe the representation of every value that enters and leaves your program in exquisite detail. Rather, it’s a tool that you can use in whatever way best suits your needs.&lt;/p&gt;

&lt;h1 id="reflection-is-not-special"&gt;Reflection is not special&lt;/h1&gt;

&lt;p&gt;We’ve now thoroughly debunked the claims made by the first commenter, but the question posed by the second commenter may still seem like a loophole in our logic. What &lt;em&gt;is&lt;/em&gt; the type of Python’s &lt;code&gt;pickle.load()&lt;/code&gt;? For those unfamiliar, &lt;a href="https://docs.python.org/3/library/pickle.html"&gt;Python’s cutely-named &lt;code&gt;pickle&lt;/code&gt; library&lt;/a&gt; allows serializing and deserializing entire Python object graphs. Any object can be serialized and stored in a file using &lt;code&gt;pickle.dump()&lt;/code&gt;, and it can be deserialized at a later point in time using &lt;code&gt;pickle.load()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What makes this appear challenging to our static type system is that the type of value produced by &lt;code&gt;pickle.load()&lt;/code&gt; is difficult to predict—it depends entirely on whatever happened to be written to that file using &lt;code&gt;pickle.dump()&lt;/code&gt;. This seems inherently dynamic, since we cannot possibly know what type of value it will produce at compile-time. At first blush, this is something a dynamically typed system can pull off, but a statically-typed one just can’t.&lt;/p&gt;

&lt;p&gt;However, it turns out this situation is actually identical to the previous examples using JSON, and the fact that Python’s pickling serializes native Python objects directly does not change things. Why? Well, consider what happens &lt;em&gt;after&lt;/em&gt; a program calls &lt;code&gt;pickle.load()&lt;/code&gt;. Say you write the following function:&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;load_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="c1"&gt;# do something with `val`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The trouble is that &lt;code&gt;val&lt;/code&gt; can now be of &lt;em&gt;any&lt;/em&gt; type, and just as you can’t do anything useful with truly unknown, unstructured input, you can’t do anything with a value unless you know at least something about it. If you call any method or access any field on the result, then you’ve already made an assumption about what sort of thing &lt;code&gt;pickle.load(f)&lt;/code&gt; returned—and it turns out those assumptions &lt;em&gt;are&lt;/em&gt; &lt;code&gt;val&lt;/code&gt;’s type!&lt;/p&gt;

&lt;p&gt;For example, imagine the only thing you do with &lt;code&gt;val&lt;/code&gt; is call the &lt;code&gt;val.foo()&lt;/code&gt; method and return its result, which is expected to be a string. If we were writing Java, then the expected type of &lt;code&gt;val&lt;/code&gt; would be quite straightforward—we’d expect it to be an instance of the following interface:&lt;/p&gt;

&lt;div class="brush: java"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Serializable&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And indeed, it turns out a &lt;code&gt;pickle.load()&lt;/code&gt;-like function can be given a perfectly reasonable type in Java:&lt;/p&gt;

&lt;div class="brush: java"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;load&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Nitpickers will complain that this isn’t the same as &lt;code&gt;pickle.load()&lt;/code&gt;, since you have to pass a &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; token to choose what type of thing you want ahead of time. However, nothing is stopping you from passing &lt;code&gt;Serializable.class&lt;/code&gt; and branching on the type later, after the object has been loaded. And that’s the key point: the instant you do &lt;em&gt;anything&lt;/em&gt; with the object, you must know something about its type, even in a dynamically typed language! The statically-typed language just forces you to be more explicit about it, just as it did when we were talking about JSON payloads.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Can we do this in Haskell, too? Absolutely—we can use &lt;a href="https://hackage.haskell.org/package/serialise"&gt;the &lt;code&gt;serialise&lt;/code&gt; library&lt;/a&gt;, which has a similar API to the Java one mentioned above. It also happens to have a very similar interface to &lt;a href="https://hackage.haskell.org/package/aeson"&gt;the Haskell JSON library, aeson&lt;/a&gt;, as it turns out the problem of dealing with unknown JSON data is not terribly different from dealing with an unknown Haskell value—at some point, you have to do a little bit of parsing to do anything with the value.&lt;/p&gt;

&lt;p&gt;That said, while you &lt;em&gt;can&lt;/em&gt; emulate the dynamic typing of &lt;code&gt;pickle.load()&lt;/code&gt; if you really want to by deferring the type check until the last possible moment, the reality is that doing so is almost never actually useful. At some point, you have to make assumptions about the structure of the value in order to use it, and you know what those assumptions are because &lt;em&gt;you wrote the code&lt;/em&gt;. While there are extremely rare exceptions to this that require true dynamic code loading (such as, say, implementing a REPL for your programming language), they do not occur in day-to-day programming, and programmers in statically-typed languages are perfectly happy to supply their assumptions up front.&lt;/p&gt;

&lt;p&gt;This is one of the fundamental disconnects between the static typing camp and the dynamic typing camp. Programmers working in statically-typed languages are perplexed when a programmer suggests they can do something in a dynamically typed language that a statically-typed language “fundamentally” prevents, since a programmer in a statically-typed language may reply the value has simply not been given a sufficiently precise type. From the perspective of a programmer working in a dynamically-typed language, the type system restricts the space of legal behaviors, but from the perspective of a programmer working in a statically-typed language, the set of legal behaviors &lt;em&gt;is&lt;/em&gt; a value’s type.&lt;/p&gt;

&lt;p&gt;Neither of these perspectives are actually inaccurate, from the appropriate point of view. Static type systems &lt;em&gt;do&lt;/em&gt; impose restrictions on program structure, as it is provably impossible to reject &lt;em&gt;all&lt;/em&gt; bad programs in a Turing-complete language without also rejecting some good ones (this is &lt;a href="https://en.wikipedia.org/wiki/Rice's_theorem"&gt;Rice’s theorem&lt;/a&gt;). But it is simultaneously true that the impossibility of solving the general problem does not preclude solving a slightly more restricted version of the problem in a useful way, and a lot of the so-called “fundamental” inabilities of static type systems are not fundamental at all.&lt;/p&gt;

&lt;h1 id="appendix-the-reality-behind-the-myths"&gt;Appendix: the reality behind the myths&lt;/h1&gt;

&lt;p&gt;The key thesis of this blog post has now been delivered: static type systems are not fundamentally worse than dynamic type systems at processing data with an open or partially-known structure. The sorts of claims made in the comments cited at the beginning of this blog post are not accurate depictions of what statically-typed program construction is like, and they misunderstand the limitations of static typing disciplines while exaggerating the capabilities of dynamically typed disciplines.&lt;/p&gt;

&lt;p&gt;However, although greatly exaggerated, these myths do have some basis in reality. They appear to have developed at least in part from a misunderstanding about the differences between structural and nominal typing. This difference is unfortunately too big to address in this blog post, as it could likely fill several blog posts of its own. About six months ago I attempted to write a blog post on the subject, but I didn’t think it came out very compelling, so I scrapped it. Maybe someday I’ll find a better way to communicate the ideas.&lt;/p&gt;

&lt;p&gt;Although I can’t give it the full treatment it deserves right now, I’d still like to touch on the idea briefly so that interested readers may be able to find other resources on the subject should they wish to do so. The key idea is that many dynamically typed languages idiomatically reuse simple data structures like hashmaps to represent what in statically-typed languages are often represented by bespoke datatypes (usually defined as classes or structs).&lt;/p&gt;

&lt;p&gt;These two styles facilitate very different flavors of programming. A JavaScript or Clojure program may represent a record as a hashmap from string or symbol keys to values, written using object or hash literals and manipulated using ordinary functions from the standard library that manipulate keys and values in a generic way. This makes it straightforward to take two records and union their fields or to take an arbitrary (or even dynamic) subselection of fields from an existing record.&lt;/p&gt;

&lt;p&gt;In contrast, most static type systems do not allow such free-form manipulation of records because records are not maps at all but unique types distinct from all other types. These types are uniquely identified by their (fully-qualified) name, hence the term &lt;em&gt;nominal typing&lt;/em&gt;. If you wish to take a subselection of a struct’s fields, you must define an entirely new struct; doing this often creates an explosion of awkward boilerplate.&lt;/p&gt;

&lt;p&gt;This is one of the main ideas that Rich Hickey has discussed in many of his talks that criticize static typing. He has advanced the idea that this ability to fluidly merge, separate, and transform records makes dynamic typing particularly suited to the domain of distributed, open systems. Unfortunately, this rhetoric has two significant flaws:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;It skirts too close to calling this a fundamental limitation of type systems, suggesting that it is not simply inconvenient but &lt;em&gt;impossible&lt;/em&gt; to model such systems in a nominal, static type system. Not only is this not true (as this blog post has demonstrated), it misdirects people away from the point of his that actually has value: the practical, pragmatic advantage of a more structural approach to data modeling.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;It confuses the structural/nominal distinction with the dynamic/static distinction, incorrectly creating the impression that the fluid merging and splitting of records represented as key-value maps is only possible in a dynamically typed language. In fact, not only can statically-typed languages support structural typing, many dynamically-typed languages also support nominal typing. These axes have historically loosely correlated, but they are theoretically orthogonal.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For counterexamples to these claims, consider Python classes, which are quite nominal despite being dynamic, and TypeScript interfaces, which are structural despite being static. Indeed, modern statically-typed languages are increasingly acquiring native support for structurally-typed records. In these systems, record types work much like hashes in Clojure—they are not distinct, named types but rather anonymous collections of key-value pairs—and they support many of the same expressive manipulation operations that Clojure’s hashes do, all within a statically-typed framework.&lt;/p&gt;

&lt;p&gt;If you are interested in exploring static type systems with strong support for structural typing, I would recommend taking a look at any of TypeScript, Flow, PureScript, Elm, OCaml, or Reason, all of which have some sort of support for structurally typed records. What I would &lt;em&gt;not&lt;/em&gt; recommend for this purpose is Haskell, which has abysmal support for structural typing; Haskell is (for various reasons outside the scope of this blog post) aggressively nominal.&lt;sup&gt;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-definition" name="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Does this mean Haskell is bad, or that it cannot be practically used to solve these kinds of problems? No, certainly not; there are many ways to model these problems in Haskell that work well enough, though some of them suffer from significant boilerplate. The core thesis of this blog post applies just as much to Haskell as it does to any of the other languages I mentioned above. However, I would be remiss not to mention this distinction, as it may give programmers from a dynamically-typed background who have historically found statically-typed languages much more frustrating to work with a better understanding of the &lt;em&gt;real&lt;/em&gt; reason they feel that way. (Essentially all mainstream, statically-typed OOP languages are even more nominal than Haskell!)&lt;/p&gt;

&lt;p&gt;As closing thoughts: this blog post is not intended to start a flame war, nor is it intended to be an assault on dynamically typed programming. There are many patterns in dynamically-typed languages that are genuinely difficult to translate into a statically-typed context, and I think discussions of those patterns can be productive. The purpose of this blog post is to clarify why one particular discussion is &lt;em&gt;not&lt;/em&gt; productive, so please: stop making these arguments. There are much more productive conversations to have about typing than this.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Technically, you could abuse the &lt;code&gt;FromJSON&lt;/code&gt; instance to convert an arbitrary string to a &lt;code&gt;UserId&lt;/code&gt;, but this would not be as easy as it sounds, since &lt;code&gt;fromJSON&lt;/code&gt; can fail. This means you’d somehow have to handle that failure case, so this trick would be unlikely to get you very far unless you’re already in a context where you’re doing input parsing… at which point it would be easier to just do the right thing. So yes, the type system doesn’t prevent you from going out of your way to shoot yourself in the foot, but it guides you towards the right solution (and there is no safeguard in existence that can completely protect a programmer from making their own life miserable if they are determined to do so).&amp;nbsp;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;I consider this to be Haskell’s most significant flaw at the time of this writing.&amp;nbsp;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item>
  <item>
   <title>Empathy and subjective experience in programming languages</title>
   <link>http://lexi-lambda.github.io/blog/2019/10/19/empathy-and-subjective-experience-in-programming-languages/?utm_source=programming-languages&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2019-10-19-empathy-and-subjective-experience-in-programming-languages</guid>
   <pubDate>Sat, 19 Oct 2019 08:35:44 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;A stereotype about programmers is that they like to think in black and white. Programmers like things to be good or bad, moral or immoral, responsible or irresponsible. Perhaps there is something romantic in the idea that programmers like to be as binary as the computers they program. Reductionist? Almost certainly, but hey, laugh at yourself a bit: we probably deserve to be made fun of from time to time.&lt;/p&gt;

&lt;p&gt;Personally, I have no idea if the trope of the nuance-challenged programmer is accurate, but whether it’s a property of programmers or just humans behind a keyboard, the intensity with which we disagree with one another never ceases to amaze. Ask any group of working programmers what their least favorite programming language is, and there’s a pretty good chance things are going to get heated real fast. Why? What is it about programming that makes us feel so strongly that we are right and others are wrong, even when our experiences contradict those of tens or hundreds of thousands of others?&lt;/p&gt;

&lt;p&gt;I think about that question a lot.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="2015-called-and-they-want-their-dress-back"&gt;2015 called, and they want their dress back&lt;/h1&gt;

&lt;p&gt;Humans have a knack for caring intensely about the most trivial of things. Name almost anything—cats versus dogs, the appropriate way to fasten a necktie, or even which day of the week comes first—and someone somewhere has probably written an essay about it on an internet forum. It would be easy to throw up our hands and give up trying to understand our peers, as sometimes they seem like aliens from another planet.&lt;/p&gt;

&lt;p&gt;However, what interests me is how the littlest things seem to get people the most upset. Few people have shouting matches over the best interpretation of quantum mechanics, but friendships will be tested when someone says they just aren’t that into &lt;em&gt;Star Wars&lt;/em&gt;. One explanation for this phenomenon is simple accessibility: most people aren’t equipped to understand quantum mechanics well enough to argue about it, but almost anyone can have an opinion on which direction the toilet paper is supposed to go.&lt;sup&gt;&lt;a href="#2019-10-19-empathy-and-subjective-experience-in-programming-languages-footnote-1-definition" name="2019-10-19-empathy-and-subjective-experience-in-programming-languages-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;There is truth in that explanation, but personally, I don’t think it’s the whole story. Rather, I think we grow so used to the idea that our experiences are universal that discovering someone else experienced the exact same thing we did yet came to a different conclusion is not just frustrating: it’s incomprehensible.&lt;/p&gt;

&lt;p&gt;Take 2015’s phenomenon of “&lt;a href="https://en.wikipedia.org/wiki/The_dress"&gt;the dress&lt;/a&gt;” as an example. Some people see black and blue, others white and gold, and frankly, whether you see one or the other has no impact on anything remotely meaningful. How did &lt;em&gt;this&lt;/em&gt;—something so completely irrelevant—become a cross-cultural phenomenon reported on by major news outlets? My guess: people just aren’t used to the idea that vision—the primary way we sense the world—does not provide us with an objective, universal understanding of reality.&lt;/p&gt;

&lt;h2 id="when-something-objective-isnt"&gt;When something objective isn’t&lt;/h2&gt;

&lt;p&gt;Our culture and society works because, in spite of our differences, we’re still all humans. We eat food, we sleep, we like spending time with each other, and we like feeling connected to those around us. So when we watch a movie, and it tickles us in a way that makes us feel good, we can have an awfully hard time understanding how our best friend—who we largely agree with about everything—didn’t like it at all.&lt;/p&gt;

&lt;p&gt;The truth, of course, is that very little of what we experience is in any way objective. Yes, we can be pretty confident that basic arithmetic is true anywhere in the universe, and that if we all agree a table is brown it probably is. There are even things we accept as subjective without a second thought, such as the kinds of food people like or the fashions they find attractive. It’s all the in-betweens that are so pernicious! “The dress” was so unbelievable to most people because, nine hundred and ninety nine times out of of a thousand, when two humans look at a picture, they at least mostly agree on the colors contained within. We do not consider that we are seeing different lenses into the same objective reality, we simply think we are perceiving objective truths directly.&lt;/p&gt;

&lt;p&gt;In the case of the dress, whether you &lt;a href="https://en.wikipedia.org/wiki/Yanny_or_Laurel"&gt;heard “yanny” or “laurel,”&lt;/a&gt; or whether you believe the &lt;em&gt;Sonic&lt;/em&gt; games were ever any good, subjective disagreement is essentially harmless. But what about when it isn’t? Might incorrect beliefs that our experiences are universal cause genuine harm?&lt;/p&gt;

&lt;p&gt;I think the answer is absolutely, unequivocally &lt;em&gt;yes&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id="subjectivity-in-programming-and-in-programming-languages-specifically"&gt;Subjectivity in programming, and in programming languages specifically&lt;/h1&gt;

&lt;p&gt;Quick question: which is better, functional or imperative programming?&lt;/p&gt;

&lt;p&gt;My guess, given the usual subject of my blog, most of my readers would pick the former. However, the actual answer you chose doesn’t matter: my guess is you feel like you have a pretty rational argument to back it up. It certainly isn’t simply a matter of taste… right?&lt;/p&gt;

&lt;p&gt;Well, no, I hope not. I don’t think the world is so subjective that we cannot ever advocate for one thing over another—we tried that whole “everything is XML” thing for a while, and I think we agreed it really wasn’t a good idea. But if you truly believe your answer to the above question can be completely objectively justified (as many do), how does one explain the average Hacker News comment thread on just about any post about Haskell?&lt;/p&gt;

&lt;p&gt;I generally try not to read Hacker News if I can help it, as I find doing it mostly just makes me angry,&lt;sup&gt;&lt;a href="#2019-10-19-empathy-and-subjective-experience-in-programming-languages-footnote-2-definition" name="2019-10-19-empathy-and-subjective-experience-in-programming-languages-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; but I did happen to find a link to &lt;a href="https://news.ycombinator.com/item?id=21282647"&gt;a recent discussion&lt;/a&gt; on a blog post about using Haskell in production. Let’s take a look at a few comments, shall we?&lt;/p&gt;

&lt;p&gt;In a &lt;a href="https://news.ycombinator.com/item?id=21284383"&gt;branch of the discussion&lt;/a&gt;, one user writes:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;blockquote&gt;
  &lt;p&gt;Haskell is great for business and great in production&lt;/p&gt;&lt;/blockquote&gt;
 &lt;p&gt;I disagree. It&amp;rsquo;s a beautiful language but it lacks a lot of features to make it useable at scale. And in my experience Haskell engineers are extremely smart but the environment/culture they create makes it difficult to foster team spirit.&lt;/p&gt;
 &lt;p&gt;I&amp;rsquo;ve been in 2 companies in the last 4 years who initially used Haskell in production. One has transitioned to Go and the other is rewriting the codebase in Rust.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The first paragraph is an assertion without many specifics, but it does sound like it could be reasonable. And although the last two sentences are entirely anecdotal, anecdotes are still better than hunches. Let’s see what someone else has to say in response:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;I’ve met some pretty damn solid engineers who started on Haskell and, even at a junior level in other languages, produce an elegant solution far more easily than a senior engineer in that language. You probably wouldn’t put the code in production verbatim but you can very easily see what’s going on and it isn’t haunted by spectre of early abstraction, which IMO is the biggest flaw of OOP at scale.&lt;/p&gt;
 &lt;p&gt;[…]&lt;/p&gt;
 &lt;p&gt;From my naive perspective it’s easy to make classes out of everything, and to hold state and put side-effects everywhere, but you don’t want to deal with the trouble of a monad until you need it. So you have an automatic inclination towards cleaner code when you start functional and move on.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Also pretty vague and high-level, but also sounds reasonable. If you read either of these comments, and your first inclination was to grow frustrated and start crafting counter-arguments in your head, I encourage you to step outside your feelings momentarily (rational as they may be!) and try your very hardest to interpret them charitably. The discussion continues:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Haskell gives one plenty of rope to hang himself on complexity.&lt;/p&gt;
 &lt;p&gt;So much that developers develop an aversion to it as deep as fear. It&amp;rsquo;s unavoidable, the ones that didn&amp;rsquo;t develop it are still buried at the working of their first Rube Goldberg machine and unavailable.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Whether you think it’s accurate or not, there is definitely a perception held by a great many people that Haskell is a very complicated language. Surely at least some of them must have given it an honest shot, so have they just not “seen the light” yet? What do you think they’re missing? Perhaps a followup commenter can help elucidate things:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Hi, I find that everything people here are complaining about (and they&amp;rsquo;re valid complaints) has also been true of C++. C++ developed a lot of its complexity (particularly 15&amp;ndash;20 yrs ago in the template space) after it got popular, so people were already wed to it.&lt;/p&gt;
 &lt;p&gt;[…]&lt;/p&gt;
 &lt;p&gt;The C++ community&amp;rsquo;s really gotten good in the last 5 years or so about reigning in the bad impulses and getting people to write clean, clear, efficient code that has reasonable expressiveness.&lt;/p&gt;
 &lt;p&gt;Coming into Haskell from C++, I have the same instincts. Haskell&amp;rsquo;s been a pure pleasure. The benefits are really there, and they&amp;rsquo;re easy to get. You just have to think of the trade-offs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That argument seems reasonable, too. Everything in moderation, right? If you disagree, and you think Haskell is just not worth it, what does this person value that you don’t? What are they missing that you see?&lt;/p&gt;

&lt;h2 id="the-unsatisfying-subjective-reality-of-programming-languages"&gt;The unsatisfying subjective reality of programming languages&lt;/h2&gt;

&lt;p&gt;You can probably see where I’m going with all this. These arguments are not built on hard, refutable facts or rigorous real-world evidence, they’re based in gut feelings and personal preferences. Does that mean they’re wrong, invalid, and worthless, and we should do studies to determine which language allows programmers to ship features the fastest and with the fewest bugs, then all agree to use that?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;No!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;These conversations are subjective because, for better or for worse, humans think in different ways and value different things, and programming languages are the medium in which we express ourselves. To many people who write Haskell (myself included), there is an effervescent joy in modeling a problem with the type system—like capturing something in amber—that others just don’t care about. What’s more, some people clearly loathe Haskell’s significant whitespace and plethora of infix operators, but I’ve never really minded. Is one of us wrong? If so, &lt;em&gt;why?&lt;/em&gt; Talk about reliability all you want, but the few rigorous numbers we have don’t provide much evidence one way or the other.&lt;/p&gt;

&lt;p&gt;While &lt;a href="https://news.ycombinator.com/item?id=21284317"&gt;one commenter&lt;/a&gt; in the aforementioned Hacker News thread described Haskell as nothing less than “pain and torture,” &lt;a href="https://news.ycombinator.com/item?id=21284540"&gt;another&lt;/a&gt; says they “did some Haskell in production and it was delightful.” People push excuses and rationalizations for these differences constantly—they point out that most people are exposed to imperative programming first, while others retort that Haskell is clearly not very widely used despite being around for an awfully long time—but none of their arguments ever seem to change people’s minds.&lt;/p&gt;

&lt;p&gt;Often, people walk away from these conversations confused and incensed. To them, their point of view is so obviously apparent that it is hard to fathom anyone else seeing things differently. They rack their brains trying to figure out why their opponents just don’t &lt;em&gt;get it.&lt;/em&gt; There must be some key point they’ve misunderstood, some joy they haven’t experienced, some sharp edge they haven’t yet been cut by. But no matter how much time they spend trying to reach these people, somehow, it’s never enough.&lt;/p&gt;

&lt;h2 id="empathy-and-how-bad-results-come-from-good-intentions"&gt;Empathy, and how bad results come from good intentions&lt;/h2&gt;

&lt;p&gt;I’ll admit that these kinds of discussions aren’t &lt;em&gt;always&lt;/em&gt; fruitless; sometimes they really do manage to change people’s minds or help them see some new idea they had not been able to grasp. When people manage to keep their cool and acknowledge the differences in their mindsets while still helping people learn, everyone benefits.&lt;/p&gt;

&lt;p&gt;Sadly, in my experience, this rarely happens. We have a natural tendency to become angry if people don’t see things the way we do; it’s confusing and disorienting, and it can even disgust us. None of those emotions are conducive to empathy. When we fail to account for the ways in which others might think differently, we voluntarily reject any insights we might have otherwise gained from the conversation because we did not allow ourselves to embrace, even just temporarily, someone else’s strange and perhaps uncomfortable set of values and experiences. We refuse to accept that our perception of color might not be as universal as we thought, and we miss out on the amazing insights we could learn about the nature of light, color, and human vision.&lt;/p&gt;

&lt;p&gt;Although failing to empathize with those we are arguing with is bad enough, in my mind, this failure to accept the potential subjectivity of one’s own views has even worse, indirect effects. Take this comment for example, again from the same thread:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Sounds like you&amp;rsquo;ve barely programmed in Haskell and don&amp;rsquo;t know what you&amp;rsquo;re talking about. Haskell was the first language I learned. I didn&amp;rsquo;t think this at all and I still don&amp;rsquo;t. It doesn&amp;rsquo;t strike me as any more difficult than learning Java or something.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I have no doubts that this commenter meant what they said: they didn’t find Haskell difficult to learn. The comment they were replying to was vitriolic and combative, so one could almost feel they had a smackdown coming to them… but this isn’t a private conversation. How do you think someone feels when they are learning Haskell, scroll through this thread, and find a comment that tells them they ought to find it easy? If they’ve been struggling, even a little bit, what do you think they might think?&lt;/p&gt;

&lt;p&gt;If I were in their place, I might feel a little stupid. I might wonder if I’m really cut out for Haskell or if I should just give up. I definitely wouldn’t feel encouraged and excited to keep trying.&lt;/p&gt;

&lt;p&gt;Who knows why this commenter found Haskell straightforward. Maybe they were exposed to certain concepts already, maybe it just fit their style of thinking, perhaps they’re even exceptionally smart. I don’t know. But no matter what the answer is, insulting the intelligence of others, even indirectly in this way, belies a lack of empathy in the face of frustration, and although the intent may not have been to hurt, it can still be seriously harmful.&lt;/p&gt;

&lt;p&gt;To be clear, I’m not saying the commenter should have pretended their experiences were different or even kept them to themselves. I don’t believe in being “fake nice”—in my experience, I am best equipped to reach people when speaking genuinely, from the heart. What I would have done is tell my story in a different way, perhaps by writing something like this:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;It’s true that a lot of people find Haskell challenging, and I totally accept that some people just don’t think it’s worth it. It’s fine if you don’t want to write Haskell. But personally, I really enjoy writing it, as do the people I work with, and I think we ship great software with it because it aligns naturally—even joyfully!—with the way we like to think about program construction.&lt;/p&gt;
 &lt;p&gt;Personally, I didn’t find Haskell as challenging to learn as I think some people have, but it was still work, and in some ways I was just exposed to it at the right time. Other people I know have struggled quite a lot at first, and reasonably so, but they’ve still managed to become great Haskell programmers, and they found it worthwhile. Our team dynamic just wouldn’t be the same in any other language.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;When I respond to comments I disagree with, I try to tell a personal story that provides a different perspective &lt;strong&gt;without&lt;/strong&gt; invalidating their experiences. Sometimes the result is ungrateful snark anyway (or just no response at all), but you might be surprised how often talking from an emotional place about &lt;em&gt;your own&lt;/em&gt; experiences—while being neither aggressive nor especially defensive—can go a long way. Perhaps you can even learn something if they return the favor and explain what they find frustrating, beyond the fundamental, subjective disagreements.&lt;/p&gt;

&lt;p&gt;It’s okay to have opinions. It’s okay to like and dislike things. It’s okay to be frustrated that others don’t see things the way you do, and to advocate for the technologies and values you believe in. It’s just not okay to tell someone else their reality is wrong.&lt;/p&gt;

&lt;p&gt;Learn to embrace the subjective differences between us all, and you won’t just be kinder. You’ll be &lt;em&gt;happier.&lt;/em&gt;&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-10-19-empathy-and-subjective-experience-in-programming-languages-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;This is where I’m supposed to put a snarky footnote saying something like “obviously, the correct way is &lt;em&gt;blah&lt;/em&gt;,” but you deserve better. So you, uh, get a &lt;em&gt;meta&lt;/em&gt; snarky footnote instead.&amp;nbsp;&lt;a href="#2019-10-19-empathy-and-subjective-experience-in-programming-languages-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-10-19-empathy-and-subjective-experience-in-programming-languages-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;Which, to be entirely fair, may well be as subjective as anything else in this blog post.&amp;nbsp;&lt;a href="#2019-10-19-empathy-and-subjective-experience-in-programming-languages-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item>
  <item>
   <title>A space of their own: adding a type namespace to Hackett</title>
   <link>http://lexi-lambda.github.io/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/?utm_source=programming-languages&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett</guid>
   <pubDate>Fri, 27 Oct 2017 17:41:17 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;As previously discussed on this blog, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;my programming language, Hackett&lt;/a&gt;, is a fusion of two languages, Haskell and Racket. What happens when two distinctly different programming languages collide? Hackett recently faced that very problem when it came to the question of namespacing: Haskell has two namespaces, one for values and another for types, but Racket is a staunch Lisp&amp;ndash;1 with a single namespace for all bindings. Which convention should Hackett adopt?&lt;/p&gt;

&lt;p&gt;For now, at least, the answer is that Hackett will emulate Haskell: &lt;strong&gt;Hackett now has two namespaces&lt;/strong&gt;. Of course, Hackett is embedded in Racket, so what did it take to add an entirely new namespace to a language that possesses only one? The answer was a little more than I had hoped, but it was still remarkably simple given the problem: after two weeks of hacking, I’ve managed to get something working.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="why-two-namespaces"&gt;Why two namespaces?&lt;/h1&gt;

&lt;p&gt;Before delving into the mechanics of how multi-namespace Hackett is implemented, it’s important to understand what Hackett’s namespaces actually are and why they exist in the first place. Its host language, Racket, is a descendant of Scheme, a Lisp derivative that famously chose to only use a single namespace. This means everything—from values to functions to classes—lives in a single namespace in Racket.&lt;/p&gt;

&lt;p&gt;This is in stark contrast to Common Lisp, which opts to divide bindings into many namespaces, most notably pushing functions into a separate namespace from other variables. You can see this difference most strikingly when applying higher-order functions. In Racket, Clojure, and Scheme, functions can be passed freely as values:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="nb"&gt;first&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ss"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ss"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ss"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In Common Lisp and other languages with two namespaces, functions may still be passed as values, but the programmer must explicitly &lt;em&gt;annotate&lt;/em&gt; when they wish to use a value from a different namespace:&lt;/p&gt;

&lt;div class="brush: lisp"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcar&lt;/span&gt; &lt;span class="nf"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The Common Lisp &lt;code&gt;#'x&lt;/code&gt; reader abbreviation is equivalent to &lt;code&gt;(function x)&lt;/code&gt;, and &lt;code&gt;function&lt;/code&gt; is a special form that references a value in the function namespace.&lt;/p&gt;

&lt;p&gt;While this distinction is somewhat arbitrary, it is generally my belief that the Scheme approach was, indeed, the right one. Runtime values are values, whether they are numbers, strings, or functions, and they ought to all be treated as equal citizens. After all, if a programmer wishes to define their own function-like thing, they should not be forced to make their abstraction a second-class citizen merely because it is slightly different from the built-in notion of a function. Higher-order functional programming encourages treating functions as ordinary values, and an arbitrary stratification of the namespace is antithetical to that mental model.&lt;/p&gt;

&lt;p&gt;However, Hackett is a little different from all of the aforementioned languages because Hackett has &lt;em&gt;types&lt;/em&gt;. Types are rather different from runtime values because they do not exist at all at runtime. One cannot use a type where a value is expected, nor can one use a value where a type is expected, so this distinction is &lt;em&gt;always&lt;/em&gt; syntactically unambiguous.&lt;sup&gt;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-1-definition" name="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; Even if types and values live in separate namespaces, there is no need for a &lt;code&gt;type&lt;/code&gt; form a la CL’s &lt;code&gt;function&lt;/code&gt; because it can always be determined implicitly.&lt;/p&gt;

&lt;p&gt;For this reason, it makes a great deal of sense for Hackett to have separate type and value namespaces, permitting declarations such as the following:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tuple&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tuple&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This defines a binding named &lt;code&gt;Tuple&lt;/code&gt; at the type level, which is a &lt;em&gt;type constructor&lt;/em&gt; of two arguments that produces a type of kind &lt;code&gt;*&lt;/code&gt;,&lt;sup&gt;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-2-definition" name="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; and another binding named &lt;code&gt;Tuple&lt;/code&gt; at the value level, which is a &lt;em&gt;value constructor&lt;/em&gt; of two arguments that produces a value of type &lt;code&gt;(Tuple a b)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But why do we want to overload names in this way, anyway? How hard would it really be to just name the value constructor &lt;code&gt;tuple&lt;/code&gt; instead of &lt;code&gt;Tuple&lt;/code&gt;? Well, it wouldn’t be hard at all, if it weren’t for the unpleasant ambiguity such a naming convention introduces when pattern-matching. Consider the following code snippet:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;foo-&amp;gt;integer&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;    &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This works fine. But what happens if the programmer decides to change the name of the &lt;code&gt;bar&lt;/code&gt; value?&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;qux&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;foo-&amp;gt;integer&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;    &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[[(&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Can you spot the bug? Disturbingly, this code &lt;em&gt;still compiles&lt;/em&gt;! Even though &lt;code&gt;bar&lt;/code&gt; is not a member of &lt;code&gt;Foo&lt;/code&gt; anymore, it’s still a valid pattern, since names used as patterns match anything, just as the &lt;code&gt;y&lt;/code&gt; pattern matches against any integer inside the &lt;code&gt;baz&lt;/code&gt; constructor. If Hackett had a pattern redundancy checker, it could at least hopefully catch this mistake, but as things are, this could would silently compile and do the wrong thing: &lt;code&gt;(foo-&amp;gt;integer (baz 42))&lt;/code&gt; will still produce &lt;code&gt;0&lt;/code&gt;, not &lt;code&gt;42&lt;/code&gt;, since the first case always matches.&lt;/p&gt;

&lt;p&gt;Haskell escapes this flaw by syntactically distinguishing between patterns and ordinary bindings by requiring all constructors start with an uppercase letter. This means that programmers often want to define data constructors and type constructors with the same name, such as the &lt;code&gt;Tuple&lt;/code&gt; example above, which is illegal if a programming language only supports a single namespace.&lt;/p&gt;

&lt;p&gt;Although Hackett now supports two namespaces, it does not currently enforce this naming convention, but it seems like an increasingly good idea. Separating the namespaces is the biggest hurdle needed to implement such a feature, and happily, it is now complete. The &lt;code&gt;Tuple&lt;/code&gt; example from above is perfectly legal Hackett.&lt;/p&gt;

&lt;h1 id="adding-namespaces-to-a-language"&gt;Adding namespaces to a language&lt;/h1&gt;

&lt;p&gt;Hopefully, we now agree that it would be nice if Hackett had two namespaces, but that doesn’t really get us any closer to being able to &lt;em&gt;implement&lt;/em&gt; such a feature. At its core, Hackett is still a Racket language, and Racket’s binding structure has no notion of namespaces. How can it possibly support a language with more than one namespace?&lt;/p&gt;

&lt;p&gt;Fortunately, Racket is no ordinary language—it is a language with a highly formalized notion of lexical scope, and many of its low-level scope control features are accessible to ordinary programmers. Before we get into the details, however, a forewarning: &lt;strong&gt;the remainder of this blog post is &lt;em&gt;highly technical&lt;/em&gt;, and some of it involves some of the more esoteric corners of Racket’s macro system&lt;/strong&gt;. This blog post is &lt;em&gt;not&lt;/em&gt; representative of most macros written in Racket, nor is it at all necessary to understand these things to be a working Racket or Hackett macrologist. It is certainly not a tutorial on any of these concepts, so if you find it intimidating, there is no shame in skipping the rest of this post! If, however, you think you can handle it, or if you simply want to stare into the sun, by all means, read on.&lt;/p&gt;

&lt;h2 id="namespaces-as-scopes"&gt;Namespaces as scopes&lt;/h2&gt;

&lt;p&gt;With that disclaimer out of the way, let’s begin. As of this writing, the current Racket macroexpander uses a scoping model known as &lt;a href="https://www.cs.utah.edu/plt/scope-sets/"&gt;&lt;em&gt;sets of scopes&lt;/em&gt;&lt;/a&gt;, which characterizes the binding structure of a program by annotating identifiers with sets of opaque markers known as “scopes”. The details of Racket’s macro system are well outside the scope of this blog post, but essentially, two identifiers with the same name can be made to refer to different bindings by adding a unique scope to each identifier.&lt;/p&gt;

&lt;p&gt;Using this system of scopes, it is surprisingly simple to create a system of two namespaces: we only need to arrange for all identifiers in a value position to have a particular scope, which we will call the &lt;em&gt;value scope&lt;/em&gt;, and all identifiers in type position must have a different scope, which we will call the &lt;em&gt;type scope&lt;/em&gt;. How do we create these scopes and apply them to identifiers? In Racket, we use a function called &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._make-syntax-introducer%29%29"&gt;&lt;code&gt;make-syntax-introducer&lt;/code&gt;&lt;/a&gt;, which produces a function that encapsulates a fresh scope. This function can be applied to any syntax object (Racket’s structured representation of code that includes lexical binding information) to do one of three things: it can &lt;em&gt;add&lt;/em&gt; the scope to all pieces of the syntax object, &lt;em&gt;remove&lt;/em&gt; the scope, or &lt;em&gt;flip&lt;/em&gt; the scope (that is, add it to pieces of the syntax object that do not have it and remove it from pieces that do have it). In practice, this means we need to call &lt;code&gt;make-syntax-introducer&lt;/code&gt; once for each namespace:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We define these in a &lt;code&gt;begin-for-syntax&lt;/code&gt; block because these definitions will be used in our compile-time macros (aka “phase 1”), not in runtime code (aka “phase 0”). Now, we can write some macros that use these introducer functions to apply the proper scopes to their contents:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;syntax/parse/define&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Each of these two forms is like &lt;code&gt;begin&lt;/code&gt;, which is a Racket form that is, for our purposes, essentially a no-op, but it applies &lt;code&gt;value-introducer&lt;/code&gt; or &lt;code&gt;type-introducer&lt;/code&gt; to add the appropriate scope. We can test that this works by writing a program that uses the two namespaces:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;value-x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;type-x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This program produces the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'value-x
'type-x&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works! Normally, if you try to define two bindings with the same name in Racket, it will produce a compile-time error, but by assigning them different scopes, we have essentially managed to create two separate namespaces.&lt;/p&gt;

&lt;p&gt;However, although this is close, it isn’t &lt;em&gt;quite&lt;/em&gt; right. What happens if we nest the two inside each other?&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;x: identifier's binding is ambiguous
  context...:
   #(189267 module) #(189268 module anonymous-module 0) #(189464 use-site)
   #(189465 use-site) #(190351 use-site) #(190354 use-site) #(190358 local)
   #(190359 intdef)
  matching binding...:
   #&amp;lt;module-path-index:()&amp;gt;
   #(189267 module) #(189268 module anonymous-module 0) #(189464 use-site)
  matching binding...:
   #&amp;lt;module-path-index:()&amp;gt;
   #(189267 module) #(189268 module anonymous-module 0) #(189465 use-site)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh no! That didn’t work at all. The error is a bit of a scary one, but the top of the error message is essentially accurate: the use of &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;ambiguous&lt;/em&gt; because it has both scopes on it, so it could refer to either binding. What we really want is for nested uses of &lt;code&gt;begin/value&lt;/code&gt; or &lt;code&gt;begin/type&lt;/code&gt; to &lt;em&gt;override&lt;/em&gt; outer ones, ensuring that a use can only be in a single namespace at a time.&lt;/p&gt;

&lt;p&gt;To do this, we simply need to adjust &lt;code&gt;begin/value&lt;/code&gt; and &lt;code&gt;begin/type&lt;/code&gt; to remove the other scope in addition to adding the appropriate one:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/value&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin/type&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt; &lt;span class="n"&gt;form*&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now our nested program runs, and it produces &lt;code&gt;'type-x&lt;/code&gt;, which is exactly what we want—the “nearest” scope wins.&lt;/p&gt;

&lt;p&gt;With just a few lines of code, we’ve managed to implement the two-namespace system Hackett needs: we simply maintain two scopes, one for each namespace, and arrange for all the types to have the type scope applied and everything else to have the value scope applied. Easy, right? Well, not quite. Things start to get a lot more complicated once our programs span more than a single module.&lt;/p&gt;

&lt;h2 id="namespaces-that-cross-module-boundaries"&gt;Namespaces that cross module boundaries&lt;/h2&gt;

&lt;p&gt;The system of using two syntax introducers to manage scopes is wonderfully simple as long as all of our programs are contained within a single module, but obviously, that is never true in practice. It is critical that users are able to export both values and types from one module and import them into another, as that is a pretty fundamental feature of any language. This is, unfortunately, where we start to run into problems.&lt;/p&gt;

&lt;p&gt;Racket’s notion of hygiene is pervasive, but it is still essentially scoped to a single module. This makes sense, since each module conceptually has its own “module scope”, and it wouldn’t be very helpful to inject a binding from a different module with the &lt;em&gt;other&lt;/em&gt; module’s scope—it would be impossible to reference the binding in the importing module. Instead, Racket’s modules essentially export &lt;em&gt;symbols&lt;/em&gt;, not identifiers (which, in Racket terminology, are symbols packaged together with their lexical scope). When a Racket module provides a binding named &lt;code&gt;foo&lt;/code&gt;, there is no other information attached to that binding. It does not have any scopes attached to it, since it is the &lt;code&gt;require&lt;/code&gt; form’s job to attach the correct scopes to imported identifiers.&lt;/p&gt;

&lt;p&gt;This completely makes sense for all normal uses of the Racket binding system, but it has unfortunate implications for our namespace system: Racket modules cannot export more than one binding with a given symbolic name!&lt;sup&gt;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-3-definition" name="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt; This won’t work at all, since a Hackett programmer might very well want to export a type and value with the same name from a single module. Indeed, this capability is one of the primary &lt;em&gt;points&lt;/em&gt; of having multiple namespaces.&lt;/p&gt;

&lt;p&gt;What to do? Sadly, Racket does not have nearly as elegant a solution for this problem, at least not at the time of this writing. Fortunately, hope is not lost. While far from perfect, we can get away with a relatively simple name-mangling scheme to prefix types upon export and unprefix them upon import. Since Racket’s &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;provide&lt;/code&gt; forms are extensible, it’s even possible to implement this mangling in a completely invisible way.&lt;/p&gt;

&lt;p&gt;Currently, the scheme that Hackett uses is to prefix &lt;code&gt;#%hackett-type:&lt;/code&gt; onto the beginning of any type exports. This can be defined in terms of a &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28tech._provide._pre._transformer%29"&gt;&lt;em&gt;provide pre-transformer&lt;/em&gt;&lt;/a&gt;, which is essentially a macro that cooperates with Racket’s &lt;code&gt;provide&lt;/code&gt; form to control the export process. In this case, we can define our &lt;code&gt;type-out&lt;/code&gt; provide pre-transformer in terms of &lt;a href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prefix-out%29%29"&gt;&lt;code&gt;prefix-out&lt;/code&gt;&lt;/a&gt;, a form built-in to Racket that allows prefixing the names of exports:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;type-out&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-provide-pre-transformer&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stx&lt;/span&gt; &lt;span class="n"&gt;modes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parse&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
       &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;provide-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pre-expand-export&lt;/span&gt;
         &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prefix-out&lt;/span&gt; &lt;span class="n"&gt;#%hackett-type:&lt;/span&gt;
                       &lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt;
                          &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;combine-out&lt;/span&gt; &lt;span class="n"&gt;provide-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="n"&gt;modes&lt;/span&gt;&lt;span class="p"&gt;)]))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that we call &lt;code&gt;type-introducer&lt;/code&gt; in this macro! That’s because we want to ensure that, when a user writes &lt;code&gt;(provide (type-out Foo))&lt;/code&gt;, we look for &lt;code&gt;Foo&lt;/code&gt; in the module’s type namespace. Of course, once it is provided, all that scoping information is thrown away, but we still need it around so that &lt;code&gt;provide&lt;/code&gt; knows &lt;em&gt;which&lt;/em&gt; &lt;code&gt;Foo&lt;/code&gt; is being provided.&lt;/p&gt;

&lt;p&gt;Once we have referenced the correct binding, the use of &lt;code&gt;prefix-out&lt;/code&gt; will appropriately add the &lt;code&gt;#%hackett-type:&lt;/code&gt; prefix, so the exporting side is already done. Users do need to explicitly write &lt;code&gt;(type-out ....)&lt;/code&gt; if they are exporting a particular type-level binding, but this is rarely necessary, since most users use &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; to export datatypes or typeclasses respectively, which can be modified to use &lt;code&gt;type-out&lt;/code&gt; internally. Very little user code actually needs to change to support this adjustment.&lt;/p&gt;

&lt;p&gt;Handling imports is, comparatively, tricky. When exporting, we can just force the user to annotate which exports are types, but we don’t have that luxury when importing, since it is merely whether or not a binding has the &lt;code&gt;#%hackett-type:&lt;/code&gt; prefix that indicates which namespace it should be imported into. This means we’ll need to explicitly iterate through every imported binding and check if it has the prefix or not. If it does, we need to strip it off and add the type namespace; otherwise, we just pass it through unchanged.&lt;/p&gt;

&lt;p&gt;Just as we extended &lt;code&gt;provide&lt;/code&gt; with a provide pre-transformer, we can extend &lt;code&gt;require&lt;/code&gt; using a &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28tech._require._transformer%29"&gt;&lt;em&gt;require transformer&lt;/em&gt;&lt;/a&gt;. In code, this entire process looks like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unmangle-type-name&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;and~&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;regexp-match&lt;/span&gt; &lt;span class="sr"&gt;#rx"^#%hackett-type:(.+)$"&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define-syntax&lt;/span&gt; &lt;span class="n"&gt;unmangle-types-in&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;make-require-transformer&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syntax-parser&lt;/span&gt;
     &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="kd"&gt;#:do&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;define-values&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;imports&lt;/span&gt; &lt;span class="n"&gt;sources&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expand-import&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;combine-in&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;values&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;match-lambda&lt;/span&gt;
              &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;local-id&lt;/span&gt; &lt;span class="n"&gt;src-sym&lt;/span&gt; &lt;span class="n"&gt;src-mod-path&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;req-mode&lt;/span&gt; &lt;span class="n"&gt;orig-mode&lt;/span&gt; &lt;span class="n"&gt;orig-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;local-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol-&amp;gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;syntax-e&lt;/span&gt; &lt;span class="n"&gt;local-id&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;unmangled-type-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unmangle-type-name&lt;/span&gt; &lt;span class="n"&gt;local-name&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;unmangled-type-name&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;unmangled-id&lt;/span&gt;
                             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="n"&gt;local-id&lt;/span&gt;
                                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;string-&amp;gt;symbol&lt;/span&gt; &lt;span class="n"&gt;unmangled-type-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                            &lt;span class="n"&gt;local-id&lt;/span&gt;
                                            &lt;span class="n"&gt;local-id&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="n"&gt;unmangled-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                               &lt;span class="n"&gt;src-sym&lt;/span&gt; &lt;span class="n"&gt;src-mod-path&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="n"&gt;req-mode&lt;/span&gt; &lt;span class="n"&gt;orig-mode&lt;/span&gt; &lt;span class="n"&gt;orig-stx&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                     &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
            &lt;span class="n"&gt;imports&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="n"&gt;sources&lt;/span&gt;&lt;span class="p"&gt;)])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is a little intimidating if you are not familiar with the intricacies of Racket’s low-level macro system, but the bulk of the code isn’t as scary as it may seem. It essentially does three things:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;It iterates over each import and calls &lt;code&gt;unmangle-type-name&lt;/code&gt; on the imported symbol. If the result is &lt;code&gt;#f&lt;/code&gt;, that means the import does not have the &lt;code&gt;#%hackett-type:&lt;/code&gt; prefix, and it can be safely passed through unchanged.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If &lt;code&gt;unmangle-type-name&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; return &lt;code&gt;#f&lt;/code&gt;, then it returns the unprefixed name, which is then provided to &lt;code&gt;datum-&amp;gt;syntax&lt;/code&gt;, which allows users to forge new identifiers in an &lt;em&gt;unhygienic&lt;/em&gt; (or “hygiene-bending”) way. In this case, we want to forge a new identifier with the name we get back from &lt;code&gt;unmangle-type-name&lt;/code&gt;, but with the lexical context of the original identifier.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, we pass the new identifier to &lt;code&gt;type-introducer&lt;/code&gt; to properly add the type scope, injecting the fresh binding into the type namespace.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;With this in place, we now have a way for Hackett users to import and export type bindings, but while it is not much of a burden to write &lt;code&gt;type-out&lt;/code&gt; when exporting types, it is unlikely that users will want to write &lt;code&gt;unmangle-types-in&lt;/code&gt; around each and every import in their program. For that reason, we can define a slightly modified version of &lt;code&gt;require&lt;/code&gt; that implicitly wraps all of its subforms with &lt;code&gt;unmangle-types-in&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;provide&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;rename-out&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;require/unmangle&lt;/span&gt; &lt;span class="k"&gt;require&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;require/unmangle&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unmangle-types-in&lt;/span&gt; &lt;span class="n"&gt;require-spec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;…and we’re done. Now, Hackett modules can properly import and export type-level bindings.&lt;/p&gt;

&lt;h2 id="namespaces-plus-submodules-the-devils-in-the-details"&gt;Namespaces plus submodules: the devil’s in the details&lt;/h2&gt;

&lt;p&gt;Up until this point, adding namespaces has required some understanding of the nuances of Racket’s macro system, but it hasn’t been particularly difficult to implement. However, getting namespaces right is a bit trickier than it appears. One area where namespaces are less than straightforward is Racket’s system of &lt;em&gt;submodules&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Submodules are a Racket feature that allows the programmer to arbitrarily nest modules. Each file always corresponds to a single outer module, but that module can contain an arbitrary number of submodules. Each submodule can have its own “module language”, which even allows different languages to be mixed within a single file.&lt;/p&gt;

&lt;p&gt;Submodules in Racket come in two flavors: &lt;code&gt;module&lt;/code&gt; and &lt;code&gt;module*&lt;/code&gt;. The difference is what order, semantically, they are defined in. Submodules defined with &lt;code&gt;module&lt;/code&gt; are essentially defined &lt;em&gt;before&lt;/em&gt; their enclosing module, so they cannot import their enclosing module, but their enclosing module can import them. Modules defined with &lt;code&gt;module*&lt;/code&gt; are the logical dual to this: they are defined after their enclosing module, so they can import their enclosing module, but the enclosing module cannot import them.&lt;/p&gt;

&lt;p&gt;How do submodules interact with namespaces? Well, for the most part, they work totally fine. This is because submodules are really, for the most part, treated like any other module, so the same machinery that works for ordinary Racket modules works fine with submodules.&lt;/p&gt;

&lt;p&gt;However, there is &lt;a href="https://docs.racket-lang.org/guide/Module_Syntax.html#%28part._submodules%29"&gt;a special sort of &lt;code&gt;module*&lt;/code&gt; submodule that uses &lt;code&gt;#f&lt;/code&gt; in place of a module language&lt;/a&gt;, which gives a module access to &lt;em&gt;all&lt;/em&gt; of its enclosing module’s bindings, even ones that aren’t exported! This is commonly used to create a &lt;code&gt;test&lt;/code&gt; submodule that contains unit tests, and functions can be tested in such a submodule even if they are not part of the enclosing module’s public API:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="c1"&gt;; not provided&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;private-add1&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;module*&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;rackunit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;check-equal?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;private-add1&lt;/span&gt; &lt;span class="mi"&gt;41&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It would be nice to be able to use these sorts of submodules in Hackett, too, but if we try, we’ll find that types from the enclosing module mysteriously can’t be referenced by the submodule. Why? Well, the issue is in how we naïvely create our type and value introducers:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Remember that &lt;code&gt;make-syntax-introducer&lt;/code&gt; is generative—each time it is called, it produces a function that operates on a fresh scope. This is a problem, since those functions will be re-evaluated on every module &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28tech._instantiate%29"&gt;instantiation&lt;/a&gt;, as ensured by Racket’s &lt;a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._separate-compilation%29"&gt;separate compilation guarantee&lt;/a&gt;. This means that each module gets its &lt;em&gt;own&lt;/em&gt; pair of scopes. This means the body of a &lt;code&gt;module*&lt;/code&gt; submodule will have different scopes from its enclosing module, and the enclosing modules bindings will not be accessible.&lt;/p&gt;

&lt;p&gt;Fortunately, there is a way to circumvent this. While we cannot directly preserve syntax introducers across module instantiations, we &lt;em&gt;can&lt;/em&gt; preserve syntax objects by embedding them in the expanded program, and we can attach scopes to syntax objects. Using &lt;a href="https://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._make-syntax-delta-introducer%29%29"&gt;&lt;code&gt;make-syntax-delta-introducer&lt;/code&gt;&lt;/a&gt;, we can create a syntax introducer the adds or removes the &lt;em&gt;difference&lt;/em&gt; between scopes on two syntax objects. Pairing this with a little bit of clever indirection, we can arrange for &lt;code&gt;value-introducer&lt;/code&gt; and &lt;code&gt;type-introducer&lt;/code&gt; to always operate on the same scopes on each module instantiation:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-simple-macro&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-value/type-introducers&lt;/span&gt;
                       &lt;span class="n"&gt;value-introducer:id&lt;/span&gt; &lt;span class="n"&gt;type-introducer:id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;scopeless-id&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;datum-&amp;gt;syntax&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt; &lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;introducer-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;value-id&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kd"&gt;#:with&lt;/span&gt; &lt;span class="n"&gt;type-id&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-introducer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;begin-for-syntax&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-delta-introducer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;value-id&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-syntax-delta-introducer&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;type-id&lt;/span&gt; &lt;span class="o"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;scopeless-id&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-value/type-introducers&lt;/span&gt; &lt;span class="n"&gt;value-introducer&lt;/span&gt; &lt;span class="n"&gt;type-introducer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The way this trick works is subtle, but to understand it, it’s important to understand that when a module is compiled, its macro uses are only evaluated once. Subsequent imports of the same module will not re-expand the module. &lt;em&gt;However&lt;/em&gt;, code inside &lt;code&gt;begin-for-syntax&lt;/code&gt; blocks is still re-evaluated every time the module is instantiated! This means we are &lt;em&gt;not&lt;/em&gt; circumventing that re-evaluation directly, we are merely arranging for each re-evaluation to always produce the same result.&lt;/p&gt;

&lt;p&gt;We still use &lt;code&gt;make-syntax-introducer&lt;/code&gt; to create our two scopes, but critically, we only call &lt;code&gt;make-syntax-introducer&lt;/code&gt; inside the &lt;code&gt;define-value/type-introducers&lt;/code&gt; macro, which is, again, only run once (when the module is expanded). The resulting compiled module embeds &lt;code&gt;value-id&lt;/code&gt; and &lt;code&gt;type-id&lt;/code&gt; as syntax objects in the fully-expanded program, so they never change on each module instantiation, and they already contain the appropriate scopes. We can use &lt;code&gt;make-syntax-delta-introducer&lt;/code&gt; to convert the “inert” scopes into introducer functions that we can use to apply the scopes to other syntax objects as we see fit.&lt;/p&gt;

&lt;p&gt;By guaranteeing each namespace’s scope is always the same, even for different modules, &lt;code&gt;module*&lt;/code&gt; submodules now work properly, and they are able to refer to bindings inherited from their enclosing module as desired.&lt;/p&gt;

&lt;h2 id="the-final-stretch-making-scribble-documentation-namespace-aware"&gt;The final stretch: making Scribble documentation namespace-aware&lt;/h2&gt;

&lt;p&gt;As discussed in &lt;a href="/blog/2017/08/28/hackett-progress-report-documentation-quality-of-life-and-snake/"&gt;my previous blog post&lt;/a&gt;, Hackett has comprehensive documentation powered by Racket’s excellent documentation tool, Scribble. Fortunately for Hackett, Scribble is incredibly flexible, and it can absolutely cope with a language with multiple namespaces. Less fortunately, it is clear that Scribble’s built-in documentation forms were not at all designed with multiple namespaces in mind.&lt;/p&gt;

&lt;p&gt;In general, documenting such a language is tricky, assuming one wishes all identifiers to be properly hyperlinked to their appropriate definition (which, of course, I do). However, documentation is far more ambiguous than code when attempting to determine which identifiers belong in which namespace. When actually writing Hackett code, forms can always syntactically deduce the appropriate namespace for their subforms and annotate them accordingly, but this is not true in documentation. Indeed, it’s entirely possible that a piece of documentation might include intentionally incorrect code, which cannot be expanded at all!&lt;/p&gt;

&lt;p&gt;Haskell’s documentation tool, Haddock, does not appear to attempt to tackle this problem at all—when given an identifier that exists in both namespaces, it will generate a hyperlink to the type, not the value. I do not know if there is a way around this, but if there is, it isn’t documented. This works alright for Haddock because Haskell’s documentation generally contains fewer examples, and Haskell programmers do not expect all examples to be appropriately hyperlinked, so a best-effort approach is accepted. Racket programmers, however, are used to a very high standard of documentation, and incorrectly hyperlinked docs are unacceptable.&lt;/p&gt;

&lt;p&gt;To work around this problem, Hackett’s documentation requires that users explicitly annotate which identifiers belong to the type namespace. Identifiers in the type namespace are prefixed with &lt;code&gt;t:&lt;/code&gt; upon import, and they are bound to Scribble &lt;a href="https://docs.racket-lang.org/scribble/scheme.html#%28tech._element._transformer%29"&gt;&lt;em&gt;element transformers&lt;/em&gt;&lt;/a&gt; that indicate they should be typeset without the &lt;code&gt;t:&lt;/code&gt; prefix. Fortunately, Scribble’s documentation forms &lt;em&gt;do&lt;/em&gt; understand Racket’s model of lexical scope (mostly), so they can properly distinguish between two identifiers with the same name but different lexical context.&lt;/p&gt;

&lt;p&gt;In practice, this means Hackett documentation must now include a proliferation of &lt;code&gt;t:&lt;/code&gt; prefixes. For example, here is the code for a typeset REPL interaction:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hackett-examples&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defn&lt;/span&gt; &lt;span class="n"&gt;square&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t:-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;t:Integer&lt;/span&gt; &lt;span class="n"&gt;t:Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;}])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;square&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note the use of &lt;code&gt;t:-&amp;gt;&lt;/code&gt; and &lt;code&gt;t:Integer&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;Integer&lt;/code&gt;. When the documentation is rendered and the example is evaluated, the prefixes are stripped, resulting in properly-typeset Hackett code.&lt;/p&gt;

&lt;p&gt;This also means Hackett’s documentation forms have been updated to understand multiple namespaces. Hackett now provides &lt;code&gt;deftype&lt;/code&gt; and &lt;code&gt;deftycon&lt;/code&gt; forms for documenting types and type constructors, respectively, which will use the additional lexical information attached to &lt;code&gt;t:&lt;/code&gt;-prefixed identifiers to properly index documented forms. Similarly, &lt;code&gt;defdata&lt;/code&gt; and &lt;code&gt;defclass&lt;/code&gt; have been updated with an understanding of types.&lt;/p&gt;

&lt;p&gt;The implementation details of these changes is less interesting than the ones made to the code itself, since it mostly just involved tweaking Racket’s implementation of &lt;code&gt;defform&lt;/code&gt; slightly to cooperate with the prefixed identifiers. To summarize, Hackett defines a notion of “type binding transformers” that include information about both prefixed and unprefixed versions of types, and Hackett provides documentation forms that consume that information when typesetting. A require transformer converts imported bindings into &lt;code&gt;t:&lt;/code&gt;-prefixed ones and attaches the necessary compile-time information to them. It isn’t especially elegant, but it works.&lt;/p&gt;

&lt;h1 id="analysis-and-unsolved-problems"&gt;Analysis and unsolved problems&lt;/h1&gt;

&lt;p&gt;When laid out from top to bottom in this blog post, the amount of code it takes to actually implement multiple namespaces in Racket is surprisingly small. In hindsight, it does not feel like two weeks worth of effort, but it would be disingenuous to suggest that any of this was obvious. I tried a variety of different implementation strategies and spent a great deal of time staring at opaque error messages and begging &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt; for help before I got things working properly. Fortunately, with everything in place, the implementation seems reliable, predictable, and useful for Hackett’s users (or, as the case may be, users-to-be).&lt;/p&gt;

&lt;p&gt;For the most part, all the machinery behind multiple namespaces is invisible to the average Hackett programmer, and it seems to “just work”. For completeness, however, I must mention one unfortunate exception: remember the work needed to unmangle type names? While it’s true that all imports into Hackett modules are automatically unmangled by the custom &lt;code&gt;require&lt;/code&gt; form, types provided by a module’s &lt;em&gt;language&lt;/em&gt; are not automatically unmangled. This is because Racket does not currently provide a hook to customize how bindings from a module language are introduced, unlike &lt;code&gt;require&lt;/code&gt;’s require transformers.&lt;/p&gt;

&lt;p&gt;To circumvent this restriction, &lt;code&gt;#lang hackett&lt;/code&gt;’s reader includes a somewhat ad-hoc solution that actually inserts a &lt;code&gt;require&lt;/code&gt; into users’ programs that unmangles and imports all the types provided by the module. This mostly works, but due to the way Racket’s imports work, it isn’t possible for Racket programmers to import different types with the same names as Hackett core types; the two bindings will conflict, and there is no way for users to hide these implicitly imported bindings. Whether or not this is actually a common problem remains to be seen. If it is rare, it might be sufficient to introduce an ad-hoc mechanism to hide certain type imports, but it might be better to extend Racket in some way to better support this use-case.&lt;/p&gt;

&lt;p&gt;That issue aside, multi-namespace Hackett is now working smoothly. It’s worth nothing that I did not have to do &lt;em&gt;any&lt;/em&gt; special work to help Racket’s tooling, such as DrRacket’s Check Syntax tool, understand the binding structure of Hackett programs. Since other tools, such as racket-mode for Emacs, use the same mechanisms under the hood, Racket programmers’ existing tools will be able to properly locate the distinct definition sites for types and values with the same name, another example of how Racket successfully &lt;a href="http://www.ccs.neu.edu/home/matthias/manifesto/sec_intern.html"&gt;internalizes extra-linguistic mechanisms&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As closing notes, even if the majority of this blog post was gibberish to you, do note that Hackett has come quite a long way in just the past two months, adding much more than just a separate type namespace. I might try and give a more comprehensive update at a later date, but here’s a quick summary of the meaningful changes for those interested:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Multi-parameter typeclasses&lt;/strong&gt; are implemented, along with &lt;strong&gt;default typeclass method implementations&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Pattern-matching performs basic &lt;strong&gt;exhaustiveness checking&lt;/strong&gt;, so unmatched cases are a compile-time error.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Hackett ships with a &lt;strong&gt;larger standard library&lt;/strong&gt;, including an &lt;code&gt;Either&lt;/code&gt; type and appropriate functions, an &lt;code&gt;Identity&lt;/code&gt; type, a &lt;code&gt;MonadTrans&lt;/code&gt; typeclass, and the &lt;code&gt;ReaderT&lt;/code&gt; and &lt;code&gt;ErrorT&lt;/code&gt; monad transformers.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;More things are documented&lt;/strong&gt;, and parts of the documentation are slightly improved. Additionally, &lt;strong&gt;Hackett’s internals are much more heavily commented&lt;/strong&gt;, hopefully making the project more accessible to new contributors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Parts of the typechecker are dramatically simplified&lt;/strong&gt;, improving the mechanisms behind dictionary elaboration and clearing the way for a variety of additional long-term improvements, including multiple compilation targets and a type-aware optimizer.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;As always, various bug fixes.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Finally, special mention to two new contributors to Hackett, &lt;a href="https://github.com/iitalics"&gt;Milo Turner&lt;/a&gt; and &lt;a href="https://github.com/Shamrock-Frost"&gt;Brendan Murphy&lt;/a&gt;. Also special thanks to &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt; and &lt;a href="https://github.com/michaelballantyne"&gt;Michael Ballantyne&lt;/a&gt; for helping me overcome two of the trickiest macro-related problems I’ve encountered in Hackett to date. It has now been just over a year since Hackett’s original conception and roughly six months since the first commit of its current implementation, and the speed at which I’ve been able to work would not have been possible without the valuable help of the wonderful Racket community. Here’s hoping this is only the beginning.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;“But what about dependent types?” you may ask. Put simply, Hackett is not dependently typed, and it is not going to be dependently typed. Dependent types are currently being bolted onto Haskell, but Haskell does not have &lt;code&gt;#lang&lt;/code&gt;. Racket does. It seems likely that a dependently-typed language would be much more useful as a separate &lt;code&gt;#lang&lt;/code&gt;, not a modified version of Hackett, so Hackett can optimize its user experience for what it &lt;em&gt;is&lt;/em&gt;, not what it might be someday.&amp;nbsp;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;Hackett does not actually have a real kind system yet, but pleasantly, this same change will allow &lt;code&gt;*&lt;/code&gt; to be used to mean “type” at the kind level and “multiply” at the value level.&amp;nbsp;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;This isn’t strictly true, as readers familiar with Racket’s macro system may likely be aware that Racket modules export bindings at different “phase levels”, where phase levels above 0 correspond to compile-time macroexpansion phases. Racket modules are allowed to export a single binding per name, &lt;em&gt;per phase&lt;/em&gt;, so the same symbolic name can be bound to different things at different phases. This isn’t meaningfully relevant for Hackett, however, since types and values are both exported at phase 0, and there are reasons that must be the case, this phase separation does not make this problem any simpler.&amp;nbsp;&lt;a href="#2017-10-27-a-space-of-their-own-adding-a-type-namespace-to-hackett-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item>
  <item>
   <title>Realizing Hackett, a metaprogrammable Haskell</title>
   <link>http://lexi-lambda.github.io/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/?utm_source=programming-languages&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2017-05-27-realizing-hackett-a-metaprogrammable-haskell</guid>
   <pubDate>Sat, 27 May 2017 15:30:00 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;&lt;a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"&gt;Almost five months ago, I wrote a blog post about my new programming language, Hackett&lt;/a&gt;, a fanciful sketch of a programming language from a far-off land with Haskell’s type system and Racket’s macros. At that point in time, I had a little prototype that barely worked, that I barely understood, and was a little bit of a technical dead-end. People saw the post, they got excited, but development sort of stopped.&lt;/p&gt;

&lt;p&gt;Then, almost two months ago, I took a second stab at the problem in earnest. I read a lot, I asked a lot of people for help, and eventually I got something sort of working. Suddenly, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Hackett is not only real, it’s working, and you can try it out yourself&lt;/a&gt;!&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="a-first-look-at-hackett"&gt;A first look at Hackett&lt;/h1&gt;

&lt;p&gt;Hackett is still very new, very experimental, and an enormous work in progress. However, that doesn’t mean it’s useless! Hackett is already a remarkably capable programming language. Let’s take a quick tour.&lt;/p&gt;

&lt;p&gt;As Racket law decrees it, every Hackett program must begin with &lt;code&gt;#lang&lt;/code&gt;. We can start with the appropriate incantation:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If you’re using DrRacket or racket-mode with background expansion enabled, then congratulations: the typechecker is online. We can begin by writing a well-typed, albeit boring program:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="s2"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In Hackett, a use of &lt;code&gt;main&lt;/code&gt; at the top level indicates that running the module as a program should execute some &lt;code&gt;IO&lt;/code&gt; action. In this case, &lt;code&gt;println&lt;/code&gt; is a function of type &lt;code&gt;{String -&amp;gt; (IO Unit)}&lt;/code&gt;. Just like Haskell, Hackett is pure, and the runtime will figure out how to actually run an &lt;code&gt;IO&lt;/code&gt; value. If you run the above program, you will notice that it really does print out &lt;code&gt;Hello, world!&lt;/code&gt;, exactly as we would like.&lt;/p&gt;

&lt;p&gt;Of course, hello world programs are boring—so imperative! We are functional programmers, and we have our &lt;em&gt;own&lt;/em&gt; class of equally boring programs we must write when learning a new language. How about some Fibonacci numbers?&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt; &lt;span class="n"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zip-with&lt;/span&gt; &lt;span class="nb"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail!&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;))})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;take&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Again, Hackett is just like Haskell in that it is &lt;em&gt;lazy&lt;/em&gt;, so we can construct an infinite list of Fibonacci numbers, and the runtime will happily do nothing at all. When we call &lt;code&gt;take&lt;/code&gt;, we realize the first ten numbers in the list, and when you run the program, you should see them printed out, clear as day!&lt;/p&gt;

&lt;p&gt;But these programs are boring. Printing strings and laziness may have been novel when you first learned about them, but if you’re reading this blog post, my bet is that you probably &lt;em&gt;aren’t&lt;/em&gt; new to programming. How about something more interesting, &lt;strong&gt;like a web server&lt;/strong&gt;?&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;hackett&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;require&lt;/span&gt; &lt;span class="n"&gt;hackett/demo/web-server&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;Greeting&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greeting&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;-&amp;gt;Body&lt;/span&gt; &lt;span class="n"&gt;Greeting&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;-&amp;gt;body&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;λ&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;greeting&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;"Hello, "&lt;/span&gt; &lt;span class="n"&gt;++&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;++&lt;/span&gt; &lt;span class="s2"&gt;"!"&lt;/span&gt;&lt;span class="p"&gt;})])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;defserver&lt;/span&gt; &lt;span class="n"&gt;run-server&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GET&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;               &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;   &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s2"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GET&lt;/span&gt; &lt;span class="s2"&gt;"greet"&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Greeting&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt; &lt;span class="s2"&gt;"Running server on port 8080."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;run-server&lt;/span&gt; &lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;br /&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ racket my-server.rkt
Running server on port &lt;span class="m"&gt;8080&lt;/span&gt;.
^Z
$ &lt;span class="nb"&gt;bg&lt;/span&gt;
$ curl &lt;span class="s1"&gt;&amp;#39;http://localhost:8080/greet/Alexis&amp;#39;&lt;/span&gt;
Hello, Alexis!
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Welcome to Hackett.&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id="what-is-hackett"&gt;What is Hackett?&lt;/h1&gt;

&lt;p&gt;Excited yet? I hope so. I certainly am.&lt;/p&gt;

&lt;p&gt;Before you get a little &lt;em&gt;too&lt;/em&gt; excited, however, let me make a small disclaimer: the above program, while quite real, is a demo. It is certainly not a production web framework, and it actually just uses the Racket web server under the hood. It does not handle very many things right now. You cannot use it to build your super awesome webapp, and even if you could, I would not recommend attempting to do so.&lt;/p&gt;

&lt;p&gt;All that said, it is a &lt;em&gt;real&lt;/em&gt; tech demo, and it shows off the potential for Hackett to do some pretty cool things. While the server implementation is just reusing Racket’s dynamically typed web server, the Hackett interface to it is 100% statically typed, and the above example shows off a host of features:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Algebraic datatypes.&lt;/strong&gt; Hackett has support for basic ADTs, including recursive datatypes (though not yet mutually recursive datatypes).&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Typeclasses.&lt;/strong&gt; The demo web server uses a &lt;code&gt;-&amp;gt;Body&lt;/code&gt; typeclass to render server responses, and this module implements a &lt;code&gt;-&amp;gt;Body&lt;/code&gt; instance for the custom &lt;code&gt;Greeting&lt;/code&gt; datatype.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Macros.&lt;/strong&gt; The &lt;code&gt;defserver&lt;/code&gt; macro provides a concise, readable, &lt;em&gt;type safe&lt;/em&gt; way to define a simple, RESTful web server. It defines two endpoints, a homepage and a greeting, and the latter parses a segment from the URL.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Static typechecking.&lt;/strong&gt; Obviously. If you try and change the homepage endpoint to produce a number instead of a string, you will get a type error! Alternatively, try removing the &lt;code&gt;-&amp;gt;Body&lt;/code&gt; instance and see what happens.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Infix operators.&lt;/strong&gt; In Hackett, &lt;code&gt;{&lt;/code&gt; curly braces &lt;code&gt;}&lt;/code&gt; enter &lt;em&gt;infix mode&lt;/em&gt;, which permits arbitrary infix operators. Most Lisps have variadic functions, so infix operators are not strictly necessary, but Hackett only supports curried, single-argument functions, so infix operators are some especially sweet sugar.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Pure, monadic I/O.&lt;/strong&gt; The &lt;code&gt;println&lt;/code&gt; and &lt;code&gt;run-server&lt;/code&gt; functions both produce &lt;code&gt;(IO Unit)&lt;/code&gt;, and &lt;code&gt;IO&lt;/code&gt; is a monad. &lt;code&gt;do&lt;/code&gt; notation is provided as a macro, and it works with any type that implements the &lt;code&gt;Monad&lt;/code&gt; typeclass.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;All these features are already implemented, and they really work! Of course, you might look at this list and be a little confused: sure, there are macros, but all these other things are firmly Haskellisms. If you thought that, you’d be quite right! &lt;strong&gt;Hackett is much closer to Haskell than Racket, even though it is syntactically a Lisp.&lt;/strong&gt; Keep this guiding principal in mind as you read this blog post or explore Hackett. Where Haskell and Racket conflict, Hackett usually prefers Haskell.&lt;/p&gt;

&lt;p&gt;For a bit more information about what Hackett is and what it aims to be, &lt;a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"&gt;check out my blog post from a few months ago&lt;/a&gt; from back when Hackett was called Rascal. I won’t reiterate everything I said there, but I do want to give a bit of a status update, explain what I’ve been working on, and hopefully give you some idea about where Hackett is going.&lt;/p&gt;

&lt;h1 id="the-story-so-far-and-getting-to-hackett-01"&gt;The story so far, and getting to Hackett 0.1&lt;/h1&gt;

&lt;p&gt;In September of 2016, I attended &lt;a href="http://con.racket-lang.org/2016/"&gt;(sixth RacketCon)&lt;/a&gt;, where I saw a &lt;a href="https://www.youtube.com/watch?v=j5Hauz6cewM"&gt;pretty incredible and extremely exciting talk&lt;/a&gt; about implementing type systems as macros. Finally, I could realize my dream of having an elegant Lisp with a safe, reliable macro system and a powerful, expressive type system! Unfortunately, reality ensued, and I remembered I didn’t actually know any type theory.&lt;/p&gt;

&lt;p&gt;Therefore, in October, I started to learn about type systems, and I began to read through Pierce’s Types and Programming Languages, then tried to learn the things I would need to understand Haskell’s type system. I learned about Hindley-Milner and basic typeclasses, and I tried to apply these things to the Type Systems as Macros approach. Throughout October, I hacked and I hacked, and by the end of the month, I stood back and admired my handiwork!&lt;/p&gt;

&lt;p&gt;…it &lt;em&gt;sort of&lt;/em&gt; worked?&lt;/p&gt;

&lt;p&gt;The trouble was that I found myself stuck. I wasn’t sure how to proceed. My language had bugs, programs sometimes did things I didn’t understand, the typechecker was clearly unsound, and there didn’t seem to be an obvious path forward. Other things in my life became distracting or difficult, and I didn’t have the energy to work on it anymore, so I stopped. I put Hackett (then Rascal) on the shelf for a couple months, only to finally return to it in late December.&lt;/p&gt;

&lt;p&gt;At the beginning of January, I decided it would be helpful to be public about what I was working on, so I wrote a blog post! Feedback was positive, overwhelmingly so, and while it was certainly encouraging, I suddenly felt nervous about expectations I had not realized I was setting. Could I really build this? Did I have the knowledge or the time? At that point, I didn’t really, so work stalled.&lt;/p&gt;

&lt;p&gt;Fortunately, in early April, some things started to become clear. I took another look at Hackett, and I knew I needed to reimplement it from the ground up. I also knew that I needed a different technique, but this time, I knew a bit more about where to find it. I got some help from &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt; and put together &lt;a href="https://gist.github.com/lexi-lambda/045ba782c8a0d915bd8abf97167d3bb5"&gt;an implementation of Pierce and Turner’s Local Type Inference&lt;/a&gt;. Unfortunately, it didn’t really provide the amount of type inference I was looking for, but fortunately, implementing it helped me figure out how to understand the rather more complicated (though very impressive) &lt;a href="http://www.cs.cmu.edu/~joshuad/papers/bidir/"&gt;Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism&lt;/a&gt;. After that, things just sort of started falling into place:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;First, I &lt;a href="https://github.com/lexi-lambda/higher-rank"&gt;implemented the Complete and Easy paper in Haskell&lt;/a&gt;, including building a little parser and interpreter. That helped me actually understand the paper, and Haskell really is a rather wonderful language for doing such a thing.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Three days later, I &lt;a href="https://github.com/lexi-lambda/racket-higher-rank"&gt;ported the Haskell implementation to Racket&lt;/a&gt;, using (and somewhat abusing) the Type Systems as Macros techniques. It wasn’t the prettiest, but it seemed to work, and that was rather encouraging.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;After that, however, I got a little stuck again, as I wasn’t sure how to generalize what I had. I was also incredibly busy with my day job, and I wasn’t able to really make progress for a few weeks. In early May, however, I decided to &lt;a href="https://twitter.com/lexi_lambda/status/865026650487967744"&gt;take a vacation&lt;/a&gt; for a week, and with some time to focus, I &lt;a href="https://github.com/lexi-lambda/higher-rank/tree/algebraic"&gt;souped up the Haskell implementation with products and sums&lt;/a&gt;. This was progress!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The &lt;em&gt;following day&lt;/em&gt; I managed to make &lt;a href="https://github.com/lexi-lambda/racket-higher-rank/tree/type-constructors"&gt;similar changes to the Racket implementation&lt;/a&gt;, but rather than add anonymous products and sums, I added arbitrary type constructors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;A couple days later and with more than a bit of help from &lt;a href="http://functorial.com"&gt;Phil Freeman&lt;/a&gt;, I &lt;a href="https://github.com/lexi-lambda/hackett/commit/1fd7fc905b93f68e39b9d01fedc4fb52aa44c4c4"&gt;rebranded the Racket implementation as Hackett, Mk II&lt;/a&gt;, and I started working towards turning it into a real programming language.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Less than three weeks later&lt;/em&gt;, and I have a programming language with everything from laziness and typeclasses to a tiny, proof-of-concept web server with &lt;a href="https://twitter.com/lexi_lambda/status/867617563206758400"&gt;editor support&lt;/a&gt;. The future of Hackett looks bright, and though there’s a &lt;em&gt;lot&lt;/em&gt; of work left before I will be even remotely satisfied with it, I am excited and reassured that it already seems to be bearing some fruit.&lt;/p&gt;

&lt;p&gt;So what’s left? Is Hackett ready for an initial release? Can you start writing programs in it today? Well, unfortunately, the answer is mostly &lt;strong&gt;no&lt;/strong&gt;, at least if you want those programs to be at all reliable in a day or two. If everything looks so cheery, though, what’s left? What is Hackett still missing?&lt;/p&gt;

&lt;h2 id="what-hackett-still-isnt"&gt;What Hackett still &lt;em&gt;isn’t&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;I have a laundry list of features I want for Hackett. I want GADTs, indexed type families, newtype deriving, and a compiler that can target multiple backends. These things, however, are not essential. You can probably imagine writing useful software without any of them. Before I can try to tackle those, I first need to tackle some of the bits of the foundation that simply don’t exist yet (or have at least been badly neglected).&lt;/p&gt;

&lt;p&gt;Fortunately, these things are not insurmountable, nor are they necessarily especially hard. They’re things like default class methods, static detection and prevention of orphan instances, exhaustiveness checking for pattern-matching, and a real kind system. That’s right—right now, Hackett’s type system is effectively dynamically typed, and even though you can write a higher-kinded type, there is no such thing as a “kind error”.&lt;/p&gt;

&lt;p&gt;Other things are simply necessary quality of life improvements before Hackett can become truly usable. Type errors are currently rather atrocious, though they could certainly be worse. Additionally, typechecking currently just halts whenever it encounters a type error, and it makes no attempt to generate more than one type error at a time. Derivation of simple instances like &lt;code&gt;Show&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; is important, and it will also likely pave the way for a more general form of typeclass deriving (since it can most certainly be implemented via macros), so it’s uncharted territory that still needs to be explored.&lt;/p&gt;

&lt;p&gt;Bits of plumbing are still exposed in places, whether it’s unexpected behavior when interoperating with Racket or errors sometimes reported in terms of internal forms. Local bindings are, if you can believe it, still entirely unimplemented, so &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;letrec&lt;/code&gt; need to be written up. The standard library needs fleshing out, and certain bits of code need to be cleaned up and slotted into the right place.&lt;/p&gt;

&lt;p&gt;Oh, and of course, &lt;strong&gt;the whole thing needs to be documented&lt;/strong&gt;. That in and of itself is probably a pretty significant project, especially since there’s a good chance I’ll want to figure out how to best make use of Scribble for a language that’s a little bit different from Racket.&lt;/p&gt;

&lt;p&gt;All in all, there’s a lot of work to be done! I am eager to make it happen, but I also work a full-time job, and I don’t have it in me to continue at the pace I’ve been working at for the past couple of weeks. Still, if you’re interested in the project, stay tuned and keep an eye on it—if all goes as planned, I hope to make it truly useful before too long.&lt;/p&gt;

&lt;h1 id="answering-some-questions"&gt;Answering some questions&lt;/h1&gt;

&lt;p&gt;It’s possible that this blog post does not seem like much; after all, it’s not terribly long. However, if you’re anything like me, there’s a good chance you are interested enough to have some questions! Obviously, I cannot anticipate all your questions and answer them here in advance, but I will try my best.&lt;/p&gt;

&lt;h2 id="can-i-try-hackett"&gt;Can I try Hackett?&lt;/h2&gt;

&lt;p&gt;Yes! With the caveat that it’s alpha software in every sense of the word: undocumented, not especially user friendly, and completely unstable. However, if you &lt;em&gt;do&lt;/em&gt; want to give it a try, it isn’t difficult: just install Racket, then run &lt;code&gt;raco pkg install hackett&lt;/code&gt;. Open DrRacket and write &lt;code&gt;#lang hackett&lt;/code&gt; at the top of the module, then start playing around.&lt;/p&gt;

&lt;p&gt;Also, note that the demo web server used in the example at the top of this blog post is &lt;em&gt;not&lt;/em&gt; included when you install the &lt;code&gt;hackett&lt;/code&gt; package. If you want to try that out, you’ll have to run &lt;code&gt;raco pkg install hackett-demo&lt;/code&gt; to install the demo package as well.&lt;/p&gt;

&lt;h2 id="are-there-any-examples-of-hackett-code"&gt;Are there any examples of Hackett code?&lt;/h2&gt;

&lt;p&gt;Unfortunately, not a lot right now, aside from the tiny examples in this blog post. However, if you are already familiar with Haskell, the syntax likely won’t be hard to pick up. Reading the Hackett source code is not especially recommended, given that it is filled with implementation details. However, if you are interested, reading the module where most of the prelude is defined isn’t so bad. You can &lt;a href="https://github.com/lexi-lambda/hackett/blob/6ceeac05e3d2a4b2dacd39163744baf239cf65a4/hackett-lib/hackett/private/prim/base.rkt"&gt;find it on GitHub here&lt;/a&gt;, or you can open the &lt;code&gt;hackett/private/prim/base&lt;/code&gt; module on a local installation.&lt;/p&gt;

&lt;h2 id="how-can-i-learn-more--ask-questions-about-hackett"&gt;How can I learn more / ask questions about Hackett?&lt;/h2&gt;

&lt;p&gt;Feel free to ping me and ask me questions! I may not always be able to get back to you immediately, but if you hang around, I will eventually send you a response. The best ways to contact me are via the #racket IRC channel on Freenode, the snek Slack community (&lt;a href="http://snek.jneen.net"&gt;which you can sign up for here&lt;/a&gt;), sending me &lt;a href="https://twitter.com/lexi_lambda"&gt;a DM on Twitter&lt;/a&gt;, opening &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;an issue on the GitHub repo&lt;/a&gt;, or even just &lt;a href="mailto:lexi.lambda@gmail.com"&gt;sending me an email&lt;/a&gt; (though I’m usually a bit slower to respond to the latter).&lt;/p&gt;

&lt;h2 id="how-can-i-help"&gt;How can I help?&lt;/h2&gt;

&lt;p&gt;Probably the easiest way to help out is to try Hackett for yourself and &lt;a href="https://github.com/lexi-lambda/hackett/issues"&gt;report any bugs or infelicities you run into&lt;/a&gt;. Of course, many issues right now are known, there’s just so much to do that I haven’t had the chance to clean everything up. For that reason, the most effective way to contribute is probably to pick an existing issue and try and implement it yourself, but I wouldn’t be surprised if most people found the existing implementation a little intimidating.&lt;/p&gt;

&lt;p&gt;If you &lt;em&gt;are&lt;/em&gt; interested in helping out, I’d be happy to give you some pointers and answer some questions, since it would be extremely nice to have some help. Please feel free to contact me using any of the methods mentioned in the previous section, and I’ll try and help you find something you could work on.&lt;/p&gt;

&lt;h2 id="how-does-hackett-compare-to-x--why-doesnt-hackett-support-y"&gt;How does Hackett compare to &lt;em&gt;X&lt;/em&gt; / why doesn’t Hackett support &lt;em&gt;Y&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;These tend to be complex questions, and I don’t always have comprehensive answers for them, especially since the language is evolving so quickly. Still, if you want to ask me about this, feel free to just send the question to me directly. In my experience, it’s usually better to have a conversation about this sort of thing rather than just answering in one big comparison, since there’s usually a fair amount of nuance.&lt;/p&gt;

&lt;h2 id="when-will-hackett-be-ready-for-me-to-use"&gt;When will Hackett be ready for me to use?&lt;/h2&gt;

&lt;p&gt;I don’t know.&lt;/p&gt;

&lt;p&gt;Obviously, there is a lot left to implement, that is certainly true, but there’s more to it than that. If all goes well, I don’t see any reason why Hackett can’t be early beta quality by the end of this year, even if it doesn’t support all of the goodies necessary to achieve perfection (which, of course, it never really can).&lt;/p&gt;

&lt;p&gt;However, there are other things to consider, too. The Racket package system is currently flawed in ways that make rapidly iterating on Hackett hard, since it is extremely difficult (if not impossible) to make backwards-incompatible changes without potentially breaking someone’s program (even if they don’t update anything about their dependencies)! This is a solvable problem, but it would take some work modifying various elements of the package system and build tools, so that might need to get done before I can recommend Hackett in good faith.&lt;/p&gt;

&lt;h1 id="appendix"&gt;Appendix&lt;/h1&gt;

&lt;p&gt;It would be unfair not to mention all the people that have made Hackett possible. I cannot list them all here, but I want to give special thanks to &lt;a href="http://www.ccs.neu.edu/home/stchang/"&gt;Stephen Chang&lt;/a&gt;, &lt;a href="http://www.cs.ubc.ca/~joshdunf/"&gt;Joshua Dunfield&lt;/a&gt;, &lt;a href="http://eecs.northwestern.edu/~robby/"&gt;Robby Findler&lt;/a&gt;, &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt;, &lt;a href="http://functorial.com"&gt;Phil Freeman&lt;/a&gt;, &lt;a href="http://www.ccs.neu.edu/home/types/"&gt;Ben Greenman&lt;/a&gt;, &lt;a href="https://github.com/AlexKnauth"&gt;Alex Knauth&lt;/a&gt;, &lt;a href="http://www.cl.cam.ac.uk/~nk480/"&gt;Neelakantan Krishnaswami&lt;/a&gt;, and &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt;. I’d also like to thank everyone involved in the Racket and Haskell projects as a whole, as well as everyone who has expressed interest and encouragement about what I’ve been working on.&lt;/p&gt;

&lt;p&gt;As a final point, just for fun, I thought I’d keep track of all the albums I’ve been listening to while working on Hackett, just in the past few weeks. It is &lt;a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/#whats-in-a-name"&gt;on theme with the name&lt;/a&gt;, after all. This list is not completely exhaustive, as I’m sure some slipped through the cracks, but you can thank the following artists for helping me power through a few of the hills in Hackett’s implementation:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The Beach Boys — Pet Sounds&lt;/li&gt;
 &lt;li&gt;Boards of Canada — Music Has The Right To Children, Geogaddi&lt;/li&gt;
 &lt;li&gt;Bruce Springsteen — Born to Run&lt;/li&gt;
 &lt;li&gt;King Crimson — In the Court of the Crimson King, Larks’ Tongues in Aspic, Starless and Bible Black, Red, Discipline&lt;/li&gt;
 &lt;li&gt;Genesis — Nursery Cryme, Foxtrot, Selling England by the Pound, The Lamb Lies Down on Broadway, A Trick of the Tail&lt;/li&gt;
 &lt;li&gt;Mahavishnu Orchestra — Birds of Fire&lt;/li&gt;
 &lt;li&gt;Metric — Fantasies, Synthetica, Pagans in Vegas&lt;/li&gt;
 &lt;li&gt;Muse — Origin of Symmetry, Absolution, The Resistance&lt;/li&gt;
 &lt;li&gt;Peter Gabriel — Peter Gabriel I, II, III, IV / Security, Us, Up&lt;/li&gt;
 &lt;li&gt;Pink Floyd — Wish You Were Here&lt;/li&gt;
 &lt;li&gt;Supertramp — Breakfast In America&lt;/li&gt;
 &lt;li&gt;The Protomen — The Protomen, Act II: The Father of Death&lt;/li&gt;
 &lt;li&gt;Talking Heads — Talking Heads: 77, More Songs About Buildings and Food, Fear of Music, Remain in Light&lt;/li&gt;
 &lt;li&gt;Yes — Fragile, Relayer, Going For The One&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;And of course, &lt;em&gt;Voyage of the Acolyte&lt;/em&gt;, by &lt;strong&gt;Steve Hackett&lt;/strong&gt;.&lt;/p&gt;</description></item>
  <item>
   <title>Rascal is now Hackett, plus some answers to questions</title>
   <link>http://lexi-lambda.github.io/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/?utm_source=programming-languages&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2017-01-05-rascal-is-now-hackett-plus-some-answers-to-questions</guid>
   <pubDate>Thu, 05 Jan 2017 05:25:32 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Since I published &lt;a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"&gt;my blog post introducing Rascal&lt;/a&gt;, I’ve gotten some &lt;em&gt;amazing&lt;/em&gt; feedback, more than I had ever anticipated! One of the things that was pointed out, though, is that &lt;a href="http://www.rascal-mpl.org"&gt;Rascal is a language that already exists&lt;/a&gt;. Given that the name “Rascal” came from a mixture of “Racket” and “Haskell”, I always had an alternative named planned, and that’s “Hackett”. So, to avoid confusion as much as possible, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;&lt;strong&gt;Rascal is now known as Hackett&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With that out of the way, I also want to answer some of the other questions I received, both to hopefully clear up some confusion and to have something I can point to if I get the same questions in the future.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="whats-in-a-name"&gt;What’s in a name?&lt;/h1&gt;

&lt;p&gt;First, a little trivia.&lt;/p&gt;

&lt;p&gt;I’ve already mentioned that the old “Rascal” name was based on the names “Racket” and “Haskell”, which is true. However, it had a slightly deeper meaning, too: the name fit a tradition of naming languages in the Scheme family after somewhat nefarious things, such as “Gambit”, “Guile”, “Larceny”, and “Racket” itself. The name goes back a little bit further to the Planner programming language; Scheme was originally called Schemer, but it was (no joke) shorted due to filename length restrictions.&lt;/p&gt;

&lt;p&gt;Still, my language isn’t really a Scheme, so the weak connection wasn’t terribly relevant. Curious readers might be wondering if there’s any deeper meaning to the name “Hackett” than a mixture of the two language names. In fact, there is. Hackett is affectionately named after the &lt;a href="https://en.wikipedia.org/wiki/Steve_Hackett"&gt;Genesis progressive rock guitarist, Steve Hackett&lt;/a&gt;, one of my favorite musicians. The fact that the name is a homophone with “hack-it” is another convenient coincidence.&lt;/p&gt;

&lt;p&gt;Perhaps not the most interesting thing in this blog post, but there it is.&lt;/p&gt;

&lt;h1 id="why-racket-why-not-haskell"&gt;Why Racket? Why &lt;em&gt;not&lt;/em&gt; Haskell?&lt;/h1&gt;

&lt;p&gt;One of the most common questions I received is why I used Racket as the implementation language instead of Haskell. This is a decent question, and I think it likely stems at least in part from an item of common confusion: &lt;strong&gt;Racket is actually two things, a programming language and a programming language platform&lt;/strong&gt;. The fact that the two things have the same name is probably not ideal, but it’s what we’ve got.&lt;/p&gt;

&lt;p&gt;Racket-the-language is obviously the primary language used on the Racket platform, but there’s actually surprisingly little need for that to be the case; it’s simply the language that is worked on the most. Much of the Racket tooling, including the compiler, macroexpander, and IDE, are actually totally language agnostic. If someone came along and wrote a language that got more popular than &lt;code&gt;#lang racket&lt;/code&gt;, then there wouldn’t really be anything hardcoded into any existing tooling that would give the impression that &lt;code&gt;#lang racket&lt;/code&gt; was ever the more “dominant” language, aside from the name.&lt;/p&gt;

&lt;p&gt;For this reason, Racket is ideal for implementing new programming languages, moreso than pretty much any other platform out there. The talk I linked to in the previous blog post, &lt;a href="https://www.youtube.com/watch?v=TfehOLha-18"&gt;Languages in an Afternoon&lt;/a&gt;, describes this unique capability. It’s short, only ~15 minutes, but if you’re not into videos, I can try and explain why Racket is so brilliant for this sort of thing.&lt;/p&gt;

&lt;p&gt;By leveraging the Racket platform instead of implementing my language from scratch, I get the following things pretty much for free:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;I get a JIT compiler for my code, and I don’t have to implement a compiler myself.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;I also get a package manager that can cooperate with Hackett code to deliver Hackett modules.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;I get a documentation system that is fully indexed and automatically locally installed when you install Hackett or any package written in Hackett, and that documentation is automatically integrated with the editor.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The DrRacket IDE can be used out of the box with Hackett code, it automatically does syntax highlighting and indenting, and it even provides interactive tools for inspecting bindings (something that I demo in my aforementioned talk).&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If you don’t want to use DrRacket, you can use the &lt;a href="https://github.com/greghendershott/racket-mode"&gt;racket-mode&lt;/a&gt; major mode for Emacs, which uses the same sets of tools that DrRacket uses under the hood, so you get most of the same DrRacket goodies without sacrificing Emacs’s power of customization.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Reimplementing all of that in another language would take years of work, and I haven’t even mentioned Racket’s module system and macroexpander, which are the underpinnings of Hackett. GHC’s typechecker is likely roughly as complex as Racket’s macroexpander combined with its module system, but I am not currently implementing GHC’s typechecker, since I do not need all of OutsideIn(X)’s features, just Haskell 98 + some extensions.&lt;/p&gt;

&lt;p&gt;In contrast, I truly do need all of the Racket macroexpander to implement Hackett, since the &lt;em&gt;Type Systems as Macros&lt;/em&gt; paper uses pretty much every trick the Racket macro system has to offer to implement typechecking as macroexpansion. For those reasons, implementing the Racket macroexpander &lt;strong&gt;alone&lt;/strong&gt; in Haskell would likely be monumentally more work than implementing a Hindley-Milner typechecker in Racket, so it doesn’t really make sense to use Haskell for that job.&lt;/p&gt;

&lt;h2 id="actually-running-hackett-code"&gt;Actually running Hackett code&lt;/h2&gt;

&lt;p&gt;Now, it’s worth noting that GHC is much more efficient as a compiler than Racket is, for a whole host of reasons. However, since typechecking and macroexpansion are inherently strictly compile-time phases, it turns out to be totally feasible to run the typechecker/macroexpander in Racket (since in Hackett, the two things are one and the same), then compile the resulting fully-expanded, well-typed code to GHC Core. That could then be handed off to GHC itself and compiled using the full power of the GHC optimizer and compiler toolchain.&lt;/p&gt;

&lt;p&gt;This would be no small amount of work, but it seems theoretically possible, so eventually it’s something I’d love to look into. There are various complexities to making it work, but I think it would let me get the best of both worlds without reinventing the wheel, so it’s something I want long-term.&lt;/p&gt;

&lt;p&gt;There’s also the question of how “native” Hackett code would be, were it compiled to GHC Core. Would Hackett code be able to use Haskell libraries, and vice versa? My guess is that the answer is “yes, with some glue”. It probably wouldn’t be possible to do it completely seamlessly, because Hackett provides type information at macroexpansion time that likely wouldn’t exist in the same form in GHC. It might be possible to do some incredibly clever bridging to be able to use Haskell libraries in Hackett almost directly, but the inverse might not be true if a library’s interface depends on macros.&lt;/p&gt;

&lt;h1 id="how-do-template-haskell-quasiquoters-compete-with-macros"&gt;How do Template Haskell quasiquoters compete with macros?&lt;/h1&gt;

&lt;p&gt;Quasiquoters have a number of drawbacks, but the two main ones are complexity and lack of composition.&lt;/p&gt;

&lt;p&gt;S-expressions happen to be simple, and this means s-expression macros have two lovely properties: they’re easy to write, given good libraries (Racket has &lt;a href="http://docs.racket-lang.org/syntax/stxparse.html"&gt;&lt;code&gt;syntax/parse&lt;/code&gt;&lt;/a&gt;), and they’re easy for tools to understand. Quasiquoters force implementors to write their own parsers from raw strings of characters, which is quite a heavy burden, and it usually means those syntaxes are confusing and brittle. To give a good example, consider &lt;a href="http://www.yesodweb.com/book/persistent#persistent_code_generation"&gt;persistent’s quasiquoters&lt;/a&gt;: they look &lt;em&gt;sort of&lt;/em&gt; like Haskell data declarations, but they’re not really, and I honestly have no idea what their actual syntax really is. It feels pretty finicky, though. In contrast, an s-expression based version of the same syntax would basically look just like the usual datatype declaration form, plus perhaps some extra goodies.&lt;/p&gt;

&lt;p&gt;Additionally, s-expression macros &lt;em&gt;compose&lt;/em&gt;, and this should probably be valued more than anything else. If you’re writing code that doesn’t compose, it’s usually a bad sign. So much of functional programming is about writing small, reusable pieces of code that can be composed together, and macros are no different. Racket’s &lt;code&gt;match&lt;/code&gt;, for example, is an expression, and it contains expressions, so &lt;code&gt;match&lt;/code&gt; can be nested within itself, as well as other arbitrary macros that produce expressions. Similarly, many Racket macros can be extended, which is possible due to having such uniform syntax.&lt;/p&gt;

&lt;p&gt;Making macros “stand out” is an issue of some subjectivity, but in my experience such a fear of macros tends to stem from a familiarity with bad macro systems (which, to be fair, is almost all of them) and poor tooling. I’ve found that, in practice, most of the reasons people want to know “is this a macro??” is because macros are scary black boxes and people want to know which things to be suspicious of.&lt;/p&gt;

&lt;p&gt;Really, though, one of the reasons macros are complicated isn’t knowing which things are macros, but it’s knowing &lt;em&gt;which identifiers are uses and which identifiers are bindings&lt;/em&gt;, and things like that. Just knowing that something is a macro use doesn’t actually help at all there—the syntax won’t tell you. &lt;a href="http://i.imgur.com/HvYee19.png"&gt;Solve that problem with tools that address the problem head on, not by making a syntax that makes macros second-class citizens.&lt;/a&gt; One of the reasons I used the phrase “syntactic abstractions” in my previous blog post is because you specifically want them to be &lt;strong&gt;abstractions&lt;/strong&gt;. If you have to think of a macro in terms of the thing it expands to then it isn’t a very watertight abstraction. You don’t think about Haskell pattern-matching in terms of what the patterns compile to, you just use them. Macros should be (and can be) just as fluid.&lt;/p&gt;

&lt;h1 id="how-can-i-help"&gt;How can I help?&lt;/h1&gt;

&lt;p&gt;Right now, what I really need is someone who understands type system implementation. You don’t need to be up to date on what’s cutting edge—I’m not implementing anything nearly as complicated as GADTs or dependent types yet—you just need to understand how to implement Haskell 98. If you have that knowledge and you’re interested in helping, even if it just means answering some of my questions, please contact me via email, IRC (the #racket channel on Freenode is a good place for now), or Slack (I’m active in the snek Slack community, &lt;a href="http://snek.jneen.net"&gt;which you can sign up for here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;If you aren’t familiar with those things, but you’re still interested in helping out, there’s definitely plenty of work that needs doing. If you want to find somewhere you can pitch in, contacting me via any of the above means is totally fine, and I can point you in the right direction. Even if you just want to be a guinea pig, that’s useful.&lt;/p&gt;</description></item>
  <item>
   <title>Rascal: a Haskell with more parentheses</title>
   <link>http://lexi-lambda.github.io/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/?utm_source=programming-languages&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2017-01-02-rascal-a-haskell-with-more-parentheses</guid>
   <pubDate>Mon, 02 Jan 2017 09:16:42 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;blockquote&gt;
 &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: since the writing of this blog post, Rascal has been renamed to Hackett. You can read about why in &lt;a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/"&gt;the followup blog post&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;“Hey! You got your Haskell in my Racket!”&lt;/p&gt;

&lt;p&gt;“No, you got &lt;em&gt;your&lt;/em&gt; Racket in &lt;em&gt;my&lt;/em&gt; Haskell!”&lt;/p&gt;

&lt;p&gt;Welcome to the &lt;a href="https://github.com/lexi-lambda/hackett"&gt;Rascal&lt;/a&gt; programming language.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="why-rascal"&gt;Why Rascal?&lt;/h1&gt;

&lt;p&gt;Why yet &lt;em&gt;another&lt;/em&gt; programming language? Anyone who knows me knows that I already have two programming languages that I &lt;em&gt;really&lt;/em&gt; like: Haskell and Racket. Really, I think they’re both great! Each brings some things to the table that aren’t really available in any other programming language I’ve ever used.&lt;/p&gt;

&lt;p&gt;Haskell, in many ways, is a programming language that fits my mental model of how to structure programs better than any other programming language I’ve used. Some people would vehemently disagree, and it seems that there is almost certainly some heavy subjectivity in how people think about programming. I think Haskell’s model is awesome once you get used to it, though, but this blog post is not really going to try and convince you why you should care about Haskell (though that &lt;em&gt;is&lt;/em&gt; something I want to write at some point). What you &lt;em&gt;should&lt;/em&gt; understand, though, is that to me, Haskell is pretty close to what I want in a programming language.&lt;/p&gt;

&lt;p&gt;At the same time, though, Haskell has problems, and a lot of that revolves around its story for metaprogramming. “Metaprogramming” is another M word that people seem to be very afraid of, and for good reason: most metaprogramming systems are ad-hoc, unsafe, unpredictable footguns that require delicate care to use properly, and &lt;em&gt;even then&lt;/em&gt; the resulting code is brittle and difficult to understand. Haskell doesn’t suffer from this problem as much as some languages, but it isn’t perfect by any means: Haskell has at least two different metaprogramming systems (generics and Template Haskell) that are designed for different tasks, but they’re both limited in scope and both tend to be pretty complicated to use.&lt;/p&gt;

&lt;p&gt;Discussing the merits and drawbacks of Haskell’s various metaprogramming capabilities is also outside the scope of this blog post, but there’s one &lt;em&gt;fact&lt;/em&gt; that I want to bring up, which is that &lt;strong&gt;Haskell does not provide any mechanism for adding syntactic abstractions to the language&lt;/strong&gt;. What do I mean by this? Well, in order to understand what a “syntactic abstraction” is and why you should care about it, I want to shift gears a little and take a look at why Racket is so amazing.&lt;/p&gt;

&lt;h2 id="a-programmable-programming-language-theory-and-practice"&gt;A programmable programming language: theory and practice&lt;/h2&gt;

&lt;p&gt;I feel confident in saying that Racket has &lt;em&gt;the&lt;/em&gt; most advanced macro system in the world, and it is pretty much unparalleled in that space. There are many languages with powerful type systems, but Racket is more or less alone in many of the niches it occupies. Racket has a large number of innovations that I don’t know of in any other programming language, and a significant portion of them focus on making Racket a &lt;a href="http://www.ccs.neu.edu/home/matthias/manifesto/"&gt;programmable programming language, a language for building languages&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This lofty goal is backed up by decades of research, providing Racket with an unparalleled toolkit for creating languages that can communicate, be extended, and even cooperate with tooling to provide introspection and error diagnostics. Working in Haskell feels like carefully designing a mould that cleanly and precisely fits your domain, carefully carving, cutting, and whittling. In contrast, working with Racket feels like moulding your domain until it looks the way &lt;em&gt;you&lt;/em&gt; want it to look, poking and prodding at a pliable substrate. The sheer &lt;em&gt;ease&lt;/em&gt; of it all is impossible for me to convey in words, so &lt;a href="https://twitter.com/andmkent_/status/724036694773628930"&gt;you will have to see it for yourself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All this stuff is super abstract, though. What does it mean for practical programming, and why should you care? Well, I’m not going to try and sell you if you’re extremely skeptical, but if you’re interested, &lt;a href="https://www.youtube.com/watch?v=TfehOLha-18"&gt;I gave a talk on some of Racket’s linguistic capabilities last year called &lt;em&gt;Languages in an Afternoon&lt;/em&gt;&lt;/a&gt;. If you’re curious, give it a watch, and you might find yourself (hopefully) a little impressed. If you prefer reading, well, I have some &lt;a href="/blog/2015/12/21/adts-in-typed-racket-with-macros/"&gt;blog posts&lt;/a&gt; on this very blog that &lt;a href="/blog/2015/08/30/managing-application-configuration-with-envy/"&gt;demonstrate what Racket can do&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The basic idea, though, is that by having a simple syntax and a powerful macro system with a formalization of lexical scope, users can effectively invent entirely new language constructs as ordinary libraries, constructs that would have to be core forms in other programming languages. For example, Racket supports pattern-matching, but it isn’t built into the compiler: it’s simply implemented in the &lt;code&gt;racket/match&lt;/code&gt; module distributed with Racket. Not only is it defined in ordinary Racket code, it’s actually &lt;em&gt;extensible&lt;/em&gt;, so users can add their own pattern-matching forms that cooperate with &lt;code&gt;match&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is the power of a macro system to produce “syntactic abstractions”, things that can transform the way a user thinks of the code they’re writing. Racket has the unique capability of making these abstractions both easy to write and watertight, so instead of being a scary tool you have to handle with extreme care, you can easily whip up a powerful, user-friendly embedded domain specific language in a matter of &lt;em&gt;minutes&lt;/em&gt;, and it’ll be safe, provide error reporting for misuse, and cooperate with existing tooling pretty much out of the box.&lt;/p&gt;

&lt;h2 id="fusing-haskell-and-racket"&gt;Fusing Haskell and Racket&lt;/h2&gt;

&lt;p&gt;So, let’s assume that we &lt;em&gt;do&lt;/em&gt; want Haskell’s strong type system and that we &lt;em&gt;also&lt;/em&gt; want a powerful metaprogramming model that permits syntactic extensions. What would that look like? Well, one way we could do it is to put one in front of the other: macro expansion is, by nature, a compile-time pass, so we could stick a macroexpander in front of the typechecker. This leads to a simple technique: first, macroexpand the program to erase the macros, then typecheck it and erase the types, then send the resulting code off to be compiled. This technique has the following properties:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;First of all, &lt;strong&gt;it’s easy to implement&lt;/strong&gt;. Racket’s macroexpander, while complex, is well-documented in academic literature and works extremely well in practice. In fact, this strategy has already been implemented! Typed Racket, the gradually-typed sister language of Racket, expands every program before typechecking. It would be possible to effectively create a “Lisp-flavored Haskell” by using this technique, and it might not even be that hard.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Unfortunately, there’s a huge problem with this approach: &lt;strong&gt;type information is not available at macroexpansion time&lt;/strong&gt;. This is the real dealbreaker with the “expand, then typecheck” model, since static type information is some of the most useful information possibly available to a macro writer. In an ideal world, macros should not only have access to type information, they should be able to manipulate it and metaprogram the typechecker as necessary, but if macroexpansion is a separate phase from typechecking, then that information simply doesn’t exist yet.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For me, the second option is unacceptable. I am &lt;em&gt;not&lt;/em&gt; satisfied by a “Lisp-flavored Haskell”; I want my types and macros to be able to cooperate and communicate with each other. The trouble, though, is that solving that problem is really, really hard! For a couple years now, I’ve been wishing this ideal language existed, but I’ve had no idea how to make it actually work. Template Haskell implements a highly restricted system of interweaving typechecking and splice evaluation, but it effectively does it by running the typechecker and the splice expander alternately, splitting the source into chunks and typechecking them one at a time. This works okay for Template Haskell, but for the more powerful macro system I am looking for, it wouldn’t scale.&lt;/p&gt;

&lt;p&gt;There’s something a little bit curious, though, about the problem as I just described it. The processes of “macroexpanding the program to erase the macros” and “typechecking the program to erase the types” sound awfully similar. It seems like maybe these are two sides of the same coin, and it would be wonderful if we could encode one in terms of the other, effectively turning the two passes into a single, unified pass. Unfortunately, while this sounds great, I had no idea how to do this (and it didn’t help that I really had no idea how existing type systems were actually implemented).&lt;/p&gt;

&lt;p&gt;Fortunately, last year, Stephen Chang, Alex Knauth, and Ben Greenman put together a rather exciting paper called &lt;a href="http://www.ccs.neu.edu/home/stchang/popl2017/"&gt;&lt;em&gt;Type Systems as Macros&lt;/em&gt;&lt;/a&gt;, which does precisely what I just described, and it delivers it all in a remarkably simple and elegant presentation. The idea is to “distribute” the task of typechecking over the individual forms of the language, leveraging existing macro communication facilities avaiable in the Racket macroexpander to propagate type information as macros are expanded. To me, it was exactly what I was looking for, and I almost immediately started playing with it and seeing what I could do with it.&lt;/p&gt;

&lt;p&gt;The result is &lt;a href="https://github.com/lexi-lambda/hackett"&gt;&lt;em&gt;Rascal&lt;/em&gt;&lt;/a&gt;, a programming language built in the Racket ecosystem that attempts to implement a Haskell-like type system.&lt;/p&gt;

&lt;h1 id="a-first-peek-at-rascal"&gt;A first peek at Rascal&lt;/h1&gt;

&lt;p&gt;Rascal is a very new programming language I’ve only been working on over the past few months. It is extremely experimental, riddled with bugs, half-baked, and may turn your computer into scrambled eggs. Still, while I might not recommend that you actually &lt;em&gt;use&lt;/em&gt; it just yet, I want to try and share what it is I’m working on, since I’d bet at least a few other people will find it interesting, too.&lt;/p&gt;

&lt;p&gt;First, let me say this up front: &lt;strong&gt;Rascal is probably a lot closer to Haskell than Racket&lt;/strong&gt;. That might come as a surprise, given that Rascal has very Lisp-y syntax, it’s written in Racket, and it runs on the Racket platform, but semantically, Rascal is mostly just Haskell 98. This is important, because it may come as a surprise, given that there are so few statically typed Lisps, but there’s obviously no inherent reason that Lisps need to be dynamically typed. They just seem to have mostly evolved that way.&lt;/p&gt;

&lt;p&gt;Taking a look at a snippet of Rascal code, it’s easy to see that the language doesn’t work quite like a traditional Lisp, though:&lt;sup&gt;&lt;a href="#2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-definition" name="2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def+ map-every-other : (forall [a] {{a -&amp;gt; a} -&amp;gt; (List a) -&amp;gt; (List a)})
  [_ nil            -&amp;gt; nil]
  [_ {x :: nil}     -&amp;gt; {x :: nil}]
  [f {x :: y :: ys} -&amp;gt; {x :: (f y) :: (map-every-other f ys)}])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a Lisp with all the goodies you would expect out of Haskell: static types, parametric polymorphism, automatically curried functions, algebraic datatypes, pattern-matching, infix operators, and of course, &lt;em&gt;typeclasses&lt;/em&gt;. Yes, with Rascal you can have your monads in all their statically dispatched glory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(data (Maybe a)
  (just a)
  nothing)

(instance (Monad Maybe)
  [join (case-lambda
          [(just (just x)) (just x)]
          [_               nothing])])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, though, this really &lt;em&gt;is&lt;/em&gt; just “Haskell with parentheses”. As alluded to above, however, Rascal is a bit more than that.&lt;/p&gt;

&lt;h2 id="core-forms-can-be-implemented-as-derived-concepts"&gt;Core forms can be implemented as derived concepts&lt;/h2&gt;

&lt;p&gt;Rascal’s type system is currently very simple, being nothing more than Hindley-Milner plus ad-hoc polymorphism in the form of typeclasses. Something interesting to note about it is that it does not implement ADTs or pattern-matching anywhere in the core! In fact, ADTs are defined as two macros &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt;, in an entirely separate module, which can be imported just like any other library.&lt;/p&gt;

&lt;p&gt;The main &lt;code&gt;rascal&lt;/code&gt; language provides ADTs by default, of course, but it would be perfectly possible to produce a &lt;code&gt;rascal/kernel&lt;/code&gt; language which does not include them at all. In this particular case, it seems unlikely that Rascal programmers would want their own implementation of ADTs, but it’s an interesting proof of concept, and it hints at other “core” features that could be implemented using macros.&lt;/p&gt;

&lt;p&gt;Simple syntactic transformations are, of course, trivially defined as macros. Haskell &lt;code&gt;do&lt;/code&gt; notation is defined as &lt;a href="https://github.com/lexi-lambda/hackett/blob/87d001a82c86fb66544d25c37ffba9be1ac63464/rascal-lib/rascal/monad.rkt#L48-L58"&gt;an eleven-line macro in &lt;code&gt;rascal/monad&lt;/code&gt;&lt;/a&gt;, and GHC’s useful &lt;code&gt;LambdaCase&lt;/code&gt; extension is also possible to implement without modifying Rascal at all. This is useful, because there are many syntactic shorthands that are extremely useful to implement, but don’t make any sense to be in GHC because they are specific to certain libraries or applications. Racket’s macro system makes those not only possible, but actually pretty easy.&lt;/p&gt;

&lt;p&gt;While the extent of what is possible to implement as derived forms remains to be seen, many useful GHC features seem quite possible to implement without touching the core language, including things like &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; and other generic deriving mechanisms like &lt;code&gt;GHC.Generics&lt;/code&gt;, &lt;code&gt;DeriveGeneric&lt;/code&gt;, and &lt;code&gt;DeriveAnyClass&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="the-language-is-not-enough"&gt;The language is not enough&lt;/h2&gt;

&lt;p&gt;No language is perfect. Most people would agree with this, but I would take it a step further: no language is even sufficient! This makes a lot of sense, given that general-purpose programming languages are designed to do &lt;em&gt;everything&lt;/em&gt;, and it’s impossible to do everything well.&lt;/p&gt;

&lt;p&gt;Haskell programmers know this, and they happily endorse the creation of embedded domain specific languages. These are fantastic, and we need more of them. Things like &lt;a href="http://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; let me write a third of the code I might otherwise need to, and the most readable code is the code you didn’t have to write in the first place. DSLs are good.&lt;/p&gt;

&lt;p&gt;Unfortunately, building DSLs is traditionally difficult, largely in part because building embedded DSLs means figuring out a way to encode your domain into your host language of choice. Sometimes, your domain simply does not elegantly map to your host language’s syntax or semantics, and you have to come up with a compromise. This is easy to see with servant, which, while it does a remarkably good job, still has to resort to some very clever type magic to create some semblance of an API description in Haskell types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type UserAPI = "users" :&amp;gt; Get '[JSON] [User]
          :&amp;lt;|&amp;gt; "users" :&amp;gt; ReqBody '[JSON] User :&amp;gt; Post '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; Get '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; ReqBody '[JSON] User
                       :&amp;gt; Put '[JSON] User&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code is &lt;em&gt;remarkably&lt;/em&gt; readable for what it is, but what if we didn’t have to worry about working within the constraints of Haskell’s syntax? What if we could design a syntax that was truly the best for the job? Perhaps we would come up with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-api User-API
  #:content-types [JSON]
  [GET  "users"                    =&amp;gt; (List User)]
  [POST "users"                    =&amp;gt; User -&amp;gt; User]
  [GET  "users" [userid : Integer] =&amp;gt; User]
  [PUT  "users" [userid : Integer] =&amp;gt; User -&amp;gt; User])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would be extremely easy to write with Racket’s macro-writing utilities, and it could even be made extensible. This could also avoid having to do the complicated typeclass trickery servant has to perform to then generate code from the above specification, since it would be much easier to just generate the necessary code directly (which still maintaining type safety).&lt;/p&gt;

&lt;p&gt;In addition to the type-level hacks that Haskell programmers often have to pull in order to make these kinds of fancy DSLs work, free monads tend to be used to create domain-specific languages. This works okay for some DSLs, but remember that when you use a free monad, you are effectively writing a &lt;em&gt;runtime interpreter&lt;/em&gt; for your language! Macros, on the other hand, are compiled, and you get ability to &lt;em&gt;compile&lt;/em&gt; your DSL to code that can be optimized by all the existing facilities of the compiler toolchain.&lt;/p&gt;

&lt;h1 id="rascal-is-embryonic"&gt;Rascal is embryonic&lt;/h1&gt;

&lt;p&gt;I’m pretty excited about Rascal. I think that it could have the potential to do some pretty interesting things, and I have some ideas in my head for how having macros in a Haskell-like language could change things. I also think that, based on what I’ve seen so far, having both macros and a Haskell-like type system could give rise to &lt;em&gt;completely&lt;/em&gt; different programming paradigms than exist in either Haskell or Racket today. My gut tells me that this is a case where the whole might actually be greater than the sum of its parts.&lt;/p&gt;

&lt;p&gt;That said, Rascal doesn’t really exist yet. Yes, &lt;a href="https://github.com/lexi-lambda/hackett"&gt;there is a GitHub repository&lt;/a&gt;, and it has some code in it that does… something. Unfortunately, the code is also currently extremely buggy, to the point of being borderline broken, and it’s also in such early stages that you can’t really do &lt;em&gt;anything&lt;/em&gt; interesting with it, aside from some tiny toy programs.&lt;/p&gt;

&lt;p&gt;As I have worked on Rascal, I’ve come to a somewhat unfortunate conclusion, which is that I really have almost zero interest in implementing type systems. I felt that way before I started the project, but I was hoping that maybe once I got into them, I would find them more interesting. Unfortunately, as much as I love working with powerful type systems (and really, I adore working with Haskell and using all the fancy features GHC provides), I find implementing the software that makes them tick completely dull.&lt;/p&gt;

&lt;p&gt;Still, I’m willing to invest the time to get something that I can use. Even so, resources for practical type system implementation are scarce. I want to thank &lt;a href="https://web.cecs.pdx.edu/~mpj/"&gt;Mark P Jones&lt;/a&gt; for his wonderful resource &lt;a href="https://web.cecs.pdx.edu/~mpj/thih/"&gt;Typing Haskell in Haskell&lt;/a&gt;, without which getting to where I am now would likely have been impossible. I also want to thank &lt;a href="http://www.stephendiehl.com"&gt;Stephen Diehl&lt;/a&gt; for his wonderful &lt;a href="http://dev.stephendiehl.com/fun/"&gt;Write You a Haskell&lt;/a&gt; series, which was also wonderfully useful to study, even if it is unfinished and doesn’t cover anything beyond ML just yet.&lt;/p&gt;

&lt;p&gt;Even with these wonderful resources, I’ve come to the realization that &lt;strong&gt;I probably can’t do all of this on my own&lt;/strong&gt;. I consider myself pretty familiar with macros and macro expanders at this point, but I don’t know much about type systems (at least not their implementation), and I could absolutely use some help. So if you’re interested in Rascal and think you might be able to pitch in, please: I would appreciate even the littlest bits of help or guidance!&lt;/p&gt;

&lt;p&gt;In the meantime, I will try to keep picking away at Rascal in the small amount of free time I currently have. Thanks, as always, to all the amazing people who have contributed to the tools I’ve been using for this project: special thanks to the authors of &lt;em&gt;Type Systems as Macros&lt;/em&gt; for their help as well as the people I mentioned just above, and also to all of the people who have built Racket and Haskell and made them what they are today. Without them, Rascal would most definitely not exist.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Note that most of the Rascal code in this blog post probably doesn’t actually work on the current Rascal implementation. Pretty much all of it can be implemented in the current implementation, the syntax just isn’t quite as nice yet.&amp;nbsp;&lt;a href="#2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item>
  <item>
   <title>Climbing the infinite ladder of abstraction</title>
   <link>http://lexi-lambda.github.io/blog/2016/08/11/climbing-the-infinite-ladder-of-abstraction/?utm_source=programming-languages&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2016-08-11-climbing-the-infinite-ladder-of-abstraction</guid>
   <pubDate>Thu, 11 Aug 2016 18:03:48 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;I started programming in elementary school.&lt;/p&gt;

&lt;p&gt;When I was young, I was fascinated by the idea of automation. I loathed doing the same repetitive task over and over again, and I always yearned for a way to &lt;a href="https://xkcd.com/974/"&gt;solve the general problem&lt;/a&gt;. When I learned about programming, I was immediately hooked: it was &lt;em&gt;so easy&lt;/em&gt; to turn repetitive tasks into automated pipelines that would free me from ever having to do the same dull, frustrating exercise ever again.&lt;/p&gt;

&lt;p&gt;Of course, one of the first things I found out once I’d started was that nothing is ever quite so simple. Before long, my solutions to eliminate repetition grew repetitive, and it became clear I spent a lot of time typing out the same things, over and over again, creating the very problem I had initially set out to destroy. It was through this that I grew interested in functions, classes, and other repetition-reducing aids, and soon enough, I discovered the wonderful world of &lt;strong&gt;abstraction&lt;/strong&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="the-brick-wall-of-inexpressiveness"&gt;The brick wall of inexpressiveness&lt;/h1&gt;

&lt;p&gt;When I started programming, I was mostly playing with ActionScript and Java, just tinkering with things and seeing what I could come up with. I had quite a lot of fun, and the joy of solving problems hooked me almost immediately, but I also ran into frustrations pretty quickly. Specifically, I started writing a lot of code that looked like this:&lt;/p&gt;

&lt;div class="brush: java"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is a bit of a cheap example, given that Java getters and setters are something of a programming language punching bag at this point, but I really did write them, and I really did get frustrated by them! I learned object-oriented design patterns, and I pored over books, forum threads, blog posts, and Stack Overflow questions about how to structure code to prevent spaghetti, but no matter how hard I tried, I kept having to type things that looked suspiciously similar to each other.&lt;/p&gt;

&lt;p&gt;It was really quite frustrating, because no matter how I approached the problem, I ended up with a boilerplate-heavy mess. The &lt;em&gt;whole reason&lt;/em&gt; I got started programming was to avoid this sort of thing, so what could I do? Well, it became increasingly obvious to me that Java had to go, and I needed to try something else. I started learning two very different programming languages, JavaScript and Objective-C, and I liked them both, for different reasons.&lt;/p&gt;

&lt;p&gt;When I learned JavaScript, I discovered the closure, the first-class function, and I was entranced by it. Through jQuery, I learned of its power to design APIs that could be fun to use, dropping the boring, “heavy” feeling that Java carried around everywhere. With Objective-C, on the other hand, I learned about the power of a more dynamic object system, something with interesting syntax and the ability to handle “message passing” at a far higher level than Java ever could.&lt;/p&gt;

&lt;p&gt;Both of these languages were flawed, as all languages are, but they opened my mind to the idea that &lt;em&gt;programming languages&lt;/em&gt; could drastically influence the way I thought about problem solving, and they set me on a quest to find the programming language that would eliminate boilerplate once and for all.&lt;/p&gt;

&lt;h1 id="discovering-lisp"&gt;Discovering Lisp&lt;/h1&gt;

&lt;p&gt;Over the next few years, I grew to appreciate JavaScript’s small, simple core, despite rather disliking its object system and poor faculties for user-friendly data modeling. I pored over its history, and I found out that its design was heavily influenced by an obscure little language called Scheme, as well as an even more obscure language called Self, and a part of me started to wonder what it would be like to incorporate those languages’ ideas without some of the compromises JavaScript had made.&lt;/p&gt;

&lt;p&gt;This idea lingered in the back of my head for a couple years, and while I tried to play with Scheme a couple times, it was simply too inaccessible for me. I was used to languages with powerful, easy to use IDEs, and when I found myself with nothing more than a command-line executable and rather scarce documentation, I was at a loss for how to begin. Even if I could do math in the REPL, where could I go from there? I’d started programming by building games, then websites. What could I possibly do with Scheme?&lt;/p&gt;

&lt;p&gt;The language (or rather, its lack of an ecosystem) proved too intimidating for me at that young age, but the idea of Lisp’s homoiconicity stuck with me. Eventually, I started to design my very own programming language, a &lt;a href="https://github.com/lexi-lambda/libsol"&gt;highly dynamic Lisp with a prototypal object system called Sol&lt;/a&gt;. I worked on it for about a year, and when I was done with it, it had a not-too-shabby complement of features: it had lambdas, macros, a fully-featured object model, and a CommonJS-esque module system, complete with the ability to dynamically import arbitrary C extensions. It was by far the largest project I’d ever worked on, and when I was done, I was pretty pleased.&lt;/p&gt;

&lt;p&gt;Unfortunately, it was also abysmally slow.&lt;/p&gt;

&lt;p&gt;I turned to a local college to find some people who could give me feedback and maybe point me in the right direction, and someone told me about another obscure programming language called &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;. At about the same time, someone pointed me to a totally different language called &lt;a href="https://www.haskell.org"&gt;Haskell&lt;/a&gt;. This was uncharted territory for me, and for a while, I didn’t really explore either of those languages further. Eventually, though, I dove into them in earnest, and what I found has dramatically altered my perspective on programming since then.&lt;/p&gt;

&lt;h1 id="a-journey-into-complexity"&gt;A journey into complexity&lt;/h1&gt;

&lt;p&gt;Fast forward about three years, and today, I am employed writing Haskell, and I spend most of my free time writing Racket. These languages left a mark on me, and while I’ve learned &lt;em&gt;so much more&lt;/em&gt; since then, I find myself continually bucking the mainstream and coming back to functional programming, hygienic macros, and possibly the most powerful type system in existence in a production-ready programming language.&lt;/p&gt;

&lt;p&gt;I’ve also started realizing something else, though: &lt;strong&gt;the languages I’ve settled into are &lt;em&gt;really complicated&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When I started programming, I thought about things like numbers, text, and shapes on a screen. Before long, I learned about functions, then classes, then message-passing and lambdas. I dove into macros and typeclasses, and now I speak in functors and monads, sets of scopes and internal definition contexts, and parser combinators and domain specific languages.&lt;/p&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;p&gt;Sometimes I talk to fellow programmers, and they are horrified by the types of terms I fling around. “Why would you ever need something called a ‘monad’?” they ask, completely perplexed. “Macros are confusing,” they argue. “Being explicit is better.”&lt;/p&gt;

&lt;p&gt;Obviously, I disagree, but why? What have I given up? If my fellow programmers cannot understand what I’m writing, is it actually worth it?&lt;/p&gt;

&lt;p&gt;I’ve searched for years to find a programming language that will eliminate boilerplate, that will allow me to express my ideas succinctly and cleanly, that will let me turn hard problems into trivial ones, and I’ve discovered two completely different approaches to tackling those issues. Racket has macros, and Haskell has its fancy type system. Both of these things are lightyears ahead of where I was nearly a decade ago, writing dozens of lines of repetitive Java that ultimately did very little, but I’m still dealing with the same problems.&lt;/p&gt;

&lt;p&gt;Racket knows too little about my program—it can’t figure out what I mean based on the type of thing I’m operating on because it is (mostly) dynamically typed. I &lt;em&gt;still&lt;/em&gt; have to clarify myself and write things that feel redundant because the computer isn’t smart enough to figure out the “obvious”. Similarly, Haskell is too limiting—the compiler cannot deduce constraints I can solve in my head in seconds, and its syntax is not extensible like Racket’s is. Every day, I peer into piles upon piles of monadic computation, and really, what have I gained?&lt;/p&gt;

&lt;h2 id="improvement-but-never-mastery"&gt;Improvement, but never mastery&lt;/h2&gt;

&lt;p&gt;Like almost anything in life, programming is not really a perfectable art. There’s always some unlearned skill or undiscovered technique, and part of this potential for perpetual self-improvement is one of the things that I find so attractive about the field. That said, I this it is reasonable to say that certain languages have higher ceilings than others.&lt;/p&gt;

&lt;p&gt;For example I am pretty confident that I &lt;em&gt;get&lt;/em&gt; JavaScript. The language has lots of nooks and crannies that I don’t completely understand, but I feel pretty confident that I understand its semantics well enough to be able to grasp any piece of JavaScript code without too much incredulity. Now, that’s not to say that JavaScript is a simplistic language—far from it—but most of the ways I improve my JavaScripting abilities are learning new techniques &lt;em&gt;within&lt;/em&gt; the language, not entirely new linguistic constructs.&lt;/p&gt;

&lt;p&gt;On the other hand, languages like Haskell and Racket tend to blur the line. I feel like I have a good grasp of Haskell’s core, but do I have a good intuition for laziness? Do I completely grok type families? What about &lt;code&gt;TypeInType&lt;/code&gt;? Ultimately, I have to come to the conclusion that I do not fully understand Haskell, much less a lot of the advanced category theory that composes some of its most powerful libraries. Racket manages to blur the line between language and library even further, and while I consider myself a decent Racketeer, I absolutely do &lt;em&gt;not&lt;/em&gt; have a good grasp on all the intricacies of Racket’s macro system.&lt;/p&gt;

&lt;p&gt;This is especially obvious to me at work, given that I write Haskell in a team setting. Just like back when I was writing Java, I end up with solutions that don’t satisfy me, and I reach for increasingly powerful constructs to help alleviate my qualms. Sometimes, I find myself cracking out &lt;code&gt;DataKinds&lt;/code&gt;, and it might even help my problem, but there’s a cost: my coworkers are sometimes confused.&lt;/p&gt;

&lt;p&gt;Every time I climb to the next rung on the ladder of abstraction, those only a couple rungs below me (even if we’re all hundreds of rungs up!) find themselves perplexed. In the worst case, people may even blame their confusion on their own inadequacy or lack of skill. This is &lt;em&gt;terrible&lt;/em&gt;, especially when I know that, by the time they’ve caught up, I’ll be off playing with some new toy: comonads or type families or classy lenses. The cycle continues, and nobody is ever truly satisfied—I always want to find a new abstraction that will make things simpler, and those just a couple steps behind me struggle to keep up.&lt;/p&gt;

&lt;p&gt;Of course, I experience it from the opposite perspective just as often: I delve into Edward Kmett’s fancier libraries or Phil Freeman’s blog posts about category theory, and I recognize that I am rather lost. Sometimes, I find myself understanding things, but just as often, I cannot wrap my head around the concepts being discussed. I may figure them out eventually, sure, but by then everyone else has moved on to even &lt;em&gt;more&lt;/em&gt; advanced things, and still, none of them truly solve my problems.&lt;/p&gt;

&lt;h1 id="ultimately-it-all-has-at-least-a-little-value"&gt;Ultimately, it all has (at least a little) value&lt;/h1&gt;

&lt;p&gt;It would be nice to think about all that and say, well, “Let’s finally break the cycle. Let’s stop deluding ourselves into thinking our solutions to our self-made problems are actually solving anything.” It would be great if I could tell myself that, but I unfortunately really can’t.&lt;/p&gt;

&lt;p&gt;The scariest part of all is that I think it’s completely worthwhile.&lt;/p&gt;

&lt;p&gt;So much of these more and more complicated abstractions are trying to do the same basic thing: come up with a better way of modeling the problem. In some sense, that’s all programming really is, modeling a domain in a way that can be leveraged by a digital computer. Our increasingly complicated DSLs &lt;em&gt;seem&lt;/em&gt; unnecessarily complicated, they &lt;em&gt;seem&lt;/em&gt; increasingly removed from reality, but that’s only because we’re getting better at creating languages that are closer to our domains without the baggage of preconceptions that came before us.&lt;/p&gt;

&lt;p&gt;The downside is that, without an understanding of those preconceptions, a lot of what we come up with seems like patent gibberish to those unaware of our languages’ history.&lt;/p&gt;

&lt;p&gt;Most programmers, even those who have never seen BASIC before, can figure out what this snippet does:&lt;/p&gt;

&lt;div class="brush: BASIC"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;INPUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"What is your name: "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;U$&lt;/span&gt;
&lt;span class="nl"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;PRINT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"Hello "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;U$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;On the other hand, very few would probably understand this one:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;-- | A class for categories.&lt;/span&gt;
&lt;span class="c1"&gt;--   id and (.) must form a monoid.&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Category&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
    &lt;span class="c1"&gt;-- | the identity morphism&lt;/span&gt;
    &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

    &lt;span class="c1"&gt;-- | morphism composition&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Yet very few new programs are being written in BASIC, and lots are being written in Haskell.&lt;/p&gt;

&lt;p&gt;Even one of the most popular, fastest-growing programming languages in the world, JavaScript, a language considered relatively accessible compared to things like Haskell, would likely be incomprehensible to a programmer not familiar with its syntax:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;export&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;composeWithProps&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;curry&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parentProps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;composed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;childProps&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="nx"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parentProps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;omit&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;children&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nx"&gt;childProps&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;childProps&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;children&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="c1"&gt;// give the composed component a pretty display name for debugging&lt;/span&gt;
  &lt;span class="nx"&gt;composed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;displayName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sb"&gt;`Composed(&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;getDisplayName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;, &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;getDisplayName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;)`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;composed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Moving towards increasingly specialized syntaxes is not inherently bad—it can often be indicative of a more streamlined, domain-specific way of thinking—but while it may dramatically increase the productivity of a seasoned programmer, it can be nothing short of baffling to a newcomer.&lt;/p&gt;

&lt;p&gt;That, specifically, is the crux of my fear: are we always aware of who we are optimizing for? I do not have a moral problem with writing code to optimize concision for seasoned programmers; after all, brevity is one of the primary ways code is made more readable (verbosity is the enemy of understanding). However, when that concision comes at the cost of beginners’ understanding, the picture becomes a bit more grey. It is not wrong to write things that are highly optimized for one’s own knowledge and understanding, and establishing a group of such people can make for an &lt;em&gt;extremely&lt;/em&gt; productive team. It’s just also important to understand that others will likely be confused, and without being willing to invest the time and money into education, smart, diligent people will still fail to grasp the concepts, and they will likely be wholly uninterested in them.&lt;/p&gt;

&lt;h2 id="reactionary-anti-intellectualism-and-the-search-for-moderation"&gt;Reactionary anti-intellectualism and the search for moderation&lt;/h2&gt;

&lt;p&gt;I have noticed lately that people close to my circles have started regularly slinging insults at people who work in highly specialized notation. Math, including things like category and type theory, has become an especially acceptable punching bag. &lt;a href="https://twitter.com/lexi_lambda/status/763111451691134976"&gt;I recently tweeted a picture of some rather dense mathematics from a paper I’d read&lt;/a&gt;, and I was frankly disturbed at some of the vitriolic responses. Academia is sometimes described as “masturbatory”, and honestly, that is both offensive and hypocritical.&lt;/p&gt;

&lt;p&gt;Mathematical notation is not perfect, no more than dense Haskell, heavily metaprogrammed Ruby, or IIFE-packed JavaScript. Still, it serves a purpose, and sometimes spelling things out is neither practically feasible nor a theoretical improvement. Programmers would not take kindly to being asked to write all their code out as prose, nor would they like being told that using higher-order functions like &lt;code&gt;map&lt;/code&gt; should be banned because they are too confusing and not immediately self-explanatory.&lt;/p&gt;

&lt;p&gt;I am glad that people are focusing on usability and accessibility more than ever, and I think that’s one of the areas I’m the most interested in. I want to get the best of both worlds: I aim to write code in a highly concise, precise style, but I try and produce intuitive interfaces with human-readable errors upon failure. To me, a user-hostile yet technically functional library is a buggy one, and I would happily file a bug report about a confusing API or error message.&lt;/p&gt;

&lt;p&gt;Abstraction is what seems to make programming possible, and indeed, it’s what makes most modern &lt;em&gt;technology&lt;/em&gt; possible. It’s what allows people to drive a car without knowing how an internal combustion engine works, and it’s what allows people to browse the web without having a deep understanding of internet protocol. In programming, abstraction serves a similar purpose. Of course, just like all tools, abstractions can have rather different goals: the average user will not pick up Photoshop in a day, but a power user is not going to be satisfied with Paint.&lt;/p&gt;

&lt;p&gt;Programmers are professionals, and we work in a technical domain. I am absolutely of the belief that programming, like any other field, is not always about what comes easiest: sometimes it’s important to sit down and study for a while to grok a particularly complicated concept, and other times, it’s simply important to learn by trying, failing, and asking questions. I strive to find that blend of accessible, concise, and robust, and just like everything else, that target shifts depending on the situation and people I’m working with.&lt;/p&gt;

&lt;p&gt;I honestly don’t know if Racket and Haskell are worth their costs in complexity. At the end of the day, maybe what really matters is writing simple, consistent things that other people can understand. I really hope that there is a place for more powerful languages within a team, but there’s something to be said about which languages tend to get the most popular.&lt;/p&gt;

&lt;p&gt;Ultimately, though, I am just trying to be aware of the tradeoffs I’m making, the benefits I’m getting, and the impact on those I’m working with. I will continue to search for abstractions that can better fit my needs, and I am sure I will keep on climbing the ladder of abstraction for years to come—I just really hope I’m not wasting my time.&lt;/p&gt;</description></item></channel></rss>