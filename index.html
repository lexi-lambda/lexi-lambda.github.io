<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Alexis King’s Blog</title><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,300italic,400italic,700,700italic,800,800italic|Merriweather:400,300,300italic,400italic,700,700italic,900,900italic|Fira+Code:300,400,500,600,700"/><link rel="stylesheet" type="text/css" href="/css/application.min.css"/><link rel="stylesheet" type="text/css" href="/css/pygments.min.css"/><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feeds/all.atom.xml"/><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feeds/all.rss.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-65250372-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);};gtag('js', new Date());gtag('config', 'UA-65250372-1');</script><body><header><nav role="navigation" class="navigation-bar"><ul class="navigation-items left"><li class="blog-title-header"><a href="/">Alexis King</a></li></ul><ul class="navigation-items center"></ul><ul class="navigation-items right"><li><a href="/">Home</a></li><li><a href="/about.html">About Me</a></li></ul></nav></header><section role="main"><div class="content"><article class="inline"><header><h1 class="title"><a href="/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/">An introduction to typeclass metaprogramming</a></h1><div class="date-and-tags"><time datetime="2021-03-25">2021-03-25</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a>, <a href="/tags/types.html">types</a>, <a href="/tags/functional-programming.html">functional programming</a></div></header><p><em>Typeclass metaprogramming</em> is a powerful technique available to Haskell programmers to automatically generate term-level code from static type information. It has been used to great effect in several popular Haskell libraries (such as the <a href="https://hackage.haskell.org/package/servant">servant</a> ecosystem), and it is the core mechanism used to implement generic programming via <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Generics.html">GHC generics</a>. Despite this, remarkably little material exists that explains the technique, relegating it to folk knowledge known only to advanced Haskell programmers.</p><p>This blog post attempts to remedy that by providing an overview of the foundational concepts behind typeclass metaprogramming. It does <em>not</em> attempt to be a complete guide to type-level programming in Haskell—such a task could easily fill a book—but it does provide explanations and illustrations of the most essential components. This is also <em>not</em> a blog post for Haskell beginners—familiarity with the essentials of the Haskell type system and several common GHC extensions is assumed—but it does not assume any prior knowledge of type-level programming.</p><p><a href="/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2020/11/01/names-are-not-type-safety/">Names are not type safety</a></h1><div class="date-and-tags"><time datetime="2020-11-01">2020-11-01</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a>, <a href="/tags/types.html">types</a>, <a href="/tags/functional-programming.html">functional programming</a></div></header><p>Haskell programmers spend a lot of time talking about <em>type safety</em>. The Haskell school of program construction advocates “capturing invariants in the type system” and “making illegal states unrepresentable,” both of which sound like compelling goals, but are rather vague on the techniques used to achieve them. Almost exactly one year ago, I published <a href="/blog/2019/11/05/parse-don-t-validate/">Parse, Don’t Validate</a> as an initial stab towards bridging that gap.</p><p>The ensuing discussions were largely productive and right-minded, but one particular source of confusion quickly became clear: Haskell’s <code>newtype</code> construct. The idea is simple enough—the <code>newtype</code> keyword declares a wrapper type, nominally distinct from but representationally equivalent to the type it wraps—and on the surface this <em>sounds</em> like a simple and straightforward path to type safety. For example, one might consider using a <code>newtype</code> declaration to define a type for an email address:</p><pre><code class="pygments"><span class="kr">newtype</span> <span class="kt">EmailAddress</span> <span class="ow">=</span> <span class="kt">EmailAddress</span> <span class="kt">Text</span></code></pre><p>This technique can provide <em>some</em> value, and when coupled with a smart constructor and an encapsulation boundary, it can even provide some safety. But it is a meaningfully distinct <em>kind</em> of type safety from the one I highlighted a year ago, one that is far weaker. On its own, a newtype is just a name.</p><p>And names are not type safety.</p><p><a href="/blog/2020/11/01/names-are-not-type-safety/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/">Types as axioms, or: playing god with static types</a></h1><div class="date-and-tags"><time datetime="2020-08-13">2020-08-13</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/types.html">types</a>, <a href="/tags/functional-programming.html">functional programming</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/typescript.html">typescript</a></div></header><p>Just what exactly <em>is</em> a type?</p><p>A common perspective is that types are <em>restrictions</em>. Static types restrict the set of values a variable may contain, capturing some subset of the space of “all possible values.” Under this worldview, a typechecker is sort of like an oracle, predicting which values will end up where when the program runs and making sure they satisfy the constraints the programmer wrote down in the type annotations. Of course, the typechecker can’t <em>really</em> predict the future, so when the typechecker gets it wrong—it can’t “figure out” what a value will be—static types can feel like self-inflicted shackles.</p><p>But that is not the <em>only</em> perspective. There is another way—a way that puts you, the programmer, back in the driver’s seat. You make the rules, you call the shots, you set the objectives. You need not be limited any longer by what the designers of your programming language decided the typechecker can and cannot prove. You do not serve the typechecker; the typechecker serves <em>you.</em></p><p>…no, I’m not trying to sell you a dubious self-help book for programmers who feel like they’ve lost control of their lives. If the above sounds too good to be true, well… I won’t pretend it’s all actually as easy as I make it sound. Nevertheless, it’s well within the reach of the working programmer, and most remarkably, all it takes is a change in perspective.</p><p><a href="/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/">No, dynamic type systems are not inherently more open</a></h1><div class="date-and-tags"><time datetime="2020-01-19">2020-01-19</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/types.html">types</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a>, <a href="/tags/functional-programming.html">functional programming</a></div></header><p>Internet debates about typing disciplines continue to be plagued by a pervasive myth that dynamic type systems are inherently better at modeling “open world” domains. The argument usually goes like this: the goal of static typing is to pin everything down as much as possible, but in the real world, that just isn’t practical. Real systems should be loosely coupled and worry about data representation as little as possible, so dynamic types lead to a more robust system in the large.</p><p>This story sounds compelling, but it isn’t true. The flaw is in the premise: static types are <em>not</em> about “classifying the world” or pinning down the structure of every value in a system. The reality is that static type systems allow specifying exactly how much a component needs to know about the structure of its inputs, and conversely, how much it doesn’t. Indeed, in practice static type systems excel at processing data with only a partially-known structure, as they can be used to ensure application logic doesn’t accidentally assume too much.</p><p><a href="/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2019/11/05/parse-don-t-validate/">Parse, don’t validate</a></h1><div class="date-and-tags"><time datetime="2019-11-05">2019-11-05</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/functional-programming.html">functional programming</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/types.html">types</a></div></header><p>Historically, I’ve struggled to find a concise, simple way to explain what it means to practice type-driven design. Too often, when someone asks me “How did you come up with this approach?” I find I can’t give them a satisfying answer. I know it didn’t just come to me in a vision—I have an iterative design process that doesn’t require plucking the “right” approach out of thin air—yet I haven’t been very successful in communicating that process to others.</p><p>However, about a month ago, <a href="https://twitter.com/lexi_lambda/status/1182242561655746560">I was reflecting on Twitter</a> about the differences I experienced parsing JSON in statically- and dynamically-typed languages, and finally, I realized what I was looking for. Now I have a single, snappy slogan that encapsulates what type-driven design means to me, and better yet, it’s only three words long:</p><div style="text-align: center; font-size: larger"><strong>Parse, don’t validate.</strong></div><p><a href="/blog/2019/11/05/parse-don-t-validate/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2019/10/19/empathy-and-subjective-experience-in-programming-languages/">Empathy and subjective experience in programming languages</a></h1><div class="date-and-tags"><time datetime="2019-10-19">2019-10-19</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a>, <a href="/tags/philosophy.html">philosophy</a></div></header><p>A stereotype about programmers is that they like to think in black and white. Programmers like things to be good or bad, moral or immoral, responsible or irresponsible. Perhaps there is something romantic in the idea that programmers like to be as binary as the computers they program. Reductionist? Almost certainly, but hey, laugh at yourself a bit: we probably deserve to be made fun of from time to time.</p><p>Personally, I have no idea if the trope of the nuance-challenged programmer is accurate, but whether it’s a property of programmers or just humans behind a keyboard, the intensity with which we disagree with one another never ceases to amaze. Ask any group of working programmers what their least favorite programming language is, and there’s a pretty good chance things are going to get heated real fast. Why? What is it about programming that makes us feel so strongly that we are right and others are wrong, even when our experiences contradict those of tens or hundreds of thousands of others?</p><p>I think about that question a lot.</p><p><a href="/blog/2019/10/19/empathy-and-subjective-experience-in-programming-languages/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2019/09/07/demystifying-monadbasecontrol/">Demystifying <code>MonadBaseControl</code></a></h1><div class="date-and-tags"><time datetime="2019-09-07">2019-09-07</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a></div></header><p><a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl"><code>MonadBaseControl</code> from the <code>monad-control</code> package</a> is a confusing typeclass, and its methods have complicated types. For many people, it’s nothing more than scary, impossible-to-understand magic that is, for some reason, needed when lifting certain kinds of operations. Few resources exist that adequately explain how, why, and when it works, which sadly seems to have resulted in some <a href="https://en.wikipedia.org/wiki/Fear,_uncertainty,_and_doubt">FUD</a> about its use.</p><p>There’s no doubt that the machinery of <code>MonadBaseControl</code> is complex, and the role it plays in practice is often subtle. However, its essence is actually much simpler than it appears, and I promise it can be understood by mere mortals. In this blog post, I hope to provide a complete survey of <code>MonadBaseControl</code>—how it works, how it’s designed, and how it can go wrong—in a way that is accessible to anyone with a firm grasp of monads and monad transformers. To start, we’ll motivate <code>MonadBaseControl</code> by reinventing it ourselves.</p><p><a href="/blog/2019/09/07/demystifying-monadbasecontrol/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/">Defeating Racket’s separate compilation guarantee</a></h1><div class="date-and-tags"><time datetime="2019-04-21">2019-04-21</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/racket.html">racket</a>, <a href="/tags/macros.html">macros</a></div></header><p>Being a self-described <a href="https://felleisen.org/matthias/manifesto/sec_pl-pl.html">programming-language programming language</a> is an ambitious goal. To preserve predictability while permitting linguistic extension, Racket comes equipped with a module system carefully designed to accommodate <a href="https://www.cs.utah.edu/plt/publications/macromod.pdf">composable and compilable macros</a>. One of the module system’s foundational properties is its <a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._separate-compilation%29"><em>separate compilation guarantee</em></a>, which imposes strong, unbreakable limits on the extent of compile-time side-effects. It is <em>essential</em> for preserving static guarantees in a world where compiling a module can execute arbitrary code, and despite numerous unsafe trapdoors that have crept into Racket since its birth as PLT Scheme, none have ever given the programmer the ability to cheat it.</p><p>Yet today, in this blog post, we’re going to do exactly that.</p><p><a href="/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2018/10/06/macroexpand-anywhere-with-local-apply-transformer/">Macroexpand anywhere with <code>local-apply-transformer</code>!</a></h1><div class="date-and-tags"><time datetime="2018-10-06">2018-10-06</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/racket.html">racket</a>, <a href="/tags/macros.html">macros</a></div></header><p>Racket programmers are accustomed to the language’s incredible capacity for extension and customization. Writing useful macros that do complicated things is easy, and it’s simple to add new syntactic forms to meet domain-specific needs. However, it doesn’t take long before many budding macrologists bump into the realization that only <em>certain positions</em> in Racket code are subject to macroexpansion.</p><p>To illustrate, consider a macro that provides a Clojure-style <code>let</code> form:</p><pre><code class="pygments"><span class="p">(</span><span class="k">require</span> <span class="n">syntax/parse/define</span><span class="p">)</span>

<span class="p">(</span><span class="n">define-simple-macro</span> <span class="p">(</span><span class="n">clj-let</span> <span class="p">[{</span><span class="n">~seq</span> <span class="n">x:id</span> <span class="n">e:expr</span><span class="p">}</span> <span class="k">...</span><span class="p">]</span> <span class="n">body:expr</span> <span class="n">...+</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">x</span> <span class="n">e</span><span class="p">]</span> <span class="k">...</span><span class="p">)</span> <span class="n">body</span> <span class="k">...</span><span class="p">))</span></code></pre><p>This can be used anywhere an expression is expected, and it does as one would expect:</p><pre><code class="pygments"><span class="nb">&gt;</span> <span class="p">(</span><span class="n">clj-let</span> <span class="p">[</span><span class="n">x</span> <span class="mi">1</span>
            <span class="n">y</span> <span class="mi">2</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="n">y</span><span class="p">))</span>
<span class="mi">3</span></code></pre><p>However, a novice macro programmer might realize that <code>clj-let</code> really only modifies the syntax of <em>binding pairs</em> for a <code>let</code> form. Therefore, could one define a macro that only adjusts the binding pairs of some existing <code>let</code> form instead of expanding to an entire <code>let</code>? That is, could one write the above example like this:</p><pre><code class="pygments"><span class="p">(</span><span class="n">define-simple-macro</span> <span class="p">(</span><span class="n">clj-binding-pairs</span> <span class="p">[{</span><span class="n">~seq</span> <span class="n">x:id</span> <span class="n">e:expr</span><span class="p">}</span> <span class="k">...</span><span class="p">])</span>
  <span class="p">([</span><span class="n">x</span> <span class="n">e</span><span class="p">]</span> <span class="k">...</span><span class="p">))</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="n">clj-binding-pairs</span>
        <span class="p">[</span><span class="n">x</span> <span class="mi">1</span>
         <span class="n">y</span> <span class="mi">2</span><span class="p">])</span>
    <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="n">y</span><span class="p">))</span>
<span class="mi">3</span></code></pre><p>The answer is <em>no</em>: the binding pairs of a <code>let</code> form are not subject to macroexpansion, so the above attempt fails with a syntax error. In this blog post, we will examine the reasons behind this limitation, then explain how to overcome it using a solution that allows macroexpansion <em>anywhere</em> in a Racket program.</p><p><a href="/blog/2018/10/06/macroexpand-anywhere-with-local-apply-transformer/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2018/09/13/custom-core-forms-in-racket-part-ii-generalizing-to-arbitrary-expressions-and-internal-definitions/">Custom core forms in Racket, part II: generalizing to arbitrary expressions and internal definitions</a></h1><div class="date-and-tags"><time datetime="2018-09-13">2018-09-13</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/racket.html">racket</a>, <a href="/tags/macros.html">macros</a></div></header><p>In my <a href="/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/">previous blog post</a>, I covered the process involved in creating a small language with a custom set of core forms. Specifically, it discussed what was necessary to create Hackett’s type language, which involved expanding to custom expressions. While somewhat involved, Hackett’s type language was actually a relatively simple example to use, since it only made use of a subset of the linguistic features Racket supports. In this blog post, I’ll demonstrate how that same technique can be generalized to support runtime bindings and internal definitions, two key concepts useful if intending to develop a more featureful language than Hackett’s intentionally-restrictive type system.</p><p><a href="/blog/2018/09/13/custom-core-forms-in-racket-part-ii-generalizing-to-arbitrary-expressions-and-internal-definitions/"><span class="read-more-text">Read more</span> →</a></p></article><ul class="pagination"><li class="disabled">←</li><li class="pagination-number active"><a href="/">1</a></li><li class="pagination-number"><a href="/index-2.html">2</a></li><li class="pagination-number"><a href="/index-3.html">3</a></li><li class="pagination-number"><a href="/index-4.html">4</a></li><li><a href="/index-2.html">→</a></li></ul></div></section><footer><div class="copyright-notice">© 2022, Alexis King</div><div>Built with <a href="https://docs.racket-lang.org/scribble/index.html"><strong>Scribble</strong></a>, the Racket document preparation system.</div><div>Feeds are available via <a href="/feeds/all.atom.xml">Atom</a> or <a href="/feeds/all.rss.xml">RSS</a>.</div></footer></body></head></html>