<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Posts tagged 'macros'</title>
    <meta name="description" content="Posts tagged 'macros'">
    <meta name="author"      content="Alexis King">
    <meta name="keywords"    content="macros">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/favicon.ico">
    <link rel="canonical" href="http://lexi-lambda.github.io/tags/macros.html">


    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,300italic,400italic,700,700italic,800,800italic|Merriweather:400,300,300italic,400italic,700,700italic,900,900italic|Fira+Code:300,400,500,600,700">
    <link rel="stylesheet" type="text/css" href="/css/application.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pygments.min.css">
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml"
          href="/feeds/macros.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml"
          href="/feeds/macros.rss.xml" title="RSS Feed">
    <!-- JS -->
    <!-- <script src="/js/application.min.js"></script> -->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-65250372-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
    <div id="page-content">
      <!-- Navigation Bar -->
      <header>
        <nav role="navigation" class="navigation-bar">
          <ul class="navigation-items left">
            <li id="blog-title-header"><a href="/"><h1>Alexis King</h1></a></li>
          </ul>
          <ul class="navigation-items center"></ul>
          <ul class="navigation-items right">
            <li><a href="/">Home</a></li>
            <li><a href="/resume.html">About Me</a></li>
          </ul>
        </nav>
      </header>
      <section role="main">
        <!-- Main column -->
        <div class="content" class="col-md-12">

          <h1>Posts tagged <em>macros</em></h1>

          <article class="inline">
  <header>
    <h2 class="title"><a href='/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/'>Defeating Racket’s separate compilation guarantee</a></h2>
    <div class='date-and-tags'>
      <time datetime="2019-04-21T05:30:00">
        2019-04-21
      </time>
      <span style="margin: 0 3px">⦿</span>
      <span class="tags"><a href="/tags/racket.html">racket</a>, <a href="/tags/macros.html">macros</a></span>
    </div>
  </header>

<p>Being a self-described <a href="https://felleisen.org/matthias/manifesto/sec_pl-pl.html">programming-language programming language</a> is an ambitious goal. To preserve predictability while permitting linguistic extension, Racket comes equipped with a module system carefully designed to accommodate <a href="https://www.cs.utah.edu/plt/publications/macromod.pdf">composable and compilable macros</a>. One of the module system’s foundational properties is its <a href="https://docs.racket-lang.org/reference/eval-model.html#%28part._separate-compilation%29"><em>separate compilation guarantee</em></a>, which imposes strong, unbreakable limits on the extent of compile-time side-effects. It is <em>essential</em> for preserving static guarantees in a world where compiling a module can execute arbitrary code, and despite numerous unsafe trapdoors that have crept into Racket since its birth as PLT Scheme, none have ever given the programmer the ability to cheat it.</p>

<p>Yet today, in this blog post, we’re going to do exactly that.</p>
  <footer class="read-more">
    <a href="/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/"><span class="read-more-text">Read more</span> →</a>
  </footer>
</article>
<article class="inline">
  <header>
    <h2 class="title"><a href='/blog/2018/10/06/macroexpand-anywhere-with-local-apply-transformer/'>Macroexpand anywhere with <code>local-apply-transformer</code>!</a></h2>
    <div class='date-and-tags'>
      <time datetime="2018-10-06T22:34:46">
        2018-10-06
      </time>
      <span style="margin: 0 3px">⦿</span>
      <span class="tags"><a href="/tags/racket.html">racket</a>, <a href="/tags/macros.html">macros</a></span>
    </div>
  </header>

<p>Racket programmers are accustomed to the language’s incredible capacity for extension and customization. Writing useful macros that do complicated things is easy, and it’s simple to add new syntactic forms to meet domain-specific needs. However, it doesn’t take long before many budding macrologists bump into the realization that only <em>certain positions</em> in Racket code are subject to macroexpansion.</p>

<p>To illustrate, consider a macro that provides a Clojure-style <code>let</code> form:</p>

<div class="brush: racket">
 <div class="source">
  <pre><span></span><span class="p">(</span><span class="k">require</span> <span class="n">syntax/parse/define</span><span class="p">)</span>

<span class="p">(</span><span class="n">define-simple-macro</span> <span class="p">(</span><span class="n">clj-let</span> <span class="p">[{</span><span class="n">~seq</span> <span class="n">x:id</span> <span class="n">e:expr</span><span class="p">}</span> <span class="k">...</span><span class="p">]</span> <span class="n">body:expr</span> <span class="n">...+</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">x</span> <span class="n">e</span><span class="p">]</span> <span class="k">...</span><span class="p">)</span> <span class="n">body</span> <span class="k">...</span><span class="p">))</span>
</pre></div>

</div>

<p>This can be used anywhere an expression is expected, and it does as one would expect:</p>

<div class="brush: racket">
 <div class="source">
  <pre><span></span><span class="nb">&gt;</span> <span class="p">(</span><span class="n">clj-let</span> <span class="p">[</span><span class="n">x</span> <span class="mi">1</span>
            <span class="n">y</span> <span class="mi">2</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="n">y</span><span class="p">))</span>
<span class="mi">3</span>
</pre></div>

</div>

<p>However, a novice macro programmer might realize that <code>clj-let</code> really only modifies the syntax of <em>binding pairs</em> for a <code>let</code> form. Therefore, could one define a macro that only adjusts the binding pairs of some existing <code>let</code> form instead of expanding to an entire <code>let</code>? That is, could one write the above example like this:</p>

<div class="brush: racket">
 <div class="source">
  <pre><span></span><span class="p">(</span><span class="n">define-simple-macro</span> <span class="p">(</span><span class="n">clj-binding-pairs</span> <span class="p">[{</span><span class="n">~seq</span> <span class="n">x:id</span> <span class="n">e:expr</span><span class="p">}</span> <span class="k">...</span><span class="p">])</span>
  <span class="p">([</span><span class="n">x</span> <span class="n">e</span><span class="p">]</span> <span class="k">...</span><span class="p">))</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="n">clj-binding-pairs</span>
        <span class="p">[</span><span class="n">x</span> <span class="mi">1</span>
         <span class="n">y</span> <span class="mi">2</span><span class="p">])</span>
    <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="n">y</span><span class="p">))</span>
<span class="mi">3</span>
</pre></div>

</div>

<p>The answer is <em>no</em>: the binding pairs of a <code>let</code> form are not subject to macroexpansion, so the above attempt fails with a syntax error. In this blog post, we will examine the reasons behind this limitation, then explain how to overcome it using a solution that allows macroexpansion <em>anywhere</em> in a Racket program.</p>
  <footer class="read-more">
    <a href="/blog/2018/10/06/macroexpand-anywhere-with-local-apply-transformer/"><span class="read-more-text">Read more</span> →</a>
  </footer>
</article>
<article class="inline">
  <header>
    <h2 class="title"><a href='/blog/2018/09/13/custom-core-forms-in-racket-part-ii-generalizing-to-arbitrary-expressions-and-internal-definitions/'>Custom core forms in Racket, part II: generalizing to arbitrary expressions and internal definitions</a></h2>
    <div class='date-and-tags'>
      <time datetime="2018-09-13T00:00:00">
        2018-09-13
      </time>
      <span style="margin: 0 3px">⦿</span>
      <span class="tags"><a href="/tags/racket.html">racket</a>, <a href="/tags/macros.html">macros</a></span>
    </div>
  </header>

<p>In my <a href="/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/">previous blog post</a>, I covered the process involved in creating a small language with a custom set of core forms. Specifically, it discussed what was necessary to create Hackett’s type language, which involved expanding to custom expressions. While somewhat involved, Hackett’s type language was actually a relatively simple example to use, since it only made use of a subset of the linguistic features Racket supports. In this blog post, I’ll demonstrate how that same technique can be generalized to support runtime bindings and internal definitions, two key concepts useful if intending to develop a more featureful language than Hackett’s intentionally-restrictive type system.</p>
  <footer class="read-more">
    <a href="/blog/2018/09/13/custom-core-forms-in-racket-part-ii-generalizing-to-arbitrary-expressions-and-internal-definitions/"><span class="read-more-text">Read more</span> →</a>
  </footer>
</article>
<article class="inline">
  <header>
    <h2 class="title"><a href='/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/'>Reimplementing Hackett’s type language: expanding to custom core forms in Racket</a></h2>
    <div class='date-and-tags'>
      <time datetime="2018-04-15T00:00:00">
        2018-04-15
      </time>
      <span style="margin: 0 3px">⦿</span>
      <span class="tags"><a href="/tags/racket.html">racket</a>, <a href="/tags/hackett.html">hackett</a>, <a href="/tags/macros.html">macros</a></span>
    </div>
  </header>

<p>In the past couple of weeks, I <a href="https://github.com/lexi-lambda/hackett/commit/ba64193da38f63dab2523f42c1b7614cdfa8c935">completely rewrote the implementation of Hackett’s type language</a> to improve the integration between the type representation and Racket’s macro system. The new type language effectively implements a way to reuse as much of the Racket macroexpanding infrastructure as possible while expanding a completely custom language, which uses a custom set of core forms. The fundamental technique used to do so is not novel, and it seems to be periodically rediscovered every so often, but it has never been published or documented anywhere, and getting it right involves understanding a great number of subtleties about the Racket macro system. While I cannot entirely eliminate the need to understand those subtleties, in this blog post, I hope to make the secret sauce considerably less secret.</p>
  <footer class="read-more">
    <a href="/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/"><span class="read-more-text">Read more</span> →</a>
  </footer>
</article>
<article class="inline">
  <header>
    <h2 class="title"><a href='/blog/2017/08/12/user-programmable-infix-operators-in-racket/'>User-programmable infix operators in Racket</a></h2>
    <div class='date-and-tags'>
      <time datetime="2017-08-12T16:26:05">
        2017-08-12
      </time>
      <span style="margin: 0 3px">⦿</span>
      <span class="tags"><a href="/tags/racket.html">racket</a>, <a href="/tags/hackett.html">hackett</a>, <a href="/tags/macros.html">macros</a></span>
    </div>
  </header>

<p>Lisps are not known for infix operators, quite the opposite; infix operators generally involve more syntax and parsing than Lispers are keen to support. However, in <a href="https://github.com/lexi-lambda/hackett">Hackett</a>, all functions are curried, and variable-arity functions do not exist. Infix operators are almost necessary for that to be palatable, and though there are other reasons to want them, it may not be obvious how to support them without making the reader considerably more complex.</p>

<p>Fortunately, if we require users to syntactically specify where they wish to use infix expressions, support for infix operators is not only possible, but can support be done <em>without</em> modifying the stock <code>#lang racket</code> reader. Futhermore, the resulting technique makes it possible for fixity information to be specified locally in a way that cooperates nicely with the Racket macro system, allowing the parsing of infix expressions to be manipulated at compile-time by users’ macros.</p>
  <footer class="read-more">
    <a href="/blog/2017/08/12/user-programmable-infix-operators-in-racket/"><span class="read-more-text">Read more</span> →</a>
  </footer>
</article>
<article class="inline">
  <header>
    <h2 class="title"><a href='/blog/2016/02/18/simple-safe-multimethods-in-racket/'>Simple, safe multimethods in Racket</a></h2>
    <div class='date-and-tags'>
      <time datetime="2016-02-18T18:48:32">
        2016-02-18
      </time>
      <span style="margin: 0 3px">⦿</span>
      <span class="tags"><a href="/tags/racket.html">racket</a>, <a href="/tags/macros.html">macros</a></span>
    </div>
  </header>

<p>Racket ships with <code>racket/generic</code>, a system for defining <em>generic methods</em>, functions that work differently depending on what sort of value they are supplied. I have made heavy use of this feature in my collections library, and it has worked well for my needs, but that system does have a bit of a limitation: it only supports <em>single dispatch</em>. Method implementations may only be chosen based on a single argument, so multiple dispatch is impossible.</p>
  <footer class="read-more">
    <a href="/blog/2016/02/18/simple-safe-multimethods-in-racket/"><span class="read-more-text">Read more</span> →</a>
  </footer>
</article>
<article class="inline">
  <header>
    <h2 class="title"><a href='/blog/2015/12/21/adts-in-typed-racket-with-macros/'>ADTs in Typed Racket with macros</a></h2>
    <div class='date-and-tags'>
      <time datetime="2015-12-21T17:57:07">
        2015-12-21
      </time>
      <span style="margin: 0 3px">⦿</span>
      <span class="tags"><a href="/tags/racket.html">racket</a>, <a href="/tags/typed-racket.html">typed racket</a>, <a href="/tags/macros.html">macros</a></span>
    </div>
  </header>

<p>Macros are one of Racket&rsquo;s flagship features, and its macro system really is state of the art. Of course, it can sometimes be difficult to demonstrate <em>why</em> macros are so highly esteemed, in part because it can be hard to find self-contained examples of using macros in practice. Of course, one thing that macros are perfect for is filling a &ldquo;hole&rdquo; in the language by introducing a feature a language lacks, and one of those features in Typed Racket is <strong>ADTs</strong>.</p>
  <footer class="read-more">
    <a href="/blog/2015/12/21/adts-in-typed-racket-with-macros/"><span class="read-more-text">Read more</span> →</a>
  </footer>
</article>
        </div>
      </section>
      <footer>
        <div class="content">
          <h2 id="copyright-notice">© 2021, Alexis King</h2>
          <h3>
            Built with <a href="https://github.com/greghendershott/frog">Frog</a>, the
            <strong>fr</strong>ozen bl<strong>og</strong> tool.
          </h3>
          <h3>
            Feeds are available via <a href="/feeds/all.atom.xml">Atom</a>
            or <a href="/feeds/all.rss.xml">RSS</a>.
          </h3>
        </div>
      </footer>
    </div>
  </body>
</html>