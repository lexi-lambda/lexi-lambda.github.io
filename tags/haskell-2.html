<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Posts tagged ‘haskell’ | Alexis King’s Blog</title><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,300italic,400italic,700,700italic,800,800italic|Merriweather:400,300,300italic,400italic,700,700italic,900,900italic|Fira+Code:300,400,500,600,700"/><link rel="stylesheet" type="text/css" href="/css/application.min.css"/><link rel="stylesheet" type="text/css" href="/css/pygments.min.css"/><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feeds/haskell.atom.xml"/><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feeds/haskell.rss.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-65250372-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);};gtag('js', new Date());gtag('config', 'UA-65250372-1');</script><body><header><nav role="navigation" class="navigation-bar"><ul class="navigation-items left"><li class="blog-title-header"><a href="/">Alexis King</a></li></ul><ul class="navigation-items center"></ul><ul class="navigation-items right"><li><a href="/">Home</a></li><li><a href="/about.html">About Me</a></li></ul></nav></header><section role="main"><div class="content"><h1 class="tag-page-header">Posts tagged <em>haskell</em></h1><article class="inline"><header><h1 class="title"><a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/">Realizing Hackett, a metaprogrammable Haskell</a></h1><div class="date-and-tags"><time datetime="2017-05-27">2017-05-27</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a></div></header><p><a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/">Almost five months ago, I wrote a blog post about my new programming language, Hackett</a>, a fanciful sketch of a programming language from a far-off land with Haskell’s type system and Racket’s macros. At that point in time, I had a little prototype that barely worked, that I barely understood, and was a little bit of a technical dead-end. People saw the post, they got excited, but development sort of stopped.</p><p>Then, almost two months ago, I took a second stab at the problem in earnest. I read a lot, I asked a lot of people for help, and eventually I got something sort of working. Suddenly, <a href="https://github.com/lexi-lambda/hackett">Hackett is not only real, it’s working, and you can try it out yourself</a>!</p><p><a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/">Lifts for free: making mtl typeclasses derivable</a></h1><div class="date-and-tags"><time datetime="2017-04-28">2017-04-28</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a></div></header><p>Perhaps the most important abstraction a Haskell programmer must understand to effectively write modern Haskell code, beyond the level of the monad, is the <em>monad transformer</em>, a way to compose monads together in a limited fashion. One frustrating downside to monad transformers is a proliferation of <code>lift</code>s, which explicitly indicate which monad in a transformer “stack” a particular computation should run in. Fortunately, the venerable <a href="https://hackage.haskell.org/package/mtl">mtl</a> provides typeclasses that make this lifting mostly automatic, using typeclass machinery to insert <code>lift</code> where appropriate.</p><p>Less fortunately, the mtl approach does not actually eliminate <code>lift</code> entirely, it simply moves it from use sites to instances. This requires a small zoo of extraordinarily boilerplate-y instances, most of which simply implement each typeclass method using <code>lift</code>. While we cannot eliminate the instances entirely without somewhat dangerous techniques like <a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#overlapping-instances">overlapping instances</a>, we <em>can</em> automatically derive them using features of modern GHC, eliminating the truly unnecessary boilerplate.</p><p><a href="/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/">Rascal is now Hackett, plus some answers to questions</a></h1><div class="date-and-tags"><time datetime="2017-01-05">2017-01-05</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a></div></header><p>Since I published <a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/">my blog post introducing Rascal</a>, I’ve gotten some <em>amazing</em> feedback, more than I had ever anticipated! One of the things that was pointed out, though, is that <a href="http://www.rascal-mpl.org">Rascal is a language that already exists</a>. Given that the name “Rascal” came from a mixture of “Racket” and “Haskell”, I always had an alternative named planned, and that’s “Hackett”. So, to avoid confusion as much as possible, <a href="https://github.com/lexi-lambda/hackett"><strong>Rascal is now known as Hackett</strong></a>.</p><p>With that out of the way, I also want to answer some of the other questions I received, both to hopefully clear up some confusion and to have something I can point to if I get the same questions in the future.</p><p><a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/">Rascal: a Haskell with more parentheses</a></h1><div class="date-and-tags"><time datetime="2017-01-02">2017-01-02</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a>, <a href="/tags/functional-programming.html">functional programming</a></div></header><blockquote><p><strong>Note</strong>: since the writing of this blog post, Rascal has been renamed to Hackett. You can read about why in <a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/">the followup blog post</a>.</p></blockquote><p>“Hey! You got your Haskell in my Racket!”</p><p>“No, you got <em>your</em> Racket in <em>my</em> Haskell!”</p><p>Welcome to the <a href="https://github.com/lexi-lambda/hackett">Rascal</a> programming language.</p><p><a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2016/10/03/using-types-to-unit-test-in-haskell/">Using types to unit-test in Haskell</a></h1><div class="date-and-tags"><time datetime="2016-10-03">2016-10-03</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a>, <a href="/tags/testing.html">testing</a></div></header><p>Object-oriented programming languages make unit testing easy by providing obvious boundaries between units of code in the form of classes and interfaces. These boundaries make it easy to stub out parts of a system to test functionality in isolation, which makes it possible to write fast, deterministic test suites that are robust in the face of change. When writing Haskell, it can be unclear how to accomplish the same goals: even inside pure code, it can become difficult to test a particular code path without also testing all its collaborators.</p><p>Fortunately, by taking advantage of Haskell’s expressive type system, it’s possible to not only achieve parity with object-oriented testing techniques, but also to provide stronger static guarantees as well. Furthermore, it’s all possible without resorting to extra-linguistic hacks that static object-oriented languages sometimes use for mocking, such as dynamic bytecode generation.</p><p><a href="/blog/2016/10/03/using-types-to-unit-test-in-haskell/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2016/08/11/climbing-the-infinite-ladder-of-abstraction/">Climbing the infinite ladder of abstraction</a></h1><div class="date-and-tags"><time datetime="2016-08-11">2016-08-11</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/programming-languages.html">programming languages</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a></div></header><p>I started programming in elementary school.</p><p>When I was young, I was fascinated by the idea of automation. I loathed doing the same repetitive task over and over again, and I always yearned for a way to <a href="https://xkcd.com/974/">solve the general problem</a>. When I learned about programming, I was immediately hooked: it was <em>so easy</em> to turn repetitive tasks into automated pipelines that would free me from ever having to do the same dull, frustrating exercise ever again.</p><p>Of course, one of the first things I found out once I’d started was that nothing is ever quite so simple. Before long, my solutions to eliminate repetition grew repetitive, and it became clear I spent a lot of time typing out the same things, over and over again, creating the very problem I had initially set out to destroy. It was through this that I grew interested in functions, classes, and other repetition-reducing aids, and soon enough, I discovered the wonderful world of <strong>abstraction</strong>.</p><p><a href="/blog/2016/08/11/climbing-the-infinite-ladder-of-abstraction/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2016/06/12/four-months-with-haskell/">Four months with Haskell</a></h1><div class="date-and-tags"><time datetime="2016-06-12">2016-06-12</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a>, <a href="/tags/functional-programming.html">functional programming</a></div></header><p>At the end of January of this year, I switched to a new job, almost exclusively because I was enticed by the idea of being able to write Haskell. The concept of using such an interesting programming language every day instead of what I’d been doing before (mostly Rails and JavaScript) was very exciting, and I’m pleased to say that the switch seems to have been well worth it.</p><p>Haskell was a language I had played with in the past but never really used for anything terribly practical, but lately I think I can confidently say that it really is an <em>incredible</em> programming language. At the same time, it has some significant drawbacks, too, though probably not the ones people expect. I certainly wasn’t prepared for some of the areas where Haskell would blow me away, nor was I capable of realizing which parts would leave me hopelessly frustrated until I actually sat down and started writing lots and lots of code.</p><p><a href="/blog/2016/06/12/four-months-with-haskell/"><span class="read-more-text">Read more</span> →</a></p></article><ul class="pagination"><li><a href="/tags/haskell.html">←</a></li><li class="pagination-number"><a href="/tags/haskell.html">1</a></li><li class="pagination-number active"><a href="/tags/haskell-2.html">2</a></li><li class="disabled">→</li></ul></div></section><footer><div class="copyright-notice">© 2022, Alexis King</div><div>Built with <a href="https://docs.racket-lang.org/scribble/index.html"><strong>Scribble</strong></a>, the Racket document preparation system.</div><div>Feeds are available via <a href="/feeds/all.atom.xml">Atom</a> or <a href="/feeds/all.rss.xml">RSS</a>.</div></footer></body></head></html>