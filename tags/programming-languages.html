<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Posts tagged ‘programming languages’ | Alexis King’s Blog</title><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,300italic,400italic,700,700italic,800,800italic|Merriweather:400,300,300italic,400italic,700,700italic,900,900italic|Fira+Code:300,400,500,600,700"/><link rel="stylesheet" type="text/css" href="/css/application.min.css"/><link rel="stylesheet" type="text/css" href="/css/pygments.min.css"/><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feeds/programming-languages.atom.xml"/><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feeds/programming-languages.rss.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-65250372-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);};gtag('js', new Date());gtag('config', 'UA-65250372-1');</script><body><header><nav role="navigation" class="navigation-bar"><ul class="navigation-items left"><li class="blog-title-header"><a href="/">Alexis King</a></li></ul><ul class="navigation-items center"></ul><ul class="navigation-items right"><li><a href="/">Home</a></li><li><a href="/about.html">About Me</a></li></ul></nav></header><section role="main"><div class="content"><h1 class="tag-page-header">Posts tagged <em>programming languages</em></h1><article class="inline"><header><h1 class="title"><a href="/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/">No, dynamic type systems are not inherently more open</a></h1><div class="date-and-tags"><time datetime="2020-01-19">2020-01-19</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/types.html">types</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a>, <a href="/tags/functional-programming.html">functional programming</a></div></header><p>Internet debates about typing disciplines continue to be plagued by a pervasive myth that dynamic type systems are inherently better at modeling “open world” domains. The argument usually goes like this: the goal of static typing is to pin everything down as much as possible, but in the real world, that just isn’t practical. Real systems should be loosely coupled and worry about data representation as little as possible, so dynamic types lead to a more robust system in the large.</p><p>This story sounds compelling, but it isn’t true. The flaw is in the premise: static types are <em>not</em> about “classifying the world” or pinning down the structure of every value in a system. The reality is that static type systems allow specifying exactly how much a component needs to know about the structure of its inputs, and conversely, how much it doesn’t. Indeed, in practice static type systems excel at processing data with only a partially-known structure, as they can be used to ensure application logic doesn’t accidentally assume too much.</p><p><a href="/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2019/10/19/empathy-and-subjective-experience-in-programming-languages/">Empathy and subjective experience in programming languages</a></h1><div class="date-and-tags"><time datetime="2019-10-19">2019-10-19</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a>, <a href="/tags/philosophy.html">philosophy</a></div></header><p>A stereotype about programmers is that they like to think in black and white. Programmers like things to be good or bad, moral or immoral, responsible or irresponsible. Perhaps there is something romantic in the idea that programmers like to be as binary as the computers they program. Reductionist? Almost certainly, but hey, laugh at yourself a bit: we probably deserve to be made fun of from time to time.</p><p>Personally, I have no idea if the trope of the nuance-challenged programmer is accurate, but whether it’s a property of programmers or just humans behind a keyboard, the intensity with which we disagree with one another never ceases to amaze. Ask any group of working programmers what their least favorite programming language is, and there’s a pretty good chance things are going to get heated real fast. Why? What is it about programming that makes us feel so strongly that we are right and others are wrong, even when our experiences contradict those of tens or hundreds of thousands of others?</p><p>I think about that question a lot.</p><p><a href="/blog/2019/10/19/empathy-and-subjective-experience-in-programming-languages/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/">A space of their own: adding a type namespace to Hackett</a></h1><div class="date-and-tags"><time datetime="2017-10-27">2017-10-27</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/programming-languages.html">programming languages</a></div></header><p>As previously discussed on this blog, <a href="https://github.com/lexi-lambda/hackett">my programming language, Hackett</a>, is a fusion of two languages, Haskell and Racket. What happens when two distinctly different programming languages collide? Hackett recently faced that very problem when it came to the question of namespacing: Haskell has two namespaces, one for values and another for types, but Racket is a staunch Lisp-1 with a single namespace for all bindings. Which convention should Hackett adopt?</p><p>For now, at least, the answer is that Hackett will emulate Haskell: <strong>Hackett now has two namespaces</strong>. Of course, Hackett is embedded in Racket, so what did it take to add an entirely new namespace to a language that possesses only one? The answer was a little more than I had hoped, but it was still remarkably simple given the problem: after two weeks of hacking, I’ve managed to get something working.</p><p><a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/">Realizing Hackett, a metaprogrammable Haskell</a></h1><div class="date-and-tags"><time datetime="2017-05-27">2017-05-27</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a></div></header><p><a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/">Almost five months ago, I wrote a blog post about my new programming language, Hackett</a>, a fanciful sketch of a programming language from a far-off land with Haskell’s type system and Racket’s macros. At that point in time, I had a little prototype that barely worked, that I barely understood, and was a little bit of a technical dead-end. People saw the post, they got excited, but development sort of stopped.</p><p>Then, almost two months ago, I took a second stab at the problem in earnest. I read a lot, I asked a lot of people for help, and eventually I got something sort of working. Suddenly, <a href="https://github.com/lexi-lambda/hackett">Hackett is not only real, it’s working, and you can try it out yourself</a>!</p><p><a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/">Rascal is now Hackett, plus some answers to questions</a></h1><div class="date-and-tags"><time datetime="2017-01-05">2017-01-05</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a></div></header><p>Since I published <a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/">my blog post introducing Rascal</a>, I’ve gotten some <em>amazing</em> feedback, more than I had ever anticipated! One of the things that was pointed out, though, is that <a href="http://www.rascal-mpl.org">Rascal is a language that already exists</a>. Given that the name “Rascal” came from a mixture of “Racket” and “Haskell”, I always had an alternative named planned, and that’s “Hackett”. So, to avoid confusion as much as possible, <a href="https://github.com/lexi-lambda/hackett"><strong>Rascal is now known as Hackett</strong></a>.</p><p>With that out of the way, I also want to answer some of the other questions I received, both to hopefully clear up some confusion and to have something I can point to if I get the same questions in the future.</p><p><a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/">Rascal: a Haskell with more parentheses</a></h1><div class="date-and-tags"><time datetime="2017-01-02">2017-01-02</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a>, <a href="/tags/functional-programming.html">functional programming</a></div></header><blockquote><p><strong>Note</strong>: since the writing of this blog post, Rascal has been renamed to Hackett. You can read about why in <a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/">the followup blog post</a>.</p></blockquote><p>“Hey! You got your Haskell in my Racket!”</p><p>“No, you got <em>your</em> Racket in <em>my</em> Haskell!”</p><p>Welcome to the <a href="https://github.com/lexi-lambda/hackett">Rascal</a> programming language.</p><p><a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2016/08/11/climbing-the-infinite-ladder-of-abstraction/">Climbing the infinite ladder of abstraction</a></h1><div class="date-and-tags"><time datetime="2016-08-11">2016-08-11</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/programming-languages.html">programming languages</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a></div></header><p>I started programming in elementary school.</p><p>When I was young, I was fascinated by the idea of automation. I loathed doing the same repetitive task over and over again, and I always yearned for a way to <a href="https://xkcd.com/974/">solve the general problem</a>. When I learned about programming, I was immediately hooked: it was <em>so easy</em> to turn repetitive tasks into automated pipelines that would free me from ever having to do the same dull, frustrating exercise ever again.</p><p>Of course, one of the first things I found out once I’d started was that nothing is ever quite so simple. Before long, my solutions to eliminate repetition grew repetitive, and it became clear I spent a lot of time typing out the same things, over and over again, creating the very problem I had initially set out to destroy. It was through this that I grew interested in functions, classes, and other repetition-reducing aids, and soon enough, I discovered the wonderful world of <strong>abstraction</strong>.</p><p><a href="/blog/2016/08/11/climbing-the-infinite-ladder-of-abstraction/"><span class="read-more-text">Read more</span> →</a></p></article><ul class="pagination"><li class="disabled">←</li><li class="pagination-number active"><a href="/tags/programming-languages.html">1</a></li><li class="disabled">→</li></ul></div></section><footer><div class="copyright-notice">© 2022, Alexis King</div><div>Built with <a href="https://docs.racket-lang.org/scribble/index.html"><strong>Scribble</strong></a>, the Racket document preparation system.</div><div>Feeds are available via <a href="/feeds/all.atom.xml">Atom</a> or <a href="/feeds/all.rss.xml">RSS</a>.</div></footer></body></head></html>