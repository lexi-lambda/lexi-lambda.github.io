<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Canonical factories for testing with factory_girl_api</title><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,300italic,400italic,700,700italic,800,800italic|Merriweather:400,300,300italic,400italic,700,700italic,900,900italic|Fira+Code:300,400,500,600,700"/><link rel="stylesheet" type="text/css" href="/css/application.min.css"/><link rel="stylesheet" type="text/css" href="/css/pygments.min.css"/><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feeds/all.atom.xml"/><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feeds/all.rss.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-65250372-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);};gtag('js', new Date());gtag('config', 'UA-65250372-1');</script><body><header><nav role="navigation" class="navigation-bar"><ul class="navigation-items left"><li class="blog-title-header"><a href="/">Alexis King</a></li></ul><ul class="navigation-items center"></ul><ul class="navigation-items right"><li><a href="/">Home</a></li><li><a href="/about.html">About Me</a></li></ul></nav></header><section role="main"><div class="content"><article class="main"><header><h1 class="title">Canonical factories for testing with factory_girl_api</h1><div class="date-and-tags"><time datetime="2015-09-23">2015-09-23</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/ruby.html">ruby</a>, <a href="/tags/rails.html">rails</a>, <a href="/tags/javascript.html">javascript</a>, <a href="/tags/angular.html">angular</a></div></header><p>Modern web applications are often built as <em>single-page apps</em>, which are great for keeping concerns separated, but problematic when tested. Logic needs to be duplicated in front- and back-end test suites, and if the two apps diverge, the tests won't catch the failure. I haven't found a very good solution to this problem aside from brittle, end-to-end integration tests.</p><p>To attempt to address a fraction of this problem, I built <a href="https://github.com/lexi-lambda/factory_girl_api">factory_girl_api</a>, a way to share context setup between both sides of the application.</p><h2><a name="a-brief-overview-of-factory-girl"></a>A brief overview of factory_girl</h2><p>In the land of Ruby and Rails, <a href="https://github.com/thoughtbot/factory_girl">factory_girl</a> is a convenient gem for managing factories for models. Out of the box, it integrates with Rails' default ORM, ActiveRecord, and provides declarative syntax for describing what attributes factories should initialize. For example, a factory declaration used to create a widget might look like this:</p><pre><code class="pygments"><span class="no">FactoryGirl</span><span class="o">.</span><span class="n">define</span> <span class="k">do</span>
  <span class="n">factory</span> <span class="ss">:widget</span> <span class="k">do</span>
    <span class="n">sequence</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="nb">id</span><span class="o">|</span> <span class="s1">&#39;Widget #&#39;</span> <span class="o">+</span> <span class="nb">id</span> <span class="p">}</span>
    <span class="n">price</span> <span class="mi">10</span>

    <span class="n">trait</span> <span class="ss">:expensive</span> <span class="k">do</span>
      <span class="n">price</span> <span class="mi">1000</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre><p>This makes it easy to create new instances of <code>Widget</code> and use them for unit tests. For example, this would create and persist a widget with a unique name and a price of 10 units:</p><pre><code class="pygments"><span class="n">widget</span> <span class="o">=</span> <span class="no">FactoryGirl</span><span class="o">.</span><span class="n">create</span> <span class="ss">:widget</span></code></pre><p>We can also create more expensive widgets by using the <code>:expensive</code> trait.</p><pre><code class="pygments"><span class="n">expensive_widget</span> <span class="o">=</span> <span class="no">FactoryGirl</span><span class="o">.</span><span class="n">create</span> <span class="ss">:widget</span><span class="p">,</span> <span class="ss">:expensive</span></code></pre><p>Any number of traits can be specified at once. Additionally, it is possible to override individual attributes manually.</p><pre><code class="pygments"><span class="n">fancy_widget</span> <span class="o">=</span> <span class="no">FactoryGirl</span><span class="o">.</span><span class="n">create</span> <span class="ss">:widget</span><span class="p">,</span> <span class="ss">:expensive</span><span class="p">,</span> <span class="nb">name</span><span class="p">:</span> <span class="s1">&#39;Fancy Widget&#39;</span></code></pre><p>It works well, and it keeps initialization boilerplate out of individual tests.</p><h2><a name="testing-on-the-front-end"></a>Testing on the front-end</h2><p>Trouble arises when we need to write tests for the JavaScript application that use the same models. Suddenly, we need to duplicate the same kind of logic in our front-end tests. We might start out by setting up object state manually:</p><pre><code class="pygments"><span class="kd">var</span> <span class="nx">fancyWidget</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Widget</span><span class="p">({</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Fancy Widget&#39;</span><span class="p">,</span>
  <span class="nx">price</span><span class="o">:</span> <span class="mi">1000</span>
<span class="p">});</span></code></pre><p>Things can quickly get out of hand when models grow complex. Even if we use a factory library in JavaScript, it's possible for our front-end factories to diverge from their back-end counterparts. This means our integration tests will fail, but our unit tests will still blindly pass. Having to duplicate all that logic in two places is dangerous. It would be nice to have a <em>single, canonical source</em> for all of our factories.</p><h3><a name="reusing-server-side-factories-with-factory-girl-api"></a>Reusing server-side factories with factory_girl_api</h3><p>To help alleviate this problem, I created the <a href="https://github.com/lexi-lambda/factory_girl_api">factory_girl_api</a> gem for Rails and the <a href="https://github.com/lexi-lambda/angular-factory-girl-api">angular-factory-girl-api</a> Bower package for Angular. These packages cooperate with each other to allow server-side factories to be used in JavaScript tests.</p><p>The Angular module provides a service with syntax comparable to factory_girl itself. Both traits and custom attributes are supported:</p><pre><code class="pygments"><span class="nx">FactoryGirl</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="s1">&#39;widget&#39;</span><span class="p">,</span> <span class="s1">&#39;expensive&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Fancy Widget&#39;</span> <span class="p">});</span></code></pre><p>In this case, however, a round-trip API call must be made to the server in order to call the factory and return the result. Because of this, the Angular version of FactoryGirl returns a promise that is resolved with the serialized version of the model, which can then be used as sample data in unit tests.</p><h3><a name="the-problems-with-relying-on-the-server-for-data"></a>The problems with relying on the server for data</h3><p>In my preliminary use of this tool, it works. In many ways, it's much nicer than duplicating logic in both places. However, I'm not <em>completely</em> convinced it's the right solution yet.</p><p>First of all, it couples the front-end to the back-end, even during unit testing, which is disappointing. It means that a server needs to be running (in test mode) in order for the tests to run at all. For the kinds of projects I work on, this isn't really a bad thing, and the benefits of the reduced duplication far outweigh the downsides.</p><p>My real concern is that this solves a very small facet of the general problem with fragile front-end test suites. Single-page applications usually depend wholly on their integration with back-end APIs. If those APIs change, the tests will continue to happily pass as long as the API is simply mocked, which seems to be the usual solution in the front-end universe. This is, frankly, unacceptable in real application development.</p><h3><a name="potential-improvements-and-other-paths-to-success"></a>Potential improvements and other paths to success</h3><p>I am ultimately unsatisfied with this approach, but writing brittle end-to-end integration tests is not the solution. This <em>kind</em> of thing may be a step in the right direction: writing tests that aren't really pure unit tests, but also aren't fragile full-stack integration tests. This is a middle-ground that seems infrequently traveled, perhaps due to a lack of tooling (or perhaps because it just doesn't work). I don't know.</p><p>Either way, I'm interested in where this is headed, and I'll be curious to see if I run into any roadblocks using the workflow I've created. If anyone else is interested in playing with these two libraries, the READMEs are much more comprehensive than what I've covered here. Take a look, and give them a spin!</p><ul><li><p><a href="https://github.com/lexi-lambda/factory_girl_api">factory_girl_api</a></p></li><li><p><a href="https://github.com/lexi-lambda/angular-factory-girl-api">angular-factory-girl-api</a></p></li></ul><ol class="footnotes"></ol><ul class="post-navigation"><li class="previous"><a href="/blog/2015/11/06/functionally-updating-record-types-in-elm/">←&nbsp;<span class="post-title">Functionally updating record types in Elm</span></a></li><li class="next"><a href="/blog/2015/08/30/managing-application-configuration-with-envy/"><span class="post-title">Managing application configuration with Envy</span>&nbsp;→</a></li></ul></article></div></section><footer><div class="copyright-notice">© 2022, Alexis King</div><div>Built with <a href="https://docs.racket-lang.org/scribble/index.html"><strong>Scribble</strong></a>, the Racket document preparation system.</div><div>Feeds are available via <a href="/feeds/all.atom.xml">Atom</a> or <a href="/feeds/all.rss.xml">RSS</a>.</div></footer></body></head></html>