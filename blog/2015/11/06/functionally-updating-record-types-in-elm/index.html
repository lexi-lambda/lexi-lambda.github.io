<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Functionally updating record types in Elm</title><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,300italic,400italic,700,700italic,800,800italic|Merriweather:400,300,300italic,400italic,700,700italic,900,900italic|Fira+Code:300,400,500,600,700"/><link rel="stylesheet" type="text/css" href="/css/application.min.css"/><link rel="stylesheet" type="text/css" href="/css/pygments.min.css"/><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feeds/all.atom.xml"/><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feeds/all.rss.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-65250372-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);};gtag('js', new Date());gtag('config', 'UA-65250372-1');</script><body><header><nav role="navigation" class="navigation-bar"><ul class="navigation-items left"><li class="blog-title-header"><a href="/">Alexis King</a></li></ul><ul class="navigation-items center"></ul><ul class="navigation-items right"><li><a href="/">Home</a></li><li><a href="/about.html">About Me</a></li></ul></nav></header><section role="main"><div class="content"><article class="main"><header><h1 class="title">Functionally updating record types in Elm</h1><div class="date-and-tags"><time datetime="2015-11-06">2015-11-06</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/elm.html">elm</a></div></header><p><a href="http://elm-lang.org">Elm</a> is a wonderful language for building web apps, and I love so much of its approach to language design. Elm does so many things <em>right</em> straight out of the box, and that's a real breath of fresh air in the intersection of functional programming and web development. Still, it gets one thing wrong, and unfortunately, that one thing is incredibly important. Elm took the "functions" out of "functional record types".</p><p>Almost any software program, at its core, is all about data. Maybe it's about computing data, maybe it's about manipulating data, or maybe it's about displaying data, but at the end of the day, some sort of data model is going to be needed. The functional model is a breathtakingly elegant system for handling data and shuttling it around throughout a program, and <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">functional reactive programming</a>, which Elm uses to model event-like interactions, makes this model work even better. The really important thing, though, is what tools Elm actually gives you to model your data.</p><h2><a name="a-brief-primer-on-elm-records"></a>A brief primer on Elm records</h2><p>Elm supports all the core datatypes one would expect—numbers, strings, booleans, optionals, etc.—and it allows users to define their own types with ADTs. However, Elm also provides another datatype, which it calls "records". Records are similar to objects in JavaScript: they're effectively key-value mappings. They're cool data structures, and they work well. Here's an example of creating a <code>Point</code> datatype in Elm:</p><pre><code class="pygments"><span class="kr">type</span> <span class="kr">alias</span> <span class="kt">Point</span> <span class="nf">=</span>
  <span class="p">{</span> <span class="nv">x</span> <span class="nf">:</span> <span class="kt">Float</span><span class="p">,</span> <span class="nv">y</span> <span class="nf">:</span> <span class="kt">Float</span> <span class="p">}</span></code></pre><p>Notice that <code>Point</code> is declared as a type <em>alias</em>, not as a separate type like an ADT. This is because record types are truly encoded in the type system as values with named fields, not as disparate types. This allows for some fun tricks, but that's outside the scope of this blog post.</p><h2><a name="the-good"></a>The good</h2><p>What I'd like to discuss is what it looks like to <em>manipulate</em> these data structures. Constructing them is completely painless, and reading from them is super simple. This is where the record system gets everything very <em>right</em>.</p><pre><code class="pygments"><span class="nv">origin</span> <span class="nf">:</span> <span class="kt">Point</span>
<span class="nv">origin</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">x</span> <span class="nf">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">y</span> <span class="nf">=</span> <span class="mi">0</span> <span class="p">}</span>

<span class="nv">distanceBetween</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Float</span>
<span class="nv">distanceBetween</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nf">=</span>
  <span class="kr">let</span> <span class="nv">dx</span> <span class="nf">=</span> <span class="nv">a</span><span class="nf">.</span><span class="nv">x</span> <span class="nf">-</span> <span class="nv">b</span><span class="nf">.</span><span class="nv">x</span>
      <span class="nv">dy</span> <span class="nf">=</span> <span class="nv">a</span><span class="nf">.</span><span class="nv">y</span> <span class="nf">-</span> <span class="nv">b</span><span class="nf">.</span><span class="nv">y</span>
  <span class="kr">in</span> <span class="nv">sqrt</span> <span class="p">(</span><span class="nv">dx</span><span class="nf">*</span><span class="nv">dx</span> <span class="nf">+</span> <span class="nv">dy</span><span class="nf">*</span><span class="nv">dy</span><span class="p">)</span></code></pre><p>The syntax is clean and simple. Most importantly, however, the record system is functional (in the "functional programming" sense). In a functional system, it's useful to express concepts in terms of function composition, and this is very easy to do in Elm. Creating a function to access a field would normally be clunky if you always needed to do <code>record.field</code> to access the value. Fortunately, Elm provides some sugar:</p><pre><code class="pygments"><span class="c1">-- These two expressions are equivalent:</span>
<span class="p">(</span><span class="nf">\</span><span class="nv">record</span> <span class="nf">-&gt;</span> <span class="nv">record</span><span class="nf">.</span><span class="nv">field</span><span class="p">)</span>
<span class="nf">.</span><span class="nv">field</span></code></pre><p>Using the <code>.field</code> shorthand allows writing some other functions in terms of composition, as most functional programmers would desire:</p><pre><code class="pygments"><span class="nv">doubledX</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Float</span>
<span class="nv">doubledX</span> <span class="nf">=</span> <span class="p">(</span><span class="nf">(*)</span> <span class="mi">2</span><span class="p">)</span> <span class="nf">&lt;&lt;</span> <span class="nf">.</span><span class="nv">x</span></code></pre><p>This satisfies me.</p><h2><a name="the-bad"></a>The bad</h2><p>So if everything in Elm is so great, what am I complaining about? Well, while the syntax to access fields is convenient, the syntax to <em>functionally set</em> fields is questionably clunky. Consider a function that accepts a point and returns a new point with its <code>x</code> field set to <code>0</code>:</p><pre><code class="pygments"><span class="nv">zeroedX</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">zeroedX</span> <span class="nv">point</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">point</span> <span class="nf">|</span> <span class="nv">x</span> <span class="nf">&lt;-</span> <span class="mi">0</span> <span class="p">}</span></code></pre><p>This doesn't look too bad, does it? It's clear and concise. To me, though, there's something deeply wrong here... this function has a lot of redundancy! It seems to me like we should be able to write this function more clearly in a point-free style. The <code>.field</code> shorthand "functionalizes" the record getter syntax, so there must be a function version of the update syntax, right? Maybe it would look something like this:</p><pre><code class="pygments"><span class="nv">zeroedX</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">zeroedX</span> <span class="nf">=</span> <span class="err">!</span><span class="nv">x</span> <span class="mi">0</span></code></pre><p>But alas, there is no such syntax.</p><p>Now you may ask... why does it matter? This seems trivial, and in fact, the explicit updater syntax may actually be more readable by virtue of how explicit it is. You'd be right, because so far, these examples have been horribly contrived. But let's consider a slightly more useful example: <em>functionally updating</em> a record.</p><p>What's the difference? Well, say I wanted to take a point and increment its <code>x</code> field by one. Well, I can easily write a function for that:</p><pre><code class="pygments"><span class="nv">incrementX</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">incrementX</span> <span class="nv">point</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">point</span> <span class="nf">|</span> <span class="nv">x</span> <span class="nf">&lt;-</span> <span class="nv">point</span><span class="nf">.</span><span class="nv">x</span> <span class="nf">+</span> <span class="mi">1</span> <span class="p">}</span></code></pre><p>Not terrible, though a <em>little</em> verbose. Still, what if we want to also add a function that <em>decrements</em> <code>x</code>?</p><pre><code class="pygments"><span class="nv">decrementX</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">decrementX</span> <span class="nv">point</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">point</span> <span class="nf">|</span> <span class="nv">x</span> <span class="nf">&lt;-</span> <span class="nv">point</span><span class="nf">.</span><span class="nv">x</span> <span class="nf">-</span> <span class="mi">1</span> <span class="p">}</span></code></pre><p>Oh, gosh. That's basically the exact same definition but with the operation flipped. Plus we probably want these operations for <code>y</code>, too. Fortunately, there's an easy solution: just pass a function in to <em>transform</em> the value! We can define an <code>updateX</code> function that allows us to do that easily, then we can define our derived operations in terms of that:</p><pre><code class="pygments"><span class="nv">updateX</span> <span class="nf">:</span> <span class="p">(</span><span class="kt">Float</span> <span class="nf">-&gt;</span> <span class="kt">Float</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">updateX</span> <span class="nv">f</span> <span class="nv">point</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">point</span> <span class="nf">|</span> <span class="nv">x</span> <span class="nf">&lt;-</span> <span class="nv">f</span> <span class="nv">point</span><span class="nf">.</span><span class="nv">x</span> <span class="p">}</span>

<span class="nv">incrementX</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">incrementX</span> <span class="nf">=</span> <span class="nv">updateX</span> <span class="p">(</span><span class="nf">(+)</span> <span class="mi">1</span><span class="p">)</span>

<span class="nv">decrementX</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">decrementX</span> <span class="nf">=</span> <span class="nv">updateX</span> <span class="p">(</span><span class="nf">\</span><span class="nv">x</span> <span class="nf">-&gt;</span> <span class="nv">x</span> <span class="nf">-</span> <span class="mi">1</span><span class="p">)</span></code></pre><p>Not only is that much cleaner, but we can now use it to implement all sorts of other operations that allow us to add, subtract, multiply, or divide the <code>x</code> field. Now we just need to generalize our solution to work with the <code>x</code> <em>and</em> <code>y</code> fields!</p><p>Oh, wait. <strong>We can't.</strong></p><h2><a name="the-ugly"></a>The ugly</h2><p>This is where everything breaks down completely. Elm does not offer enough abstraction to reduce this level of crazy duplication:</p><pre><code class="pygments"><span class="nv">updateX</span> <span class="nf">:</span> <span class="p">(</span><span class="kt">Float</span> <span class="nf">-&gt;</span> <span class="kt">Float</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">updateX</span> <span class="nv">f</span> <span class="nv">point</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">point</span> <span class="nf">|</span> <span class="nv">x</span> <span class="nf">&lt;-</span> <span class="nv">f</span> <span class="nv">point</span><span class="nf">.</span><span class="nv">x</span> <span class="p">}</span>

<span class="nv">incrementX</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">incrementX</span> <span class="nf">=</span> <span class="nv">updateX</span> <span class="p">(</span><span class="nf">(+)</span> <span class="mi">1</span><span class="p">)</span>

<span class="nv">decrementX</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">decrementX</span> <span class="nf">=</span> <span class="nv">updateX</span> <span class="p">(</span><span class="nf">\</span><span class="nv">x</span> <span class="nf">-&gt;</span> <span class="nv">x</span> <span class="nf">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="nv">updateY</span> <span class="nf">:</span> <span class="p">(</span><span class="kt">Float</span> <span class="nf">-&gt;</span> <span class="kt">Float</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">updateY</span> <span class="nv">f</span> <span class="nv">point</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">point</span> <span class="nf">|</span> <span class="nv">y</span> <span class="nf">&lt;-</span> <span class="nv">f</span> <span class="nv">point</span><span class="nf">.</span><span class="nv">y</span> <span class="p">}</span>

<span class="nv">incrementY</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">incrementY</span> <span class="nf">=</span> <span class="nv">updateY</span> <span class="p">(</span><span class="nf">(+)</span> <span class="mi">1</span><span class="p">)</span>

<span class="nv">decrementY</span> <span class="nf">:</span> <span class="kt">Point</span> <span class="nf">-&gt;</span> <span class="kt">Point</span>
<span class="nv">decrementY</span> <span class="nf">=</span> <span class="nv">updateY</span> <span class="p">(</span><span class="nf">\</span><span class="nv">x</span> <span class="nf">-&gt;</span> <span class="nv">x</span> <span class="nf">-</span> <span class="mi">1</span><span class="p">)</span></code></pre><p>We sure can give it a shot, though. At the very least, we <em>can</em> implement the increment and decrement functions in a more general way by passing in an updater function:</p><pre><code class="pygments"><span class="nv">increment</span> <span class="nf">:</span> <span class="p">((</span><span class="kt">Float</span> <span class="nf">-&gt;</span> <span class="kt">Float</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="nv">a</span> <span class="nf">-&gt;</span> <span class="nv">a</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="nv">a</span> <span class="nf">-&gt;</span> <span class="nv">a</span>
<span class="nv">increment</span> <span class="nv">update</span> <span class="nf">=</span> <span class="nv">update</span> <span class="p">(</span><span class="nf">(+)</span> <span class="mi">1</span><span class="p">)</span></code></pre><p>Now, with <code>updateX</code> and <code>updateY</code>, we can increment either field very clearly and expressively. If we shorten the names to <code>uX</code> and <code>uY</code>, then the resulting code is actually very readable:</p><pre><code class="pygments"><span class="nv">pointAbove</span> <span class="nf">=</span> <span class="nv">uY</span> <span class="p">(</span><span class="nf">\</span><span class="nv">x</span> <span class="nf">-&gt;</span> <span class="nv">x</span> <span class="nf">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">pointBelow</span> <span class="nf">=</span> <span class="nv">uY</span> <span class="p">(</span><span class="nf">\</span><span class="nv">x</span> <span class="nf">-&gt;</span> <span class="nv">x</span> <span class="nf">-</span> <span class="mi">1</span><span class="p">)</span></code></pre><p>It's almost like English now: "update Y using this transformation". This is actually pretty satisfactory. The trouble arises when you have a struct with many fields:</p><pre><code class="pygments"><span class="kr">type</span> <span class="kr">alias</span> <span class="kt">PlayerStats</span> <span class="nf">=</span>
  <span class="p">{</span> <span class="nv">health</span> <span class="nf">:</span> <span class="kt">Integer</span>
  <span class="p">,</span> <span class="nv">strength</span> <span class="nf">:</span> <span class="kt">Integer</span>
  <span class="p">,</span> <span class="nv">charisma</span> <span class="nf">:</span> <span class="kt">Integer</span>
  <span class="p">,</span> <span class="nv">intellect</span> <span class="nf">:</span> <span class="kt">Integer</span>
  <span class="c1">-- etc.</span>
  <span class="p">}</span></code></pre><p>It might be very convenient to have generic functional updaters in this case. One could imagine a game that has <code>Potion</code> items:</p><pre><code class="pygments"><span class="kr">type</span> <span class="kt">Potion</span> <span class="nf">=</span> <span class="kt">Potion</span> <span class="kt">String</span> <span class="p">(</span><span class="kt">PlayerStats</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span><span class="p">)</span></code></pre><p>And then some different kinds of potions:</p><pre><code class="pygments"><span class="nv">potions</span> <span class="nf">=</span>
  <span class="p">[</span> <span class="p">(</span><span class="kt">Potion</span> <span class="s">"Health Potion"</span> <span class="p">(</span><span class="nv">uHealth</span> <span class="p">(</span><span class="nf">(+)</span> <span class="mi">1</span><span class="p">))),</span>
  <span class="p">,</span> <span class="p">(</span><span class="kt">Potion</span> <span class="s">"Greater Intellect Potion"</span> <span class="p">(</span><span class="nv">uIntellect</span> <span class="p">(</span><span class="nf">(+)</span> <span class="mi">3</span><span class="p">)))</span>
  <span class="p">,</span> <span class="p">(</span><span class="kt">Potion</span> <span class="s">"Potion of Weakness"</span> <span class="p">(</span><span class="nv">uStrength</span> <span class="p">(</span><span class="nf">\</span><span class="nv">x</span> <span class="nf">-&gt;</span> <span class="nv">x</span> <span class="nf">//</span> <span class="mi">5</span><span class="p">)))</span>
  <span class="p">]</span></code></pre><p>This is a really elegant way to think about items that can affect a player's stats! Unfortunately, it also means you have to define updater functions for <em>every single field in the record</em>. This can get tedious rather quickly:</p><pre><code class="pygments"><span class="nv">uHealth</span> <span class="nf">:</span> <span class="p">(</span><span class="kt">Integer</span> <span class="nf">-&gt;</span> <span class="kt">Integer</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span>
<span class="nv">uHealth</span> <span class="nv">f</span> <span class="nv">stats</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">stats</span> <span class="nf">|</span> <span class="nv">health</span> <span class="nf">&lt;-</span> <span class="nv">f</span> <span class="nv">stats</span><span class="nf">.</span><span class="nv">health</span> <span class="p">}</span>

<span class="nv">uStrength</span> <span class="nf">:</span> <span class="p">(</span><span class="kt">Integer</span> <span class="nf">-&gt;</span> <span class="kt">Integer</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span>
<span class="nv">uStrength</span> <span class="nv">f</span> <span class="nv">stats</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">stats</span> <span class="nf">|</span> <span class="nv">strength</span> <span class="nf">&lt;-</span> <span class="nv">f</span> <span class="nv">stats</span><span class="nf">.</span><span class="nv">strength</span> <span class="p">}</span>

<span class="nv">uCharisma</span> <span class="nf">:</span> <span class="p">(</span><span class="kt">Integer</span> <span class="nf">-&gt;</span> <span class="kt">Integer</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span>
<span class="nv">uCharisma</span> <span class="nv">f</span> <span class="nv">stats</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">stats</span> <span class="nf">|</span> <span class="nv">charisma</span> <span class="nf">&lt;-</span> <span class="nv">f</span> <span class="nv">stats</span><span class="nf">.</span><span class="nv">charisma</span> <span class="p">}</span>

<span class="c1">-- etc.</span></code></pre><p>This is pretty icky. Could there be a better way?</p><h2><a name="trying-to-create-a-more-general-abstraction"></a>Trying to create a more general abstraction</h2><p>Interestingly, this pattern doesn't <em>need</em> to be this bad. There are better ways to do this. Let's revisit our updater functions.</p><p>Really, <code>update</code> can be defined in terms of two other primitive operations: a read and a (functional) write. What would it look like if we implemented it that way instead of requiring special updater functions to be defined? Well, it would look like this:</p><pre><code class="pygments"><span class="nv">update</span> <span class="nf">:</span> <span class="p">(</span><span class="nv">a</span> <span class="nf">-&gt;</span> <span class="nv">b</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="p">(</span><span class="nv">b</span> <span class="nf">-&gt;</span> <span class="nv">a</span> <span class="nf">-&gt;</span> <span class="nv">a</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="p">(</span><span class="nv">b</span> <span class="nf">-&gt;</span> <span class="nv">b</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="nv">a</span> <span class="nf">-&gt;</span> <span class="nv">a</span>
<span class="nv">update</span> <span class="nv">get</span> <span class="nv">set</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nf">=</span> <span class="nv">set</span> <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">get</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">x</span></code></pre><p>The type definition is a little long, but it's really pretty simple. We just supply a getter and a setter, then a function to do the transformation, and finally a record to actually transform. Of course, as you can see from the type, this function isn't actually specific to records: it can be used with any value for which a getter and setter can be provided.</p><p>The trouble here is that writing field setters isn't any easier in Elm than writing field updaters. They still look pretty verbose:</p><pre><code class="pygments"><span class="nv">sHealth</span> <span class="nf">:</span> <span class="kt">Integer</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span>
<span class="nv">sHealth</span> <span class="nv">x</span> <span class="nv">stats</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">stats</span> <span class="nf">|</span> <span class="nv">health</span> <span class="nf">&lt;-</span> <span class="nv">x</span> <span class="p">}</span>

<span class="nv">uHealth</span> <span class="nf">:</span> <span class="p">(</span><span class="kt">Integer</span> <span class="nf">-&gt;</span> <span class="kt">Integer</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span>
<span class="nv">uHealth</span> <span class="nf">=</span> <span class="nv">update</span> <span class="nf">.</span><span class="nv">health</span> <span class="nv">sHealth</span></code></pre><p>So, at the end of it all, this isn't really a better abstraction. Still remember my fantasy <code>!field</code> setter shorthand half a blog post ago? Now perhaps it makes a little more sense. <em>If</em> such a syntax existed, then defining the updater would be incredibly simple:</p><pre><code class="pygments"><span class="nv">uHealth</span> <span class="nf">:</span> <span class="p">(</span><span class="kt">Integer</span> <span class="nf">-&gt;</span> <span class="kt">Integer</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span> <span class="nf">-&gt;</span> <span class="kt">PlayerStats</span>
<span class="nv">uHealth</span> <span class="nf">=</span> <span class="nv">update</span> <span class="nf">.</span><span class="nv">health</span> <span class="err">!</span><span class="nv">health</span></code></pre><p>Still, no syntax, no easy updaters, and by extension, no easy, declarative description of behavior without quite a bit of boilerplate.</p><h2><a name="conclusions-and-related-work"></a>Conclusions and related work</h2><p>Elm is a very promising language, and it seems to be in fairly rapid development. So far, its author, <a href="https://twitter.com/czaplic">Evan Czaplicki</a>, has taken a very cautious approach to implementing language features, especially potentially redundant ones. This caution is why things like operator slicing, "where" clauses, and special updater syntax have not yet made it into the language. Maybe at some point these will be deemed important enough to include, but for the time being, they've been excluded.</p><p>I obviously think that having this sort of thing is incredibly important to being able to write expressive code without a huge amount of overhead. However, I also do <em>not</em> want to give the impression that I think adding special setter syntax is the only way to do it.</p><p>Seasoned functional programmers will surely have noticed that many of these concepts sound a lot like lenses, and Elm actually already has a lens-like library authored by Evan himself, called <a href="https://github.com/evancz/focus">Focus</a>. This, however, does not actually solve the problem: it requires manual description of setters just like the purely function based approach does. Really, lenses are just the logical next step in the line of abstraction I've already laid out above.</p><p>Interestingly, PureScript and Elm, the two Haskell-likes-on-the-frontend that I've paid attention to (though PureScript is much closer to Haskell than Elm), both have this very same problem. Haskell itself solves it with macros via Template Haskell. My favorite language, Racket, solves it with its own macro system. Is there another way to do these things that doesn't involve introducing a heavyweight macro system? Definitely. But I think this is a <em>necessary feature</em>, not a "nice to have", so if a macro system is out of the picture, then a simpler, less flexible solution is the obvious logical alternative.</p><p>I really like Elm, and most of my experiences with it have been more than enough to convince me that it is a fantastic language for the job. Unfortunately, the issue of functional record updaters has been quite the frustrating obstacle in my otherwise frictionless ride. I will continue to happily use Elm over other, far less accommodating tools, but I hope that issues like these will be smoothed out as the language and its ecosystem matures.</p><ol class="footnotes"></ol><ul class="post-navigation"><li class="previous"><a href="/blog/2015/12/21/adts-in-typed-racket-with-macros/">←&nbsp;<span class="post-title">ADTs in Typed Racket with macros</span></a></li><li class="next"><a href="/blog/2015/09/23/canonical-factories-for-testing-with-factory-girl-api/"><span class="post-title">Canonical factories for testing with factory_girl_api</span>&nbsp;→</a></li></ul></article></div></section><footer><div class="copyright-notice">© 2022, Alexis King</div><div>Built with <a href="https://docs.racket-lang.org/scribble/index.html"><strong>Scribble</strong></a>, the Racket document preparation system.</div><div>Feeds are available via <a href="/feeds/all.atom.xml">Atom</a> or <a href="/feeds/all.rss.xml">RSS</a>.</div></footer></body></head></html>