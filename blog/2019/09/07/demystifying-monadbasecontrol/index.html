<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Demystifying `MonadBaseControl`</title>
    <meta name="description" content="`MonadBaseControl` from the `monad-control` package is a confusing typeclass, and its methods have complicated types. For many people, it’s nothing more than scary, impossible-to-understand magic that is, for some reason, needed when lifting certain kinds...">
    <meta name="author"      content="Alexis King">
    <meta name="keywords"    content="haskell">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/favicon.ico">
    <link rel="canonical" href="http://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/">
    <link rel="next" href="/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/">
    <link rel="prev" href="/blog/2019/10/19/empathy-and-subjective-experience-in-programming-languages/">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,300italic,400italic,700,700italic,800,800italic|Merriweather:400,300,300italic,400italic,700,700italic,900,900italic|Fira+Code:300,400,500,600,700">
    <link rel="stylesheet" type="text/css" href="/css/application.min.css">
    <link rel="stylesheet" type="text/css" href="/css/pygments.min.css">
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml"
          href="/feeds/all.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml"
          href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    <!-- <script src="/js/application.min.js"></script> -->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-65250372-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
    <div id="page-content">
      <!-- Navigation Bar -->
      <header>
        <nav role="navigation" class="navigation-bar">
          <ul class="navigation-items left">
            <li id="blog-title-header"><a href="/"><h1>Alexis King</h1></a></li>
          </ul>
          <ul class="navigation-items center"></ul>
          <ul class="navigation-items right">
            <li><a href="/">Home</a></li>
            <li><a href="/resume.html">About Me</a></li>
          </ul>
        </nav>
      </header>
      <section role="main">
        <!-- Main column -->
        <div class="content" class="col-md-12">



          <article class="main">
  <header>
    <h1 class="title">Demystifying <code>MonadBaseControl</code></h1>
    <div class='date-and-tags'>
      <time datetime="2019-09-07T18:00:00">
        2019-09-07
      </time>
      <span style="margin: 0 3px">⦿</span>
      <span class="tags"><a href="/tags/haskell.html">haskell</a></span>
    </div>
  </header>

<p><a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl"><code>MonadBaseControl</code> from the <code>monad-control</code> package</a> is a confusing typeclass, and its methods have complicated types. For many people, it’s nothing more than scary, impossible-to-understand magic that is, for some reason, needed when lifting certain kinds of operations. Few resources exist that adequately explain how, why, and when it works, which sadly seems to have resulted in some <a href="https://en.wikipedia.org/wiki/Fear,_uncertainty,_and_doubt">FUD</a> about its use.</p>

<p>There’s no doubt that the machinery of <code>MonadBaseControl</code> is complex, and the role it plays in practice is often subtle. However, its essence is actually much simpler than it appears, and I promise it can be understood by mere mortals. In this blog post, I hope to provide a complete survey of <code>MonadBaseControl</code>—how it works, how it’s designed, and how it can go wrong—in a way that is accessible to anyone with a firm grasp of monads and monad transformers. To start, we’ll motivate <code>MonadBaseControl</code> by reinventing it ourselves.</p>
<!-- more-->

<h1 id="the-higher-order-action-problem">The higher-order action problem</h1>

<p>Say we have a function with the following type:<sup><a href="#2019-09-07-demystifying-monadbasecontrol-footnote-1-definition" name="2019-09-07-demystifying-monadbasecontrol-footnote-1-return">1</a></sup></p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
</pre></div>

</div>

<p>If we have an action built from a transformer stack like</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">bar</span> <span class="ow">::</span> <span class="kt">StateT</span> <span class="kt">X</span> <span class="kt">IO</span> <span class="kt">Y</span>
</pre></div>

</div>

<p>then we might wish to apply <code>foo</code> to <code>bar</code>, but that is ill-typed, since <code>IO</code> is not the same as <code>StateT X IO</code>. In cases like these, we often use <code>lift</code>, but it’s not good enough here: <code>lift</code> <em>adds</em> a new monad transformer to an action, but here we need to <em>remove</em> a transformer. So we need a function with a type like this:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">unliftState</span> <span class="ow">::</span> <span class="kt">StateT</span> <span class="kt">X</span> <span class="kt">IO</span> <span class="kt">Y</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Y</span>
</pre></div>

</div>

<p>However, if you think about that type just a little bit, it’s clear something’s wrong: it throws away information, namely the state. You may remember that a <code>StateT X IO Y</code> action is equivalent to a function of type <code>X -&gt; IO (Y, X)</code>, so our hypothetical <code>unliftState</code> function has two problems:</p>

<ol>
 <li>
  <p>We have no <code>X</code> to use as the initial state.</p></li>
 <li>
  <p>We’ll lose any modifications <code>bar</code> made to the state, since the result type is just <code>Y</code>, not <code>(Y, X)</code>.</p></li></ol>

<p>Clearly, we’ll need something more sophisticated, but what?</p>

<h1 id="a-naïve-solution">A naïve solution</h1>

<p>Given that <code>foo</code> doesn’t know anything about the state, we can’t easily thread it through <code>foo</code> itself. However, by using <code>runStateT</code> explicitly, we could do some of the state management ourselves:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">StateT</span> <span class="n">s</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">StateT</span> <span class="n">s</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">foo&#39;</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">get</span>
  <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">lift</span> <span class="o">$</span> <span class="n">foo</span> <span class="p">(</span><span class="n">runStateT</span> <span class="n">m</span> <span class="n">s</span><span class="p">)</span>
  <span class="n">put</span> <span class="n">s&#39;</span>
  <span class="n">pure</span> <span class="n">v</span>
</pre></div>

</div>

<p>Do you see what’s going on there? It’s not actually very complicated: we get the current state, then pass it as the initial state to <code>runStateT</code>. This produces an action <code>IO (a, s)</code> that has <em>closed over</em> the current state. We can pass that action to <code>foo</code> without issue, since <code>foo</code> is polymorphic in the action’s return type. Finally, all we have to do is <code>put</code> the modified state back into the enclosing <code>StateT</code> computation, and we can get on with our business.</p>

<p>That strategy works okay when we only have one monad transformer, but it gets hairy quickly as soon as we have two or more. For example, if we had <code>baz :: ExceptT X (StateT Y IO) Z</code>, then we <em>could</em> do the same trick by getting the underlying</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kt">Y</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Either</span> <span class="kt">X</span> <span class="kt">Z</span><span class="p">,</span> <span class="kt">Y</span><span class="p">)</span>
</pre></div>

</div>

<p>function, closing over the state, restoring it, and doing the appropriate case analysis to re-raise any <code>ExceptT</code> errors, but that’s a lot of work to do for every single function! What we’d like to do instead is somehow abstract over the pattern we used to write <code>foo'</code> in a way that scales to arbitrary monad transformers.</p>

<h1 id="the-essence-of-monadbasecontrol">The essence of <code>MonadBaseControl</code></h1>

<p>To build a more general solution for “unlifting” arbitrary monad transformers, we need to start thinking about monad transformer state. The technique we used to implement <code>foo'</code> operated on the following process:</p>

<ol>
 <li>
  <p>Capture the action’s input state and close over it.</p></li>
 <li>
  <p>Package up the action’s output state with its result and run it.</p></li>
 <li>
  <p>Restore the action’s output state into the enclosing transformer.</p></li>
 <li>
  <p>Return the action’s result.</p></li></ol>

<p>For <code>StateT s</code>, it turns out that the input state and output state are both <code>s</code>, but other monad transformers have state, too. Consider the input and output state for the following common monad transformers:</p>

<div class="table-wrapper">
 <table class="no-line-wrapping">
  <thead>
   <tr>
    <th>transformer</th> 
    <th>representation</th> 
    <th>input state</th> 
    <th>output state</th></tr></thead>
  <tr>
   <td><code>StateT s m a</code></td> 
   <td><code>s -&gt; m (a, s)</code></td> 
   <td><code>s</code></td> 
   <td><code>s</code></td></tr>
  <tr>
   <td><code>ReaderT r m a</code></td> 
   <td><code>r -&gt; m a</code></td> 
   <td><code>r</code></td> 
   <td><code>()</code></td></tr>
  <tr>
   <td><code>WriterT w m a</code></td> 
   <td><code>m (a, w)</code></td> 
   <td><code>()</code></td> 
   <td><code>w</code></td></tr></table></div>

<p>Notice how the input state is whatever is to the left of the <code>-&gt;</code>, while the output state is whatever extra information gets produced alongside the result. Using the same reasoning, we can also deduce the input and output state for compositions of multiple monad transformers, such as the following:</p>

<div class="table-wrapper">
 <table class="no-line-wrapping">
  <thead>
   <tr>
    <th>transformer</th> 
    <th>representation</th> 
    <th>input state</th> 
    <th>output state</th></tr></thead>
  <tr>
   <td><code>ReaderT r (WriterT w m) a</code></td> 
   <td><code>r -&gt; m (a, w)</code></td> 
   <td><code>r</code></td> 
   <td><code>w</code></td></tr>
  <tr>
   <td><code>StateT s (ReaderT r m) a</code></td> 
   <td><code>r -&gt; s -&gt; m (a, s)</code></td> 
   <td><code>(r, s)</code></td> 
   <td><code>s</code></td></tr>
  <tr>
   <td><code>WriterT w (StateT s m) a</code></td> 
   <td><code>s -&gt; m ((a, w), s)</code></td> 
   <td><code>s</code></td> 
   <td><code>(w, s)</code></td></tr></table></div>

<p>Notice that when monad transformers are composed, their states are composed, too. This is useful to keep in mind, since our goal is to capture the four steps above in a typeclass, polymorphic in the state of the monad transformers we need to lift through. At minimum, we need two new operations: one to capture the input state and close over it (step 1) and one to restore the output state (step 3). One class we might come up with could look like this:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">class</span> <span class="kt">MonadBase</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">InputState</span> <span class="n">m</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="n">m</span>
  <span class="n">captureInputState</span> <span class="ow">::</span> <span class="n">m</span> <span class="p">(</span><span class="kt">InputState</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">closeOverInputState</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">InputState</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">OutputState</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">restoreOutputState</span> <span class="ow">::</span> <span class="kt">OutputState</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
</pre></div>

</div>

<p>If we can write instances of that typeclass for various transformers, we can use the class’s operations to implement <code>foo'</code> in a generic way that works with any combination of them:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">foo&#39;</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">captureInputState</span>
  <span class="kr">let</span> <span class="n">m&#39;</span> <span class="ow">=</span> <span class="n">closeOverInputState</span> <span class="n">m</span> <span class="n">s</span>
  <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">liftBase</span> <span class="o">$</span> <span class="n">foo</span> <span class="n">m&#39;</span>
  <span class="n">restoreOutputState</span> <span class="n">s&#39;</span>
  <span class="n">pure</span> <span class="n">v</span>
</pre></div>

</div>

<p>So how do we implement those instances? Let’s start with <code>IO</code>, since that’s the base case:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="kt">IO</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">InputState</span> <span class="kt">IO</span> <span class="ow">=</span> <span class="nb">()</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="kt">IO</span> <span class="ow">=</span> <span class="nb">()</span>
  <span class="n">captureInputState</span> <span class="ow">=</span> <span class="n">pure</span> <span class="nb">()</span>
  <span class="n">closeOverInputState</span> <span class="n">m</span> <span class="nb">()</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&lt;&amp;&gt;</span> <span class="p">(,</span> <span class="nb">()</span><span class="p">)</span>
  <span class="n">restoreOutputState</span> <span class="nb">()</span> <span class="ow">=</span> <span class="n">pure</span> <span class="nb">()</span>
</pre></div>

</div>

<p>Not very exciting. The <code>StateT s</code> instance, on the other hand, is significantly more interesting:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">InputState</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kt">InputState</span> <span class="n">m</span><span class="p">)</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kt">OutputState</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">captureInputState</span> <span class="ow">=</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="n">get</span> <span class="o">&lt;*&gt;</span> <span class="n">lift</span> <span class="n">captureInputState</span>
  <span class="n">closeOverInputState</span> <span class="n">m</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">),</span> <span class="n">ss&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">closeOverInputState</span> <span class="p">(</span><span class="n">runStateT</span> <span class="n">m</span> <span class="n">s</span><span class="p">)</span> <span class="n">ss</span>
    <span class="n">pure</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">ss&#39;</span><span class="p">))</span>
  <span class="n">restoreOutputState</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">restoreOutputState</span> <span class="n">ss</span><span class="p">)</span> <span class="o">*&gt;</span> <span class="n">put</span> <span class="n">s</span>
</pre></div>

</div>

<p><strong>This instance alone includes most of the key ideas behind <code>MonadBaseControl</code>.</strong> There’s a lot going on, so let’s break it down, step by step:</p>

<ol>
 <li>
  <p>Start by examining the definitions of <code>InputState</code> and <code>OutputState</code>. Are they what you expected? You’d be forgiven for expecting the following:</p>
  <div class="brush: haskell">
   <div class="source">
    <pre><span></span><span class="kr">type</span> <span class="kt">InputState</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">s</span>
<span class="kr">type</span> <span class="kt">OutputState</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">s</span>
</pre></div>

</div>
  <p>After all, that’s what we wrote in the table, isn’t it?</p>
  <p>However, if you give it a try, you’ll find it doesn’t work. <code>InputState</code> and <code>OutputState</code> must capture the state of the <em>entire</em> monad, not just a single transformer layer, so we have to combine the <code>StateT s</code> state with the state of the underlying monad. In the simplest case we get</p>
  <div class="brush: haskell">
   <div class="source">
    <pre><span></span><span class="kt">InputState</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="kt">IO</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">()</span><span class="p">)</span>
</pre></div>

</div>
  <p>which is boring, but in a more complex case, we need to get something like this:</p>
  <div class="brush: haskell">
   <div class="source">
    <pre><span></span><span class="kt">InputState</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="kt">IO</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nb">()</span><span class="p">))</span>
</pre></div>

</div>
  <p>Therefore, <code>InputState (StateT s m)</code> combines <code>s</code> with <code>InputState m</code> in a tuple, and <code>OutputState</code> does the same.</p></li>
 <li>
  <p>Moving on, take a look at <code>captureInputState</code> and <code>closeOverInputState</code>. Just as <code>InputState</code> and <code>OutputState</code> capture the state of the entire monad, these functions need to be inductive in the same way.</p>
  <p><code>captureInputState</code> acquires the current state using <code>get</code>, and it combines it with the remaining monadic state using <code>lift captureInputState</code>. <code>closeOverInputState</code> uses the captured state to peel off the outermost <code>StateT</code> layer, then calls <code>closeOverInputState</code> recursively to peel off the rest of them.</p></li>
 <li>Finally, <code>restoreOutputState</code> restores the state of the underlying monad stack, then restores the <code>StateT</code> state, ensuring everything ends up back the way it’s supposed to be.</li></ol>

<p>Take the time to digest all that—work through it yourself if you need to—as it’s a dense piece of code. Once you feel comfortable with it, take a look at the instances for <code>ReaderT</code> and <code>WriterT</code> as well:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">InputState</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="kt">InputState</span> <span class="n">m</span><span class="p">)</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">OutputState</span> <span class="n">m</span>
  <span class="n">captureInputState</span> <span class="ow">=</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="n">ask</span> <span class="o">&lt;*&gt;</span> <span class="n">lift</span> <span class="n">captureInputState</span>
  <span class="n">closeOverInputState</span> <span class="n">m</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="ow">=</span> <span class="n">closeOverInputState</span> <span class="p">(</span><span class="n">runReaderT</span> <span class="n">m</span> <span class="n">s</span><span class="p">)</span> <span class="n">ss</span>
  <span class="n">restoreOutputState</span> <span class="n">ss</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">restoreOutputState</span> <span class="n">ss</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">InputState</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">InputState</span> <span class="n">m</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="kt">OutputState</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">captureInputState</span> <span class="ow">=</span> <span class="n">lift</span> <span class="n">captureInputState</span>
  <span class="n">closeOverInputState</span> <span class="n">m</span> <span class="n">ss</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">),</span> <span class="n">ss&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">closeOverInputState</span> <span class="p">(</span><span class="n">runWriterT</span> <span class="n">m</span><span class="p">)</span> <span class="n">ss</span>
    <span class="n">pure</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">ss&#39;</span><span class="p">))</span>
  <span class="n">restoreOutputState</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">restoreOutputState</span> <span class="n">ss</span><span class="p">)</span> <span class="o">*&gt;</span> <span class="n">tell</span> <span class="n">s</span>
</pre></div>

</div>

<p>Make sure you understand these instances, too. It should be easier this time, since they share most of their structure with the <code>StateT</code> instance, but note the asymmetry that arises from the differing input and output states. (It may even help to try and write these instances yourself, focusing on the types whenever you get stuck.)</p>

<p>If you feel alright with them, then congratulations: you’re already well on your way to grokking <code>MonadBaseControl</code>!</p>

<h2 id="hiding-the-input-state">Hiding the input state</h2>

<p>So far, our implementation of <code>MonadBaseControl</code> works, but it’s actually slightly more complicated than it needs to be. As it happens, all valid uses of <code>MonadBaseControl</code> will always end up performing the following pattern:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">s</span> <span class="ow">&lt;-</span> <span class="n">captureInputState</span>
<span class="kr">let</span> <span class="n">m&#39;</span> <span class="ow">=</span> <span class="n">closeOverInputState</span> <span class="n">m</span> <span class="n">s</span>
</pre></div>

</div>

<p>That is, we close over the input state as soon as we capture it. We can therefore combine <code>captureInputState</code> and <code>closeOverInputState</code> into a single function:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">captureAndCloseOverInputState</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">b</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">OutputState</span> <span class="n">m</span><span class="p">))</span>
</pre></div>

</div>

<p>What’s more, we no longer need the <code>InputState</code> associated type at all! This is an improvement, since it simplifies the API and removes the possibility for any misuse of the input state, since it’s never directly exposed. On the other hand, it has a more complicated type: it produces a monadic action <em>that returns another monadic action</em>. This can be a little more difficult to grok, which is why I presented the original version first, but it may help to consider how the above type arises naturally from the following definition:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">closeOverInputState</span> <span class="n">m</span> <span class="o">&lt;$&gt;</span> <span class="n">captureInputState</span>
</pre></div>

</div>

<p>Let’s update the <code>MonadBaseControl</code> class to incorporate this simplification:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">class</span> <span class="kt">MonadBase</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="n">m</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">b</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">OutputState</span> <span class="n">m</span><span class="p">))</span>
  <span class="n">restoreOutputState</span> <span class="ow">::</span> <span class="kt">OutputState</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
</pre></div>

</div>

<p>We can then update all the instances to use the simpler API by simply fusing the definitions of <code>captureInputState</code> and <code>closeOverInputState</code> together:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="kt">IO</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="kt">IO</span> <span class="ow">=</span> <span class="nb">()</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;&amp;&gt;</span> <span class="p">(,</span> <span class="nb">()</span><span class="p">))</span>
  <span class="n">restoreOutputState</span> <span class="nb">()</span> <span class="ow">=</span> <span class="n">pure</span> <span class="nb">()</span>

<span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kt">OutputState</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">get</span>
    <span class="n">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">lift</span> <span class="o">$</span> <span class="n">captureAndCloseOverInputState</span> <span class="p">(</span><span class="n">runStateT</span> <span class="n">m</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">pure</span> <span class="o">$</span> <span class="kr">do</span>
      <span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">),</span> <span class="n">ss&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">m&#39;</span>
      <span class="n">pure</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">ss&#39;</span><span class="p">))</span>
  <span class="n">restoreOutputState</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">restoreOutputState</span> <span class="n">ss</span><span class="p">)</span> <span class="o">*&gt;</span> <span class="n">put</span> <span class="n">s</span>

<span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">OutputState</span> <span class="n">m</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">ask</span>
    <span class="n">lift</span> <span class="o">$</span> <span class="n">captureAndCloseOverInputState</span> <span class="p">(</span><span class="n">runReaderT</span> <span class="n">m</span> <span class="n">s</span><span class="p">)</span>
  <span class="n">restoreOutputState</span> <span class="n">ss</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">restoreOutputState</span> <span class="n">ss</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="kt">OutputState</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">lift</span> <span class="o">$</span> <span class="n">captureAndCloseOverInputState</span> <span class="p">(</span><span class="n">runWriterT</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">pure</span> <span class="o">$</span> <span class="kr">do</span>
      <span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">),</span> <span class="n">ss&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">m&#39;</span>
      <span class="n">pure</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">ss&#39;</span><span class="p">))</span>
  <span class="n">restoreOutputState</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">restoreOutputState</span> <span class="n">ss</span><span class="p">)</span> <span class="o">*&gt;</span> <span class="n">tell</span> <span class="n">s</span>
</pre></div>

</div>

<p>This is already very close to a full <code>MonadBaseControl</code> implementation. The <code>captureAndCloseOverInputState</code> implementations are getting a little out of hand, but bear with me—they’ll get simpler before this blog post is over.</p>

<h2 id="coping-with-partiality">Coping with partiality</h2>

<p>Our <code>MonadBaseControl</code> class now works with <code>StateT</code>, <code>ReaderT</code>, and <code>WriterT</code>, but one transformer we haven’t considered is <code>ExceptT</code>. Let’s try to extend our table from before with a row for <code>ExceptT</code>:</p>

<div class="table-wrapper">
 <table class="no-line-wrapping">
  <thead>
   <tr>
    <th>transformer</th> 
    <th>representation</th> 
    <th>input state</th> 
    <th>output state</th></tr></thead>
  <tr>
   <td><code>ExceptT e m a</code></td> 
   <td><code>m (Either e a)</code></td> 
   <td><code>()</code></td> 
   <td><code>???</code></td></tr></table></div>

<p>Hmm… what <em>is</em> the output state for <code>ExceptT</code>?</p>

<p>The answer can’t be <code>e</code>, since we might not end up with an <code>e</code>—the computation might not fail. <code>Maybe e</code> would be closer… could that work?</p>

<p>Well, let’s try it. Let’s write a <code>MonadBaseControl</code> instance for <code>ExceptT</code>:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="n">e</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">OutputState</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="n">e</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">e</span><span class="p">,</span> <span class="kt">OutputState</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">lift</span> <span class="o">$</span> <span class="n">captureAndCloseOverInputState</span> <span class="p">(</span><span class="n">runExceptT</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">pure</span> <span class="o">$</span> <span class="kr">do</span>
      <span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">),</span> <span class="n">ss&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">m&#39;</span>
      <span class="n">pure</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">s&#39;</span><span class="p">,</span> <span class="n">ss&#39;</span><span class="p">))</span>
  <span class="n">restoreOutputState</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ss</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">restoreOutputState</span> <span class="n">ss</span><span class="p">)</span> <span class="o">*&gt;</span> <span class="kr">case</span> <span class="n">s</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="n">e</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">pure</span> <span class="nb">()</span>
</pre></div>

</div>

<p>Sadly, the above implementation doesn’t typecheck; it is rejected with the following type error:</p>

<pre><code>• Couldn't match type ‘Either e a’ with ‘(a, Maybe e)’
  Expected type: m (b ((a, Maybe e), OutputState m))
    Actual type: m (b (Either e a, OutputState m))
• In the second argument of ‘($)’, namely
    ‘captureAndCloseOverInputState (runExceptT m)’
  In a stmt of a 'do' block:
    m' &lt;- lift $ captureAndCloseOverInputState (runExceptT m)
  In the expression:
    do m' &lt;- lift $ captureAndCloseOverInputState (runExceptT m)
       return do ((v, s'), ss') &lt;- m'
                 pure (v, (s', ss'))</code></pre>

<p>We promised a <code>(a, Maybe e)</code>, but we have an <code>Either e a</code>, and there’s certainly no way to get the former from the latter. Are we stuck? (If you’d like, take a moment to think about how you’d solve this type error before moving on, as it may be helpful for understanding the following solution.)</p>

<p>The fundamental problem here is <em>partiality</em>. The type of the <code>captureAndCloseOverInputState</code> method always produces an action in the base monad that includes an <code>a</code> <em>in addition</em> to some other output state. But <code>ExceptT</code> is different: when it an error is raised, it doesn’t produce an <code>a</code> at all—it only produces an <code>e</code>. Therefore, as written, it’s impossible to give <code>ExceptT</code> a <code>MonadBaseControl</code> instance.</p>

<p>Of course, we’d very much <em>like</em> to give <code>ExceptT</code> a <code>MonadBaseControl</code> instance, so that isn’t very satisfying. Somehow, we need to change <code>captureAndCloseOverInputState</code> so that it doesn’t always need to produce an <code>a</code>. There are a few ways we could accomplish that, but an elegant way to do it is this:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">class</span> <span class="kt">MonadBase</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">WithOutputState</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">b</span> <span class="p">(</span><span class="kt">WithOutputState</span> <span class="n">m</span> <span class="n">a</span><span class="p">))</span>
  <span class="n">restoreOutputState</span> <span class="ow">::</span> <span class="kt">WithOutputState</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>

</div>

<p>We’ve replaced the old <code>OutputState</code> associated type with a new <code>WithOutputState</code> type, and the key difference between them is that <code>WithOutputState</code> describes the type of a <em>combination</em> of the result (of type <code>a</code>) and the output state, rather than describing the type of the output state alone. For total monad transformers like <code>StateT</code>, <code>ReaderT</code>, and <code>WriterT</code>, <code>WithOutputState m a</code> will just be a tuple of the result value and the output state, the same as before. For example, here’s an updated <code>MonadBaseControl</code> instance for <code>StateT</code>:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">WithOutputState</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">WithOutputState</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">get</span>
    <span class="n">lift</span> <span class="o">$</span> <span class="n">captureAndCloseOverInputState</span> <span class="p">(</span><span class="n">runStateT</span> <span class="n">m</span> <span class="n">s</span><span class="p">)</span>
  <span class="n">restoreOutputState</span> <span class="n">ss</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">lift</span> <span class="o">$</span> <span class="n">restoreOutputState</span> <span class="n">ss</span>
    <span class="n">put</span> <span class="n">s</span>
    <span class="n">pure</span> <span class="n">a</span>
</pre></div>

</div>

<p>Before we consider how this helps us with <code>ExceptT</code>, let’s pause for a moment and examine the revised <code>StateT</code> instance in detail, as there are some new things going on here:</p>

<ul>
 <li>
  <p>Take a close look at the definition of <code>WithOutputState (StateT s m) a</code>. Note that we’ve defined it to be <code>WithOutputState m (a, s)</code>, <em>not</em> <code>(WithOutputState m a, s)</code>. Consider, for a moment, the difference between these types. Can you see why we used the former, not the latter?</p>
  <p>If it’s unclear to you, that’s okay—let’s illustrate the difference with an example. Consider two similar monad transformer stacks:</p>
  <div class="brush: haskell">
   <div class="source">
    <pre><span></span><span class="nf">m1</span> <span class="ow">::</span> <span class="kt">StateT</span> <span class="n">s</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="n">e</span> <span class="kt">IO</span><span class="p">)</span> <span class="n">a</span>
<span class="nf">m2</span> <span class="ow">::</span> <span class="kt">ExceptT</span> <span class="n">e</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="kt">IO</span><span class="p">)</span> <span class="n">a</span>
</pre></div>

</div>
  <p>Both these stacks contain <code>StateT</code> and <code>ExceptT</code>, but they are layered in a different order. What’s the difference? Well, consider what <code>m1</code> and <code>m2</code> return once fully unwrapped:</p>
  <div class="brush: haskell">
   <div class="source">
    <pre><span></span><span class="nf">runExceptT</span> <span class="p">(</span><span class="n">runStateT</span> <span class="n">m1</span> <span class="n">s</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
<span class="nf">runStateT</span> <span class="p">(</span><span class="n">runExceptT</span> <span class="n">m2</span><span class="p">)</span> <span class="n">s</span> <span class="ow">::</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

</div>
  <p>These results are meaningfully different: in <code>m1</code>, the state is discarded if an error is raised, but in <code>m2</code>, the final state is always returned, even if the computation is aborted. What does this mean for <code>WithOutputState</code>?</p>
  <p>Here’s the important detail: <strong>the state is discarded when <code>ExceptT</code> is “inside” <code>StateT</code>, not the other way around.</strong> This can be counterintuitive, since the <code>s</code> ends up <em>inside</em> the <code>Either</code> when the <code>StateT</code> constructor is on the <em>outside</em> and vice versa. This is really just a property of how monad transformers compose, not anything specific to <code>MonadBaseControl</code>, so an explanation of why this happens is outside the scope of this blog post, but the relevant insight is that the <code>m</code> in <code>StateT s m a</code> controls the eventual action’s output state.</p>
  <p>If we had defined <code>WithOutputState (StateT s m) a</code> to be <code>(WithOutputState m a, s)</code>, we’d be in a pickle, since <code>m</code> would be unable to influence the presence of <code>s</code> in the output state. Therefore, we have no choice but to use <code>WithOutputState m (a, s)</code>. (If you are still confused by this, try it yourself; you’ll find that there’s no way to make the other definition typecheck.)</p></li>
 <li>
  <p>Now that we’ve developed an intuitive understanding of why <code>WithOutputState</code> must be defined the way it is, let’s look at things from another perspective. Consider the type of <code>runStateT</code> once more:</p>
  <div class="brush: haskell">
   <div class="source">
    <pre><span></span><span class="nf">runStateT</span> <span class="ow">::</span> <span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

</div>
  <p>Note that the result type is <code>m (a, s)</code>, with the <code>m</code> on the outside. As it happens, this correspondence simplifies the definition of <code>captureAndCloseOverInputState</code>, since we no longer have to do any fiddling with its result—it’s already in the proper shape, so we can just return it directly.</p></li>
 <li>
  <p>Finally, this instance illustrates an interesting change to <code>restoreOutputState</code>. Since the <code>a</code> is now packed inside the <code>WithOutputState m a</code> value, the caller of <code>captureAndCloseOverInputState</code> needs some way to get the <code>a</code> back out! Conveniently, <code>restoreOutputState</code> can play that role, both restoring the output state and unpacking the result.</p>
  <p>Even ignoring partial transformers like <code>ExceptT</code>, this is an improvement over the old API, as it conveniently prevents the programmer from forgetting to call <code>restoreOutputState</code>. However, as we’ll see shortly, it is much more than a convenience: once <code>ExceptT</code> comes into play, it is essential!</p></li></ul>

<p>With those details addressed, let’s return to <code>ExceptT</code>. Using the new interface, writing an instance for <code>ExceptT</code> is not only possible, it’s actually rather easy:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="n">e</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">WithOutputState</span> <span class="p">(</span><span class="kt">ExceptT</span> <span class="n">e</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">WithOutputState</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span>
    <span class="n">lift</span> <span class="o">$</span> <span class="n">captureAndCloseOverInputState</span> <span class="p">(</span><span class="n">runExceptT</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">restoreOutputState</span> <span class="n">ss</span> <span class="ow">=</span>
    <span class="n">either</span> <span class="n">throwError</span> <span class="n">pure</span> <span class="o">=&lt;&lt;</span> <span class="n">lift</span> <span class="p">(</span><span class="n">restoreOutputState</span> <span class="n">ss</span><span class="p">)</span>
</pre></div>

</div>

<p>This instance illustrates why it’s so crucial that <code>restoreOutputState</code> have the aforementioned dual role: it must handle the case where no <code>a</code> exists at all! In the case of <code>ExceptT</code>, it restores the state in the enclosing monad by re-raising an error.</p>

<p>Now all that’s left to do is update the other instances:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="kt">IO</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">WithOutputState</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="ow">=</span> <span class="n">pure</span>
  <span class="n">restoreOutputState</span> <span class="ow">=</span> <span class="n">pure</span>

<span class="kr">instance</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">WithOutputState</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">WithOutputState</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">ask</span>
    <span class="n">lift</span> <span class="o">$</span> <span class="n">captureAndCloseOverInputState</span> <span class="p">(</span><span class="n">runReaderT</span> <span class="n">m</span> <span class="n">s</span><span class="p">)</span>
  <span class="n">restoreOutputState</span> <span class="n">ss</span> <span class="ow">=</span> <span class="n">lift</span> <span class="o">$</span> <span class="n">restoreOutputState</span> <span class="n">ss</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">WithOutputState</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">WithOutputState</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span>
    <span class="n">lift</span> <span class="o">$</span> <span class="n">captureAndCloseOverInputState</span> <span class="p">(</span><span class="n">runWriterT</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">restoreOutputState</span> <span class="n">ss</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">lift</span> <span class="o">$</span> <span class="n">restoreOutputState</span> <span class="n">ss</span>
    <span class="n">tell</span> <span class="n">s</span>
    <span class="n">pure</span> <span class="n">a</span>
</pre></div>

</div>

<p>Finally, we can update our lifted variant of <code>foo</code> to use the new interface so it will work with transformer stacks that include <code>ExceptT</code>:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">foo&#39;</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span>
  <span class="n">restoreOutputState</span> <span class="o">=&lt;&lt;</span> <span class="n">liftBase</span> <span class="p">(</span><span class="n">foo</span> <span class="n">m&#39;</span><span class="p">)</span>
</pre></div>

</div>

<p>At this point, it’s worth considering something: although getting the <code>MonadBaseControl</code> class and instances right was a lot of work, the resulting <code>foo'</code> implementation is actually incredibly simple. That’s a good sign, since we only have to write the <code>MonadBaseControl</code> instances once (in a library), but we have to write functions like <code>foo'</code> quite often.</p>

<h1 id="scaling-to-the-real-monadbasecontrol">Scaling to the real <code>MonadBaseControl</code></h1>

<p>The <code>MonadBaseControl</code> class we implemented in the previous section is complete. It is a working, useful class that is equivalent in power to <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl">the “real” <code>MonadBaseControl</code> class in the <code>monad-control</code> library</a>. However, if you compare the two, you’ll notice that the version in <code>monad-control</code> looks a little bit different. What gives?</p>

<p>Let’s compare the two classes side by side:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="c1">-- ours</span>
<span class="kr">class</span> <span class="kt">MonadBase</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">WithOutputState</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">captureAndCloseOverInputState</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">b</span> <span class="p">(</span><span class="kt">WithOutputState</span> <span class="n">m</span> <span class="n">a</span><span class="p">))</span>
  <span class="n">restoreOutputState</span> <span class="ow">::</span> <span class="kt">WithOutputState</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>

<span class="c1">-- theirs</span>
<span class="kr">class</span> <span class="kt">MonadBase</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">StM</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">liftBaseWith</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RunInBase</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">restoreM</span> <span class="ow">::</span> <span class="kt">StM</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>

</div>

<p>Let’s start with the similarities, since those are easy:</p>

<ul>
 <li>
  <p>Our <code>WithOutputState</code> associated type is precisely equivalent to their <code>StM</code> associated type, they just use a (considerably) shorter name.</p></li>
 <li>
  <p>Likewise, our <code>restoreOutputState</code> method is precisely equivalent to their <code>restoreM</code> method, simply under a different name.</p></li></ul>

<p>That leaves <code>captureAndCloseOverInputState</code> and <code>liftBaseWith</code>. Those two methods both do similar things, but they aren’t identical, and that’s where all the differences lie. To understand <code>liftBaseWith</code>, let’s start by inlining the definition of the <code>RunInBase</code> type alias so we can see the fully-expanded type:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">liftBaseWith</span>
  <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span>
  <span class="ow">=&gt;</span> <span class="p">((</span><span class="n">forall</span> <span class="n">c</span><span class="o">.</span> <span class="n">m</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="p">(</span><span class="kt">StM</span> <span class="n">m</span> <span class="n">c</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="n">a</span><span class="p">)</span>
  <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>

</div>

<p>That type is complicated! However, if we break it down, hopefully you’ll find it’s not as scary as it first appears. Let’s reimplement the <code>foo'</code> example from before using <code>liftBaseWith</code> to show how this version of <code>MonadBaseControl</code> works:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">foo&#39;</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="n">runInBase</span> <span class="ow">-&gt;</span> <span class="n">foo</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">restoreM</span> <span class="n">s</span>
</pre></div>

</div>

<p>This is, in some ways, superficially similar to the version we wrote using our version of <code>MonadBaseControl</code>. Just like in our version, we capture the input state, apply <code>foo</code> in the <code>IO</code> monad, then restore the state. But what exactly is doing the state capturing, and what is <code>runInBase</code>?</p>

<p>Let’s start by adding a type annotation to <code>runInBase</code> to help make it a little clearer what’s going on:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">m</span> <span class="n">a</span><span class="o">.</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">foo&#39;</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">runInBase</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">StM</span> <span class="n">m</span> <span class="n">b</span><span class="p">))</span> <span class="ow">-&gt;</span>
    <span class="n">foo</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">restoreM</span> <span class="n">s</span>
</pre></div>

</div>

<p>That type should look sort of recognizable. If we replace <code>StM</code> with <code>WithOutputState</code>, then we get a type that looks very similar to that of our original <code>closeOverInputState</code> function, except it doesn’t need to take the input state as an argument. How does that work?</p>

<p>Here’s the trick: <code>liftBaseWith</code> starts by capturing the input state, just as before. However, it then builds a function, <code>runInBase</code>, which is like <code>closeOverInputState</code> partially-applied to the input state it captured. It hands that function to us, and we’re free to apply it to <code>m</code>, which produces the <code>IO (StM m a)</code> action we need, and we can now pass that action to <code>foo</code>. The result is returned in the outer monad, and we restore the state using <code>restoreM</code>.</p>

<h2 id="sharing-the-input-state">Sharing the input state</h2>

<p>At first, this might seem needlessly complicated. When we first started, we separated capturing the input state and closing over it into two separate operations (<code>captureInputState</code> and <code>closeOverInputState</code>), but we eventually combined them so that we could keep the input state hidden. Why does <code>monad-control</code> split them back into two operations again?</p>

<p>As it turns out, when lifting <code>foo</code>, there’s no advantage to the more complicated API of <code>monad-control</code>. In fact, we could implement our <code>captureAndCloseOverInputState</code> operation in terms of <code>liftBaseWith</code>, and we could use that to implement <code>foo'</code> the same way we did before:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">captureAndCloseOverInputState</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">b</span> <span class="p">(</span><span class="kt">StM</span> <span class="n">m</span> <span class="n">a</span><span class="p">))</span>
<span class="nf">captureAndCloseOverInputState</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="n">runInBase</span> <span class="ow">-&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">m</span><span class="p">)</span>

<span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">foo&#39;</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">captureAndCloseOverInputState</span> <span class="n">m</span>
  <span class="n">restoreM</span> <span class="o">=&lt;&lt;</span> <span class="n">liftBase</span> <span class="p">(</span><span class="n">foo</span> <span class="n">m&#39;</span><span class="p">)</span>
</pre></div>

</div>

<p>However, that approach has a downside once we need to lift more complicated functions. <code>foo</code> is exceptionally simple, as it only accepts a single input argument, but what if we wanted to lift a more complicated function that took <em>two</em> monadic arguments, such as this one:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">bar</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
</pre></div>

</div>

<p>We could implement that by calling <code>captureAndCloseOverInputState</code> twice, like this:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">bar&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">bar&#39;</span> <span class="n">ma</span> <span class="n">mb</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ma&#39;</span> <span class="ow">&lt;-</span> <span class="n">captureAndCloseOverInputState</span> <span class="n">ma</span>
  <span class="n">mb&#39;</span> <span class="ow">&lt;-</span> <span class="n">captureAndCloseOverInputState</span> <span class="n">mb</span>
  <span class="n">restoreM</span> <span class="o">=&lt;&lt;</span> <span class="n">liftBase</span> <span class="p">(</span><span class="n">bar</span> <span class="n">ma&#39;</span> <span class="n">mb&#39;</span><span class="p">)</span>
</pre></div>

</div>

<p>However, that would capture the monadic state twice, which is rather inefficient. By using <code>liftBaseWith</code>, the state capturing is done just once, and it’s shared between all calls to <code>runInBase</code>:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">bar&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">bar&#39;</span> <span class="n">ma</span> <span class="n">mb</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="n">runInBase</span> <span class="ow">-&gt;</span>
    <span class="n">bar</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">ma</span><span class="p">)</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">mb</span><span class="p">)</span>
  <span class="n">restoreM</span> <span class="n">s</span>
</pre></div>

</div>

<p>By providing a “running” function (<code>runInBase</code>) instead of direct access to the input state, <code>liftBaseWith</code> allows sharing the captured input state between multiple actions without exposing it directly.</p>

<h2 id="sidebar-continuation-passing-and-impredicativity">Sidebar: continuation-passing and impredicativity</h2>

<p>One last point before we move on: although the above explains why <code>captureAndCloseOverInputState</code> is insufficient, you may be left wondering why <code>liftBaseWith</code> can’t just <em>return</em> <code>runInBase</code>. Why does it need to be given a continuation? After all, it would be nicer if we could just write this:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">bar&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">bar&#39;</span> <span class="n">ma</span> <span class="n">mb</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">runInBase</span> <span class="ow">&lt;-</span> <span class="n">askRunInBase</span>
  <span class="n">restoreM</span> <span class="o">=&lt;&lt;</span> <span class="n">liftBase</span> <span class="p">(</span><span class="n">bar</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">ma</span><span class="p">)</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">mb</span><span class="p">))</span>
</pre></div>

</div>

<p>To understand the problem with a hypothetical <code>askRunInBase</code> function, remember that the type of <code>runInBase</code> is polymorphic:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">runInBase</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="p">(</span><span class="kt">StM</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span>
</pre></div>

</div>

<p>This is important, since if you need to lift a function with a type like</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">baz</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
</pre></div>

</div>

<p>then you’ll want to instantiate that <code>a</code> variable with two different types. We’d need to retain that power in <code>askRunInBase</code>, so it would need to have the following type:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">askRunInBase</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="p">(</span><span class="kt">StM</span> <span class="n">m</span> <span class="n">a</span><span class="p">))</span>
</pre></div>

</div>

<p>Sadly, that type is illegal in Haskell. Type constructors must be applied to monomorphic types, but in the above type signature, <code>m</code> is applied to a polymorphic type.<sup><a href="#2019-09-07-demystifying-monadbasecontrol-footnote-2-definition" name="2019-09-07-demystifying-monadbasecontrol-footnote-2-return">2</a></sup> The <code>RankNTypes</code> GHC extension introduces a single exception: the <code>(-&gt;)</code> type constructor is special and may be applied to polymorphic types. That’s why <code>liftBaseWith</code> is legal, but <code>askRunInBase</code> is not: since <code>liftBaseWith</code> is passed a higher-order function that receives <code>runInBase</code> as an argument, the polymorphic type appears immediately under an application of <code>(-&gt;)</code>, which is allowed.</p>

<p>The aforementioned restriction means we’re basically out of luck, but if you <em>really</em> want <code>askRunInBase</code>, there is a workaround. GHC is perfectly alright with a field of a datatype being polymorphic, so we can define a newtype that wraps a suitably-polymorphic function:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">newtype</span> <span class="kt">RunInBase</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">RunInBase</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="p">(</span><span class="kt">StM</span> <span class="n">m</span> <span class="n">a</span><span class="p">))</span>
</pre></div>

</div>

<p>We can now alter <code>askRunInBase</code> to return our newtype, and we can implement it in terms of <code>liftBaseWith</code>:<sup><a href="#2019-09-07-demystifying-monadbasecontrol-footnote-3-definition" name="2019-09-07-demystifying-monadbasecontrol-footnote-3-return">3</a></sup></p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">askRunInBase</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="n">b</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">RunInBase</span> <span class="n">b</span> <span class="n">m</span><span class="p">)</span>
<span class="nf">askRunInBase</span> <span class="ow">=</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="n">runInBase</span> <span class="ow">-&gt;</span> <span class="n">pure</span> <span class="o">$</span> <span class="kt">RunInBase</span> <span class="n">runInBase</span>
</pre></div>

</div>

<p>To use <code>askRunInBase</code>, we have to pattern match on the <code>RunInBase</code> constructor, but it isn’t very noisy, since we can do it directly in a <code>do</code> binding. For example, we could implement a lifted version of <code>baz</code> this way:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">baz&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">baz&#39;</span> <span class="n">ma</span> <span class="n">mb</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kt">RunInBase</span> <span class="n">runInBase</span> <span class="ow">&lt;-</span> <span class="n">askRunInBase</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">liftBase</span> <span class="p">(</span><span class="n">baz</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">ma</span><span class="p">)</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">mb</span><span class="p">))</span>
  <span class="n">bitraverse</span> <span class="n">restoreM</span> <span class="n">restoreM</span> <span class="n">s</span>
</pre></div>

</div>

<p>As of version 1.0.2.3, <code>monad-control</code> does not provide a newtype like <code>RunInBase</code>, so it also doesn’t provide a function like <code>askRunInBase</code>. For now, you’ll have to use <code>liftBaseWith</code>, but it might be a useful future addition to the library.</p>

<h1 id="pitfalls">Pitfalls</h1>

<p>At this point in the blog post, we’ve covered the essentials of <code>MonadBaseControl</code>: how it works, how it’s designed, and how you might go about using it. However, so far, we’ve only considered situations where <code>MonadBaseControl</code> works well, and I’ve intentionally avoided examples where the technique breaks down. In this section, we’re going to take a look at the pitfalls and drawbacks of <code>MonadBaseControl</code>, plus some ways they can be mitigated.</p>

<h2 id="no-polymorphism-no-lifting">No polymorphism, no lifting</h2>

<p>All of the pitfalls of <code>MonadBaseControl</code> stem from the same root problem, and that’s the particular technique it uses to save and restore monadic state. We’ll start by considering one of the simplest ways that technique is thwarted, and that’s monomorphism. Consider the following two functions:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">poly</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">mono</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">X</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">X</span>
</pre></div>

</div>

<p>Even after all we’ve covered, it may surprise you to learn that although <code>poly</code> can be easily lifted to <code>MonadBaseControl IO m =&gt; m a -&gt; m a</code>, it’s <em>impossible</em> to lift <code>mono</code> to <code>MonadBaseControl IO m =&gt; m X -&gt; m X</code>. It’s a little unintuitive, as we often think of polymorphic types as being more complicated (so surely lifting polymorphic functions ought to be harder), but in fact, it’s the flexibility of polymorphism that allows <code>MonadBaseControl</code> to work in the first place.</p>

<p>To understand the problem, remember that when we lift a function of type <code>forall a. b a -&gt; b a</code> using <code>MonadBaseControl</code>, we actually instantiate <code>a</code> to <code>(StM m c)</code>. That produces a function of type <code>b (StM m c) -&gt; b (StM m c)</code>, which is isomorphic to the <code>m c -&gt; m c</code> type we want. The instantiation step is easily overlooked, but it’s crucial, since otherwise we have no way to thread the state through the otherwise opaque function we’re trying to lift!</p>

<p>In the case of <code>mono</code>, that’s exactly the problem we’re faced with. <code>mono</code> will not accept an <code>IO (StM m X)</code> as an argument, only precisely an <code>IO X</code>, so we can’t pass along the monadic state. For all its machinery, <code>MonadBaseControl</code> is no help at all if no polymorphism is involved. Trying to generalize <code>mono</code> without modifying its implementation is a lost cause.</p>

<h2 id="the-dangers-of-discarded-state">The dangers of discarded state</h2>

<p>Our inability to lift <code>mono</code> is frustrating, but at least it’s conclusively impossible. In practice, however, many functions lie in an insidious in-between: polymorphic enough to be lifted, but not without compromises. The simplest of these functions have types such as the following:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">sideEffect</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>

</div>

<p>Unlike <code>mono</code>, it’s entirely possible to lift <code>sideEffect</code>:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">sideEffect&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">sideEffect&#39;</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="n">runInBase</span> <span class="ow">-&gt;</span> <span class="n">sideEffect</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

</div>

<p>This definition typechecks, but you may very well prefer it didn’t, since it has a serious problem: any changes made by <code>m</code> to the monadic state are completely discarded once <code>sideEffect'</code> returns! Since <code>sideEffect'</code> never calls <code>restoreM</code>, there’s no way the state of <code>m</code> can be any different from the original state, but it’s impossible to call <code>restoreM</code> since we don’t actually get an <code>StM m ()</code> result from <code>sideEffect</code>.</p>

<p>Sometimes this may be acceptable, since some monad transformers don’t actually have any output state anyway, such as <code>ReaderT r</code>. In other cases, however, <code>sideEffect'</code> could be a bug waiting to happen. One way to make <code>sideEffect'</code> safe would be to add a <code>StM m a ~ a</code> constraint to its context, since that guarantees the monad transformers being lifted through are stateless, and nothing is actually being discarded. Of course, that significantly restricts the set of monad transformers that can be lifted through.</p>

<h3 id="rewindable-state">Rewindable state</h3>

<p>One scenario where state discarding can actually be useful is operations with so-called rewindable or transactional state. The most common example of such an operation is <code>catch</code>:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">catch</span> <span class="ow">::</span> <span class="kt">Exception</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
</pre></div>

</div>

<p>When lifted, state changes from the action <em>or</em> from the exception handler will be “committed,” but never both. If an exception is raised during the computation, those state changes are discarded (“rewound”), giving <code>catch</code> a kind of backtracking semantics. This behavior arises naturally from the way a lifted version of <code>catch</code> must be implemented:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">catch&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Exception</span> <span class="n">e</span><span class="p">,</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">catch&#39;</span> <span class="n">m</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="n">runInBase</span> <span class="ow">-&gt;</span>
    <span class="n">catch</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">runInBase</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
  <span class="n">restoreM</span> <span class="n">s</span>
</pre></div>

</div>

<p>If <code>m</code> raises an exception, it will never return an <code>StM m a</code> value, so there’s no way to get ahold of any of the state changes that happened before the exception. Therefore, the only option is to discard that state.</p>

<p>This behavior is actually quite useful, and it’s definitely not unreasonable. However, useful or not, it’s inconsistent with state changes to mutable values like <code>IORef</code>s or <code>MVar</code>s (they stay modified whether an exception is raised or not), so it can still be a gotcha. Either way, it’s worth being aware of.</p>

<h3 id="partially-discarded-state">Partially discarded state</h3>

<p>The next function we’re going to examine is <code>finally</code>:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">finally</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
</pre></div>

</div>

<p>This function has a similar type to <code>catch</code>, and it even has similar semantics. Like <code>catch</code>, <code>finally</code> can be lifted, but unlike <code>catch</code>, its state <em>can’t</em> be given any satisfying treatment. The only way to implement a lifted version is</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">finally&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">finally&#39;</span> <span class="n">ma</span> <span class="n">mb</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="n">runInBase</span> <span class="ow">-&gt;</span>
    <span class="n">finally</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">ma</span><span class="p">)</span> <span class="p">(</span><span class="n">runInBase</span> <span class="n">mb</span><span class="p">)</span>
  <span class="n">restoreM</span> <span class="n">s</span>
</pre></div>

</div>

<p>which always discards all state changes made by the second argument. This is clear just from looking at <code>finally</code>’s type: since <code>b</code> doesn’t appear anywhere in the return type, there’s simply no way to access that action’s result, and therefore no way to access its modified state.</p>

<p>However, don’t despair: there actually <em>is</em> a way to produce a lifted version of <code>finally</code> that preserves all state changes. It can’t be done by lifting <code>finally</code> directly, but if we reimplement <code>finally</code> in terms of simpler lifted functions that are more amenable to lifting, we can produce a lifted version of <code>finally</code> that preserves all the state:<sup><a href="#2019-09-07-demystifying-monadbasecontrol-footnote-4-definition" name="2019-09-07-demystifying-monadbasecontrol-footnote-4-return">4</a></sup></p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">finally&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">finally&#39;</span> <span class="n">ma</span> <span class="n">mb</span> <span class="ow">=</span> <span class="n">mask&#39;</span> <span class="o">$</span> <span class="nf">\</span><span class="n">restore</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
  <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="n">runInBase</span> <span class="ow">-&gt;</span>
    <span class="n">try</span> <span class="p">(</span><span class="n">runInBase</span> <span class="p">(</span><span class="n">restore</span> <span class="n">ma</span><span class="p">))</span>
  <span class="kr">case</span> <span class="n">a</span> <span class="kr">of</span>
    <span class="kt">Left</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">mb</span> <span class="o">*&gt;</span> <span class="n">liftBase</span> <span class="p">(</span><span class="n">throwIO</span> <span class="p">(</span><span class="n">e</span> <span class="ow">::</span> <span class="kt">SomeException</span><span class="p">))</span>
    <span class="kt">Right</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">restoreM</span> <span class="n">s</span> <span class="o">&lt;*</span> <span class="n">mb</span>
</pre></div>

</div>

<p>This illustrates an important (and interesting) point about <code>MonadBaseControl</code>: whether or not an operation can be made state-preserving is not a fundamental property of the operation’s type, but rather a property of the types of the exposed primitives. There is sometimes a way to implement a state-preserving variant of operations that might otherwise seem unliftable given the right primitives and a bit of cleverness.</p>

<h3 id="forking-state">Forking state</h3>

<p>As a final example, I want to provide an example where the state may not actually be discarded <em>per se</em>, just inaccessible. Consider the type of <code>forkIO</code>:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">forkIO</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">ThreadId</span>
</pre></div>

</div>

<p>Although <code>forkIO</code> isn’t actually polymorphic in its argument, we can convert <em>any</em> <code>IO</code> action to one that produces <code>()</code> via <code>void</code>, so it might as well be. Therefore, we can lift <code>forkIO</code> in much the same way we did with <code>sideEffect</code>:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="nf">forkIO&#39;</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">ThreadId</span>
<span class="nf">forkIO&#39;</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">liftBaseWith</span> <span class="o">$</span> <span class="nf">\</span><span class="n">runInBase</span> <span class="ow">-&gt;</span> <span class="n">forkIO</span> <span class="p">(</span><span class="n">void</span> <span class="o">$</span> <span class="n">runInBase</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

</div>

<p>As with <code>sideEffect</code>, we can’t recover the output state, but in this case, there’s a fundamental reason that goes deeper than the types: we’ve forked off a concurrent computation! We’ve therefore split the state in two, which might be what we want… but it also might not. <code>forkIO</code> is yet another illustration that it’s important to think about the state-preservation semantics when using <code>MonadBaseControl</code>, or you may end up with a bug!</p>

<h1 id="monadbasecontrol-in-context"><code>MonadBaseControl</code> in context</h1>

<p>Congratulations: you’ve made it through most of this blog post. If you’ve followed everything so far, you now understand <code>MonadBaseControl</code>. All the tricky parts are over. However, before wrapping up, I’d like to add a little extra information about how <code>MonadBaseControl</code> relates to various other parts of the Haskell ecosystem. In practice, that information can be as important as understanding <code>MonadBaseControl</code> itself.</p>

<h2 id="the-remainder-of-monad-control">The remainder of <code>monad-control</code></h2>

<p>If you look at <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html">the documentation for <code>monad-control</code></a>, you’ll find that it provides more than just the <code>MonadBaseControl</code> typeclass. I’m not going to cover everything else in detail in this blog post, but I do want to touch upon it briefly.</p>

<p>First off, you should definitely take a look at the handful of helper functions provided by <code>monad-control</code>, such as <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#v:control"><code>control</code></a> and <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#v:liftBaseOp_"><code>liftBaseOp_</code></a>. These functions provide support for lifting common function types without having to use <code>liftBaseWith</code> directly. It’s useful to understand <code>liftBaseWith</code>, since it’s the most general way to use <code>MonadBaseControl</code>, but in practice, it is simpler and more readable to use the more specialized functions wherever possible. Many of the examples in this very blog post could be simplified using them, and I only stuck to <code>liftBaseWith</code> to introduce as few new concepts at a time as possible.</p>

<p>Second, I’d like to mention the related <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadTransControl"><code>MonadTransControl</code></a> typeclass. You hopefully remember from earlier in the blog post how we defined <code>MonadBaseControl</code> instances inductively so that we could lift all the way down to the base monad. <code>MonadTransControl</code> is like <code>MonadBaseControl</code> if it intentionally did <em>not</em> do that—it allows lifting through a single transformer at a time, rather than through all of them at once.</p>

<p>Usually, <code>MonadTransControl</code> is not terribly useful to use directly (though I did use it once <a href="/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/#making-mtls-classes-derivable">in a previous blog post of mine</a> to help derive instances of mtl-style classes), but it <em>is</em> useful for implementing <code>MonadBaseControl</code> instances for your own transformers. If you define a <code>MonadTransControl</code> instance for your monad transformer, you can get a <code>MonadBaseControl</code> implementation for free using the provided <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:ComposeSt"><code>ComposeSt</code></a>, <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#v:defaultLiftBaseWith"><code>defaultLiftBaseWith</code></a>, and <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#v:defaultRestoreM"><code>defaultRestoreM</code></a> bindings; see the documentation for more details.</p>

<h2 id="lifted-base-and-lifted-async"><code>lifted-base</code> and <code>lifted-async</code></h2>

<p>If you’re going to use <code>MonadBaseControl</code>, the <a href="http://hackage.haskell.org/package/lifted-base"><code>lifted-base</code></a> and <a href="http://hackage.haskell.org/package/lifted-async"><code>lifted-async</code></a> packages are good to know about. As their names imply, they provide lifted versions of bindings in the <code>base</code> and <code>async</code> packages, so you can use them directly without needing to lift them yourself. For example, if you needed a lifted version of <code>mask</code> from <code>Control.Exception</code>, you could swap it for the <code>mask</code> export from <code>Control.Exception.Lifted</code>, and everything would mostly just work (though always be sure to check the documentation for any caveats on state discarding).</p>

<h2 id="relationship-to-monadunliftio">Relationship to <code>MonadUnliftIO</code></h2>

<p>Recently, FP Complete has developed the <a href="https://hackage.haskell.org/package/unliftio"><code>unliftio</code></a> package as an alternative to <code>monad-control</code>. It provides the <a href="https://hackage.haskell.org/package/unliftio-core-0.1.2.0/docs/Control-Monad-IO-Unlift.html#t:MonadUnliftIO"><code>MonadUnliftIO</code></a> typeclass, which is similar in spirit to <code>MonadBaseControl</code>, but heavily restricted: it is specialized to <code>IO</code> as the base monad, and it <em>only</em> allows instances for stateless monads, such as <code>ReaderT</code>. This is designed to encourage the so-called <a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern"><code>ReaderT</code> design pattern</a>, which avoids ever using stateful monads like <code>ExceptT</code> or <code>StateT</code> over <code>IO</code>, encouraging the use of <code>IO</code> exceptions and mutable variables (e.g. <code>MVar</code>s or <code>TVar</code>s) instead.</p>

<p>I should be clear: I really like most of what FP Complete has done—to this day, I still use <code>stack</code> as my Haskell build tool of choice—and I think the suggestions given in the aforementioned “<code>ReaderT</code> design pattern” blog post have real weight to them. I have a deep respect for Michael Snoyman’s commitment to opinionated, user-friendly tools and libraries. But truthfully, I can’t stand <code>MonadUnliftIO</code>.</p>

<p><code>MonadUnliftIO</code> is designed to avoid all the complexity around state discarding that <code>MonadBaseControl</code> introduces, and on its own, that’s a noble goal. Safety first, after all. The problem is that <code>MonadUnliftIO</code> really is extremely limiting, and what’s more, it can actually be trivially encoded in terms of <code>MonadBaseControl</code> as follows:</p>

<div class="brush: haskell">
 <div class="source">
  <pre><span></span><span class="kr">type</span> <span class="kt">MonadUnliftIO</span> <span class="n">m</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span><span class="p">,</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">StM</span> <span class="n">m</span> <span class="n">a</span> <span class="o">~</span> <span class="n">a</span><span class="p">)</span>
</pre></div>

</div>

<p>This alias can be used to define safe, lifted functions that never discard state while still allowing functions that <em>can</em> be safely lifted through stateful transformers to do so. Indeed, the <a href="https://hackage.haskell.org/package/lifted-async-0.10.0.4/docs/Control-Concurrent-Async-Lifted-Safe.html"><code>Control.Concurrent.Async.Lifted.Safe</code></a> module from <code>lifted-async</code> does exactly that (albeit with a slightly different formulation than the above alias).</p>

<p>To be fair, the <code>unliftio</code> README does address this in its <a href="https://github.com/fpco/unliftio/tree/bb2e26e7fbbaebb15555f417ba9753a76b3218b2/unliftio#monad-control">comparison section</a>:</p>

<blockquote>
 <p><code>monad-control</code> allows us to unlift both styles. In theory, we could write a variant of <code>lifted-base</code> that never does state discards […] In other words, this is an advantage of <code>monad-control</code> over <code>MonadUnliftIO</code>. We&rsquo;ve avoided providing any such extra typeclass in this package though, for two reasons:</p>
 <ul>
  <li>
   <p><code>MonadUnliftIO</code> is a simple typeclass, easy to explain. We don&rsquo;t want to complicated [sic] matters […]</p></li>
  <li>
   <p>Having this kind of split would be confusing in user code, when suddenly [certain operations are] not available to us.</p></li></ul></blockquote>

<p>In other words, the authors of <code>unliftio</code> felt that <code>MonadBaseControl</code> was simply not worth the complexity, and they could get away with <code>MonadUnliftIO</code>. Frankly, if you feel the same way, by all means, use <code>unliftio</code>. I just found it too limiting given the way I write Haskell, plain and simple.</p>

<h1 id="recap">Recap</h1>

<p>So ends another long blog post. As often seems the case, I set out to write something short, but I ended up writing well over 5,000 words. I suppose that means I learned something from this experience, too: <code>MonadBaseControl</code> is more complicated than I had anticipated! Maybe there’s something to take away from that.</p>

<p>In any case, it’s over now, so I’d like to briefly summarize what we’ve covered:</p>

<ul>
 <li>
  <p><a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl"><code>MonadBaseControl</code></a> allows us to lift higher-order monadic operations.</p></li>
 <li>
  <p>It operates by capturing the current monadic state and explicitly threading it through the action in the base monad before restoring it.</p></li>
 <li>
  <p>That technique works well for polymorphic operations for the type <code>forall a. b a -&gt; b a</code>, but it can be tricky or even impossible for more complex operations, sometimes leading to discarded state.</p>
  <p>This can sometimes be mitigated by restricting certain operations to stateless monads using a <code>StM m a ~ a</code> constraint, or by reimplementing the operation in terms of simpler primitives.</p></li>
 <li>The <a href="http://hackage.haskell.org/package/lifted-base"><code>lifted-base</code></a> and <a href="http://hackage.haskell.org/package/lifted-async"><code>lifted-async</code></a> packages provide lifted versions of existing operations, avoiding the need to lift them yourself.</li></ul>

<p>As with many abstractions in Haskell, don’t worry too much if you don’t have a completely firm grasp of <code>MonadBaseControl</code> at first. Insight often comes with repeated experience, and <code>monad-control</code> can still be used in useful ways even without a perfect understanding. My hope is that this blog post has helped you build intuitions about <code>MonadBaseControl</code> even if some of the underlying machinery remains a little fuzzy, and I hope it can also serve as a reference for those who want or need to understand (or just be reminded of) all the little details.</p>

<p>Finally, I’ll admit <code>MonadBaseControl</code> isn’t especially elegant or beautiful as Haskell abstractions go. In fact, in many ways, it’s a bit of a kludge! Perhaps, in time, effect systems will evolve and mature so that it and its ilk are no longer necessary, and they may become distant relics of an inferior past. But in the meantime, it’s here, it’s useful, and I think it’s worth embracing. If you’ve shied away from it in the past, I hope I’ve illuminated it enough to make you consider giving it another try.</p>

<div class="footnotes">
 <ol>
  <li id="2019-09-07-demystifying-monadbasecontrol-footnote-1-definition" class="footnote-definition">
   <p>One example of a function with that type is <code>mask_</code>.&nbsp;<a href="#2019-09-07-demystifying-monadbasecontrol-footnote-1-return">↩</a></p></li>
  <li id="2019-09-07-demystifying-monadbasecontrol-footnote-2-definition" class="footnote-definition">
   <p>Types with polymorphic types under type constructors are called <em>impredicative</em>. GHC technically has limited support for impredicativity via the <code>ImpredicativeTypes</code> language extension, but as of GHC 8.8, it has been fairly broken for some time. A fix is apparently being worked on, but even if that effort is successful, I don’t know what impact it will have on type inference.&nbsp;<a href="#2019-09-07-demystifying-monadbasecontrol-footnote-2-return">↩</a></p></li>
  <li id="2019-09-07-demystifying-monadbasecontrol-footnote-3-definition" class="footnote-definition">
   <p>Note that <code>askRunInBase = liftBaseWith (pure . RunInBase)</code> does <em>not</em> typecheck, as it would require impredicative polymorphism: it would require instantiating the type of <code>(.)</code> with polymorphic types. The version using <code>($)</code> works because GHC actually has special typechecking rules for <code>($)</code>! Effectively, <code>f $ x</code> is really syntax in GHC.&nbsp;<a href="#2019-09-07-demystifying-monadbasecontrol-footnote-3-return">↩</a></p></li>
  <li id="2019-09-07-demystifying-monadbasecontrol-footnote-4-definition" class="footnote-definition">
   <p>Assume that <code>mask'</code> is a suitably lifted version of <code>mask</code> (which can in fact be made state-preserving).&nbsp;<a href="#2019-09-07-demystifying-monadbasecontrol-footnote-4-return">↩</a></p></li></ol></div>
  <footer>
    <ul class="pager">
      <li class="previous">
        <a href="/blog/2019/10/19/empathy-and-subjective-experience-in-programming-languages/">&larr; <em>Empathy and subjective experience in programming languages</em></a>
      </li>
      <li class="next">
        <a href="/blog/2019/04/21/defeating-racket-s-separate-compilation-guarantee/"><em>Defeating Racket’s separate compilation guarantee</em> &rarr;</a>
      </li>
    </ul>
  </footer>
</article>
        </div>
      </section>
      <footer>
        <div class="content">
          <h2 id="copyright-notice">© 2021, Alexis King</h2>
          <h3>
            Built with <a href="https://github.com/greghendershott/frog">Frog</a>, the
            <strong>fr</strong>ozen bl<strong>og</strong> tool.
          </h3>
          <h3>
            Feeds are available via <a href="/feeds/all.atom.xml">Atom</a>
            or <a href="/feeds/all.rss.xml">RSS</a>.
          </h3>
        </div>
      </footer>
    </div>
  </body>
</html>