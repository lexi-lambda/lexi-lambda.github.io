<!doctype html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Alexis King’s Blog</title><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,300,300italic,400italic,700,700italic,800,800italic|Merriweather:400,300,300italic,400italic,700,700italic,900,900italic|Fira+Code:300,400,500,600,700"/><link rel="stylesheet" type="text/css" href="/css/application.min.css"/><link rel="stylesheet" type="text/css" href="/css/pygments.min.css"/><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feeds/all.atom.xml"/><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/feeds/all.rss.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-65250372-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);};gtag('js', new Date());gtag('config', 'UA-65250372-1');</script><body><header><nav role="navigation" class="navigation-bar"><ul class="navigation-items left"><li class="blog-title-header"><a href="/">Alexis King</a></li></ul><ul class="navigation-items center"></ul><ul class="navigation-items right"><li><a href="/">Home</a></li><li><a href="/about.html">About Me</a></li></ul></nav></header><section role="main"><div class="content"><article class="inline"><header><h1 class="title"><a href="/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/">Reimplementing Hackett’s type language: expanding to custom core forms in Racket</a></h1><div class="date-and-tags"><time datetime="2018-04-15">2018-04-15</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/racket.html">racket</a>, <a href="/tags/hackett.html">hackett</a>, <a href="/tags/macros.html">macros</a></div></header><p>In the past couple of weeks, I <a href="https://github.com/lexi-lambda/hackett/commit/ba64193da38f63dab2523f42c1b7614cdfa8c935">completely rewrote the implementation of Hackett’s type language</a> to improve the integration between the type representation and Racket’s macro system. The new type language effectively implements a way to reuse as much of the Racket macroexpanding infrastructure as possible while expanding a completely custom language, which uses a custom set of core forms. The fundamental technique used to do so is not novel, and it seems to be periodically rediscovered every so often, but it has never been published or documented anywhere, and getting it right involves understanding a great number of subtleties about the Racket macro system. While I cannot entirely eliminate the need to understand those subtleties, in this blog post, I hope to make the secret sauce considerably less secret.</p><p>This blog post is both a case study on how I implemented the expander for Hackett’s new type language and a discussion of how such a technique can apply more generally. Like <a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/">my previous blog post on Hackett</a>, which covered the implementation of its namespace system, the implementation section of this blog post is highly technical and probably requires significant experience with Racket’s macro system to completely comprehend. However, the surrounding material is written to be more accessible, so even if you are not a Racket programmer, you should hopefully be able to understand the big ideas behind this change.</p><p><a href="/blog/2018/04/15/reimplementing-hackett-s-type-language-expanding-to-custom-core-forms-in-racket/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/">An opinionated guide to Haskell in 2018</a></h1><div class="date-and-tags"><time datetime="2018-02-10">2018-02-10</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a></div></header><p>For me, this month marks the end of an era in my life: as of February 2018, I am no longer employed writing Haskell. It’s been a fascinating two years, and while I am excitedly looking forward to what I’ll be doing next, it’s likely I will continue to write Haskell in my spare time. I’ll probably even write it again professionally in the future.</p><p>In the meantime, in the interest of both sharing with others the small amount of wisdom I’ve gained and preserving it for my future self, I’ve decided to write a long, rather dry overview of a few select parts of the Haskell workflow I developed and the ecosystem I settled into. This guide is, as the title notes, <em>opinionated</em>—it is what I used in my day-to-day work, nothing more—and I don’t claim that anything here is the only way to write Haskell, nor even the best way. It is merely what I found helpful and productive. Take from it as much or as little as you’d like.</p><p><a href="/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/">A space of their own: adding a type namespace to Hackett</a></h1><div class="date-and-tags"><time datetime="2017-10-27">2017-10-27</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/programming-languages.html">programming languages</a></div></header><p>As previously discussed on this blog, <a href="https://github.com/lexi-lambda/hackett">my programming language, Hackett</a>, is a fusion of two languages, Haskell and Racket. What happens when two distinctly different programming languages collide? Hackett recently faced that very problem when it came to the question of namespacing: Haskell has two namespaces, one for values and another for types, but Racket is a staunch Lisp-1 with a single namespace for all bindings. Which convention should Hackett adopt?</p><p>For now, at least, the answer is that Hackett will emulate Haskell: <strong>Hackett now has two namespaces</strong>. Of course, Hackett is embedded in Racket, so what did it take to add an entirely new namespace to a language that possesses only one? The answer was a little more than I had hoped, but it was still remarkably simple given the problem: after two weeks of hacking, I’ve managed to get something working.</p><p><a href="/blog/2017/10/27/a-space-of-their-own-adding-a-type-namespace-to-hackett/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/08/28/hackett-progress-report-documentation-quality-of-life-and-snake/">Hackett progress report: documentation, quality of life, and snake</a></h1><div class="date-and-tags"><time datetime="2017-08-28">2017-08-28</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a></div></header><p>Three months ago, <a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/">I wrote a blog post describing my new, prototype implementation of my programming language, Hackett</a>. At the time, some things looked promising—the language already included algebraic datatypes, typeclasses, laziness, and even a mini, proof of concept web server. It was, however, clearly still rather rough around the edges—error messages were poor, features were sometimes brittle, the REPL experience was less than ideal, and there was no documentation to speak of. In the time since, while the language is still experimental, I have tackled a handful of those issues, and I am excited to announce <a href="https://pkg-build.racket-lang.org/doc/hackett@hackett-doc/"><strong>the first (albeit quite incomplete) approach to Hackett’s documentation</strong></a>.</p><p>I’d recommend clicking that link above and at least skimming around before reading the rest of this blog post, as its remainder will describe some of the pieces that didn’t end up in the documentation: the development process, the project’s status, a small demo, and some other details from behind the scenes.</p><p><a href="/blog/2017/08/28/hackett-progress-report-documentation-quality-of-life-and-snake/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/08/12/user-programmable-infix-operators-in-racket/">User-programmable infix operators in Racket</a></h1><div class="date-and-tags"><time datetime="2017-08-12">2017-08-12</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/racket.html">racket</a>, <a href="/tags/hackett.html">hackett</a>, <a href="/tags/macros.html">macros</a></div></header><p>Lisps are not known for infix operators, quite the opposite; infix operators generally involve more syntax and parsing than Lispers are keen to support. However, in <a href="https://github.com/lexi-lambda/hackett">Hackett</a>, all functions are curried, and variable-arity functions do not exist. Infix operators are almost necessary for that to be palatable, and though there are other reasons to want them, it may not be obvious how to support them without making the reader considerably more complex.</p><p>Fortunately, if we require users to syntactically specify where they wish to use infix expressions, support for infix operators is not only possible, but can support be done <em>without</em> modifying the stock <code>#lang racket</code> reader. Futhermore, the resulting technique makes it possible for fixity information to be specified locally in a way that cooperates nicely with the Racket macro system, allowing the parsing of infix expressions to be manipulated at compile-time by users’ macros.</p><p><a href="/blog/2017/08/12/user-programmable-infix-operators-in-racket/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/">Unit testing effectful Haskell with monad-mock</a></h1><div class="date-and-tags"><time datetime="2017-06-29">2017-06-29</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a>, <a href="/tags/testing.html">testing</a></div></header><p>Nearly eight months ago, <a href="/blog/2016/10/03/using-types-to-unit-test-in-haskell/">I wrote a blog post about unit testing effectful Haskell code</a> using a library called test-fixture. That library has served us well, but it wasn’t as easy to use as I would have liked, and it worked better with certain patterns than others. Since then, I’ve learned more about Haskell and more about testing, and I’m pleased to announce that I am releasing an entirely new testing library, <a href="https://hackage.haskell.org/package/monad-mock">monad-mock</a>.</p><p><a href="/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/">Realizing Hackett, a metaprogrammable Haskell</a></h1><div class="date-and-tags"><time datetime="2017-05-27">2017-05-27</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a></div></header><p><a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/">Almost five months ago, I wrote a blog post about my new programming language, Hackett</a>, a fanciful sketch of a programming language from a far-off land with Haskell’s type system and Racket’s macros. At that point in time, I had a little prototype that barely worked, that I barely understood, and was a little bit of a technical dead-end. People saw the post, they got excited, but development sort of stopped.</p><p>Then, almost two months ago, I took a second stab at the problem in earnest. I read a lot, I asked a lot of people for help, and eventually I got something sort of working. Suddenly, <a href="https://github.com/lexi-lambda/hackett">Hackett is not only real, it’s working, and you can try it out yourself</a>!</p><p><a href="/blog/2017/05/27/realizing-hackett-a-metaprogrammable-haskell/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/">Lifts for free: making mtl typeclasses derivable</a></h1><div class="date-and-tags"><time datetime="2017-04-28">2017-04-28</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/haskell.html">haskell</a></div></header><p>Perhaps the most important abstraction a Haskell programmer must understand to effectively write modern Haskell code, beyond the level of the monad, is the <em>monad transformer</em>, a way to compose monads together in a limited fashion. One frustrating downside to monad transformers is a proliferation of <code>lift</code>s, which explicitly indicate which monad in a transformer “stack” a particular computation should run in. Fortunately, the venerable <a href="https://hackage.haskell.org/package/mtl">mtl</a> provides typeclasses that make this lifting mostly automatic, using typeclass machinery to insert <code>lift</code> where appropriate.</p><p>Less fortunately, the mtl approach does not actually eliminate <code>lift</code> entirely, it simply moves it from use sites to instances. This requires a small zoo of extraordinarily boilerplate-y instances, most of which simply implement each typeclass method using <code>lift</code>. While we cannot eliminate the instances entirely without somewhat dangerous techniques like <a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#overlapping-instances">overlapping instances</a>, we <em>can</em> automatically derive them using features of modern GHC, eliminating the truly unnecessary boilerplate.</p><p><a href="/blog/2017/04/28/lifts-for-free-making-mtl-typeclasses-derivable/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/">Rascal is now Hackett, plus some answers to questions</a></h1><div class="date-and-tags"><time datetime="2017-01-05">2017-01-05</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a></div></header><p>Since I published <a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/">my blog post introducing Rascal</a>, I’ve gotten some <em>amazing</em> feedback, more than I had ever anticipated! One of the things that was pointed out, though, is that <a href="http://www.rascal-mpl.org">Rascal is a language that already exists</a>. Given that the name “Rascal” came from a mixture of “Racket” and “Haskell”, I always had an alternative named planned, and that’s “Hackett”. So, to avoid confusion as much as possible, <a href="https://github.com/lexi-lambda/hackett"><strong>Rascal is now known as Hackett</strong></a>.</p><p>With that out of the way, I also want to answer some of the other questions I received, both to hopefully clear up some confusion and to have something I can point to if I get the same questions in the future.</p><p><a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/"><span class="read-more-text">Read more</span> →</a></p></article><article class="inline"><header><h1 class="title"><a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/">Rascal: a Haskell with more parentheses</a></h1><div class="date-and-tags"><time datetime="2017-01-02">2017-01-02</time> <span style="margin: 0 5px">⦿</span> <a href="/tags/hackett.html">hackett</a>, <a href="/tags/racket.html">racket</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming-languages.html">programming languages</a>, <a href="/tags/functional-programming.html">functional programming</a></div></header><blockquote><p><strong>Note</strong>: since the writing of this blog post, Rascal has been renamed to Hackett. You can read about why in <a href="/blog/2017/01/05/rascal-is-now-hackett-plus-some-answers-to-questions/">the followup blog post</a>.</p></blockquote><p>“Hey! You got your Haskell in my Racket!”</p><p>“No, you got <em>your</em> Racket in <em>my</em> Haskell!”</p><p>Welcome to the <a href="https://github.com/lexi-lambda/hackett">Rascal</a> programming language.</p><p><a href="/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/"><span class="read-more-text">Read more</span> →</a></p></article><ul class="pagination"><li><a href="/">←</a></li><li class="pagination-number"><a href="/">1</a></li><li class="pagination-number active"><a href="/index-2.html">2</a></li><li class="pagination-number"><a href="/index-3.html">3</a></li><li class="pagination-number"><a href="/index-4.html">4</a></li><li><a href="/index-3.html">→</a></li></ul></div></section><footer><div class="copyright-notice">© 2022, Alexis King</div><div>Built with <a href="https://docs.racket-lang.org/scribble/index.html"><strong>Scribble</strong></a>, the Racket document preparation system.</div><div>Feeds are available via <a href="/feeds/all.atom.xml">Atom</a> or <a href="/feeds/all.rss.xml">RSS</a>.</div></footer></body></head></html>